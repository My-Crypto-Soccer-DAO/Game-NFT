/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fianov%2Fgame3%2Ftrump-cards%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!***********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fianov%2Fgame3%2Ftrump-cards%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \***********************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/page.tsx */ \"(app-pages-browser)/./app/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGaG9tZSUyRmlhbm92JTJGZ2FtZTMlMkZ0cnVtcC1jYXJkcyUyRmFwcCUyRnBhZ2UudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsc0pBQStFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/YWRiYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9ob21lL2lhbm92L2dhbWUzL3RydW1wLWNhcmRzL2FwcC9wYWdlLnRzeFwiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fianov%2Fgame3%2Ftrump-cards%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/enquire.js/src/MediaQuery.js":
/*!***************************************************!*\
  !*** ./node_modules/enquire.js/src/MediaQuery.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var QueryHandler = __webpack_require__(/*! ./QueryHandler */ \"(app-pages-browser)/./node_modules/enquire.js/src/QueryHandler.js\");\nvar each = (__webpack_require__(/*! ./Util */ \"(app-pages-browser)/./node_modules/enquire.js/src/Util.js\").each);\n\n/**\n * Represents a single media query, manages it's state and registered handlers for this query\n *\n * @constructor\n * @param {string} query the media query string\n * @param {boolean} [isUnconditional=false] whether the media query should run regardless of whether the conditions are met. Primarily for helping older browsers deal with mobile-first design\n */\nfunction MediaQuery(query, isUnconditional) {\n    this.query = query;\n    this.isUnconditional = isUnconditional;\n    this.handlers = [];\n    this.mql = window.matchMedia(query);\n\n    var self = this;\n    this.listener = function(mql) {\n        // Chrome passes an MediaQueryListEvent object, while other browsers pass MediaQueryList directly\n        self.mql = mql.currentTarget || mql;\n        self.assess();\n    };\n    this.mql.addListener(this.listener);\n}\n\nMediaQuery.prototype = {\n\n    constuctor : MediaQuery,\n\n    /**\n     * add a handler for this query, triggering if already active\n     *\n     * @param {object} handler\n     * @param {function} handler.match callback for when query is activated\n     * @param {function} [handler.unmatch] callback for when query is deactivated\n     * @param {function} [handler.setup] callback for immediate execution when a query handler is registered\n     * @param {boolean} [handler.deferSetup=false] should the setup callback be deferred until the first time the handler is matched?\n     */\n    addHandler : function(handler) {\n        var qh = new QueryHandler(handler);\n        this.handlers.push(qh);\n\n        this.matches() && qh.on();\n    },\n\n    /**\n     * removes the given handler from the collection, and calls it's destroy methods\n     *\n     * @param {object || function} handler the handler to remove\n     */\n    removeHandler : function(handler) {\n        var handlers = this.handlers;\n        each(handlers, function(h, i) {\n            if(h.equals(handler)) {\n                h.destroy();\n                return !handlers.splice(i,1); //remove from array and exit each early\n            }\n        });\n    },\n\n    /**\n     * Determine whether the media query should be considered a match\n     *\n     * @return {Boolean} true if media query can be considered a match, false otherwise\n     */\n    matches : function() {\n        return this.mql.matches || this.isUnconditional;\n    },\n\n    /**\n     * Clears all handlers and unbinds events\n     */\n    clear : function() {\n        each(this.handlers, function(handler) {\n            handler.destroy();\n        });\n        this.mql.removeListener(this.listener);\n        this.handlers.length = 0; //clear array\n    },\n\n    /*\n        * Assesses the query, turning on all handlers if it matches, turning them off if it doesn't match\n        */\n    assess : function() {\n        var action = this.matches() ? 'on' : 'off';\n\n        each(this.handlers, function(handler) {\n            handler[action]();\n        });\n    }\n};\n\nmodule.exports = MediaQuery;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbnF1aXJlLmpzL3NyYy9NZWRpYVF1ZXJ5LmpzIiwibWFwcGluZ3MiOiJBQUFBLG1CQUFtQixtQkFBTyxDQUFDLHlGQUFnQjtBQUMzQyxXQUFXLHFHQUFzQjs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0NBQWtDO0FBQ2xDLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2VucXVpcmUuanMvc3JjL01lZGlhUXVlcnkuanM/MWIzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUXVlcnlIYW5kbGVyID0gcmVxdWlyZSgnLi9RdWVyeUhhbmRsZXInKTtcbnZhciBlYWNoID0gcmVxdWlyZSgnLi9VdGlsJykuZWFjaDtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc2luZ2xlIG1lZGlhIHF1ZXJ5LCBtYW5hZ2VzIGl0J3Mgc3RhdGUgYW5kIHJlZ2lzdGVyZWQgaGFuZGxlcnMgZm9yIHRoaXMgcXVlcnlcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSB0aGUgbWVkaWEgcXVlcnkgc3RyaW5nXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1VuY29uZGl0aW9uYWw9ZmFsc2VdIHdoZXRoZXIgdGhlIG1lZGlhIHF1ZXJ5IHNob3VsZCBydW4gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBjb25kaXRpb25zIGFyZSBtZXQuIFByaW1hcmlseSBmb3IgaGVscGluZyBvbGRlciBicm93c2VycyBkZWFsIHdpdGggbW9iaWxlLWZpcnN0IGRlc2lnblxuICovXG5mdW5jdGlvbiBNZWRpYVF1ZXJ5KHF1ZXJ5LCBpc1VuY29uZGl0aW9uYWwpIHtcbiAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgdGhpcy5pc1VuY29uZGl0aW9uYWwgPSBpc1VuY29uZGl0aW9uYWw7XG4gICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgIHRoaXMubXFsID0gd2luZG93Lm1hdGNoTWVkaWEocXVlcnkpO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbihtcWwpIHtcbiAgICAgICAgLy8gQ2hyb21lIHBhc3NlcyBhbiBNZWRpYVF1ZXJ5TGlzdEV2ZW50IG9iamVjdCwgd2hpbGUgb3RoZXIgYnJvd3NlcnMgcGFzcyBNZWRpYVF1ZXJ5TGlzdCBkaXJlY3RseVxuICAgICAgICBzZWxmLm1xbCA9IG1xbC5jdXJyZW50VGFyZ2V0IHx8IG1xbDtcbiAgICAgICAgc2VsZi5hc3Nlc3MoKTtcbiAgICB9O1xuICAgIHRoaXMubXFsLmFkZExpc3RlbmVyKHRoaXMubGlzdGVuZXIpO1xufVxuXG5NZWRpYVF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0dWN0b3IgOiBNZWRpYVF1ZXJ5LFxuXG4gICAgLyoqXG4gICAgICogYWRkIGEgaGFuZGxlciBmb3IgdGhpcyBxdWVyeSwgdHJpZ2dlcmluZyBpZiBhbHJlYWR5IGFjdGl2ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyLm1hdGNoIGNhbGxiYWNrIGZvciB3aGVuIHF1ZXJ5IGlzIGFjdGl2YXRlZFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtoYW5kbGVyLnVubWF0Y2hdIGNhbGxiYWNrIGZvciB3aGVuIHF1ZXJ5IGlzIGRlYWN0aXZhdGVkXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2hhbmRsZXIuc2V0dXBdIGNhbGxiYWNrIGZvciBpbW1lZGlhdGUgZXhlY3V0aW9uIHdoZW4gYSBxdWVyeSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtoYW5kbGVyLmRlZmVyU2V0dXA9ZmFsc2VdIHNob3VsZCB0aGUgc2V0dXAgY2FsbGJhY2sgYmUgZGVmZXJyZWQgdW50aWwgdGhlIGZpcnN0IHRpbWUgdGhlIGhhbmRsZXIgaXMgbWF0Y2hlZD9cbiAgICAgKi9cbiAgICBhZGRIYW5kbGVyIDogZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgICB2YXIgcWggPSBuZXcgUXVlcnlIYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgICB0aGlzLmhhbmRsZXJzLnB1c2gocWgpO1xuXG4gICAgICAgIHRoaXMubWF0Y2hlcygpICYmIHFoLm9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZXMgdGhlIGdpdmVuIGhhbmRsZXIgZnJvbSB0aGUgY29sbGVjdGlvbiwgYW5kIGNhbGxzIGl0J3MgZGVzdHJveSBtZXRob2RzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdCB8fCBmdW5jdGlvbn0gaGFuZGxlciB0aGUgaGFuZGxlciB0byByZW1vdmVcbiAgICAgKi9cbiAgICByZW1vdmVIYW5kbGVyIDogZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICBlYWNoKGhhbmRsZXJzLCBmdW5jdGlvbihoLCBpKSB7XG4gICAgICAgICAgICBpZihoLmVxdWFscyhoYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgIGguZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiAhaGFuZGxlcnMuc3BsaWNlKGksMSk7IC8vcmVtb3ZlIGZyb20gYXJyYXkgYW5kIGV4aXQgZWFjaCBlYXJseVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIG1lZGlhIHF1ZXJ5IHNob3VsZCBiZSBjb25zaWRlcmVkIGEgbWF0Y2hcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgbWVkaWEgcXVlcnkgY2FuIGJlIGNvbnNpZGVyZWQgYSBtYXRjaCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgbWF0Y2hlcyA6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tcWwubWF0Y2hlcyB8fCB0aGlzLmlzVW5jb25kaXRpb25hbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCBoYW5kbGVycyBhbmQgdW5iaW5kcyBldmVudHNcbiAgICAgKi9cbiAgICBjbGVhciA6IGZ1bmN0aW9uKCkge1xuICAgICAgICBlYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tcWwucmVtb3ZlTGlzdGVuZXIodGhpcy5saXN0ZW5lcik7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMubGVuZ3RoID0gMDsgLy9jbGVhciBhcnJheVxuICAgIH0sXG5cbiAgICAvKlxuICAgICAgICAqIEFzc2Vzc2VzIHRoZSBxdWVyeSwgdHVybmluZyBvbiBhbGwgaGFuZGxlcnMgaWYgaXQgbWF0Y2hlcywgdHVybmluZyB0aGVtIG9mZiBpZiBpdCBkb2Vzbid0IG1hdGNoXG4gICAgICAgICovXG4gICAgYXNzZXNzIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhY3Rpb24gPSB0aGlzLm1hdGNoZXMoKSA/ICdvbicgOiAnb2ZmJztcblxuICAgICAgICBlYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGhhbmRsZXJbYWN0aW9uXSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1lZGlhUXVlcnk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/enquire.js/src/MediaQuery.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/enquire.js/src/MediaQueryDispatch.js":
/*!***********************************************************!*\
  !*** ./node_modules/enquire.js/src/MediaQueryDispatch.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var MediaQuery = __webpack_require__(/*! ./MediaQuery */ \"(app-pages-browser)/./node_modules/enquire.js/src/MediaQuery.js\");\nvar Util = __webpack_require__(/*! ./Util */ \"(app-pages-browser)/./node_modules/enquire.js/src/Util.js\");\nvar each = Util.each;\nvar isFunction = Util.isFunction;\nvar isArray = Util.isArray;\n\n/**\n * Allows for registration of query handlers.\n * Manages the query handler's state and is responsible for wiring up browser events\n *\n * @constructor\n */\nfunction MediaQueryDispatch () {\n    if(!window.matchMedia) {\n        throw new Error('matchMedia not present, legacy browsers require a polyfill');\n    }\n\n    this.queries = {};\n    this.browserIsIncapable = !window.matchMedia('only all').matches;\n}\n\nMediaQueryDispatch.prototype = {\n\n    constructor : MediaQueryDispatch,\n\n    /**\n     * Registers a handler for the given media query\n     *\n     * @param {string} q the media query\n     * @param {object || Array || Function} options either a single query handler object, a function, or an array of query handlers\n     * @param {function} options.match fired when query matched\n     * @param {function} [options.unmatch] fired when a query is no longer matched\n     * @param {function} [options.setup] fired when handler first triggered\n     * @param {boolean} [options.deferSetup=false] whether setup should be run immediately or deferred until query is first matched\n     * @param {boolean} [shouldDegrade=false] whether this particular media query should always run on incapable browsers\n     */\n    register : function(q, options, shouldDegrade) {\n        var queries         = this.queries,\n            isUnconditional = shouldDegrade && this.browserIsIncapable;\n\n        if(!queries[q]) {\n            queries[q] = new MediaQuery(q, isUnconditional);\n        }\n\n        //normalise to object in an array\n        if(isFunction(options)) {\n            options = { match : options };\n        }\n        if(!isArray(options)) {\n            options = [options];\n        }\n        each(options, function(handler) {\n            if (isFunction(handler)) {\n                handler = { match : handler };\n            }\n            queries[q].addHandler(handler);\n        });\n\n        return this;\n    },\n\n    /**\n     * unregisters a query and all it's handlers, or a specific handler for a query\n     *\n     * @param {string} q the media query to target\n     * @param {object || function} [handler] specific handler to unregister\n     */\n    unregister : function(q, handler) {\n        var query = this.queries[q];\n\n        if(query) {\n            if(handler) {\n                query.removeHandler(handler);\n            }\n            else {\n                query.clear();\n                delete this.queries[q];\n            }\n        }\n\n        return this;\n    }\n};\n\nmodule.exports = MediaQueryDispatch;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbnF1aXJlLmpzL3NyYy9NZWRpYVF1ZXJ5RGlzcGF0Y2guanMiLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLG1CQUFPLENBQUMscUZBQWM7QUFDdkMsV0FBVyxtQkFBTyxDQUFDLHlFQUFRO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsNkJBQTZCO0FBQzVDLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2VucXVpcmUuanMvc3JjL01lZGlhUXVlcnlEaXNwYXRjaC5qcz8yZGFmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBNZWRpYVF1ZXJ5ID0gcmVxdWlyZSgnLi9NZWRpYVF1ZXJ5Jyk7XG52YXIgVXRpbCA9IHJlcXVpcmUoJy4vVXRpbCcpO1xudmFyIGVhY2ggPSBVdGlsLmVhY2g7XG52YXIgaXNGdW5jdGlvbiA9IFV0aWwuaXNGdW5jdGlvbjtcbnZhciBpc0FycmF5ID0gVXRpbC5pc0FycmF5O1xuXG4vKipcbiAqIEFsbG93cyBmb3IgcmVnaXN0cmF0aW9uIG9mIHF1ZXJ5IGhhbmRsZXJzLlxuICogTWFuYWdlcyB0aGUgcXVlcnkgaGFuZGxlcidzIHN0YXRlIGFuZCBpcyByZXNwb25zaWJsZSBmb3Igd2lyaW5nIHVwIGJyb3dzZXIgZXZlbnRzXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1lZGlhUXVlcnlEaXNwYXRjaCAoKSB7XG4gICAgaWYoIXdpbmRvdy5tYXRjaE1lZGlhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWF0Y2hNZWRpYSBub3QgcHJlc2VudCwgbGVnYWN5IGJyb3dzZXJzIHJlcXVpcmUgYSBwb2x5ZmlsbCcpO1xuICAgIH1cblxuICAgIHRoaXMucXVlcmllcyA9IHt9O1xuICAgIHRoaXMuYnJvd3NlcklzSW5jYXBhYmxlID0gIXdpbmRvdy5tYXRjaE1lZGlhKCdvbmx5IGFsbCcpLm1hdGNoZXM7XG59XG5cbk1lZGlhUXVlcnlEaXNwYXRjaC5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvciA6IE1lZGlhUXVlcnlEaXNwYXRjaCxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiBtZWRpYSBxdWVyeVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHEgdGhlIG1lZGlhIHF1ZXJ5XG4gICAgICogQHBhcmFtIHtvYmplY3QgfHwgQXJyYXkgfHwgRnVuY3Rpb259IG9wdGlvbnMgZWl0aGVyIGEgc2luZ2xlIHF1ZXJ5IGhhbmRsZXIgb2JqZWN0LCBhIGZ1bmN0aW9uLCBvciBhbiBhcnJheSBvZiBxdWVyeSBoYW5kbGVyc1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMubWF0Y2ggZmlyZWQgd2hlbiBxdWVyeSBtYXRjaGVkXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMudW5tYXRjaF0gZmlyZWQgd2hlbiBhIHF1ZXJ5IGlzIG5vIGxvbmdlciBtYXRjaGVkXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuc2V0dXBdIGZpcmVkIHdoZW4gaGFuZGxlciBmaXJzdCB0cmlnZ2VyZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRlZmVyU2V0dXA9ZmFsc2VdIHdoZXRoZXIgc2V0dXAgc2hvdWxkIGJlIHJ1biBpbW1lZGlhdGVseSBvciBkZWZlcnJlZCB1bnRpbCBxdWVyeSBpcyBmaXJzdCBtYXRjaGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc2hvdWxkRGVncmFkZT1mYWxzZV0gd2hldGhlciB0aGlzIHBhcnRpY3VsYXIgbWVkaWEgcXVlcnkgc2hvdWxkIGFsd2F5cyBydW4gb24gaW5jYXBhYmxlIGJyb3dzZXJzXG4gICAgICovXG4gICAgcmVnaXN0ZXIgOiBmdW5jdGlvbihxLCBvcHRpb25zLCBzaG91bGREZWdyYWRlKSB7XG4gICAgICAgIHZhciBxdWVyaWVzICAgICAgICAgPSB0aGlzLnF1ZXJpZXMsXG4gICAgICAgICAgICBpc1VuY29uZGl0aW9uYWwgPSBzaG91bGREZWdyYWRlICYmIHRoaXMuYnJvd3NlcklzSW5jYXBhYmxlO1xuXG4gICAgICAgIGlmKCFxdWVyaWVzW3FdKSB7XG4gICAgICAgICAgICBxdWVyaWVzW3FdID0gbmV3IE1lZGlhUXVlcnkocSwgaXNVbmNvbmRpdGlvbmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vbm9ybWFsaXNlIHRvIG9iamVjdCBpbiBhbiBhcnJheVxuICAgICAgICBpZihpc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBvcHRpb25zID0geyBtYXRjaCA6IG9wdGlvbnMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZighaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IFtvcHRpb25zXTtcbiAgICAgICAgfVxuICAgICAgICBlYWNoKG9wdGlvbnMsIGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IHsgbWF0Y2ggOiBoYW5kbGVyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWVyaWVzW3FdLmFkZEhhbmRsZXIoaGFuZGxlcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1bnJlZ2lzdGVycyBhIHF1ZXJ5IGFuZCBhbGwgaXQncyBoYW5kbGVycywgb3IgYSBzcGVjaWZpYyBoYW5kbGVyIGZvciBhIHF1ZXJ5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcSB0aGUgbWVkaWEgcXVlcnkgdG8gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtvYmplY3QgfHwgZnVuY3Rpb259IFtoYW5kbGVyXSBzcGVjaWZpYyBoYW5kbGVyIHRvIHVucmVnaXN0ZXJcbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyIDogZnVuY3Rpb24ocSwgaGFuZGxlcikge1xuICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJpZXNbcV07XG5cbiAgICAgICAgaWYocXVlcnkpIHtcbiAgICAgICAgICAgIGlmKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBxdWVyeS5yZW1vdmVIYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVlcnkuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5xdWVyaWVzW3FdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNZWRpYVF1ZXJ5RGlzcGF0Y2g7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/enquire.js/src/MediaQueryDispatch.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/enquire.js/src/QueryHandler.js":
/*!*****************************************************!*\
  !*** ./node_modules/enquire.js/src/QueryHandler.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/**\n * Delegate to handle a media query being matched and unmatched.\n *\n * @param {object} options\n * @param {function} options.match callback for when the media query is matched\n * @param {function} [options.unmatch] callback for when the media query is unmatched\n * @param {function} [options.setup] one-time callback triggered the first time a query is matched\n * @param {boolean} [options.deferSetup=false] should the setup callback be run immediately, rather than first time query is matched?\n * @constructor\n */\nfunction QueryHandler(options) {\n    this.options = options;\n    !options.deferSetup && this.setup();\n}\n\nQueryHandler.prototype = {\n\n    constructor : QueryHandler,\n\n    /**\n     * coordinates setup of the handler\n     *\n     * @function\n     */\n    setup : function() {\n        if(this.options.setup) {\n            this.options.setup();\n        }\n        this.initialised = true;\n    },\n\n    /**\n     * coordinates setup and triggering of the handler\n     *\n     * @function\n     */\n    on : function() {\n        !this.initialised && this.setup();\n        this.options.match && this.options.match();\n    },\n\n    /**\n     * coordinates the unmatch event for the handler\n     *\n     * @function\n     */\n    off : function() {\n        this.options.unmatch && this.options.unmatch();\n    },\n\n    /**\n     * called when a handler is to be destroyed.\n     * delegates to the destroy or unmatch callbacks, depending on availability.\n     *\n     * @function\n     */\n    destroy : function() {\n        this.options.destroy ? this.options.destroy() : this.off();\n    },\n\n    /**\n     * determines equality by reference.\n     * if object is supplied compare options, if function, compare match callback\n     *\n     * @function\n     * @param {object || function} [target] the target for comparison\n     */\n    equals : function(target) {\n        return this.options === target || this.options.match === target;\n    }\n\n};\n\nmodule.exports = QueryHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbnF1aXJlLmpzL3NyYy9RdWVyeUhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2VucXVpcmUuanMvc3JjL1F1ZXJ5SGFuZGxlci5qcz9hOTEzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRGVsZWdhdGUgdG8gaGFuZGxlIGEgbWVkaWEgcXVlcnkgYmVpbmcgbWF0Y2hlZCBhbmQgdW5tYXRjaGVkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLm1hdGNoIGNhbGxiYWNrIGZvciB3aGVuIHRoZSBtZWRpYSBxdWVyeSBpcyBtYXRjaGVkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy51bm1hdGNoXSBjYWxsYmFjayBmb3Igd2hlbiB0aGUgbWVkaWEgcXVlcnkgaXMgdW5tYXRjaGVkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5zZXR1cF0gb25lLXRpbWUgY2FsbGJhY2sgdHJpZ2dlcmVkIHRoZSBmaXJzdCB0aW1lIGEgcXVlcnkgaXMgbWF0Y2hlZFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kZWZlclNldHVwPWZhbHNlXSBzaG91bGQgdGhlIHNldHVwIGNhbGxiYWNrIGJlIHJ1biBpbW1lZGlhdGVseSwgcmF0aGVyIHRoYW4gZmlyc3QgdGltZSBxdWVyeSBpcyBtYXRjaGVkP1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFF1ZXJ5SGFuZGxlcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAhb3B0aW9ucy5kZWZlclNldHVwICYmIHRoaXMuc2V0dXAoKTtcbn1cblxuUXVlcnlIYW5kbGVyLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yIDogUXVlcnlIYW5kbGVyLFxuXG4gICAgLyoqXG4gICAgICogY29vcmRpbmF0ZXMgc2V0dXAgb2YgdGhlIGhhbmRsZXJcbiAgICAgKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIHNldHVwIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy5zZXR1cCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNldHVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0aWFsaXNlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNvb3JkaW5hdGVzIHNldHVwIGFuZCB0cmlnZ2VyaW5nIG9mIHRoZSBoYW5kbGVyXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICBvbiA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAhdGhpcy5pbml0aWFsaXNlZCAmJiB0aGlzLnNldHVwKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5tYXRjaCAmJiB0aGlzLm9wdGlvbnMubWF0Y2goKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29vcmRpbmF0ZXMgdGhlIHVubWF0Y2ggZXZlbnQgZm9yIHRoZSBoYW5kbGVyXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICBvZmYgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnVubWF0Y2ggJiYgdGhpcy5vcHRpb25zLnVubWF0Y2goKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsbGVkIHdoZW4gYSBoYW5kbGVyIGlzIHRvIGJlIGRlc3Ryb3llZC5cbiAgICAgKiBkZWxlZ2F0ZXMgdG8gdGhlIGRlc3Ryb3kgb3IgdW5tYXRjaCBjYWxsYmFja3MsIGRlcGVuZGluZyBvbiBhdmFpbGFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICBkZXN0cm95IDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5kZXN0cm95ID8gdGhpcy5vcHRpb25zLmRlc3Ryb3koKSA6IHRoaXMub2ZmKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRldGVybWluZXMgZXF1YWxpdHkgYnkgcmVmZXJlbmNlLlxuICAgICAqIGlmIG9iamVjdCBpcyBzdXBwbGllZCBjb21wYXJlIG9wdGlvbnMsIGlmIGZ1bmN0aW9uLCBjb21wYXJlIG1hdGNoIGNhbGxiYWNrXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdCB8fCBmdW5jdGlvbn0gW3RhcmdldF0gdGhlIHRhcmdldCBmb3IgY29tcGFyaXNvblxuICAgICAqL1xuICAgIGVxdWFscyA6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zID09PSB0YXJnZXQgfHwgdGhpcy5vcHRpb25zLm1hdGNoID09PSB0YXJnZXQ7XG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5SGFuZGxlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/enquire.js/src/QueryHandler.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/enquire.js/src/Util.js":
/*!*********************************************!*\
  !*** ./node_modules/enquire.js/src/Util.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/**\n * Helper function for iterating over a collection\n *\n * @param collection\n * @param fn\n */\nfunction each(collection, fn) {\n    var i      = 0,\n        length = collection.length,\n        cont;\n\n    for(i; i < length; i++) {\n        cont = fn(collection[i], i);\n        if(cont === false) {\n            break; //allow early exit\n        }\n    }\n}\n\n/**\n * Helper function for determining whether target object is an array\n *\n * @param target the object under test\n * @return {Boolean} true if array, false otherwise\n */\nfunction isArray(target) {\n    return Object.prototype.toString.apply(target) === '[object Array]';\n}\n\n/**\n * Helper function for determining whether target object is a function\n *\n * @param target the object under test\n * @return {Boolean} true if function, false otherwise\n */\nfunction isFunction(target) {\n    return typeof target === 'function';\n}\n\nmodule.exports = {\n    isFunction : isFunction,\n    isArray : isArray,\n    each : each\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbnF1aXJlLmpzL3NyYy9VdGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9lbnF1aXJlLmpzL3NyYy9VdGlsLmpzP2E3NGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gZm9yIGl0ZXJhdGluZyBvdmVyIGEgY29sbGVjdGlvblxuICpcbiAqIEBwYXJhbSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0gZm5cbiAqL1xuZnVuY3Rpb24gZWFjaChjb2xsZWN0aW9uLCBmbikge1xuICAgIHZhciBpICAgICAgPSAwLFxuICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgY29udDtcblxuICAgIGZvcihpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29udCA9IGZuKGNvbGxlY3Rpb25baV0sIGkpO1xuICAgICAgICBpZihjb250ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7IC8vYWxsb3cgZWFybHkgZXhpdFxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0YXJnZXQgb2JqZWN0IGlzIGFuIGFycmF5XG4gKlxuICogQHBhcmFtIHRhcmdldCB0aGUgb2JqZWN0IHVuZGVyIHRlc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgYXJyYXksIGZhbHNlIG90aGVyd2lzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHRhcmdldCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRhcmdldCBvYmplY3QgaXMgYSBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB0YXJnZXQgdGhlIG9iamVjdCB1bmRlciB0ZXN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGZ1bmN0aW9uLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih0YXJnZXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaXNGdW5jdGlvbiA6IGlzRnVuY3Rpb24sXG4gICAgaXNBcnJheSA6IGlzQXJyYXksXG4gICAgZWFjaCA6IGVhY2hcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/enquire.js/src/Util.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/enquire.js/src/index.js":
/*!**********************************************!*\
  !*** ./node_modules/enquire.js/src/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var MediaQueryDispatch = __webpack_require__(/*! ./MediaQueryDispatch */ \"(app-pages-browser)/./node_modules/enquire.js/src/MediaQueryDispatch.js\");\nmodule.exports = new MediaQueryDispatch();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbnF1aXJlLmpzL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx5QkFBeUIsbUJBQU8sQ0FBQyxxR0FBc0I7QUFDdkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2VucXVpcmUuanMvc3JjL2luZGV4LmpzPzA1OTMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIE1lZGlhUXVlcnlEaXNwYXRjaCA9IHJlcXVpcmUoJy4vTWVkaWFRdWVyeURpc3BhdGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBNZWRpYVF1ZXJ5RGlzcGF0Y2goKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/enquire.js/src/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/json2mq/index.js":
/*!***************************************!*\
  !*** ./node_modules/json2mq/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var camel2hyphen = __webpack_require__(/*! string-convert/camel2hyphen */ \"(app-pages-browser)/./node_modules/string-convert/camel2hyphen.js\");\n\nvar isDimension = function (feature) {\n  var re = /[height|width]$/;\n  return re.test(feature);\n};\n\nvar obj2mq = function (obj) {\n  var mq = '';\n  var features = Object.keys(obj);\n  features.forEach(function (feature, index) {\n    var value = obj[feature];\n    feature = camel2hyphen(feature);\n    // Add px to dimension features\n    if (isDimension(feature) && typeof value === 'number') {\n      value = value + 'px';\n    }\n    if (value === true) {\n      mq += feature;\n    } else if (value === false) {\n      mq += 'not ' + feature;\n    } else {\n      mq += '(' + feature + ': ' + value + ')';\n    }\n    if (index < features.length-1) {\n      mq += ' and '\n    }\n  });\n  return mq;\n};\n\nvar json2mq = function (query) {\n  var mq = '';\n  if (typeof query === 'string') {\n    return query;\n  }\n  // Handling array of media queries\n  if (query instanceof Array) {\n    query.forEach(function (q, index) {\n      mq += obj2mq(q);\n      if (index < query.length-1) {\n        mq += ', '\n      }\n    });\n    return mq;\n  }\n  // Handling single media query\n  return obj2mq(query);\n};\n\nmodule.exports = json2mq;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc29uMm1xL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLG1CQUFtQixtQkFBTyxDQUFDLHNHQUE2Qjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvanNvbjJtcS9pbmRleC5qcz9jZjA1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBjYW1lbDJoeXBoZW4gPSByZXF1aXJlKCdzdHJpbmctY29udmVydC9jYW1lbDJoeXBoZW4nKTtcblxudmFyIGlzRGltZW5zaW9uID0gZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgdmFyIHJlID0gL1toZWlnaHR8d2lkdGhdJC87XG4gIHJldHVybiByZS50ZXN0KGZlYXR1cmUpO1xufTtcblxudmFyIG9iajJtcSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIG1xID0gJyc7XG4gIHZhciBmZWF0dXJlcyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGZlYXR1cmUsIGluZGV4KSB7XG4gICAgdmFyIHZhbHVlID0gb2JqW2ZlYXR1cmVdO1xuICAgIGZlYXR1cmUgPSBjYW1lbDJoeXBoZW4oZmVhdHVyZSk7XG4gICAgLy8gQWRkIHB4IHRvIGRpbWVuc2lvbiBmZWF0dXJlc1xuICAgIGlmIChpc0RpbWVuc2lvbihmZWF0dXJlKSAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICsgJ3B4JztcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICBtcSArPSBmZWF0dXJlO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICBtcSArPSAnbm90ICcgKyBmZWF0dXJlO1xuICAgIH0gZWxzZSB7XG4gICAgICBtcSArPSAnKCcgKyBmZWF0dXJlICsgJzogJyArIHZhbHVlICsgJyknO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPCBmZWF0dXJlcy5sZW5ndGgtMSkge1xuICAgICAgbXEgKz0gJyBhbmQgJ1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtcTtcbn07XG5cbnZhciBqc29uMm1xID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gIHZhciBtcSA9ICcnO1xuICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBxdWVyeTtcbiAgfVxuICAvLyBIYW5kbGluZyBhcnJheSBvZiBtZWRpYSBxdWVyaWVzXG4gIGlmIChxdWVyeSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgcXVlcnkuZm9yRWFjaChmdW5jdGlvbiAocSwgaW5kZXgpIHtcbiAgICAgIG1xICs9IG9iajJtcShxKTtcbiAgICAgIGlmIChpbmRleCA8IHF1ZXJ5Lmxlbmd0aC0xKSB7XG4gICAgICAgIG1xICs9ICcsICdcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbXE7XG4gIH1cbiAgLy8gSGFuZGxpbmcgc2luZ2xlIG1lZGlhIHF1ZXJ5XG4gIHJldHVybiBvYmoybXEocXVlcnkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBqc29uMm1xOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/json2mq/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lodash.debounce/index.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash.debounce/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = debounce;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb2Rhc2guZGVib3VuY2UvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IscUJBQU0sZ0JBQWdCLHFCQUFNLElBQUkscUJBQU0sc0JBQXNCLHFCQUFNOztBQUUxRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRLFdBQVc7QUFDOUIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsK0NBQStDLGlCQUFpQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC5kZWJvdW5jZS9pbmRleC5qcz9jMmM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICogaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgcmVzdWx0ID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbihyZXN1bHQsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH1cbiAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfVxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJvdW5jZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lodash.debounce/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lottie-react/build/index.umd.js":
/*!******************************************************!*\
  !*** ./node_modules/lottie-react/build/index.umd.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! lottie-web */ \"(app-pages-browser)/./node_modules/lottie-web/build/player/lottie.js\"), __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\")) :\n  0;\n})(this, (function (exports, lottie, React) { 'use strict';\n\n  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n  var lottie__default = /*#__PURE__*/_interopDefaultLegacy(lottie);\n  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);\n\n  function _iterableToArrayLimit(arr, i) {\n    var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (null != _i) {\n      var _s,\n        _e,\n        _x,\n        _r,\n        _arr = [],\n        _n = !0,\n        _d = !1;\n      try {\n        if (_x = (_i = _i.call(arr)).next, 0 === i) {\n          if (Object(_i) !== _i) return;\n          _n = !1;\n        } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n      } catch (err) {\n        _d = !0, _e = err;\n      } finally {\n        try {\n          if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n        } finally {\n          if (_d) throw _e;\n        }\n      }\n      return _arr;\n    }\n  }\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      enumerableOnly && (symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n  }\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = null != arguments[i] ? arguments[i] : {};\n      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n    return target;\n  }\n  function _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n    return obj;\n  }\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n    return target;\n  }\n  function _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n      for (i = 0; i < sourceSymbolKeys.length; i++) {\n        key = sourceSymbolKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n        target[key] = source[key];\n      }\n    }\n    return target;\n  }\n  function _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n  }\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n    return arr2;\n  }\n  function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  function _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n      var res = prim.call(input, hint || \"default\");\n      if (typeof res !== \"object\") return res;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n  }\n  function _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n  }\n\n  var _excluded$1 = [\"animationData\", \"loop\", \"autoplay\", \"initialSegment\", \"onComplete\", \"onLoopComplete\", \"onEnterFrame\", \"onSegmentStart\", \"onConfigReady\", \"onDataReady\", \"onDataFailed\", \"onLoadedImages\", \"onDOMLoaded\", \"onDestroy\", \"lottieRef\", \"renderer\", \"name\", \"assetsPath\", \"rendererSettings\"];\n  var useLottie = function useLottie(props, style) {\n    var animationData = props.animationData,\n      loop = props.loop,\n      autoplay = props.autoplay,\n      initialSegment = props.initialSegment,\n      onComplete = props.onComplete,\n      onLoopComplete = props.onLoopComplete,\n      onEnterFrame = props.onEnterFrame,\n      onSegmentStart = props.onSegmentStart,\n      onConfigReady = props.onConfigReady,\n      onDataReady = props.onDataReady,\n      onDataFailed = props.onDataFailed,\n      onLoadedImages = props.onLoadedImages,\n      onDOMLoaded = props.onDOMLoaded,\n      onDestroy = props.onDestroy;\n      props.lottieRef;\n      props.renderer;\n      props.name;\n      props.assetsPath;\n      props.rendererSettings;\n      var rest = _objectWithoutProperties(props, _excluded$1);\n    var _useState = React.useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      animationLoaded = _useState2[0],\n      setAnimationLoaded = _useState2[1];\n    var animationInstanceRef = React.useRef();\n    var animationContainer = React.useRef(null);\n    /*\n          ======================================\n              INTERACTION METHODS\n          ======================================\n       */\n    /**\n     * Play\n     */\n    var play = function play() {\n      var _a;\n      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.play();\n    };\n    /**\n     * Stop\n     */\n    var stop = function stop() {\n      var _a;\n      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.stop();\n    };\n    /**\n     * Pause\n     */\n    var pause = function pause() {\n      var _a;\n      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.pause();\n    };\n    /**\n     * Set animation speed\n     * @param speed\n     */\n    var setSpeed = function setSpeed(speed) {\n      var _a;\n      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.setSpeed(speed);\n    };\n    /**\n     * Got to frame and play\n     * @param value\n     * @param isFrame\n     */\n    var goToAndPlay = function goToAndPlay(value, isFrame) {\n      var _a;\n      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.goToAndPlay(value, isFrame);\n    };\n    /**\n     * Got to frame and stop\n     * @param value\n     * @param isFrame\n     */\n    var goToAndStop = function goToAndStop(value, isFrame) {\n      var _a;\n      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.goToAndStop(value, isFrame);\n    };\n    /**\n     * Set animation direction\n     * @param direction\n     */\n    var setDirection = function setDirection(direction) {\n      var _a;\n      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.setDirection(direction);\n    };\n    /**\n     * Play animation segments\n     * @param segments\n     * @param forceFlag\n     */\n    var playSegments = function playSegments(segments, forceFlag) {\n      var _a;\n      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.playSegments(segments, forceFlag);\n    };\n    /**\n     * Set sub frames\n     * @param useSubFrames\n     */\n    var setSubframe = function setSubframe(useSubFrames) {\n      var _a;\n      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.setSubframe(useSubFrames);\n    };\n    /**\n     * Get animation duration\n     * @param inFrames\n     */\n    var getDuration = function getDuration(inFrames) {\n      var _a;\n      return (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.getDuration(inFrames);\n    };\n    /**\n     * Destroy animation\n     */\n    var destroy = function destroy() {\n      var _a;\n      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.destroy();\n      // Removing the reference to the animation so separate cleanups are skipped.\n      // Without it the internal `lottie-react` instance throws exceptions as it already cleared itself on destroy.\n      animationInstanceRef.current = undefined;\n    };\n    /*\n          ======================================\n              LOTTIE\n          ======================================\n       */\n    /**\n     * Load a new animation, and if it's the case, destroy the previous one\n     * @param {Object} forcedConfigs\n     */\n    var loadAnimation = function loadAnimation() {\n      var forcedConfigs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _a;\n      // Return if the container ref is null\n      if (!animationContainer.current) {\n        return;\n      }\n      // Destroy any previous instance\n      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.destroy();\n      // Build the animation configuration\n      var config = _objectSpread2(_objectSpread2(_objectSpread2({}, props), forcedConfigs), {}, {\n        container: animationContainer.current\n      });\n      // Save the animation instance\n      animationInstanceRef.current = lottie__default[\"default\"].loadAnimation(config);\n      setAnimationLoaded(!!animationInstanceRef.current);\n      // Return a function that will clean up\n      return function () {\n        var _a;\n        (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.destroy();\n        animationInstanceRef.current = undefined;\n      };\n    };\n    /**\n     * (Re)Initialize when animation data changed\n     */\n    React.useEffect(function () {\n      var onUnmount = loadAnimation();\n      // Clean up on unmount\n      return function () {\n        return onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount();\n      };\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [animationData, loop]);\n    // Update the autoplay state\n    React.useEffect(function () {\n      if (!animationInstanceRef.current) {\n        return;\n      }\n      animationInstanceRef.current.autoplay = !!autoplay;\n    }, [autoplay]);\n    // Update the initial segment state\n    React.useEffect(function () {\n      if (!animationInstanceRef.current) {\n        return;\n      }\n      // When null should reset to default animation length\n      if (!initialSegment) {\n        animationInstanceRef.current.resetSegments(true);\n        return;\n      }\n      // If it's not a valid segment, do nothing\n      if (!Array.isArray(initialSegment) || !initialSegment.length) {\n        return;\n      }\n      // If the current position it's not in the new segment\n      // set the current position to start\n      if (animationInstanceRef.current.currentRawFrame < initialSegment[0] || animationInstanceRef.current.currentRawFrame > initialSegment[1]) {\n        animationInstanceRef.current.currentRawFrame = initialSegment[0];\n      }\n      // Update the segment\n      animationInstanceRef.current.setSegment(initialSegment[0], initialSegment[1]);\n    }, [initialSegment]);\n    /*\n          ======================================\n              EVENTS\n          ======================================\n       */\n    /**\n     * Reinitialize listener on change\n     */\n    React.useEffect(function () {\n      var partialListeners = [{\n        name: \"complete\",\n        handler: onComplete\n      }, {\n        name: \"loopComplete\",\n        handler: onLoopComplete\n      }, {\n        name: \"enterFrame\",\n        handler: onEnterFrame\n      }, {\n        name: \"segmentStart\",\n        handler: onSegmentStart\n      }, {\n        name: \"config_ready\",\n        handler: onConfigReady\n      }, {\n        name: \"data_ready\",\n        handler: onDataReady\n      }, {\n        name: \"data_failed\",\n        handler: onDataFailed\n      }, {\n        name: \"loaded_images\",\n        handler: onLoadedImages\n      }, {\n        name: \"DOMLoaded\",\n        handler: onDOMLoaded\n      }, {\n        name: \"destroy\",\n        handler: onDestroy\n      }];\n      var listeners = partialListeners.filter(function (listener) {\n        return listener.handler != null;\n      });\n      if (!listeners.length) {\n        return;\n      }\n      var deregisterList = listeners.map(\n      /**\n       * Handle the process of adding an event listener\n       * @param {Listener} listener\n       * @return {Function} Function that deregister the listener\n       */\n      function (listener) {\n        var _a;\n        (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.addEventListener(listener.name, listener.handler);\n        // Return a function to deregister this listener\n        return function () {\n          var _a;\n          (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.removeEventListener(listener.name, listener.handler);\n        };\n      });\n      // Deregister listeners on unmount\n      return function () {\n        deregisterList.forEach(function (deregister) {\n          return deregister();\n        });\n      };\n    }, [onComplete, onLoopComplete, onEnterFrame, onSegmentStart, onConfigReady, onDataReady, onDataFailed, onLoadedImages, onDOMLoaded, onDestroy]);\n    /**\n     * Build the animation view\n     */\n    var View = /*#__PURE__*/React__default[\"default\"].createElement(\"div\", _objectSpread2({\n      style: style,\n      ref: animationContainer\n    }, rest));\n    return {\n      View: View,\n      play: play,\n      stop: stop,\n      pause: pause,\n      setSpeed: setSpeed,\n      goToAndStop: goToAndStop,\n      goToAndPlay: goToAndPlay,\n      setDirection: setDirection,\n      playSegments: playSegments,\n      setSubframe: setSubframe,\n      getDuration: getDuration,\n      destroy: destroy,\n      animationContainerRef: animationContainer,\n      animationLoaded: animationLoaded,\n      animationItem: animationInstanceRef.current\n    };\n  };\n\n  // helpers\n  function getContainerVisibility(container) {\n    var _container$getBoundin = container.getBoundingClientRect(),\n      top = _container$getBoundin.top,\n      height = _container$getBoundin.height;\n    var current = window.innerHeight - top;\n    var max = window.innerHeight + height;\n    return current / max;\n  }\n  function getContainerCursorPosition(container, cursorX, cursorY) {\n    var _container$getBoundin2 = container.getBoundingClientRect(),\n      top = _container$getBoundin2.top,\n      left = _container$getBoundin2.left,\n      width = _container$getBoundin2.width,\n      height = _container$getBoundin2.height;\n    var x = (cursorX - left) / width;\n    var y = (cursorY - top) / height;\n    return {\n      x: x,\n      y: y\n    };\n  }\n  var useInitInteractivity = function useInitInteractivity(_ref) {\n    var wrapperRef = _ref.wrapperRef,\n      animationItem = _ref.animationItem,\n      mode = _ref.mode,\n      actions = _ref.actions;\n    React.useEffect(function () {\n      var wrapper = wrapperRef.current;\n      if (!wrapper || !animationItem || !actions.length) {\n        return;\n      }\n      animationItem.stop();\n      var scrollModeHandler = function scrollModeHandler() {\n        var assignedSegment = null;\n        var scrollHandler = function scrollHandler() {\n          var currentPercent = getContainerVisibility(wrapper);\n          // Find the first action that satisfies the current position conditions\n          var action = actions.find(function (_ref2) {\n            var visibility = _ref2.visibility;\n            return visibility && currentPercent >= visibility[0] && currentPercent <= visibility[1];\n          });\n          // Skip if no matching action was found!\n          if (!action) {\n            return;\n          }\n          if (action.type === \"seek\" && action.visibility && action.frames.length === 2) {\n            // Seek: Go to a frame based on player scroll position action\n            var frameToGo = action.frames[0] + Math.ceil((currentPercent - action.visibility[0]) / (action.visibility[1] - action.visibility[0]) * action.frames[1]);\n            //! goToAndStop must be relative to the start of the current segment\n            animationItem.goToAndStop(frameToGo - animationItem.firstFrame - 1, true);\n          }\n          if (action.type === \"loop\") {\n            // Loop: Loop a given frames\n            if (assignedSegment === null) {\n              // if not playing any segments currently. play those segments and save to state\n              animationItem.playSegments(action.frames, true);\n              assignedSegment = action.frames;\n            } else {\n              // if playing any segments currently.\n              //check if segments in state are equal to the frames selected by action\n              if (assignedSegment !== action.frames) {\n                // if they are not equal. new segments are to be loaded\n                animationItem.playSegments(action.frames, true);\n                assignedSegment = action.frames;\n              } else if (animationItem.isPaused) {\n                // if they are equal the play method must be called only if lottie is paused\n                animationItem.playSegments(action.frames, true);\n                assignedSegment = action.frames;\n              }\n            }\n          }\n          if (action.type === \"play\" && animationItem.isPaused) {\n            // Play: Reset segments and continue playing full animation from current position\n            animationItem.resetSegments(true);\n            animationItem.play();\n          }\n          if (action.type === \"stop\") {\n            // Stop: Stop playback\n            animationItem.goToAndStop(action.frames[0] - animationItem.firstFrame - 1, true);\n          }\n        };\n        document.addEventListener(\"scroll\", scrollHandler);\n        return function () {\n          document.removeEventListener(\"scroll\", scrollHandler);\n        };\n      };\n      var cursorModeHandler = function cursorModeHandler() {\n        var handleCursor = function handleCursor(_x, _y) {\n          var x = _x;\n          var y = _y;\n          // Resolve cursor position if cursor is inside container\n          if (x !== -1 && y !== -1) {\n            // Get container cursor position\n            var pos = getContainerCursorPosition(wrapper, x, y);\n            // Use the resolved position\n            x = pos.x;\n            y = pos.y;\n          }\n          // Find the first action that satisfies the current position conditions\n          var action = actions.find(function (_ref3) {\n            var position = _ref3.position;\n            if (position && Array.isArray(position.x) && Array.isArray(position.y)) {\n              return x >= position.x[0] && x <= position.x[1] && y >= position.y[0] && y <= position.y[1];\n            }\n            if (position && !Number.isNaN(position.x) && !Number.isNaN(position.y)) {\n              return x === position.x && y === position.y;\n            }\n            return false;\n          });\n          // Skip if no matching action was found!\n          if (!action) {\n            return;\n          }\n          // Process action types:\n          if (action.type === \"seek\" && action.position && Array.isArray(action.position.x) && Array.isArray(action.position.y) && action.frames.length === 2) {\n            // Seek: Go to a frame based on player scroll position action\n            var xPercent = (x - action.position.x[0]) / (action.position.x[1] - action.position.x[0]);\n            var yPercent = (y - action.position.y[0]) / (action.position.y[1] - action.position.y[0]);\n            animationItem.playSegments(action.frames, true);\n            animationItem.goToAndStop(Math.ceil((xPercent + yPercent) / 2 * (action.frames[1] - action.frames[0])), true);\n          }\n          if (action.type === \"loop\") {\n            animationItem.playSegments(action.frames, true);\n          }\n          if (action.type === \"play\") {\n            // Play: Reset segments and continue playing full animation from current position\n            if (animationItem.isPaused) {\n              animationItem.resetSegments(false);\n            }\n            animationItem.playSegments(action.frames);\n          }\n          if (action.type === \"stop\") {\n            animationItem.goToAndStop(action.frames[0], true);\n          }\n        };\n        var mouseMoveHandler = function mouseMoveHandler(ev) {\n          handleCursor(ev.clientX, ev.clientY);\n        };\n        var mouseOutHandler = function mouseOutHandler() {\n          handleCursor(-1, -1);\n        };\n        wrapper.addEventListener(\"mousemove\", mouseMoveHandler);\n        wrapper.addEventListener(\"mouseout\", mouseOutHandler);\n        return function () {\n          wrapper.removeEventListener(\"mousemove\", mouseMoveHandler);\n          wrapper.removeEventListener(\"mouseout\", mouseOutHandler);\n        };\n      };\n      switch (mode) {\n        case \"scroll\":\n          return scrollModeHandler();\n        case \"cursor\":\n          return cursorModeHandler();\n      }\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [mode, animationItem]);\n  };\n  var useLottieInteractivity = function useLottieInteractivity(_ref4) {\n    var actions = _ref4.actions,\n      mode = _ref4.mode,\n      lottieObj = _ref4.lottieObj;\n    var animationItem = lottieObj.animationItem,\n      View = lottieObj.View,\n      animationContainerRef = lottieObj.animationContainerRef;\n    useInitInteractivity({\n      actions: actions,\n      animationItem: animationItem,\n      mode: mode,\n      wrapperRef: animationContainerRef\n    });\n    return View;\n  };\n\n  var _excluded = [\"style\", \"interactivity\"];\n  var Lottie = function Lottie(props) {\n    var _a, _b, _c;\n    var style = props.style,\n      interactivity = props.interactivity,\n      lottieProps = _objectWithoutProperties(props, _excluded);\n    /**\n     * Initialize the 'useLottie' hook\n     */\n    var _useLottie = useLottie(lottieProps, style),\n      View = _useLottie.View,\n      play = _useLottie.play,\n      stop = _useLottie.stop,\n      pause = _useLottie.pause,\n      setSpeed = _useLottie.setSpeed,\n      goToAndStop = _useLottie.goToAndStop,\n      goToAndPlay = _useLottie.goToAndPlay,\n      setDirection = _useLottie.setDirection,\n      playSegments = _useLottie.playSegments,\n      setSubframe = _useLottie.setSubframe,\n      getDuration = _useLottie.getDuration,\n      destroy = _useLottie.destroy,\n      animationContainerRef = _useLottie.animationContainerRef,\n      animationLoaded = _useLottie.animationLoaded,\n      animationItem = _useLottie.animationItem;\n    /**\n     * Make the hook variables/methods available through the provided 'lottieRef'\n     */\n    React.useEffect(function () {\n      if (props.lottieRef) {\n        props.lottieRef.current = {\n          play: play,\n          stop: stop,\n          pause: pause,\n          setSpeed: setSpeed,\n          goToAndPlay: goToAndPlay,\n          goToAndStop: goToAndStop,\n          setDirection: setDirection,\n          playSegments: playSegments,\n          setSubframe: setSubframe,\n          getDuration: getDuration,\n          destroy: destroy,\n          animationContainerRef: animationContainerRef,\n          animationLoaded: animationLoaded,\n          animationItem: animationItem\n        };\n      }\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [(_a = props.lottieRef) === null || _a === void 0 ? void 0 : _a.current]);\n    return useLottieInteractivity({\n      lottieObj: {\n        View: View,\n        play: play,\n        stop: stop,\n        pause: pause,\n        setSpeed: setSpeed,\n        goToAndStop: goToAndStop,\n        goToAndPlay: goToAndPlay,\n        setDirection: setDirection,\n        playSegments: playSegments,\n        setSubframe: setSubframe,\n        getDuration: getDuration,\n        destroy: destroy,\n        animationContainerRef: animationContainerRef,\n        animationLoaded: animationLoaded,\n        animationItem: animationItem\n      },\n      actions: (_b = interactivity === null || interactivity === void 0 ? void 0 : interactivity.actions) !== null && _b !== void 0 ? _b : [],\n      mode: (_c = interactivity === null || interactivity === void 0 ? void 0 : interactivity.mode) !== null && _c !== void 0 ? _c : \"scroll\"\n    });\n  };\n\n  Object.defineProperty(exports, 'LottiePlayer', {\n    enumerable: true,\n    get: function () { return lottie__default[\"default\"]; }\n  });\n  exports[\"default\"] = Lottie;\n  exports.useLottie = useLottie;\n  exports.useLottieInteractivity = useLottieInteractivity;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=index.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb3R0aWUtcmVhY3QvYnVpbGQvaW5kZXgudW1kLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsRUFBRSxLQUE0RCxvQkFBb0IsbUJBQU8sQ0FBQyx3RkFBWSxHQUFHLG1CQUFPLENBQUMsbUZBQU87QUFDeEgsRUFBRSxDQUM2STtBQUMvSSxDQUFDLDZDQUE2Qzs7QUFFOUMsdUNBQXVDLDREQUE0RDs7QUFFbkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZLDZFQUE2RTtBQUNuRyxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSw0QkFBNEI7QUFDOUY7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELGFBQWE7O0FBRTlELENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG90dGllLXJlYWN0L2J1aWxkL2luZGV4LnVtZC5qcz8wNzUwIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnbG90dGllLXdlYicpLCByZXF1aXJlKCdyZWFjdCcpKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnbG90dGllLXdlYicsICdyZWFjdCddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsW1wibG90dGllLXJlYWN0XCJdID0ge30sIGdsb2JhbC5Mb3R0aWUsIGdsb2JhbC5SZWFjdCkpO1xufSkodGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLCBsb3R0aWUsIFJlYWN0KSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3kgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxuICB2YXIgbG90dGllX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShsb3R0aWUpO1xuICB2YXIgUmVhY3RfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KFJlYWN0KTtcblxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gICAgdmFyIF9pID0gbnVsbCA9PSBhcnIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG4gICAgaWYgKG51bGwgIT0gX2kpIHtcbiAgICAgIHZhciBfcyxcbiAgICAgICAgX2UsXG4gICAgICAgIF94LFxuICAgICAgICBfcixcbiAgICAgICAgX2FyciA9IFtdLFxuICAgICAgICBfbiA9ICEwLFxuICAgICAgICBfZCA9ICExO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKF94ID0gKF9pID0gX2kuY2FsbChhcnIpKS5uZXh0LCAwID09PSBpKSB7XG4gICAgICAgICAgaWYgKE9iamVjdChfaSkgIT09IF9pKSByZXR1cm47XG4gICAgICAgICAgX24gPSAhMTtcbiAgICAgICAgfSBlbHNlIGZvciAoOyAhKF9uID0gKF9zID0gX3guY2FsbChfaSkpLmRvbmUpICYmIChfYXJyLnB1c2goX3MudmFsdWUpLCBfYXJyLmxlbmd0aCAhPT0gaSk7IF9uID0gITApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kID0gITAsIF9lID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9uICYmIG51bGwgIT0gX2kucmV0dXJuICYmIChfciA9IF9pLnJldHVybigpLCBPYmplY3QoX3IpICE9PSBfcikpIHJldHVybjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX2FycjtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICAgIGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgIH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbiAgfVxuICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgICBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpO1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gICAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gICAgdmFyIHRhcmdldCA9IHt9O1xuICAgIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICB2YXIga2V5LCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gICAgdmFyIGtleSwgaTtcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICAgIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG4gIH1cbiAgZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG4gIH1cbiAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICAgIGlmICghbykgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICAgIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB9XG4gIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuICAgIHJldHVybiBhcnIyO1xuICB9XG4gIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgfVxuICBmdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gICAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICAgIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgICAgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gICAgfVxuICAgIHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xuICB9XG4gIGZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICAgIHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTtcbiAgICByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpO1xuICB9XG5cbiAgdmFyIF9leGNsdWRlZCQxID0gW1wiYW5pbWF0aW9uRGF0YVwiLCBcImxvb3BcIiwgXCJhdXRvcGxheVwiLCBcImluaXRpYWxTZWdtZW50XCIsIFwib25Db21wbGV0ZVwiLCBcIm9uTG9vcENvbXBsZXRlXCIsIFwib25FbnRlckZyYW1lXCIsIFwib25TZWdtZW50U3RhcnRcIiwgXCJvbkNvbmZpZ1JlYWR5XCIsIFwib25EYXRhUmVhZHlcIiwgXCJvbkRhdGFGYWlsZWRcIiwgXCJvbkxvYWRlZEltYWdlc1wiLCBcIm9uRE9NTG9hZGVkXCIsIFwib25EZXN0cm95XCIsIFwibG90dGllUmVmXCIsIFwicmVuZGVyZXJcIiwgXCJuYW1lXCIsIFwiYXNzZXRzUGF0aFwiLCBcInJlbmRlcmVyU2V0dGluZ3NcIl07XG4gIHZhciB1c2VMb3R0aWUgPSBmdW5jdGlvbiB1c2VMb3R0aWUocHJvcHMsIHN0eWxlKSB7XG4gICAgdmFyIGFuaW1hdGlvbkRhdGEgPSBwcm9wcy5hbmltYXRpb25EYXRhLFxuICAgICAgbG9vcCA9IHByb3BzLmxvb3AsXG4gICAgICBhdXRvcGxheSA9IHByb3BzLmF1dG9wbGF5LFxuICAgICAgaW5pdGlhbFNlZ21lbnQgPSBwcm9wcy5pbml0aWFsU2VnbWVudCxcbiAgICAgIG9uQ29tcGxldGUgPSBwcm9wcy5vbkNvbXBsZXRlLFxuICAgICAgb25Mb29wQ29tcGxldGUgPSBwcm9wcy5vbkxvb3BDb21wbGV0ZSxcbiAgICAgIG9uRW50ZXJGcmFtZSA9IHByb3BzLm9uRW50ZXJGcmFtZSxcbiAgICAgIG9uU2VnbWVudFN0YXJ0ID0gcHJvcHMub25TZWdtZW50U3RhcnQsXG4gICAgICBvbkNvbmZpZ1JlYWR5ID0gcHJvcHMub25Db25maWdSZWFkeSxcbiAgICAgIG9uRGF0YVJlYWR5ID0gcHJvcHMub25EYXRhUmVhZHksXG4gICAgICBvbkRhdGFGYWlsZWQgPSBwcm9wcy5vbkRhdGFGYWlsZWQsXG4gICAgICBvbkxvYWRlZEltYWdlcyA9IHByb3BzLm9uTG9hZGVkSW1hZ2VzLFxuICAgICAgb25ET01Mb2FkZWQgPSBwcm9wcy5vbkRPTUxvYWRlZCxcbiAgICAgIG9uRGVzdHJveSA9IHByb3BzLm9uRGVzdHJveTtcbiAgICAgIHByb3BzLmxvdHRpZVJlZjtcbiAgICAgIHByb3BzLnJlbmRlcmVyO1xuICAgICAgcHJvcHMubmFtZTtcbiAgICAgIHByb3BzLmFzc2V0c1BhdGg7XG4gICAgICBwcm9wcy5yZW5kZXJlclNldHRpbmdzO1xuICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIF9leGNsdWRlZCQxKTtcbiAgICB2YXIgX3VzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLFxuICAgICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMiksXG4gICAgICBhbmltYXRpb25Mb2FkZWQgPSBfdXNlU3RhdGUyWzBdLFxuICAgICAgc2V0QW5pbWF0aW9uTG9hZGVkID0gX3VzZVN0YXRlMlsxXTtcbiAgICB2YXIgYW5pbWF0aW9uSW5zdGFuY2VSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgICB2YXIgYW5pbWF0aW9uQ29udGFpbmVyID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIC8qXG4gICAgICAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgICAgSU5URVJBQ1RJT04gTUVUSE9EU1xuICAgICAgICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgKi9cbiAgICAvKipcbiAgICAgKiBQbGF5XG4gICAgICovXG4gICAgdmFyIHBsYXkgPSBmdW5jdGlvbiBwbGF5KCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gYW5pbWF0aW9uSW5zdGFuY2VSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBsYXkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0b3BcbiAgICAgKi9cbiAgICB2YXIgc3RvcCA9IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSBhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RvcCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGF1c2VcbiAgICAgKi9cbiAgICB2YXIgcGF1c2UgPSBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IGFuaW1hdGlvbkluc3RhbmNlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXVzZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IGFuaW1hdGlvbiBzcGVlZFxuICAgICAqIEBwYXJhbSBzcGVlZFxuICAgICAqL1xuICAgIHZhciBzZXRTcGVlZCA9IGZ1bmN0aW9uIHNldFNwZWVkKHNwZWVkKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSBhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0U3BlZWQoc3BlZWQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR290IHRvIGZyYW1lIGFuZCBwbGF5XG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHBhcmFtIGlzRnJhbWVcbiAgICAgKi9cbiAgICB2YXIgZ29Ub0FuZFBsYXkgPSBmdW5jdGlvbiBnb1RvQW5kUGxheSh2YWx1ZSwgaXNGcmFtZSkge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gYW5pbWF0aW9uSW5zdGFuY2VSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdvVG9BbmRQbGF5KHZhbHVlLCBpc0ZyYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdvdCB0byBmcmFtZSBhbmQgc3RvcFxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSBpc0ZyYW1lXG4gICAgICovXG4gICAgdmFyIGdvVG9BbmRTdG9wID0gZnVuY3Rpb24gZ29Ub0FuZFN0b3AodmFsdWUsIGlzRnJhbWUpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IGFuaW1hdGlvbkluc3RhbmNlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nb1RvQW5kU3RvcCh2YWx1ZSwgaXNGcmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgYW5pbWF0aW9uIGRpcmVjdGlvblxuICAgICAqIEBwYXJhbSBkaXJlY3Rpb25cbiAgICAgKi9cbiAgICB2YXIgc2V0RGlyZWN0aW9uID0gZnVuY3Rpb24gc2V0RGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gYW5pbWF0aW9uSW5zdGFuY2VSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGxheSBhbmltYXRpb24gc2VnbWVudHNcbiAgICAgKiBAcGFyYW0gc2VnbWVudHNcbiAgICAgKiBAcGFyYW0gZm9yY2VGbGFnXG4gICAgICovXG4gICAgdmFyIHBsYXlTZWdtZW50cyA9IGZ1bmN0aW9uIHBsYXlTZWdtZW50cyhzZWdtZW50cywgZm9yY2VGbGFnKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSBhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGxheVNlZ21lbnRzKHNlZ21lbnRzLCBmb3JjZUZsYWcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHN1YiBmcmFtZXNcbiAgICAgKiBAcGFyYW0gdXNlU3ViRnJhbWVzXG4gICAgICovXG4gICAgdmFyIHNldFN1YmZyYW1lID0gZnVuY3Rpb24gc2V0U3ViZnJhbWUodXNlU3ViRnJhbWVzKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSBhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0U3ViZnJhbWUodXNlU3ViRnJhbWVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBhbmltYXRpb24gZHVyYXRpb25cbiAgICAgKiBAcGFyYW0gaW5GcmFtZXNcbiAgICAgKi9cbiAgICB2YXIgZ2V0RHVyYXRpb24gPSBmdW5jdGlvbiBnZXREdXJhdGlvbihpbkZyYW1lcykge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIChfYSA9IGFuaW1hdGlvbkluc3RhbmNlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXREdXJhdGlvbihpbkZyYW1lcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95IGFuaW1hdGlvblxuICAgICAqL1xuICAgIHZhciBkZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IGFuaW1hdGlvbkluc3RhbmNlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KCk7XG4gICAgICAvLyBSZW1vdmluZyB0aGUgcmVmZXJlbmNlIHRvIHRoZSBhbmltYXRpb24gc28gc2VwYXJhdGUgY2xlYW51cHMgYXJlIHNraXBwZWQuXG4gICAgICAvLyBXaXRob3V0IGl0IHRoZSBpbnRlcm5hbCBgbG90dGllLXJlYWN0YCBpbnN0YW5jZSB0aHJvd3MgZXhjZXB0aW9ucyBhcyBpdCBhbHJlYWR5IGNsZWFyZWQgaXRzZWxmIG9uIGRlc3Ryb3kuXG4gICAgICBhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLypcbiAgICAgICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgICBMT1RUSUVcbiAgICAgICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICovXG4gICAgLyoqXG4gICAgICogTG9hZCBhIG5ldyBhbmltYXRpb24sIGFuZCBpZiBpdCdzIHRoZSBjYXNlLCBkZXN0cm95IHRoZSBwcmV2aW91cyBvbmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZm9yY2VkQ29uZmlnc1xuICAgICAqL1xuICAgIHZhciBsb2FkQW5pbWF0aW9uID0gZnVuY3Rpb24gbG9hZEFuaW1hdGlvbigpIHtcbiAgICAgIHZhciBmb3JjZWRDb25maWdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIHZhciBfYTtcbiAgICAgIC8vIFJldHVybiBpZiB0aGUgY29udGFpbmVyIHJlZiBpcyBudWxsXG4gICAgICBpZiAoIWFuaW1hdGlvbkNvbnRhaW5lci5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIERlc3Ryb3kgYW55IHByZXZpb3VzIGluc3RhbmNlXG4gICAgICAoX2EgPSBhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgICAgLy8gQnVpbGQgdGhlIGFuaW1hdGlvbiBjb25maWd1cmF0aW9uXG4gICAgICB2YXIgY29uZmlnID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHByb3BzKSwgZm9yY2VkQ29uZmlncyksIHt9LCB7XG4gICAgICAgIGNvbnRhaW5lcjogYW5pbWF0aW9uQ29udGFpbmVyLmN1cnJlbnRcbiAgICAgIH0pO1xuICAgICAgLy8gU2F2ZSB0aGUgYW5pbWF0aW9uIGluc3RhbmNlXG4gICAgICBhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50ID0gbG90dGllX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5sb2FkQW5pbWF0aW9uKGNvbmZpZyk7XG4gICAgICBzZXRBbmltYXRpb25Mb2FkZWQoISFhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50KTtcbiAgICAgIC8vIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBjbGVhbiB1cFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSBhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgICAgICBhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIChSZSlJbml0aWFsaXplIHdoZW4gYW5pbWF0aW9uIGRhdGEgY2hhbmdlZFxuICAgICAqL1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb25Vbm1vdW50ID0gbG9hZEFuaW1hdGlvbigpO1xuICAgICAgLy8gQ2xlYW4gdXAgb24gdW5tb3VudFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG9uVW5tb3VudCA9PT0gbnVsbCB8fCBvblVubW91bnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uVW5tb3VudCgpO1xuICAgICAgfTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbYW5pbWF0aW9uRGF0YSwgbG9vcF0pO1xuICAgIC8vIFVwZGF0ZSB0aGUgYXV0b3BsYXkgc3RhdGVcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGFuaW1hdGlvbkluc3RhbmNlUmVmLmN1cnJlbnQuYXV0b3BsYXkgPSAhIWF1dG9wbGF5O1xuICAgIH0sIFthdXRvcGxheV0pO1xuICAgIC8vIFVwZGF0ZSB0aGUgaW5pdGlhbCBzZWdtZW50IHN0YXRlXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghYW5pbWF0aW9uSW5zdGFuY2VSZWYuY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBXaGVuIG51bGwgc2hvdWxkIHJlc2V0IHRvIGRlZmF1bHQgYW5pbWF0aW9uIGxlbmd0aFxuICAgICAgaWYgKCFpbml0aWFsU2VnbWVudCkge1xuICAgICAgICBhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50LnJlc2V0U2VnbWVudHModHJ1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIElmIGl0J3Mgbm90IGEgdmFsaWQgc2VnbWVudCwgZG8gbm90aGluZ1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGluaXRpYWxTZWdtZW50KSB8fCAhaW5pdGlhbFNlZ21lbnQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSBjdXJyZW50IHBvc2l0aW9uIGl0J3Mgbm90IGluIHRoZSBuZXcgc2VnbWVudFxuICAgICAgLy8gc2V0IHRoZSBjdXJyZW50IHBvc2l0aW9uIHRvIHN0YXJ0XG4gICAgICBpZiAoYW5pbWF0aW9uSW5zdGFuY2VSZWYuY3VycmVudC5jdXJyZW50UmF3RnJhbWUgPCBpbml0aWFsU2VnbWVudFswXSB8fCBhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50LmN1cnJlbnRSYXdGcmFtZSA+IGluaXRpYWxTZWdtZW50WzFdKSB7XG4gICAgICAgIGFuaW1hdGlvbkluc3RhbmNlUmVmLmN1cnJlbnQuY3VycmVudFJhd0ZyYW1lID0gaW5pdGlhbFNlZ21lbnRbMF07XG4gICAgICB9XG4gICAgICAvLyBVcGRhdGUgdGhlIHNlZ21lbnRcbiAgICAgIGFuaW1hdGlvbkluc3RhbmNlUmVmLmN1cnJlbnQuc2V0U2VnbWVudChpbml0aWFsU2VnbWVudFswXSwgaW5pdGlhbFNlZ21lbnRbMV0pO1xuICAgIH0sIFtpbml0aWFsU2VnbWVudF0pO1xuICAgIC8qXG4gICAgICAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgICAgRVZFTlRTXG4gICAgICAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAqL1xuICAgIC8qKlxuICAgICAqIFJlaW5pdGlhbGl6ZSBsaXN0ZW5lciBvbiBjaGFuZ2VcbiAgICAgKi9cbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcnRpYWxMaXN0ZW5lcnMgPSBbe1xuICAgICAgICBuYW1lOiBcImNvbXBsZXRlXCIsXG4gICAgICAgIGhhbmRsZXI6IG9uQ29tcGxldGVcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJsb29wQ29tcGxldGVcIixcbiAgICAgICAgaGFuZGxlcjogb25Mb29wQ29tcGxldGVcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJlbnRlckZyYW1lXCIsXG4gICAgICAgIGhhbmRsZXI6IG9uRW50ZXJGcmFtZVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiBcInNlZ21lbnRTdGFydFwiLFxuICAgICAgICBoYW5kbGVyOiBvblNlZ21lbnRTdGFydFxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiBcImNvbmZpZ19yZWFkeVwiLFxuICAgICAgICBoYW5kbGVyOiBvbkNvbmZpZ1JlYWR5XG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiZGF0YV9yZWFkeVwiLFxuICAgICAgICBoYW5kbGVyOiBvbkRhdGFSZWFkeVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiBcImRhdGFfZmFpbGVkXCIsXG4gICAgICAgIGhhbmRsZXI6IG9uRGF0YUZhaWxlZFxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiBcImxvYWRlZF9pbWFnZXNcIixcbiAgICAgICAgaGFuZGxlcjogb25Mb2FkZWRJbWFnZXNcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJET01Mb2FkZWRcIixcbiAgICAgICAgaGFuZGxlcjogb25ET01Mb2FkZWRcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJkZXN0cm95XCIsXG4gICAgICAgIGhhbmRsZXI6IG9uRGVzdHJveVxuICAgICAgfV07XG4gICAgICB2YXIgbGlzdGVuZXJzID0gcGFydGlhbExpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lci5oYW5kbGVyICE9IG51bGw7XG4gICAgICB9KTtcbiAgICAgIGlmICghbGlzdGVuZXJzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZGVyZWdpc3Rlckxpc3QgPSBsaXN0ZW5lcnMubWFwKFxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgdGhlIHByb2Nlc3Mgb2YgYWRkaW5nIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICAgKiBAcGFyYW0ge0xpc3RlbmVyfSBsaXN0ZW5lclxuICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgZGVyZWdpc3RlciB0aGUgbGlzdGVuZXJcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gYW5pbWF0aW9uSW5zdGFuY2VSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZEV2ZW50TGlzdGVuZXIobGlzdGVuZXIubmFtZSwgbGlzdGVuZXIuaGFuZGxlcik7XG4gICAgICAgIC8vIFJldHVybiBhIGZ1bmN0aW9uIHRvIGRlcmVnaXN0ZXIgdGhpcyBsaXN0ZW5lclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAoX2EgPSBhbmltYXRpb25JbnN0YW5jZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlRXZlbnRMaXN0ZW5lcihsaXN0ZW5lci5uYW1lLCBsaXN0ZW5lci5oYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgLy8gRGVyZWdpc3RlciBsaXN0ZW5lcnMgb24gdW5tb3VudFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVyZWdpc3Rlckxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZGVyZWdpc3Rlcikge1xuICAgICAgICAgIHJldHVybiBkZXJlZ2lzdGVyKCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9LCBbb25Db21wbGV0ZSwgb25Mb29wQ29tcGxldGUsIG9uRW50ZXJGcmFtZSwgb25TZWdtZW50U3RhcnQsIG9uQ29uZmlnUmVhZHksIG9uRGF0YVJlYWR5LCBvbkRhdGFGYWlsZWQsIG9uTG9hZGVkSW1hZ2VzLCBvbkRPTUxvYWRlZCwgb25EZXN0cm95XSk7XG4gICAgLyoqXG4gICAgICogQnVpbGQgdGhlIGFuaW1hdGlvbiB2aWV3XG4gICAgICovXG4gICAgdmFyIFZpZXcgPSAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX29iamVjdFNwcmVhZDIoe1xuICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgcmVmOiBhbmltYXRpb25Db250YWluZXJcbiAgICB9LCByZXN0KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIFZpZXc6IFZpZXcsXG4gICAgICBwbGF5OiBwbGF5LFxuICAgICAgc3RvcDogc3RvcCxcbiAgICAgIHBhdXNlOiBwYXVzZSxcbiAgICAgIHNldFNwZWVkOiBzZXRTcGVlZCxcbiAgICAgIGdvVG9BbmRTdG9wOiBnb1RvQW5kU3RvcCxcbiAgICAgIGdvVG9BbmRQbGF5OiBnb1RvQW5kUGxheSxcbiAgICAgIHNldERpcmVjdGlvbjogc2V0RGlyZWN0aW9uLFxuICAgICAgcGxheVNlZ21lbnRzOiBwbGF5U2VnbWVudHMsXG4gICAgICBzZXRTdWJmcmFtZTogc2V0U3ViZnJhbWUsXG4gICAgICBnZXREdXJhdGlvbjogZ2V0RHVyYXRpb24sXG4gICAgICBkZXN0cm95OiBkZXN0cm95LFxuICAgICAgYW5pbWF0aW9uQ29udGFpbmVyUmVmOiBhbmltYXRpb25Db250YWluZXIsXG4gICAgICBhbmltYXRpb25Mb2FkZWQ6IGFuaW1hdGlvbkxvYWRlZCxcbiAgICAgIGFuaW1hdGlvbkl0ZW06IGFuaW1hdGlvbkluc3RhbmNlUmVmLmN1cnJlbnRcbiAgICB9O1xuICB9O1xuXG4gIC8vIGhlbHBlcnNcbiAgZnVuY3Rpb24gZ2V0Q29udGFpbmVyVmlzaWJpbGl0eShjb250YWluZXIpIHtcbiAgICB2YXIgX2NvbnRhaW5lciRnZXRCb3VuZGluID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgdG9wID0gX2NvbnRhaW5lciRnZXRCb3VuZGluLnRvcCxcbiAgICAgIGhlaWdodCA9IF9jb250YWluZXIkZ2V0Qm91bmRpbi5oZWlnaHQ7XG4gICAgdmFyIGN1cnJlbnQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSB0b3A7XG4gICAgdmFyIG1heCA9IHdpbmRvdy5pbm5lckhlaWdodCArIGhlaWdodDtcbiAgICByZXR1cm4gY3VycmVudCAvIG1heDtcbiAgfVxuICBmdW5jdGlvbiBnZXRDb250YWluZXJDdXJzb3JQb3NpdGlvbihjb250YWluZXIsIGN1cnNvclgsIGN1cnNvclkpIHtcbiAgICB2YXIgX2NvbnRhaW5lciRnZXRCb3VuZGluMiA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIHRvcCA9IF9jb250YWluZXIkZ2V0Qm91bmRpbjIudG9wLFxuICAgICAgbGVmdCA9IF9jb250YWluZXIkZ2V0Qm91bmRpbjIubGVmdCxcbiAgICAgIHdpZHRoID0gX2NvbnRhaW5lciRnZXRCb3VuZGluMi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9jb250YWluZXIkZ2V0Qm91bmRpbjIuaGVpZ2h0O1xuICAgIHZhciB4ID0gKGN1cnNvclggLSBsZWZ0KSAvIHdpZHRoO1xuICAgIHZhciB5ID0gKGN1cnNvclkgLSB0b3ApIC8gaGVpZ2h0O1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH07XG4gIH1cbiAgdmFyIHVzZUluaXRJbnRlcmFjdGl2aXR5ID0gZnVuY3Rpb24gdXNlSW5pdEludGVyYWN0aXZpdHkoX3JlZikge1xuICAgIHZhciB3cmFwcGVyUmVmID0gX3JlZi53cmFwcGVyUmVmLFxuICAgICAgYW5pbWF0aW9uSXRlbSA9IF9yZWYuYW5pbWF0aW9uSXRlbSxcbiAgICAgIG1vZGUgPSBfcmVmLm1vZGUsXG4gICAgICBhY3Rpb25zID0gX3JlZi5hY3Rpb25zO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgd3JhcHBlciA9IHdyYXBwZXJSZWYuY3VycmVudDtcbiAgICAgIGlmICghd3JhcHBlciB8fCAhYW5pbWF0aW9uSXRlbSB8fCAhYWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYW5pbWF0aW9uSXRlbS5zdG9wKCk7XG4gICAgICB2YXIgc2Nyb2xsTW9kZUhhbmRsZXIgPSBmdW5jdGlvbiBzY3JvbGxNb2RlSGFuZGxlcigpIHtcbiAgICAgICAgdmFyIGFzc2lnbmVkU2VnbWVudCA9IG51bGw7XG4gICAgICAgIHZhciBzY3JvbGxIYW5kbGVyID0gZnVuY3Rpb24gc2Nyb2xsSGFuZGxlcigpIHtcbiAgICAgICAgICB2YXIgY3VycmVudFBlcmNlbnQgPSBnZXRDb250YWluZXJWaXNpYmlsaXR5KHdyYXBwZXIpO1xuICAgICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IGFjdGlvbiB0aGF0IHNhdGlzZmllcyB0aGUgY3VycmVudCBwb3NpdGlvbiBjb25kaXRpb25zXG4gICAgICAgICAgdmFyIGFjdGlvbiA9IGFjdGlvbnMuZmluZChmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgICAgIHZhciB2aXNpYmlsaXR5ID0gX3JlZjIudmlzaWJpbGl0eTtcbiAgICAgICAgICAgIHJldHVybiB2aXNpYmlsaXR5ICYmIGN1cnJlbnRQZXJjZW50ID49IHZpc2liaWxpdHlbMF0gJiYgY3VycmVudFBlcmNlbnQgPD0gdmlzaWJpbGl0eVsxXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBTa2lwIGlmIG5vIG1hdGNoaW5nIGFjdGlvbiB3YXMgZm91bmQhXG4gICAgICAgICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSBcInNlZWtcIiAmJiBhY3Rpb24udmlzaWJpbGl0eSAmJiBhY3Rpb24uZnJhbWVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgLy8gU2VlazogR28gdG8gYSBmcmFtZSBiYXNlZCBvbiBwbGF5ZXIgc2Nyb2xsIHBvc2l0aW9uIGFjdGlvblxuICAgICAgICAgICAgdmFyIGZyYW1lVG9HbyA9IGFjdGlvbi5mcmFtZXNbMF0gKyBNYXRoLmNlaWwoKGN1cnJlbnRQZXJjZW50IC0gYWN0aW9uLnZpc2liaWxpdHlbMF0pIC8gKGFjdGlvbi52aXNpYmlsaXR5WzFdIC0gYWN0aW9uLnZpc2liaWxpdHlbMF0pICogYWN0aW9uLmZyYW1lc1sxXSk7XG4gICAgICAgICAgICAvLyEgZ29Ub0FuZFN0b3AgbXVzdCBiZSByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGN1cnJlbnQgc2VnbWVudFxuICAgICAgICAgICAgYW5pbWF0aW9uSXRlbS5nb1RvQW5kU3RvcChmcmFtZVRvR28gLSBhbmltYXRpb25JdGVtLmZpcnN0RnJhbWUgLSAxLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSBcImxvb3BcIikge1xuICAgICAgICAgICAgLy8gTG9vcDogTG9vcCBhIGdpdmVuIGZyYW1lc1xuICAgICAgICAgICAgaWYgKGFzc2lnbmVkU2VnbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBpZiBub3QgcGxheWluZyBhbnkgc2VnbWVudHMgY3VycmVudGx5LiBwbGF5IHRob3NlIHNlZ21lbnRzIGFuZCBzYXZlIHRvIHN0YXRlXG4gICAgICAgICAgICAgIGFuaW1hdGlvbkl0ZW0ucGxheVNlZ21lbnRzKGFjdGlvbi5mcmFtZXMsIHRydWUpO1xuICAgICAgICAgICAgICBhc3NpZ25lZFNlZ21lbnQgPSBhY3Rpb24uZnJhbWVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaWYgcGxheWluZyBhbnkgc2VnbWVudHMgY3VycmVudGx5LlxuICAgICAgICAgICAgICAvL2NoZWNrIGlmIHNlZ21lbnRzIGluIHN0YXRlIGFyZSBlcXVhbCB0byB0aGUgZnJhbWVzIHNlbGVjdGVkIGJ5IGFjdGlvblxuICAgICAgICAgICAgICBpZiAoYXNzaWduZWRTZWdtZW50ICE9PSBhY3Rpb24uZnJhbWVzKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhleSBhcmUgbm90IGVxdWFsLiBuZXcgc2VnbWVudHMgYXJlIHRvIGJlIGxvYWRlZFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbkl0ZW0ucGxheVNlZ21lbnRzKGFjdGlvbi5mcmFtZXMsIHRydWUpO1xuICAgICAgICAgICAgICAgIGFzc2lnbmVkU2VnbWVudCA9IGFjdGlvbi5mcmFtZXM7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYW5pbWF0aW9uSXRlbS5pc1BhdXNlZCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXkgYXJlIGVxdWFsIHRoZSBwbGF5IG1ldGhvZCBtdXN0IGJlIGNhbGxlZCBvbmx5IGlmIGxvdHRpZSBpcyBwYXVzZWRcbiAgICAgICAgICAgICAgICBhbmltYXRpb25JdGVtLnBsYXlTZWdtZW50cyhhY3Rpb24uZnJhbWVzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBhc3NpZ25lZFNlZ21lbnQgPSBhY3Rpb24uZnJhbWVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gXCJwbGF5XCIgJiYgYW5pbWF0aW9uSXRlbS5pc1BhdXNlZCkge1xuICAgICAgICAgICAgLy8gUGxheTogUmVzZXQgc2VnbWVudHMgYW5kIGNvbnRpbnVlIHBsYXlpbmcgZnVsbCBhbmltYXRpb24gZnJvbSBjdXJyZW50IHBvc2l0aW9uXG4gICAgICAgICAgICBhbmltYXRpb25JdGVtLnJlc2V0U2VnbWVudHModHJ1ZSk7XG4gICAgICAgICAgICBhbmltYXRpb25JdGVtLnBsYXkoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSBcInN0b3BcIikge1xuICAgICAgICAgICAgLy8gU3RvcDogU3RvcCBwbGF5YmFja1xuICAgICAgICAgICAgYW5pbWF0aW9uSXRlbS5nb1RvQW5kU3RvcChhY3Rpb24uZnJhbWVzWzBdIC0gYW5pbWF0aW9uSXRlbS5maXJzdEZyYW1lIC0gMSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHNjcm9sbEhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgc2Nyb2xsSGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgdmFyIGN1cnNvck1vZGVIYW5kbGVyID0gZnVuY3Rpb24gY3Vyc29yTW9kZUhhbmRsZXIoKSB7XG4gICAgICAgIHZhciBoYW5kbGVDdXJzb3IgPSBmdW5jdGlvbiBoYW5kbGVDdXJzb3IoX3gsIF95KSB7XG4gICAgICAgICAgdmFyIHggPSBfeDtcbiAgICAgICAgICB2YXIgeSA9IF95O1xuICAgICAgICAgIC8vIFJlc29sdmUgY3Vyc29yIHBvc2l0aW9uIGlmIGN1cnNvciBpcyBpbnNpZGUgY29udGFpbmVyXG4gICAgICAgICAgaWYgKHggIT09IC0xICYmIHkgIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBHZXQgY29udGFpbmVyIGN1cnNvciBwb3NpdGlvblxuICAgICAgICAgICAgdmFyIHBvcyA9IGdldENvbnRhaW5lckN1cnNvclBvc2l0aW9uKHdyYXBwZXIsIHgsIHkpO1xuICAgICAgICAgICAgLy8gVXNlIHRoZSByZXNvbHZlZCBwb3NpdGlvblxuICAgICAgICAgICAgeCA9IHBvcy54O1xuICAgICAgICAgICAgeSA9IHBvcy55O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCBhY3Rpb24gdGhhdCBzYXRpc2ZpZXMgdGhlIGN1cnJlbnQgcG9zaXRpb24gY29uZGl0aW9uc1xuICAgICAgICAgIHZhciBhY3Rpb24gPSBhY3Rpb25zLmZpbmQoZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBfcmVmMy5wb3NpdGlvbjtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiAmJiBBcnJheS5pc0FycmF5KHBvc2l0aW9uLngpICYmIEFycmF5LmlzQXJyYXkocG9zaXRpb24ueSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHggPj0gcG9zaXRpb24ueFswXSAmJiB4IDw9IHBvc2l0aW9uLnhbMV0gJiYgeSA+PSBwb3NpdGlvbi55WzBdICYmIHkgPD0gcG9zaXRpb24ueVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiAmJiAhTnVtYmVyLmlzTmFOKHBvc2l0aW9uLngpICYmICFOdW1iZXIuaXNOYU4ocG9zaXRpb24ueSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHggPT09IHBvc2l0aW9uLnggJiYgeSA9PT0gcG9zaXRpb24ueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBTa2lwIGlmIG5vIG1hdGNoaW5nIGFjdGlvbiB3YXMgZm91bmQhXG4gICAgICAgICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUHJvY2VzcyBhY3Rpb24gdHlwZXM6XG4gICAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSBcInNlZWtcIiAmJiBhY3Rpb24ucG9zaXRpb24gJiYgQXJyYXkuaXNBcnJheShhY3Rpb24ucG9zaXRpb24ueCkgJiYgQXJyYXkuaXNBcnJheShhY3Rpb24ucG9zaXRpb24ueSkgJiYgYWN0aW9uLmZyYW1lcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIC8vIFNlZWs6IEdvIHRvIGEgZnJhbWUgYmFzZWQgb24gcGxheWVyIHNjcm9sbCBwb3NpdGlvbiBhY3Rpb25cbiAgICAgICAgICAgIHZhciB4UGVyY2VudCA9ICh4IC0gYWN0aW9uLnBvc2l0aW9uLnhbMF0pIC8gKGFjdGlvbi5wb3NpdGlvbi54WzFdIC0gYWN0aW9uLnBvc2l0aW9uLnhbMF0pO1xuICAgICAgICAgICAgdmFyIHlQZXJjZW50ID0gKHkgLSBhY3Rpb24ucG9zaXRpb24ueVswXSkgLyAoYWN0aW9uLnBvc2l0aW9uLnlbMV0gLSBhY3Rpb24ucG9zaXRpb24ueVswXSk7XG4gICAgICAgICAgICBhbmltYXRpb25JdGVtLnBsYXlTZWdtZW50cyhhY3Rpb24uZnJhbWVzLCB0cnVlKTtcbiAgICAgICAgICAgIGFuaW1hdGlvbkl0ZW0uZ29Ub0FuZFN0b3AoTWF0aC5jZWlsKCh4UGVyY2VudCArIHlQZXJjZW50KSAvIDIgKiAoYWN0aW9uLmZyYW1lc1sxXSAtIGFjdGlvbi5mcmFtZXNbMF0pKSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gXCJsb29wXCIpIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbkl0ZW0ucGxheVNlZ21lbnRzKGFjdGlvbi5mcmFtZXMsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09IFwicGxheVwiKSB7XG4gICAgICAgICAgICAvLyBQbGF5OiBSZXNldCBzZWdtZW50cyBhbmQgY29udGludWUgcGxheWluZyBmdWxsIGFuaW1hdGlvbiBmcm9tIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgICAgIGlmIChhbmltYXRpb25JdGVtLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICAgIGFuaW1hdGlvbkl0ZW0ucmVzZXRTZWdtZW50cyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmltYXRpb25JdGVtLnBsYXlTZWdtZW50cyhhY3Rpb24uZnJhbWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSBcInN0b3BcIikge1xuICAgICAgICAgICAgYW5pbWF0aW9uSXRlbS5nb1RvQW5kU3RvcChhY3Rpb24uZnJhbWVzWzBdLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtb3VzZU1vdmVIYW5kbGVyID0gZnVuY3Rpb24gbW91c2VNb3ZlSGFuZGxlcihldikge1xuICAgICAgICAgIGhhbmRsZUN1cnNvcihldi5jbGllbnRYLCBldi5jbGllbnRZKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1vdXNlT3V0SGFuZGxlciA9IGZ1bmN0aW9uIG1vdXNlT3V0SGFuZGxlcigpIHtcbiAgICAgICAgICBoYW5kbGVDdXJzb3IoLTEsIC0xKTtcbiAgICAgICAgfTtcbiAgICAgICAgd3JhcHBlci5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdXNlTW92ZUhhbmRsZXIpO1xuICAgICAgICB3cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCBtb3VzZU91dEhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBtb3VzZU1vdmVIYW5kbGVyKTtcbiAgICAgICAgICB3cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCBtb3VzZU91dEhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICBjYXNlIFwic2Nyb2xsXCI6XG4gICAgICAgICAgcmV0dXJuIHNjcm9sbE1vZGVIYW5kbGVyKCk7XG4gICAgICAgIGNhc2UgXCJjdXJzb3JcIjpcbiAgICAgICAgICByZXR1cm4gY3Vyc29yTW9kZUhhbmRsZXIoKTtcbiAgICAgIH1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbbW9kZSwgYW5pbWF0aW9uSXRlbV0pO1xuICB9O1xuICB2YXIgdXNlTG90dGllSW50ZXJhY3Rpdml0eSA9IGZ1bmN0aW9uIHVzZUxvdHRpZUludGVyYWN0aXZpdHkoX3JlZjQpIHtcbiAgICB2YXIgYWN0aW9ucyA9IF9yZWY0LmFjdGlvbnMsXG4gICAgICBtb2RlID0gX3JlZjQubW9kZSxcbiAgICAgIGxvdHRpZU9iaiA9IF9yZWY0LmxvdHRpZU9iajtcbiAgICB2YXIgYW5pbWF0aW9uSXRlbSA9IGxvdHRpZU9iai5hbmltYXRpb25JdGVtLFxuICAgICAgVmlldyA9IGxvdHRpZU9iai5WaWV3LFxuICAgICAgYW5pbWF0aW9uQ29udGFpbmVyUmVmID0gbG90dGllT2JqLmFuaW1hdGlvbkNvbnRhaW5lclJlZjtcbiAgICB1c2VJbml0SW50ZXJhY3Rpdml0eSh7XG4gICAgICBhY3Rpb25zOiBhY3Rpb25zLFxuICAgICAgYW5pbWF0aW9uSXRlbTogYW5pbWF0aW9uSXRlbSxcbiAgICAgIG1vZGU6IG1vZGUsXG4gICAgICB3cmFwcGVyUmVmOiBhbmltYXRpb25Db250YWluZXJSZWZcbiAgICB9KTtcbiAgICByZXR1cm4gVmlldztcbiAgfTtcblxuICB2YXIgX2V4Y2x1ZGVkID0gW1wic3R5bGVcIiwgXCJpbnRlcmFjdGl2aXR5XCJdO1xuICB2YXIgTG90dGllID0gZnVuY3Rpb24gTG90dGllKHByb3BzKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgdmFyIHN0eWxlID0gcHJvcHMuc3R5bGUsXG4gICAgICBpbnRlcmFjdGl2aXR5ID0gcHJvcHMuaW50ZXJhY3Rpdml0eSxcbiAgICAgIGxvdHRpZVByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBfZXhjbHVkZWQpO1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlICd1c2VMb3R0aWUnIGhvb2tcbiAgICAgKi9cbiAgICB2YXIgX3VzZUxvdHRpZSA9IHVzZUxvdHRpZShsb3R0aWVQcm9wcywgc3R5bGUpLFxuICAgICAgVmlldyA9IF91c2VMb3R0aWUuVmlldyxcbiAgICAgIHBsYXkgPSBfdXNlTG90dGllLnBsYXksXG4gICAgICBzdG9wID0gX3VzZUxvdHRpZS5zdG9wLFxuICAgICAgcGF1c2UgPSBfdXNlTG90dGllLnBhdXNlLFxuICAgICAgc2V0U3BlZWQgPSBfdXNlTG90dGllLnNldFNwZWVkLFxuICAgICAgZ29Ub0FuZFN0b3AgPSBfdXNlTG90dGllLmdvVG9BbmRTdG9wLFxuICAgICAgZ29Ub0FuZFBsYXkgPSBfdXNlTG90dGllLmdvVG9BbmRQbGF5LFxuICAgICAgc2V0RGlyZWN0aW9uID0gX3VzZUxvdHRpZS5zZXREaXJlY3Rpb24sXG4gICAgICBwbGF5U2VnbWVudHMgPSBfdXNlTG90dGllLnBsYXlTZWdtZW50cyxcbiAgICAgIHNldFN1YmZyYW1lID0gX3VzZUxvdHRpZS5zZXRTdWJmcmFtZSxcbiAgICAgIGdldER1cmF0aW9uID0gX3VzZUxvdHRpZS5nZXREdXJhdGlvbixcbiAgICAgIGRlc3Ryb3kgPSBfdXNlTG90dGllLmRlc3Ryb3ksXG4gICAgICBhbmltYXRpb25Db250YWluZXJSZWYgPSBfdXNlTG90dGllLmFuaW1hdGlvbkNvbnRhaW5lclJlZixcbiAgICAgIGFuaW1hdGlvbkxvYWRlZCA9IF91c2VMb3R0aWUuYW5pbWF0aW9uTG9hZGVkLFxuICAgICAgYW5pbWF0aW9uSXRlbSA9IF91c2VMb3R0aWUuYW5pbWF0aW9uSXRlbTtcbiAgICAvKipcbiAgICAgKiBNYWtlIHRoZSBob29rIHZhcmlhYmxlcy9tZXRob2RzIGF2YWlsYWJsZSB0aHJvdWdoIHRoZSBwcm92aWRlZCAnbG90dGllUmVmJ1xuICAgICAqL1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocHJvcHMubG90dGllUmVmKSB7XG4gICAgICAgIHByb3BzLmxvdHRpZVJlZi5jdXJyZW50ID0ge1xuICAgICAgICAgIHBsYXk6IHBsYXksXG4gICAgICAgICAgc3RvcDogc3RvcCxcbiAgICAgICAgICBwYXVzZTogcGF1c2UsXG4gICAgICAgICAgc2V0U3BlZWQ6IHNldFNwZWVkLFxuICAgICAgICAgIGdvVG9BbmRQbGF5OiBnb1RvQW5kUGxheSxcbiAgICAgICAgICBnb1RvQW5kU3RvcDogZ29Ub0FuZFN0b3AsXG4gICAgICAgICAgc2V0RGlyZWN0aW9uOiBzZXREaXJlY3Rpb24sXG4gICAgICAgICAgcGxheVNlZ21lbnRzOiBwbGF5U2VnbWVudHMsXG4gICAgICAgICAgc2V0U3ViZnJhbWU6IHNldFN1YmZyYW1lLFxuICAgICAgICAgIGdldER1cmF0aW9uOiBnZXREdXJhdGlvbixcbiAgICAgICAgICBkZXN0cm95OiBkZXN0cm95LFxuICAgICAgICAgIGFuaW1hdGlvbkNvbnRhaW5lclJlZjogYW5pbWF0aW9uQ29udGFpbmVyUmVmLFxuICAgICAgICAgIGFuaW1hdGlvbkxvYWRlZDogYW5pbWF0aW9uTG9hZGVkLFxuICAgICAgICAgIGFuaW1hdGlvbkl0ZW06IGFuaW1hdGlvbkl0ZW1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbKF9hID0gcHJvcHMubG90dGllUmVmKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3VycmVudF0pO1xuICAgIHJldHVybiB1c2VMb3R0aWVJbnRlcmFjdGl2aXR5KHtcbiAgICAgIGxvdHRpZU9iajoge1xuICAgICAgICBWaWV3OiBWaWV3LFxuICAgICAgICBwbGF5OiBwbGF5LFxuICAgICAgICBzdG9wOiBzdG9wLFxuICAgICAgICBwYXVzZTogcGF1c2UsXG4gICAgICAgIHNldFNwZWVkOiBzZXRTcGVlZCxcbiAgICAgICAgZ29Ub0FuZFN0b3A6IGdvVG9BbmRTdG9wLFxuICAgICAgICBnb1RvQW5kUGxheTogZ29Ub0FuZFBsYXksXG4gICAgICAgIHNldERpcmVjdGlvbjogc2V0RGlyZWN0aW9uLFxuICAgICAgICBwbGF5U2VnbWVudHM6IHBsYXlTZWdtZW50cyxcbiAgICAgICAgc2V0U3ViZnJhbWU6IHNldFN1YmZyYW1lLFxuICAgICAgICBnZXREdXJhdGlvbjogZ2V0RHVyYXRpb24sXG4gICAgICAgIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gICAgICAgIGFuaW1hdGlvbkNvbnRhaW5lclJlZjogYW5pbWF0aW9uQ29udGFpbmVyUmVmLFxuICAgICAgICBhbmltYXRpb25Mb2FkZWQ6IGFuaW1hdGlvbkxvYWRlZCxcbiAgICAgICAgYW5pbWF0aW9uSXRlbTogYW5pbWF0aW9uSXRlbVxuICAgICAgfSxcbiAgICAgIGFjdGlvbnM6IChfYiA9IGludGVyYWN0aXZpdHkgPT09IG51bGwgfHwgaW50ZXJhY3Rpdml0eSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJhY3Rpdml0eS5hY3Rpb25zKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSxcbiAgICAgIG1vZGU6IChfYyA9IGludGVyYWN0aXZpdHkgPT09IG51bGwgfHwgaW50ZXJhY3Rpdml0eSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJhY3Rpdml0eS5tb2RlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBcInNjcm9sbFwiXG4gICAgfSk7XG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdMb3R0aWVQbGF5ZXInLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvdHRpZV9fZGVmYXVsdFtcImRlZmF1bHRcIl07IH1cbiAgfSk7XG4gIGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gTG90dGllO1xuICBleHBvcnRzLnVzZUxvdHRpZSA9IHVzZUxvdHRpZTtcbiAgZXhwb3J0cy51c2VMb3R0aWVJbnRlcmFjdGl2aXR5ID0gdXNlTG90dGllSW50ZXJhY3Rpdml0eTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC51bWQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lottie-react/build/index.umd.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lottie-web/build/player/lottie.js":
/*!********************************************************!*\
  !*** ./node_modules/lottie-web/build/player/lottie.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("(typeof navigator !== \"undefined\") && (function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n})(this, (function () { 'use strict';\n\n  var svgNS = 'http://www.w3.org/2000/svg';\n  var locationHref = '';\n  var _useWebWorker = false;\n  var initialDefaultFrame = -999999;\n\n  var setWebWorker = function setWebWorker(flag) {\n    _useWebWorker = !!flag;\n  };\n\n  var getWebWorker = function getWebWorker() {\n    return _useWebWorker;\n  };\n\n  var setLocationHref = function setLocationHref(value) {\n    locationHref = value;\n  };\n\n  var getLocationHref = function getLocationHref() {\n    return locationHref;\n  };\n\n  function createTag(type) {\n    // return {appendChild:function(){},setAttribute:function(){},style:{}}\n    return document.createElement(type);\n  }\n\n  function extendPrototype(sources, destination) {\n    var i;\n    var len = sources.length;\n    var sourcePrototype;\n\n    for (i = 0; i < len; i += 1) {\n      sourcePrototype = sources[i].prototype;\n\n      for (var attr in sourcePrototype) {\n        if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr)) destination.prototype[attr] = sourcePrototype[attr];\n      }\n    }\n  }\n\n  function getDescriptor(object, prop) {\n    return Object.getOwnPropertyDescriptor(object, prop);\n  }\n\n  function createProxyFunction(prototype) {\n    function ProxyFunction() {}\n\n    ProxyFunction.prototype = prototype;\n    return ProxyFunction;\n  }\n\n  // import Howl from '../../3rd_party/howler';\n  var audioControllerFactory = function () {\n    function AudioController(audioFactory) {\n      this.audios = [];\n      this.audioFactory = audioFactory;\n      this._volume = 1;\n      this._isMuted = false;\n    }\n\n    AudioController.prototype = {\n      addAudio: function addAudio(audio) {\n        this.audios.push(audio);\n      },\n      pause: function pause() {\n        var i;\n        var len = this.audios.length;\n\n        for (i = 0; i < len; i += 1) {\n          this.audios[i].pause();\n        }\n      },\n      resume: function resume() {\n        var i;\n        var len = this.audios.length;\n\n        for (i = 0; i < len; i += 1) {\n          this.audios[i].resume();\n        }\n      },\n      setRate: function setRate(rateValue) {\n        var i;\n        var len = this.audios.length;\n\n        for (i = 0; i < len; i += 1) {\n          this.audios[i].setRate(rateValue);\n        }\n      },\n      createAudio: function createAudio(assetPath) {\n        if (this.audioFactory) {\n          return this.audioFactory(assetPath);\n        }\n\n        if (window.Howl) {\n          return new window.Howl({\n            src: [assetPath]\n          });\n        }\n\n        return {\n          isPlaying: false,\n          play: function play() {\n            this.isPlaying = true;\n          },\n          seek: function seek() {\n            this.isPlaying = false;\n          },\n          playing: function playing() {},\n          rate: function rate() {},\n          setVolume: function setVolume() {}\n        };\n      },\n      setAudioFactory: function setAudioFactory(audioFactory) {\n        this.audioFactory = audioFactory;\n      },\n      setVolume: function setVolume(value) {\n        this._volume = value;\n\n        this._updateVolume();\n      },\n      mute: function mute() {\n        this._isMuted = true;\n\n        this._updateVolume();\n      },\n      unmute: function unmute() {\n        this._isMuted = false;\n\n        this._updateVolume();\n      },\n      getVolume: function getVolume() {\n        return this._volume;\n      },\n      _updateVolume: function _updateVolume() {\n        var i;\n        var len = this.audios.length;\n\n        for (i = 0; i < len; i += 1) {\n          this.audios[i].volume(this._volume * (this._isMuted ? 0 : 1));\n        }\n      }\n    };\n    return function () {\n      return new AudioController();\n    };\n  }();\n\n  var createTypedArray = function () {\n    function createRegularArray(type, len) {\n      var i = 0;\n      var arr = [];\n      var value;\n\n      switch (type) {\n        case 'int16':\n        case 'uint8c':\n          value = 1;\n          break;\n\n        default:\n          value = 1.1;\n          break;\n      }\n\n      for (i = 0; i < len; i += 1) {\n        arr.push(value);\n      }\n\n      return arr;\n    }\n\n    function createTypedArrayFactory(type, len) {\n      if (type === 'float32') {\n        return new Float32Array(len);\n      }\n\n      if (type === 'int16') {\n        return new Int16Array(len);\n      }\n\n      if (type === 'uint8c') {\n        return new Uint8ClampedArray(len);\n      }\n\n      return createRegularArray(type, len);\n    }\n\n    if (typeof Uint8ClampedArray === 'function' && typeof Float32Array === 'function') {\n      return createTypedArrayFactory;\n    }\n\n    return createRegularArray;\n  }();\n\n  function createSizedArray(len) {\n    return Array.apply(null, {\n      length: len\n    });\n  }\n\n  function _typeof$6(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof$6 = function _typeof(obj) { return typeof obj; }; } else { _typeof$6 = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof$6(obj); }\n  var subframeEnabled = true;\n  var expressionsPlugin = null;\n  var expressionsInterfaces = null;\n  var idPrefix$1 = '';\n  var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n  var _shouldRoundValues = false;\n  var bmPow = Math.pow;\n  var bmSqrt = Math.sqrt;\n  var bmFloor = Math.floor;\n  var bmMax = Math.max;\n  var bmMin = Math.min;\n  var BMMath = {};\n\n  (function () {\n    var propertyNames = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'atan2', 'ceil', 'cbrt', 'expm1', 'clz32', 'cos', 'cosh', 'exp', 'floor', 'fround', 'hypot', 'imul', 'log', 'log1p', 'log2', 'log10', 'max', 'min', 'pow', 'random', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc', 'E', 'LN10', 'LN2', 'LOG10E', 'LOG2E', 'PI', 'SQRT1_2', 'SQRT2'];\n    var i;\n    var len = propertyNames.length;\n\n    for (i = 0; i < len; i += 1) {\n      BMMath[propertyNames[i]] = Math[propertyNames[i]];\n    }\n  })();\n\n  function ProjectInterface$1() {\n    return {};\n  }\n\n  BMMath.random = Math.random;\n\n  BMMath.abs = function (val) {\n    var tOfVal = _typeof$6(val);\n\n    if (tOfVal === 'object' && val.length) {\n      var absArr = createSizedArray(val.length);\n      var i;\n      var len = val.length;\n\n      for (i = 0; i < len; i += 1) {\n        absArr[i] = Math.abs(val[i]);\n      }\n\n      return absArr;\n    }\n\n    return Math.abs(val);\n  };\n\n  var defaultCurveSegments = 150;\n  var degToRads = Math.PI / 180;\n  var roundCorner = 0.5519;\n\n  function roundValues(flag) {\n    _shouldRoundValues = !!flag;\n  }\n\n  function bmRnd(value) {\n    if (_shouldRoundValues) {\n      return Math.round(value);\n    }\n\n    return value;\n  }\n\n  function styleDiv(element) {\n    element.style.position = 'absolute';\n    element.style.top = 0;\n    element.style.left = 0;\n    element.style.display = 'block';\n    element.style.transformOrigin = '0 0';\n    element.style.webkitTransformOrigin = '0 0';\n    element.style.backfaceVisibility = 'visible';\n    element.style.webkitBackfaceVisibility = 'visible';\n    element.style.transformStyle = 'preserve-3d';\n    element.style.webkitTransformStyle = 'preserve-3d';\n    element.style.mozTransformStyle = 'preserve-3d';\n  }\n\n  function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier) {\n    this.type = type;\n    this.currentTime = currentTime;\n    this.totalTime = totalTime;\n    this.direction = frameMultiplier < 0 ? -1 : 1;\n  }\n\n  function BMCompleteEvent(type, frameMultiplier) {\n    this.type = type;\n    this.direction = frameMultiplier < 0 ? -1 : 1;\n  }\n\n  function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier) {\n    this.type = type;\n    this.currentLoop = currentLoop;\n    this.totalLoops = totalLoops;\n    this.direction = frameMultiplier < 0 ? -1 : 1;\n  }\n\n  function BMSegmentStartEvent(type, firstFrame, totalFrames) {\n    this.type = type;\n    this.firstFrame = firstFrame;\n    this.totalFrames = totalFrames;\n  }\n\n  function BMDestroyEvent(type, target) {\n    this.type = type;\n    this.target = target;\n  }\n\n  function BMRenderFrameErrorEvent(nativeError, currentTime) {\n    this.type = 'renderFrameError';\n    this.nativeError = nativeError;\n    this.currentTime = currentTime;\n  }\n\n  function BMConfigErrorEvent(nativeError) {\n    this.type = 'configError';\n    this.nativeError = nativeError;\n  }\n\n  function BMAnimationConfigErrorEvent(type, nativeError) {\n    this.type = type;\n    this.nativeError = nativeError;\n  }\n\n  var createElementID = function () {\n    var _count = 0;\n    return function createID() {\n      _count += 1;\n      return idPrefix$1 + '__lottie_element_' + _count;\n    };\n  }();\n\n  function HSVtoRGB(h, s, v) {\n    var r;\n    var g;\n    var b;\n    var i;\n    var f;\n    var p;\n    var q;\n    var t;\n    i = Math.floor(h * 6);\n    f = h * 6 - i;\n    p = v * (1 - s);\n    q = v * (1 - f * s);\n    t = v * (1 - (1 - f) * s);\n\n    switch (i % 6) {\n      case 0:\n        r = v;\n        g = t;\n        b = p;\n        break;\n\n      case 1:\n        r = q;\n        g = v;\n        b = p;\n        break;\n\n      case 2:\n        r = p;\n        g = v;\n        b = t;\n        break;\n\n      case 3:\n        r = p;\n        g = q;\n        b = v;\n        break;\n\n      case 4:\n        r = t;\n        g = p;\n        b = v;\n        break;\n\n      case 5:\n        r = v;\n        g = p;\n        b = q;\n        break;\n\n      default:\n        break;\n    }\n\n    return [r, g, b];\n  }\n\n  function RGBtoHSV(r, g, b) {\n    var max = Math.max(r, g, b);\n    var min = Math.min(r, g, b);\n    var d = max - min;\n    var h;\n    var s = max === 0 ? 0 : d / max;\n    var v = max / 255;\n\n    switch (max) {\n      case min:\n        h = 0;\n        break;\n\n      case r:\n        h = g - b + d * (g < b ? 6 : 0);\n        h /= 6 * d;\n        break;\n\n      case g:\n        h = b - r + d * 2;\n        h /= 6 * d;\n        break;\n\n      case b:\n        h = r - g + d * 4;\n        h /= 6 * d;\n        break;\n\n      default:\n        break;\n    }\n\n    return [h, s, v];\n  }\n\n  function addSaturationToRGB(color, offset) {\n    var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);\n    hsv[1] += offset;\n\n    if (hsv[1] > 1) {\n      hsv[1] = 1;\n    } else if (hsv[1] <= 0) {\n      hsv[1] = 0;\n    }\n\n    return HSVtoRGB(hsv[0], hsv[1], hsv[2]);\n  }\n\n  function addBrightnessToRGB(color, offset) {\n    var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);\n    hsv[2] += offset;\n\n    if (hsv[2] > 1) {\n      hsv[2] = 1;\n    } else if (hsv[2] < 0) {\n      hsv[2] = 0;\n    }\n\n    return HSVtoRGB(hsv[0], hsv[1], hsv[2]);\n  }\n\n  function addHueToRGB(color, offset) {\n    var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);\n    hsv[0] += offset / 360;\n\n    if (hsv[0] > 1) {\n      hsv[0] -= 1;\n    } else if (hsv[0] < 0) {\n      hsv[0] += 1;\n    }\n\n    return HSVtoRGB(hsv[0], hsv[1], hsv[2]);\n  }\n\n  var rgbToHex = function () {\n    var colorMap = [];\n    var i;\n    var hex;\n\n    for (i = 0; i < 256; i += 1) {\n      hex = i.toString(16);\n      colorMap[i] = hex.length === 1 ? '0' + hex : hex;\n    }\n\n    return function (r, g, b) {\n      if (r < 0) {\n        r = 0;\n      }\n\n      if (g < 0) {\n        g = 0;\n      }\n\n      if (b < 0) {\n        b = 0;\n      }\n\n      return '#' + colorMap[r] + colorMap[g] + colorMap[b];\n    };\n  }();\n\n  var setSubframeEnabled = function setSubframeEnabled(flag) {\n    subframeEnabled = !!flag;\n  };\n\n  var getSubframeEnabled = function getSubframeEnabled() {\n    return subframeEnabled;\n  };\n\n  var setExpressionsPlugin = function setExpressionsPlugin(value) {\n    expressionsPlugin = value;\n  };\n\n  var getExpressionsPlugin = function getExpressionsPlugin() {\n    return expressionsPlugin;\n  };\n\n  var setExpressionInterfaces = function setExpressionInterfaces(value) {\n    expressionsInterfaces = value;\n  };\n\n  var getExpressionInterfaces = function getExpressionInterfaces() {\n    return expressionsInterfaces;\n  };\n\n  var setDefaultCurveSegments = function setDefaultCurveSegments(value) {\n    defaultCurveSegments = value;\n  };\n\n  var getDefaultCurveSegments = function getDefaultCurveSegments() {\n    return defaultCurveSegments;\n  };\n\n  var setIdPrefix = function setIdPrefix(value) {\n    idPrefix$1 = value;\n  };\n\n  var getIdPrefix = function getIdPrefix() {\n    return idPrefix$1;\n  };\n\n  function createNS(type) {\n    // return {appendChild:function(){},setAttribute:function(){},style:{}}\n    return document.createElementNS(svgNS, type);\n  }\n\n  function _typeof$5(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof$5 = function _typeof(obj) { return typeof obj; }; } else { _typeof$5 = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof$5(obj); }\n\n  var dataManager = function () {\n    var _counterId = 1;\n    var processes = [];\n    var workerFn;\n    var workerInstance;\n    var workerProxy = {\n      onmessage: function onmessage() {},\n      postMessage: function postMessage(path) {\n        workerFn({\n          data: path\n        });\n      }\n    };\n    var _workerSelf = {\n      postMessage: function postMessage(data) {\n        workerProxy.onmessage({\n          data: data\n        });\n      }\n    };\n\n    function createWorker(fn) {\n      if (window.Worker && window.Blob && getWebWorker()) {\n        var blob = new Blob(['var _workerSelf = self; self.onmessage = ', fn.toString()], {\n          type: 'text/javascript'\n        }); // var blob = new Blob(['self.onmessage = ', fn.toString()], { type: 'text/javascript' });\n\n        var url = URL.createObjectURL(blob);\n        return new Worker(url);\n      }\n\n      workerFn = fn;\n      return workerProxy;\n    }\n\n    function setupWorker() {\n      if (!workerInstance) {\n        workerInstance = createWorker(function workerStart(e) {\n          function dataFunctionManager() {\n            function completeLayers(layers, comps) {\n              var layerData;\n              var i;\n              var len = layers.length;\n              var j;\n              var jLen;\n              var k;\n              var kLen;\n\n              for (i = 0; i < len; i += 1) {\n                layerData = layers[i];\n\n                if ('ks' in layerData && !layerData.completed) {\n                  layerData.completed = true;\n\n                  if (layerData.hasMask) {\n                    var maskProps = layerData.masksProperties;\n                    jLen = maskProps.length;\n\n                    for (j = 0; j < jLen; j += 1) {\n                      if (maskProps[j].pt.k.i) {\n                        convertPathsToAbsoluteValues(maskProps[j].pt.k);\n                      } else {\n                        kLen = maskProps[j].pt.k.length;\n\n                        for (k = 0; k < kLen; k += 1) {\n                          if (maskProps[j].pt.k[k].s) {\n                            convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);\n                          }\n\n                          if (maskProps[j].pt.k[k].e) {\n                            convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);\n                          }\n                        }\n                      }\n                    }\n                  }\n\n                  if (layerData.ty === 0) {\n                    layerData.layers = findCompLayers(layerData.refId, comps);\n                    completeLayers(layerData.layers, comps);\n                  } else if (layerData.ty === 4) {\n                    completeShapes(layerData.shapes);\n                  } else if (layerData.ty === 5) {\n                    completeText(layerData);\n                  }\n                }\n              }\n            }\n\n            function completeChars(chars, assets) {\n              if (chars) {\n                var i = 0;\n                var len = chars.length;\n\n                for (i = 0; i < len; i += 1) {\n                  if (chars[i].t === 1) {\n                    // var compData = findComp(chars[i].data.refId, assets);\n                    chars[i].data.layers = findCompLayers(chars[i].data.refId, assets); // chars[i].data.ip = 0;\n                    // chars[i].data.op = 99999;\n                    // chars[i].data.st = 0;\n                    // chars[i].data.sr = 1;\n                    // chars[i].w = compData.w;\n                    // chars[i].data.ks = {\n                    //   a: { k: [0, 0, 0], a: 0 },\n                    //   p: { k: [0, -compData.h, 0], a: 0 },\n                    //   r: { k: 0, a: 0 },\n                    //   s: { k: [100, 100], a: 0 },\n                    //   o: { k: 100, a: 0 },\n                    // };\n\n                    completeLayers(chars[i].data.layers, assets);\n                  }\n                }\n              }\n            }\n\n            function findComp(id, comps) {\n              var i = 0;\n              var len = comps.length;\n\n              while (i < len) {\n                if (comps[i].id === id) {\n                  return comps[i];\n                }\n\n                i += 1;\n              }\n\n              return null;\n            }\n\n            function findCompLayers(id, comps) {\n              var comp = findComp(id, comps);\n\n              if (comp) {\n                if (!comp.layers.__used) {\n                  comp.layers.__used = true;\n                  return comp.layers;\n                }\n\n                return JSON.parse(JSON.stringify(comp.layers));\n              }\n\n              return null;\n            }\n\n            function completeShapes(arr) {\n              var i;\n              var len = arr.length;\n              var j;\n              var jLen;\n\n              for (i = len - 1; i >= 0; i -= 1) {\n                if (arr[i].ty === 'sh') {\n                  if (arr[i].ks.k.i) {\n                    convertPathsToAbsoluteValues(arr[i].ks.k);\n                  } else {\n                    jLen = arr[i].ks.k.length;\n\n                    for (j = 0; j < jLen; j += 1) {\n                      if (arr[i].ks.k[j].s) {\n                        convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);\n                      }\n\n                      if (arr[i].ks.k[j].e) {\n                        convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);\n                      }\n                    }\n                  }\n                } else if (arr[i].ty === 'gr') {\n                  completeShapes(arr[i].it);\n                }\n              }\n            }\n\n            function convertPathsToAbsoluteValues(path) {\n              var i;\n              var len = path.i.length;\n\n              for (i = 0; i < len; i += 1) {\n                path.i[i][0] += path.v[i][0];\n                path.i[i][1] += path.v[i][1];\n                path.o[i][0] += path.v[i][0];\n                path.o[i][1] += path.v[i][1];\n              }\n            }\n\n            function checkVersion(minimum, animVersionString) {\n              var animVersion = animVersionString ? animVersionString.split('.') : [100, 100, 100];\n\n              if (minimum[0] > animVersion[0]) {\n                return true;\n              }\n\n              if (animVersion[0] > minimum[0]) {\n                return false;\n              }\n\n              if (minimum[1] > animVersion[1]) {\n                return true;\n              }\n\n              if (animVersion[1] > minimum[1]) {\n                return false;\n              }\n\n              if (minimum[2] > animVersion[2]) {\n                return true;\n              }\n\n              if (animVersion[2] > minimum[2]) {\n                return false;\n              }\n\n              return null;\n            }\n\n            var checkText = function () {\n              var minimumVersion = [4, 4, 14];\n\n              function updateTextLayer(textLayer) {\n                var documentData = textLayer.t.d;\n                textLayer.t.d = {\n                  k: [{\n                    s: documentData,\n                    t: 0\n                  }]\n                };\n              }\n\n              function iterateLayers(layers) {\n                var i;\n                var len = layers.length;\n\n                for (i = 0; i < len; i += 1) {\n                  if (layers[i].ty === 5) {\n                    updateTextLayer(layers[i]);\n                  }\n                }\n              }\n\n              return function (animationData) {\n                if (checkVersion(minimumVersion, animationData.v)) {\n                  iterateLayers(animationData.layers);\n\n                  if (animationData.assets) {\n                    var i;\n                    var len = animationData.assets.length;\n\n                    for (i = 0; i < len; i += 1) {\n                      if (animationData.assets[i].layers) {\n                        iterateLayers(animationData.assets[i].layers);\n                      }\n                    }\n                  }\n                }\n              };\n            }();\n\n            var checkChars = function () {\n              var minimumVersion = [4, 7, 99];\n              return function (animationData) {\n                if (animationData.chars && !checkVersion(minimumVersion, animationData.v)) {\n                  var i;\n                  var len = animationData.chars.length;\n\n                  for (i = 0; i < len; i += 1) {\n                    var charData = animationData.chars[i];\n\n                    if (charData.data && charData.data.shapes) {\n                      completeShapes(charData.data.shapes);\n                      charData.data.ip = 0;\n                      charData.data.op = 99999;\n                      charData.data.st = 0;\n                      charData.data.sr = 1;\n                      charData.data.ks = {\n                        p: {\n                          k: [0, 0],\n                          a: 0\n                        },\n                        s: {\n                          k: [100, 100],\n                          a: 0\n                        },\n                        a: {\n                          k: [0, 0],\n                          a: 0\n                        },\n                        r: {\n                          k: 0,\n                          a: 0\n                        },\n                        o: {\n                          k: 100,\n                          a: 0\n                        }\n                      };\n\n                      if (!animationData.chars[i].t) {\n                        charData.data.shapes.push({\n                          ty: 'no'\n                        });\n                        charData.data.shapes[0].it.push({\n                          p: {\n                            k: [0, 0],\n                            a: 0\n                          },\n                          s: {\n                            k: [100, 100],\n                            a: 0\n                          },\n                          a: {\n                            k: [0, 0],\n                            a: 0\n                          },\n                          r: {\n                            k: 0,\n                            a: 0\n                          },\n                          o: {\n                            k: 100,\n                            a: 0\n                          },\n                          sk: {\n                            k: 0,\n                            a: 0\n                          },\n                          sa: {\n                            k: 0,\n                            a: 0\n                          },\n                          ty: 'tr'\n                        });\n                      }\n                    }\n                  }\n                }\n              };\n            }();\n\n            var checkPathProperties = function () {\n              var minimumVersion = [5, 7, 15];\n\n              function updateTextLayer(textLayer) {\n                var pathData = textLayer.t.p;\n\n                if (typeof pathData.a === 'number') {\n                  pathData.a = {\n                    a: 0,\n                    k: pathData.a\n                  };\n                }\n\n                if (typeof pathData.p === 'number') {\n                  pathData.p = {\n                    a: 0,\n                    k: pathData.p\n                  };\n                }\n\n                if (typeof pathData.r === 'number') {\n                  pathData.r = {\n                    a: 0,\n                    k: pathData.r\n                  };\n                }\n              }\n\n              function iterateLayers(layers) {\n                var i;\n                var len = layers.length;\n\n                for (i = 0; i < len; i += 1) {\n                  if (layers[i].ty === 5) {\n                    updateTextLayer(layers[i]);\n                  }\n                }\n              }\n\n              return function (animationData) {\n                if (checkVersion(minimumVersion, animationData.v)) {\n                  iterateLayers(animationData.layers);\n\n                  if (animationData.assets) {\n                    var i;\n                    var len = animationData.assets.length;\n\n                    for (i = 0; i < len; i += 1) {\n                      if (animationData.assets[i].layers) {\n                        iterateLayers(animationData.assets[i].layers);\n                      }\n                    }\n                  }\n                }\n              };\n            }();\n\n            var checkColors = function () {\n              var minimumVersion = [4, 1, 9];\n\n              function iterateShapes(shapes) {\n                var i;\n                var len = shapes.length;\n                var j;\n                var jLen;\n\n                for (i = 0; i < len; i += 1) {\n                  if (shapes[i].ty === 'gr') {\n                    iterateShapes(shapes[i].it);\n                  } else if (shapes[i].ty === 'fl' || shapes[i].ty === 'st') {\n                    if (shapes[i].c.k && shapes[i].c.k[0].i) {\n                      jLen = shapes[i].c.k.length;\n\n                      for (j = 0; j < jLen; j += 1) {\n                        if (shapes[i].c.k[j].s) {\n                          shapes[i].c.k[j].s[0] /= 255;\n                          shapes[i].c.k[j].s[1] /= 255;\n                          shapes[i].c.k[j].s[2] /= 255;\n                          shapes[i].c.k[j].s[3] /= 255;\n                        }\n\n                        if (shapes[i].c.k[j].e) {\n                          shapes[i].c.k[j].e[0] /= 255;\n                          shapes[i].c.k[j].e[1] /= 255;\n                          shapes[i].c.k[j].e[2] /= 255;\n                          shapes[i].c.k[j].e[3] /= 255;\n                        }\n                      }\n                    } else {\n                      shapes[i].c.k[0] /= 255;\n                      shapes[i].c.k[1] /= 255;\n                      shapes[i].c.k[2] /= 255;\n                      shapes[i].c.k[3] /= 255;\n                    }\n                  }\n                }\n              }\n\n              function iterateLayers(layers) {\n                var i;\n                var len = layers.length;\n\n                for (i = 0; i < len; i += 1) {\n                  if (layers[i].ty === 4) {\n                    iterateShapes(layers[i].shapes);\n                  }\n                }\n              }\n\n              return function (animationData) {\n                if (checkVersion(minimumVersion, animationData.v)) {\n                  iterateLayers(animationData.layers);\n\n                  if (animationData.assets) {\n                    var i;\n                    var len = animationData.assets.length;\n\n                    for (i = 0; i < len; i += 1) {\n                      if (animationData.assets[i].layers) {\n                        iterateLayers(animationData.assets[i].layers);\n                      }\n                    }\n                  }\n                }\n              };\n            }();\n\n            var checkShapes = function () {\n              var minimumVersion = [4, 4, 18];\n\n              function completeClosingShapes(arr) {\n                var i;\n                var len = arr.length;\n                var j;\n                var jLen;\n\n                for (i = len - 1; i >= 0; i -= 1) {\n                  if (arr[i].ty === 'sh') {\n                    if (arr[i].ks.k.i) {\n                      arr[i].ks.k.c = arr[i].closed;\n                    } else {\n                      jLen = arr[i].ks.k.length;\n\n                      for (j = 0; j < jLen; j += 1) {\n                        if (arr[i].ks.k[j].s) {\n                          arr[i].ks.k[j].s[0].c = arr[i].closed;\n                        }\n\n                        if (arr[i].ks.k[j].e) {\n                          arr[i].ks.k[j].e[0].c = arr[i].closed;\n                        }\n                      }\n                    }\n                  } else if (arr[i].ty === 'gr') {\n                    completeClosingShapes(arr[i].it);\n                  }\n                }\n              }\n\n              function iterateLayers(layers) {\n                var layerData;\n                var i;\n                var len = layers.length;\n                var j;\n                var jLen;\n                var k;\n                var kLen;\n\n                for (i = 0; i < len; i += 1) {\n                  layerData = layers[i];\n\n                  if (layerData.hasMask) {\n                    var maskProps = layerData.masksProperties;\n                    jLen = maskProps.length;\n\n                    for (j = 0; j < jLen; j += 1) {\n                      if (maskProps[j].pt.k.i) {\n                        maskProps[j].pt.k.c = maskProps[j].cl;\n                      } else {\n                        kLen = maskProps[j].pt.k.length;\n\n                        for (k = 0; k < kLen; k += 1) {\n                          if (maskProps[j].pt.k[k].s) {\n                            maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;\n                          }\n\n                          if (maskProps[j].pt.k[k].e) {\n                            maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;\n                          }\n                        }\n                      }\n                    }\n                  }\n\n                  if (layerData.ty === 4) {\n                    completeClosingShapes(layerData.shapes);\n                  }\n                }\n              }\n\n              return function (animationData) {\n                if (checkVersion(minimumVersion, animationData.v)) {\n                  iterateLayers(animationData.layers);\n\n                  if (animationData.assets) {\n                    var i;\n                    var len = animationData.assets.length;\n\n                    for (i = 0; i < len; i += 1) {\n                      if (animationData.assets[i].layers) {\n                        iterateLayers(animationData.assets[i].layers);\n                      }\n                    }\n                  }\n                }\n              };\n            }();\n\n            function completeData(animationData) {\n              if (animationData.__complete) {\n                return;\n              }\n\n              checkColors(animationData);\n              checkText(animationData);\n              checkChars(animationData);\n              checkPathProperties(animationData);\n              checkShapes(animationData);\n              completeLayers(animationData.layers, animationData.assets);\n              completeChars(animationData.chars, animationData.assets);\n              animationData.__complete = true;\n            }\n\n            function completeText(data) {\n              if (data.t.a.length === 0 && !('m' in data.t.p)) {// data.singleShape = true;\n              }\n            }\n\n            var moduleOb = {};\n            moduleOb.completeData = completeData;\n            moduleOb.checkColors = checkColors;\n            moduleOb.checkChars = checkChars;\n            moduleOb.checkPathProperties = checkPathProperties;\n            moduleOb.checkShapes = checkShapes;\n            moduleOb.completeLayers = completeLayers;\n            return moduleOb;\n          }\n\n          if (!_workerSelf.dataManager) {\n            _workerSelf.dataManager = dataFunctionManager();\n          }\n\n          if (!_workerSelf.assetLoader) {\n            _workerSelf.assetLoader = function () {\n              function formatResponse(xhr) {\n                // using typeof doubles the time of execution of this method,\n                // so if available, it's better to use the header to validate the type\n                var contentTypeHeader = xhr.getResponseHeader('content-type');\n\n                if (contentTypeHeader && xhr.responseType === 'json' && contentTypeHeader.indexOf('json') !== -1) {\n                  return xhr.response;\n                }\n\n                if (xhr.response && _typeof$5(xhr.response) === 'object') {\n                  return xhr.response;\n                }\n\n                if (xhr.response && typeof xhr.response === 'string') {\n                  return JSON.parse(xhr.response);\n                }\n\n                if (xhr.responseText) {\n                  return JSON.parse(xhr.responseText);\n                }\n\n                return null;\n              }\n\n              function loadAsset(path, fullPath, callback, errorCallback) {\n                var response;\n                var xhr = new XMLHttpRequest(); // set responseType after calling open or IE will break.\n\n                try {\n                  // This crashes on Android WebView prior to KitKat\n                  xhr.responseType = 'json';\n                } catch (err) {} // eslint-disable-line no-empty\n\n\n                xhr.onreadystatechange = function () {\n                  if (xhr.readyState === 4) {\n                    if (xhr.status === 200) {\n                      response = formatResponse(xhr);\n                      callback(response);\n                    } else {\n                      try {\n                        response = formatResponse(xhr);\n                        callback(response);\n                      } catch (err) {\n                        if (errorCallback) {\n                          errorCallback(err);\n                        }\n                      }\n                    }\n                  }\n                };\n\n                try {\n                  // Hack to workaround banner validation\n                  xhr.open(['G', 'E', 'T'].join(''), path, true);\n                } catch (error) {\n                  // Hack to workaround banner validation\n                  xhr.open(['G', 'E', 'T'].join(''), fullPath + '/' + path, true);\n                }\n\n                xhr.send();\n              }\n\n              return {\n                load: loadAsset\n              };\n            }();\n          }\n\n          if (e.data.type === 'loadAnimation') {\n            _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function (data) {\n              _workerSelf.dataManager.completeData(data);\n\n              _workerSelf.postMessage({\n                id: e.data.id,\n                payload: data,\n                status: 'success'\n              });\n            }, function () {\n              _workerSelf.postMessage({\n                id: e.data.id,\n                status: 'error'\n              });\n            });\n          } else if (e.data.type === 'complete') {\n            var animation = e.data.animation;\n\n            _workerSelf.dataManager.completeData(animation);\n\n            _workerSelf.postMessage({\n              id: e.data.id,\n              payload: animation,\n              status: 'success'\n            });\n          } else if (e.data.type === 'loadData') {\n            _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function (data) {\n              _workerSelf.postMessage({\n                id: e.data.id,\n                payload: data,\n                status: 'success'\n              });\n            }, function () {\n              _workerSelf.postMessage({\n                id: e.data.id,\n                status: 'error'\n              });\n            });\n          }\n        });\n\n        workerInstance.onmessage = function (event) {\n          var data = event.data;\n          var id = data.id;\n          var process = processes[id];\n          processes[id] = null;\n\n          if (data.status === 'success') {\n            process.onComplete(data.payload);\n          } else if (process.onError) {\n            process.onError();\n          }\n        };\n      }\n    }\n\n    function createProcess(onComplete, onError) {\n      _counterId += 1;\n      var id = 'processId_' + _counterId;\n      processes[id] = {\n        onComplete: onComplete,\n        onError: onError\n      };\n      return id;\n    }\n\n    function loadAnimation(path, onComplete, onError) {\n      setupWorker();\n      var processId = createProcess(onComplete, onError);\n      workerInstance.postMessage({\n        type: 'loadAnimation',\n        path: path,\n        fullPath: window.location.origin + window.location.pathname,\n        id: processId\n      });\n    }\n\n    function loadData(path, onComplete, onError) {\n      setupWorker();\n      var processId = createProcess(onComplete, onError);\n      workerInstance.postMessage({\n        type: 'loadData',\n        path: path,\n        fullPath: window.location.origin + window.location.pathname,\n        id: processId\n      });\n    }\n\n    function completeAnimation(anim, onComplete, onError) {\n      setupWorker();\n      var processId = createProcess(onComplete, onError);\n      workerInstance.postMessage({\n        type: 'complete',\n        animation: anim,\n        id: processId\n      });\n    }\n\n    return {\n      loadAnimation: loadAnimation,\n      loadData: loadData,\n      completeAnimation: completeAnimation\n    };\n  }();\n\n  var ImagePreloader = function () {\n    var proxyImage = function () {\n      var canvas = createTag('canvas');\n      canvas.width = 1;\n      canvas.height = 1;\n      var ctx = canvas.getContext('2d');\n      ctx.fillStyle = 'rgba(0,0,0,0)';\n      ctx.fillRect(0, 0, 1, 1);\n      return canvas;\n    }();\n\n    function imageLoaded() {\n      this.loadedAssets += 1;\n\n      if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {\n        if (this.imagesLoadedCb) {\n          this.imagesLoadedCb(null);\n        }\n      }\n    }\n\n    function footageLoaded() {\n      this.loadedFootagesCount += 1;\n\n      if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {\n        if (this.imagesLoadedCb) {\n          this.imagesLoadedCb(null);\n        }\n      }\n    }\n\n    function getAssetsPath(assetData, assetsPath, originalPath) {\n      var path = '';\n\n      if (assetData.e) {\n        path = assetData.p;\n      } else if (assetsPath) {\n        var imagePath = assetData.p;\n\n        if (imagePath.indexOf('images/') !== -1) {\n          imagePath = imagePath.split('/')[1];\n        }\n\n        path = assetsPath + imagePath;\n      } else {\n        path = originalPath;\n        path += assetData.u ? assetData.u : '';\n        path += assetData.p;\n      }\n\n      return path;\n    }\n\n    function testImageLoaded(img) {\n      var _count = 0;\n      var intervalId = setInterval(function () {\n        var box = img.getBBox();\n\n        if (box.width || _count > 500) {\n          this._imageLoaded();\n\n          clearInterval(intervalId);\n        }\n\n        _count += 1;\n      }.bind(this), 50);\n    }\n\n    function createImageData(assetData) {\n      var path = getAssetsPath(assetData, this.assetsPath, this.path);\n      var img = createNS('image');\n\n      if (isSafari) {\n        this.testImageLoaded(img);\n      } else {\n        img.addEventListener('load', this._imageLoaded, false);\n      }\n\n      img.addEventListener('error', function () {\n        ob.img = proxyImage;\n\n        this._imageLoaded();\n      }.bind(this), false);\n      img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', path);\n\n      if (this._elementHelper.append) {\n        this._elementHelper.append(img);\n      } else {\n        this._elementHelper.appendChild(img);\n      }\n\n      var ob = {\n        img: img,\n        assetData: assetData\n      };\n      return ob;\n    }\n\n    function createImgData(assetData) {\n      var path = getAssetsPath(assetData, this.assetsPath, this.path);\n      var img = createTag('img');\n      img.crossOrigin = 'anonymous';\n      img.addEventListener('load', this._imageLoaded, false);\n      img.addEventListener('error', function () {\n        ob.img = proxyImage;\n\n        this._imageLoaded();\n      }.bind(this), false);\n      img.src = path;\n      var ob = {\n        img: img,\n        assetData: assetData\n      };\n      return ob;\n    }\n\n    function createFootageData(data) {\n      var ob = {\n        assetData: data\n      };\n      var path = getAssetsPath(data, this.assetsPath, this.path);\n      dataManager.loadData(path, function (footageData) {\n        ob.img = footageData;\n\n        this._footageLoaded();\n      }.bind(this), function () {\n        ob.img = {};\n\n        this._footageLoaded();\n      }.bind(this));\n      return ob;\n    }\n\n    function loadAssets(assets, cb) {\n      this.imagesLoadedCb = cb;\n      var i;\n      var len = assets.length;\n\n      for (i = 0; i < len; i += 1) {\n        if (!assets[i].layers) {\n          if (!assets[i].t || assets[i].t === 'seq') {\n            this.totalImages += 1;\n            this.images.push(this._createImageData(assets[i]));\n          } else if (assets[i].t === 3) {\n            this.totalFootages += 1;\n            this.images.push(this.createFootageData(assets[i]));\n          }\n        }\n      }\n    }\n\n    function setPath(path) {\n      this.path = path || '';\n    }\n\n    function setAssetsPath(path) {\n      this.assetsPath = path || '';\n    }\n\n    function getAsset(assetData) {\n      var i = 0;\n      var len = this.images.length;\n\n      while (i < len) {\n        if (this.images[i].assetData === assetData) {\n          return this.images[i].img;\n        }\n\n        i += 1;\n      }\n\n      return null;\n    }\n\n    function destroy() {\n      this.imagesLoadedCb = null;\n      this.images.length = 0;\n    }\n\n    function loadedImages() {\n      return this.totalImages === this.loadedAssets;\n    }\n\n    function loadedFootages() {\n      return this.totalFootages === this.loadedFootagesCount;\n    }\n\n    function setCacheType(type, elementHelper) {\n      if (type === 'svg') {\n        this._elementHelper = elementHelper;\n        this._createImageData = this.createImageData.bind(this);\n      } else {\n        this._createImageData = this.createImgData.bind(this);\n      }\n    }\n\n    function ImagePreloaderFactory() {\n      this._imageLoaded = imageLoaded.bind(this);\n      this._footageLoaded = footageLoaded.bind(this);\n      this.testImageLoaded = testImageLoaded.bind(this);\n      this.createFootageData = createFootageData.bind(this);\n      this.assetsPath = '';\n      this.path = '';\n      this.totalImages = 0;\n      this.totalFootages = 0;\n      this.loadedAssets = 0;\n      this.loadedFootagesCount = 0;\n      this.imagesLoadedCb = null;\n      this.images = [];\n    }\n\n    ImagePreloaderFactory.prototype = {\n      loadAssets: loadAssets,\n      setAssetsPath: setAssetsPath,\n      setPath: setPath,\n      loadedImages: loadedImages,\n      loadedFootages: loadedFootages,\n      destroy: destroy,\n      getAsset: getAsset,\n      createImgData: createImgData,\n      createImageData: createImageData,\n      imageLoaded: imageLoaded,\n      footageLoaded: footageLoaded,\n      setCacheType: setCacheType\n    };\n    return ImagePreloaderFactory;\n  }();\n\n  function BaseEvent() {}\n\n  BaseEvent.prototype = {\n    triggerEvent: function triggerEvent(eventName, args) {\n      if (this._cbs[eventName]) {\n        var callbacks = this._cbs[eventName];\n\n        for (var i = 0; i < callbacks.length; i += 1) {\n          callbacks[i](args);\n        }\n      }\n    },\n    addEventListener: function addEventListener(eventName, callback) {\n      if (!this._cbs[eventName]) {\n        this._cbs[eventName] = [];\n      }\n\n      this._cbs[eventName].push(callback);\n\n      return function () {\n        this.removeEventListener(eventName, callback);\n      }.bind(this);\n    },\n    removeEventListener: function removeEventListener(eventName, callback) {\n      if (!callback) {\n        this._cbs[eventName] = null;\n      } else if (this._cbs[eventName]) {\n        var i = 0;\n        var len = this._cbs[eventName].length;\n\n        while (i < len) {\n          if (this._cbs[eventName][i] === callback) {\n            this._cbs[eventName].splice(i, 1);\n\n            i -= 1;\n            len -= 1;\n          }\n\n          i += 1;\n        }\n\n        if (!this._cbs[eventName].length) {\n          this._cbs[eventName] = null;\n        }\n      }\n    }\n  };\n\n  var markerParser = function () {\n    function parsePayloadLines(payload) {\n      var lines = payload.split('\\r\\n');\n      var keys = {};\n      var line;\n      var keysCount = 0;\n\n      for (var i = 0; i < lines.length; i += 1) {\n        line = lines[i].split(':');\n\n        if (line.length === 2) {\n          keys[line[0]] = line[1].trim();\n          keysCount += 1;\n        }\n      }\n\n      if (keysCount === 0) {\n        throw new Error();\n      }\n\n      return keys;\n    }\n\n    return function (_markers) {\n      var markers = [];\n\n      for (var i = 0; i < _markers.length; i += 1) {\n        var _marker = _markers[i];\n        var markerData = {\n          time: _marker.tm,\n          duration: _marker.dr\n        };\n\n        try {\n          markerData.payload = JSON.parse(_markers[i].cm);\n        } catch (_) {\n          try {\n            markerData.payload = parsePayloadLines(_markers[i].cm);\n          } catch (__) {\n            markerData.payload = {\n              name: _markers[i].cm\n            };\n          }\n        }\n\n        markers.push(markerData);\n      }\n\n      return markers;\n    };\n  }();\n\n  var ProjectInterface = function () {\n    function registerComposition(comp) {\n      this.compositions.push(comp);\n    }\n\n    return function () {\n      function _thisProjectFunction(name) {\n        var i = 0;\n        var len = this.compositions.length;\n\n        while (i < len) {\n          if (this.compositions[i].data && this.compositions[i].data.nm === name) {\n            if (this.compositions[i].prepareFrame && this.compositions[i].data.xt) {\n              this.compositions[i].prepareFrame(this.currentFrame);\n            }\n\n            return this.compositions[i].compInterface;\n          }\n\n          i += 1;\n        }\n\n        return null;\n      }\n\n      _thisProjectFunction.compositions = [];\n      _thisProjectFunction.currentFrame = 0;\n      _thisProjectFunction.registerComposition = registerComposition;\n      return _thisProjectFunction;\n    };\n  }();\n\n  var renderers = {};\n\n  var registerRenderer = function registerRenderer(key, value) {\n    renderers[key] = value;\n  };\n\n  function getRenderer(key) {\n    return renderers[key];\n  }\n\n  function getRegisteredRenderer() {\n    // Returns canvas by default for compatibility\n    if (renderers.canvas) {\n      return 'canvas';\n    } // Returns any renderer that is registered\n\n\n    for (var key in renderers) {\n      if (renderers[key]) {\n        return key;\n      }\n    }\n\n    return '';\n  }\n\n  function _typeof$4(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof$4 = function _typeof(obj) { return typeof obj; }; } else { _typeof$4 = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof$4(obj); }\n\n  var AnimationItem = function AnimationItem() {\n    this._cbs = [];\n    this.name = '';\n    this.path = '';\n    this.isLoaded = false;\n    this.currentFrame = 0;\n    this.currentRawFrame = 0;\n    this.firstFrame = 0;\n    this.totalFrames = 0;\n    this.frameRate = 0;\n    this.frameMult = 0;\n    this.playSpeed = 1;\n    this.playDirection = 1;\n    this.playCount = 0;\n    this.animationData = {};\n    this.assets = [];\n    this.isPaused = true;\n    this.autoplay = false;\n    this.loop = true;\n    this.renderer = null;\n    this.animationID = createElementID();\n    this.assetsPath = '';\n    this.timeCompleted = 0;\n    this.segmentPos = 0;\n    this.isSubframeEnabled = getSubframeEnabled();\n    this.segments = [];\n    this._idle = true;\n    this._completedLoop = false;\n    this.projectInterface = ProjectInterface();\n    this.imagePreloader = new ImagePreloader();\n    this.audioController = audioControllerFactory();\n    this.markers = [];\n    this.configAnimation = this.configAnimation.bind(this);\n    this.onSetupError = this.onSetupError.bind(this);\n    this.onSegmentComplete = this.onSegmentComplete.bind(this);\n    this.drawnFrameEvent = new BMEnterFrameEvent('drawnFrame', 0, 0, 0);\n    this.expressionsPlugin = getExpressionsPlugin();\n  };\n\n  extendPrototype([BaseEvent], AnimationItem);\n\n  AnimationItem.prototype.setParams = function (params) {\n    if (params.wrapper || params.container) {\n      this.wrapper = params.wrapper || params.container;\n    }\n\n    var animType = 'svg';\n\n    if (params.animType) {\n      animType = params.animType;\n    } else if (params.renderer) {\n      animType = params.renderer;\n    }\n\n    var RendererClass = getRenderer(animType);\n    this.renderer = new RendererClass(this, params.rendererSettings);\n    this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs);\n    this.renderer.setProjectInterface(this.projectInterface);\n    this.animType = animType;\n\n    if (params.loop === '' || params.loop === null || params.loop === undefined || params.loop === true) {\n      this.loop = true;\n    } else if (params.loop === false) {\n      this.loop = false;\n    } else {\n      this.loop = parseInt(params.loop, 10);\n    }\n\n    this.autoplay = 'autoplay' in params ? params.autoplay : true;\n    this.name = params.name ? params.name : '';\n    this.autoloadSegments = Object.prototype.hasOwnProperty.call(params, 'autoloadSegments') ? params.autoloadSegments : true;\n    this.assetsPath = params.assetsPath;\n    this.initialSegment = params.initialSegment;\n\n    if (params.audioFactory) {\n      this.audioController.setAudioFactory(params.audioFactory);\n    }\n\n    if (params.animationData) {\n      this.setupAnimation(params.animationData);\n    } else if (params.path) {\n      if (params.path.lastIndexOf('\\\\') !== -1) {\n        this.path = params.path.substr(0, params.path.lastIndexOf('\\\\') + 1);\n      } else {\n        this.path = params.path.substr(0, params.path.lastIndexOf('/') + 1);\n      }\n\n      this.fileName = params.path.substr(params.path.lastIndexOf('/') + 1);\n      this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf('.json'));\n      dataManager.loadAnimation(params.path, this.configAnimation, this.onSetupError);\n    }\n  };\n\n  AnimationItem.prototype.onSetupError = function () {\n    this.trigger('data_failed');\n  };\n\n  AnimationItem.prototype.setupAnimation = function (data) {\n    dataManager.completeAnimation(data, this.configAnimation);\n  };\n\n  AnimationItem.prototype.setData = function (wrapper, animationData) {\n    if (animationData) {\n      if (_typeof$4(animationData) !== 'object') {\n        animationData = JSON.parse(animationData);\n      }\n    }\n\n    var params = {\n      wrapper: wrapper,\n      animationData: animationData\n    };\n    var wrapperAttributes = wrapper.attributes;\n    params.path = wrapperAttributes.getNamedItem('data-animation-path') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('data-animation-path').value : wrapperAttributes.getNamedItem('data-bm-path') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('data-bm-path').value : wrapperAttributes.getNamedItem('bm-path') ? wrapperAttributes.getNamedItem('bm-path').value : '';\n    params.animType = wrapperAttributes.getNamedItem('data-anim-type') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('data-anim-type').value : wrapperAttributes.getNamedItem('data-bm-type') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('data-bm-type').value : wrapperAttributes.getNamedItem('bm-type') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('bm-type').value : wrapperAttributes.getNamedItem('data-bm-renderer') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('data-bm-renderer').value : wrapperAttributes.getNamedItem('bm-renderer') ? wrapperAttributes.getNamedItem('bm-renderer').value : getRegisteredRenderer() || 'canvas';\n    var loop = wrapperAttributes.getNamedItem('data-anim-loop') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('data-anim-loop').value : wrapperAttributes.getNamedItem('data-bm-loop') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('data-bm-loop').value : wrapperAttributes.getNamedItem('bm-loop') ? wrapperAttributes.getNamedItem('bm-loop').value : '';\n\n    if (loop === 'false') {\n      params.loop = false;\n    } else if (loop === 'true') {\n      params.loop = true;\n    } else if (loop !== '') {\n      params.loop = parseInt(loop, 10);\n    }\n\n    var autoplay = wrapperAttributes.getNamedItem('data-anim-autoplay') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('data-anim-autoplay').value : wrapperAttributes.getNamedItem('data-bm-autoplay') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('data-bm-autoplay').value : wrapperAttributes.getNamedItem('bm-autoplay') ? wrapperAttributes.getNamedItem('bm-autoplay').value : true;\n    params.autoplay = autoplay !== 'false';\n    params.name = wrapperAttributes.getNamedItem('data-name') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('data-name').value : wrapperAttributes.getNamedItem('data-bm-name') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('data-bm-name').value : wrapperAttributes.getNamedItem('bm-name') ? wrapperAttributes.getNamedItem('bm-name').value : '';\n    var prerender = wrapperAttributes.getNamedItem('data-anim-prerender') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('data-anim-prerender').value : wrapperAttributes.getNamedItem('data-bm-prerender') // eslint-disable-line no-nested-ternary\n    ? wrapperAttributes.getNamedItem('data-bm-prerender').value : wrapperAttributes.getNamedItem('bm-prerender') ? wrapperAttributes.getNamedItem('bm-prerender').value : '';\n\n    if (prerender === 'false') {\n      params.prerender = false;\n    }\n\n    if (!params.path) {\n      this.trigger('destroy');\n    } else {\n      this.setParams(params);\n    }\n  };\n\n  AnimationItem.prototype.includeLayers = function (data) {\n    if (data.op > this.animationData.op) {\n      this.animationData.op = data.op;\n      this.totalFrames = Math.floor(data.op - this.animationData.ip);\n    }\n\n    var layers = this.animationData.layers;\n    var i;\n    var len = layers.length;\n    var newLayers = data.layers;\n    var j;\n    var jLen = newLayers.length;\n\n    for (j = 0; j < jLen; j += 1) {\n      i = 0;\n\n      while (i < len) {\n        if (layers[i].id === newLayers[j].id) {\n          layers[i] = newLayers[j];\n          break;\n        }\n\n        i += 1;\n      }\n    }\n\n    if (data.chars || data.fonts) {\n      this.renderer.globalData.fontManager.addChars(data.chars);\n      this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs);\n    }\n\n    if (data.assets) {\n      len = data.assets.length;\n\n      for (i = 0; i < len; i += 1) {\n        this.animationData.assets.push(data.assets[i]);\n      }\n    }\n\n    this.animationData.__complete = false;\n    dataManager.completeAnimation(this.animationData, this.onSegmentComplete);\n  };\n\n  AnimationItem.prototype.onSegmentComplete = function (data) {\n    this.animationData = data;\n    var expressionsPlugin = getExpressionsPlugin();\n\n    if (expressionsPlugin) {\n      expressionsPlugin.initExpressions(this);\n    }\n\n    this.loadNextSegment();\n  };\n\n  AnimationItem.prototype.loadNextSegment = function () {\n    var segments = this.animationData.segments;\n\n    if (!segments || segments.length === 0 || !this.autoloadSegments) {\n      this.trigger('data_ready');\n      this.timeCompleted = this.totalFrames;\n      return;\n    }\n\n    var segment = segments.shift();\n    this.timeCompleted = segment.time * this.frameRate;\n    var segmentPath = this.path + this.fileName + '_' + this.segmentPos + '.json';\n    this.segmentPos += 1;\n    dataManager.loadData(segmentPath, this.includeLayers.bind(this), function () {\n      this.trigger('data_failed');\n    }.bind(this));\n  };\n\n  AnimationItem.prototype.loadSegments = function () {\n    var segments = this.animationData.segments;\n\n    if (!segments) {\n      this.timeCompleted = this.totalFrames;\n    }\n\n    this.loadNextSegment();\n  };\n\n  AnimationItem.prototype.imagesLoaded = function () {\n    this.trigger('loaded_images');\n    this.checkLoaded();\n  };\n\n  AnimationItem.prototype.preloadImages = function () {\n    this.imagePreloader.setAssetsPath(this.assetsPath);\n    this.imagePreloader.setPath(this.path);\n    this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));\n  };\n\n  AnimationItem.prototype.configAnimation = function (animData) {\n    if (!this.renderer) {\n      return;\n    }\n\n    try {\n      this.animationData = animData;\n\n      if (this.initialSegment) {\n        this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]);\n        this.firstFrame = Math.round(this.initialSegment[0]);\n      } else {\n        this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);\n        this.firstFrame = Math.round(this.animationData.ip);\n      }\n\n      this.renderer.configAnimation(animData);\n\n      if (!animData.assets) {\n        animData.assets = [];\n      }\n\n      this.assets = this.animationData.assets;\n      this.frameRate = this.animationData.fr;\n      this.frameMult = this.animationData.fr / 1000;\n      this.renderer.searchExtraCompositions(animData.assets);\n      this.markers = markerParser(animData.markers || []);\n      this.trigger('config_ready');\n      this.preloadImages();\n      this.loadSegments();\n      this.updaFrameModifier();\n      this.waitForFontsLoaded();\n\n      if (this.isPaused) {\n        this.audioController.pause();\n      }\n    } catch (error) {\n      this.triggerConfigError(error);\n    }\n  };\n\n  AnimationItem.prototype.waitForFontsLoaded = function () {\n    if (!this.renderer) {\n      return;\n    }\n\n    if (this.renderer.globalData.fontManager.isLoaded) {\n      this.checkLoaded();\n    } else {\n      setTimeout(this.waitForFontsLoaded.bind(this), 20);\n    }\n  };\n\n  AnimationItem.prototype.checkLoaded = function () {\n    if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== 'canvas') && this.imagePreloader.loadedFootages()) {\n      this.isLoaded = true;\n      var expressionsPlugin = getExpressionsPlugin();\n\n      if (expressionsPlugin) {\n        expressionsPlugin.initExpressions(this);\n      }\n\n      this.renderer.initItems();\n      setTimeout(function () {\n        this.trigger('DOMLoaded');\n      }.bind(this), 0);\n      this.gotoFrame();\n\n      if (this.autoplay) {\n        this.play();\n      }\n    }\n  };\n\n  AnimationItem.prototype.resize = function (width, height) {\n    // Adding this validation for backwards compatibility in case an event object was being passed down\n    var _width = typeof width === 'number' ? width : undefined;\n\n    var _height = typeof height === 'number' ? height : undefined;\n\n    this.renderer.updateContainerSize(_width, _height);\n  };\n\n  AnimationItem.prototype.setSubframe = function (flag) {\n    this.isSubframeEnabled = !!flag;\n  };\n\n  AnimationItem.prototype.gotoFrame = function () {\n    this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame; // eslint-disable-line no-bitwise\n\n    if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) {\n      this.currentFrame = this.timeCompleted;\n    }\n\n    this.trigger('enterFrame');\n    this.renderFrame();\n    this.trigger('drawnFrame');\n  };\n\n  AnimationItem.prototype.renderFrame = function () {\n    if (this.isLoaded === false || !this.renderer) {\n      return;\n    }\n\n    try {\n      if (this.expressionsPlugin) {\n        this.expressionsPlugin.resetFrame();\n      }\n\n      this.renderer.renderFrame(this.currentFrame + this.firstFrame);\n    } catch (error) {\n      this.triggerRenderFrameError(error);\n    }\n  };\n\n  AnimationItem.prototype.play = function (name) {\n    if (name && this.name !== name) {\n      return;\n    }\n\n    if (this.isPaused === true) {\n      this.isPaused = false;\n      this.trigger('_play');\n      this.audioController.resume();\n\n      if (this._idle) {\n        this._idle = false;\n        this.trigger('_active');\n      }\n    }\n  };\n\n  AnimationItem.prototype.pause = function (name) {\n    if (name && this.name !== name) {\n      return;\n    }\n\n    if (this.isPaused === false) {\n      this.isPaused = true;\n      this.trigger('_pause');\n      this._idle = true;\n      this.trigger('_idle');\n      this.audioController.pause();\n    }\n  };\n\n  AnimationItem.prototype.togglePause = function (name) {\n    if (name && this.name !== name) {\n      return;\n    }\n\n    if (this.isPaused === true) {\n      this.play();\n    } else {\n      this.pause();\n    }\n  };\n\n  AnimationItem.prototype.stop = function (name) {\n    if (name && this.name !== name) {\n      return;\n    }\n\n    this.pause();\n    this.playCount = 0;\n    this._completedLoop = false;\n    this.setCurrentRawFrameValue(0);\n  };\n\n  AnimationItem.prototype.getMarkerData = function (markerName) {\n    var marker;\n\n    for (var i = 0; i < this.markers.length; i += 1) {\n      marker = this.markers[i];\n\n      if (marker.payload && marker.payload.name === markerName) {\n        return marker;\n      }\n    }\n\n    return null;\n  };\n\n  AnimationItem.prototype.goToAndStop = function (value, isFrame, name) {\n    if (name && this.name !== name) {\n      return;\n    }\n\n    var numValue = Number(value);\n\n    if (isNaN(numValue)) {\n      var marker = this.getMarkerData(value);\n\n      if (marker) {\n        this.goToAndStop(marker.time, true);\n      }\n    } else if (isFrame) {\n      this.setCurrentRawFrameValue(value);\n    } else {\n      this.setCurrentRawFrameValue(value * this.frameModifier);\n    }\n\n    this.pause();\n  };\n\n  AnimationItem.prototype.goToAndPlay = function (value, isFrame, name) {\n    if (name && this.name !== name) {\n      return;\n    }\n\n    var numValue = Number(value);\n\n    if (isNaN(numValue)) {\n      var marker = this.getMarkerData(value);\n\n      if (marker) {\n        if (!marker.duration) {\n          this.goToAndStop(marker.time, true);\n        } else {\n          this.playSegments([marker.time, marker.time + marker.duration], true);\n        }\n      }\n    } else {\n      this.goToAndStop(numValue, isFrame, name);\n    }\n\n    this.play();\n  };\n\n  AnimationItem.prototype.advanceTime = function (value) {\n    if (this.isPaused === true || this.isLoaded === false) {\n      return;\n    }\n\n    var nextValue = this.currentRawFrame + value * this.frameModifier;\n    var _isComplete = false; // Checking if nextValue > totalFrames - 1 for addressing non looping and looping animations.\n    // If animation won't loop, it should stop at totalFrames - 1. If it will loop it should complete the last frame and then loop.\n\n    if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {\n      if (!this.loop || this.playCount === this.loop) {\n        if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {\n          _isComplete = true;\n          nextValue = this.totalFrames - 1;\n        }\n      } else if (nextValue >= this.totalFrames) {\n        this.playCount += 1;\n\n        if (!this.checkSegments(nextValue % this.totalFrames)) {\n          this.setCurrentRawFrameValue(nextValue % this.totalFrames);\n          this._completedLoop = true;\n          this.trigger('loopComplete');\n        }\n      } else {\n        this.setCurrentRawFrameValue(nextValue);\n      }\n    } else if (nextValue < 0) {\n      if (!this.checkSegments(nextValue % this.totalFrames)) {\n        if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) {\n          // eslint-disable-line no-plusplus\n          this.setCurrentRawFrameValue(this.totalFrames + nextValue % this.totalFrames);\n\n          if (!this._completedLoop) {\n            this._completedLoop = true;\n          } else {\n            this.trigger('loopComplete');\n          }\n        } else {\n          _isComplete = true;\n          nextValue = 0;\n        }\n      }\n    } else {\n      this.setCurrentRawFrameValue(nextValue);\n    }\n\n    if (_isComplete) {\n      this.setCurrentRawFrameValue(nextValue);\n      this.pause();\n      this.trigger('complete');\n    }\n  };\n\n  AnimationItem.prototype.adjustSegment = function (arr, offset) {\n    this.playCount = 0;\n\n    if (arr[1] < arr[0]) {\n      if (this.frameModifier > 0) {\n        if (this.playSpeed < 0) {\n          this.setSpeed(-this.playSpeed);\n        } else {\n          this.setDirection(-1);\n        }\n      }\n\n      this.totalFrames = arr[0] - arr[1];\n      this.timeCompleted = this.totalFrames;\n      this.firstFrame = arr[1];\n      this.setCurrentRawFrameValue(this.totalFrames - 0.001 - offset);\n    } else if (arr[1] > arr[0]) {\n      if (this.frameModifier < 0) {\n        if (this.playSpeed < 0) {\n          this.setSpeed(-this.playSpeed);\n        } else {\n          this.setDirection(1);\n        }\n      }\n\n      this.totalFrames = arr[1] - arr[0];\n      this.timeCompleted = this.totalFrames;\n      this.firstFrame = arr[0];\n      this.setCurrentRawFrameValue(0.001 + offset);\n    }\n\n    this.trigger('segmentStart');\n  };\n\n  AnimationItem.prototype.setSegment = function (init, end) {\n    var pendingFrame = -1;\n\n    if (this.isPaused) {\n      if (this.currentRawFrame + this.firstFrame < init) {\n        pendingFrame = init;\n      } else if (this.currentRawFrame + this.firstFrame > end) {\n        pendingFrame = end - init;\n      }\n    }\n\n    this.firstFrame = init;\n    this.totalFrames = end - init;\n    this.timeCompleted = this.totalFrames;\n\n    if (pendingFrame !== -1) {\n      this.goToAndStop(pendingFrame, true);\n    }\n  };\n\n  AnimationItem.prototype.playSegments = function (arr, forceFlag) {\n    if (forceFlag) {\n      this.segments.length = 0;\n    }\n\n    if (_typeof$4(arr[0]) === 'object') {\n      var i;\n      var len = arr.length;\n\n      for (i = 0; i < len; i += 1) {\n        this.segments.push(arr[i]);\n      }\n    } else {\n      this.segments.push(arr);\n    }\n\n    if (this.segments.length && forceFlag) {\n      this.adjustSegment(this.segments.shift(), 0);\n    }\n\n    if (this.isPaused) {\n      this.play();\n    }\n  };\n\n  AnimationItem.prototype.resetSegments = function (forceFlag) {\n    this.segments.length = 0;\n    this.segments.push([this.animationData.ip, this.animationData.op]);\n\n    if (forceFlag) {\n      this.checkSegments(0);\n    }\n  };\n\n  AnimationItem.prototype.checkSegments = function (offset) {\n    if (this.segments.length) {\n      this.adjustSegment(this.segments.shift(), offset);\n      return true;\n    }\n\n    return false;\n  };\n\n  AnimationItem.prototype.destroy = function (name) {\n    if (name && this.name !== name || !this.renderer) {\n      return;\n    }\n\n    this.renderer.destroy();\n    this.imagePreloader.destroy();\n    this.trigger('destroy');\n    this._cbs = null;\n    this.onEnterFrame = null;\n    this.onLoopComplete = null;\n    this.onComplete = null;\n    this.onSegmentStart = null;\n    this.onDestroy = null;\n    this.renderer = null;\n    this.expressionsPlugin = null;\n    this.imagePreloader = null;\n    this.projectInterface = null;\n  };\n\n  AnimationItem.prototype.setCurrentRawFrameValue = function (value) {\n    this.currentRawFrame = value;\n    this.gotoFrame();\n  };\n\n  AnimationItem.prototype.setSpeed = function (val) {\n    this.playSpeed = val;\n    this.updaFrameModifier();\n  };\n\n  AnimationItem.prototype.setDirection = function (val) {\n    this.playDirection = val < 0 ? -1 : 1;\n    this.updaFrameModifier();\n  };\n\n  AnimationItem.prototype.setLoop = function (isLooping) {\n    this.loop = isLooping;\n  };\n\n  AnimationItem.prototype.setVolume = function (val, name) {\n    if (name && this.name !== name) {\n      return;\n    }\n\n    this.audioController.setVolume(val);\n  };\n\n  AnimationItem.prototype.getVolume = function () {\n    return this.audioController.getVolume();\n  };\n\n  AnimationItem.prototype.mute = function (name) {\n    if (name && this.name !== name) {\n      return;\n    }\n\n    this.audioController.mute();\n  };\n\n  AnimationItem.prototype.unmute = function (name) {\n    if (name && this.name !== name) {\n      return;\n    }\n\n    this.audioController.unmute();\n  };\n\n  AnimationItem.prototype.updaFrameModifier = function () {\n    this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;\n    this.audioController.setRate(this.playSpeed * this.playDirection);\n  };\n\n  AnimationItem.prototype.getPath = function () {\n    return this.path;\n  };\n\n  AnimationItem.prototype.getAssetsPath = function (assetData) {\n    var path = '';\n\n    if (assetData.e) {\n      path = assetData.p;\n    } else if (this.assetsPath) {\n      var imagePath = assetData.p;\n\n      if (imagePath.indexOf('images/') !== -1) {\n        imagePath = imagePath.split('/')[1];\n      }\n\n      path = this.assetsPath + imagePath;\n    } else {\n      path = this.path;\n      path += assetData.u ? assetData.u : '';\n      path += assetData.p;\n    }\n\n    return path;\n  };\n\n  AnimationItem.prototype.getAssetData = function (id) {\n    var i = 0;\n    var len = this.assets.length;\n\n    while (i < len) {\n      if (id === this.assets[i].id) {\n        return this.assets[i];\n      }\n\n      i += 1;\n    }\n\n    return null;\n  };\n\n  AnimationItem.prototype.hide = function () {\n    this.renderer.hide();\n  };\n\n  AnimationItem.prototype.show = function () {\n    this.renderer.show();\n  };\n\n  AnimationItem.prototype.getDuration = function (isFrame) {\n    return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;\n  };\n\n  AnimationItem.prototype.updateDocumentData = function (path, documentData, index) {\n    try {\n      var element = this.renderer.getElementByPath(path);\n      element.updateDocumentData(documentData, index);\n    } catch (error) {// TODO: decide how to handle catch case\n    }\n  };\n\n  AnimationItem.prototype.trigger = function (name) {\n    if (this._cbs && this._cbs[name]) {\n      switch (name) {\n        case 'enterFrame':\n          this.triggerEvent(name, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameModifier));\n          break;\n\n        case 'drawnFrame':\n          this.drawnFrameEvent.currentTime = this.currentFrame;\n          this.drawnFrameEvent.totalTime = this.totalFrames;\n          this.drawnFrameEvent.direction = this.frameModifier;\n          this.triggerEvent(name, this.drawnFrameEvent);\n          break;\n\n        case 'loopComplete':\n          this.triggerEvent(name, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));\n          break;\n\n        case 'complete':\n          this.triggerEvent(name, new BMCompleteEvent(name, this.frameMult));\n          break;\n\n        case 'segmentStart':\n          this.triggerEvent(name, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));\n          break;\n\n        case 'destroy':\n          this.triggerEvent(name, new BMDestroyEvent(name, this));\n          break;\n\n        default:\n          this.triggerEvent(name);\n      }\n    }\n\n    if (name === 'enterFrame' && this.onEnterFrame) {\n      this.onEnterFrame.call(this, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameMult));\n    }\n\n    if (name === 'loopComplete' && this.onLoopComplete) {\n      this.onLoopComplete.call(this, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));\n    }\n\n    if (name === 'complete' && this.onComplete) {\n      this.onComplete.call(this, new BMCompleteEvent(name, this.frameMult));\n    }\n\n    if (name === 'segmentStart' && this.onSegmentStart) {\n      this.onSegmentStart.call(this, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));\n    }\n\n    if (name === 'destroy' && this.onDestroy) {\n      this.onDestroy.call(this, new BMDestroyEvent(name, this));\n    }\n  };\n\n  AnimationItem.prototype.triggerRenderFrameError = function (nativeError) {\n    var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);\n    this.triggerEvent('error', error);\n\n    if (this.onError) {\n      this.onError.call(this, error);\n    }\n  };\n\n  AnimationItem.prototype.triggerConfigError = function (nativeError) {\n    var error = new BMConfigErrorEvent(nativeError, this.currentFrame);\n    this.triggerEvent('error', error);\n\n    if (this.onError) {\n      this.onError.call(this, error);\n    }\n  };\n\n  var animationManager = function () {\n    var moduleOb = {};\n    var registeredAnimations = [];\n    var initTime = 0;\n    var len = 0;\n    var playingAnimationsNum = 0;\n    var _stopped = true;\n    var _isFrozen = false;\n\n    function removeElement(ev) {\n      var i = 0;\n      var animItem = ev.target;\n\n      while (i < len) {\n        if (registeredAnimations[i].animation === animItem) {\n          registeredAnimations.splice(i, 1);\n          i -= 1;\n          len -= 1;\n\n          if (!animItem.isPaused) {\n            subtractPlayingCount();\n          }\n        }\n\n        i += 1;\n      }\n    }\n\n    function registerAnimation(element, animationData) {\n      if (!element) {\n        return null;\n      }\n\n      var i = 0;\n\n      while (i < len) {\n        if (registeredAnimations[i].elem === element && registeredAnimations[i].elem !== null) {\n          return registeredAnimations[i].animation;\n        }\n\n        i += 1;\n      }\n\n      var animItem = new AnimationItem();\n      setupAnimation(animItem, element);\n      animItem.setData(element, animationData);\n      return animItem;\n    }\n\n    function getRegisteredAnimations() {\n      var i;\n      var lenAnims = registeredAnimations.length;\n      var animations = [];\n\n      for (i = 0; i < lenAnims; i += 1) {\n        animations.push(registeredAnimations[i].animation);\n      }\n\n      return animations;\n    }\n\n    function addPlayingCount() {\n      playingAnimationsNum += 1;\n      activate();\n    }\n\n    function subtractPlayingCount() {\n      playingAnimationsNum -= 1;\n    }\n\n    function setupAnimation(animItem, element) {\n      animItem.addEventListener('destroy', removeElement);\n      animItem.addEventListener('_active', addPlayingCount);\n      animItem.addEventListener('_idle', subtractPlayingCount);\n      registeredAnimations.push({\n        elem: element,\n        animation: animItem\n      });\n      len += 1;\n    }\n\n    function loadAnimation(params) {\n      var animItem = new AnimationItem();\n      setupAnimation(animItem, null);\n      animItem.setParams(params);\n      return animItem;\n    }\n\n    function setSpeed(val, animation) {\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.setSpeed(val, animation);\n      }\n    }\n\n    function setDirection(val, animation) {\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.setDirection(val, animation);\n      }\n    }\n\n    function play(animation) {\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.play(animation);\n      }\n    }\n\n    function resume(nowTime) {\n      var elapsedTime = nowTime - initTime;\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.advanceTime(elapsedTime);\n      }\n\n      initTime = nowTime;\n\n      if (playingAnimationsNum && !_isFrozen) {\n        window.requestAnimationFrame(resume);\n      } else {\n        _stopped = true;\n      }\n    }\n\n    function first(nowTime) {\n      initTime = nowTime;\n      window.requestAnimationFrame(resume);\n    }\n\n    function pause(animation) {\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.pause(animation);\n      }\n    }\n\n    function goToAndStop(value, isFrame, animation) {\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.goToAndStop(value, isFrame, animation);\n      }\n    }\n\n    function stop(animation) {\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.stop(animation);\n      }\n    }\n\n    function togglePause(animation) {\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.togglePause(animation);\n      }\n    }\n\n    function destroy(animation) {\n      var i;\n\n      for (i = len - 1; i >= 0; i -= 1) {\n        registeredAnimations[i].animation.destroy(animation);\n      }\n    }\n\n    function searchAnimations(animationData, standalone, renderer) {\n      var animElements = [].concat([].slice.call(document.getElementsByClassName('lottie')), [].slice.call(document.getElementsByClassName('bodymovin')));\n      var i;\n      var lenAnims = animElements.length;\n\n      for (i = 0; i < lenAnims; i += 1) {\n        if (renderer) {\n          animElements[i].setAttribute('data-bm-type', renderer);\n        }\n\n        registerAnimation(animElements[i], animationData);\n      }\n\n      if (standalone && lenAnims === 0) {\n        if (!renderer) {\n          renderer = 'svg';\n        }\n\n        var body = document.getElementsByTagName('body')[0];\n        body.innerText = '';\n        var div = createTag('div');\n        div.style.width = '100%';\n        div.style.height = '100%';\n        div.setAttribute('data-bm-type', renderer);\n        body.appendChild(div);\n        registerAnimation(div, animationData);\n      }\n    }\n\n    function resize() {\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.resize();\n      }\n    }\n\n    function activate() {\n      if (!_isFrozen && playingAnimationsNum) {\n        if (_stopped) {\n          window.requestAnimationFrame(first);\n          _stopped = false;\n        }\n      }\n    }\n\n    function freeze() {\n      _isFrozen = true;\n    }\n\n    function unfreeze() {\n      _isFrozen = false;\n      activate();\n    }\n\n    function setVolume(val, animation) {\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.setVolume(val, animation);\n      }\n    }\n\n    function mute(animation) {\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.mute(animation);\n      }\n    }\n\n    function unmute(animation) {\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.unmute(animation);\n      }\n    }\n\n    moduleOb.registerAnimation = registerAnimation;\n    moduleOb.loadAnimation = loadAnimation;\n    moduleOb.setSpeed = setSpeed;\n    moduleOb.setDirection = setDirection;\n    moduleOb.play = play;\n    moduleOb.pause = pause;\n    moduleOb.stop = stop;\n    moduleOb.togglePause = togglePause;\n    moduleOb.searchAnimations = searchAnimations;\n    moduleOb.resize = resize; // moduleOb.start = start;\n\n    moduleOb.goToAndStop = goToAndStop;\n    moduleOb.destroy = destroy;\n    moduleOb.freeze = freeze;\n    moduleOb.unfreeze = unfreeze;\n    moduleOb.setVolume = setVolume;\n    moduleOb.mute = mute;\n    moduleOb.unmute = unmute;\n    moduleOb.getRegisteredAnimations = getRegisteredAnimations;\n    return moduleOb;\n  }();\n\n  /* eslint-disable */\n  var BezierFactory = function () {\n    /**\r\n       * BezierEasing - use bezier curve for transition easing function\r\n       * by Gaëtan Renaudeau 2014 - 2015 – MIT License\r\n       *\r\n       * Credits: is based on Firefox's nsSMILKeySpline.cpp\r\n       * Usage:\r\n       * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])\r\n       * spline.get(x) => returns the easing value | x must be in [0, 1] range\r\n       *\r\n       */\n    var ob = {};\n    ob.getBezierEasing = getBezierEasing;\n    var beziers = {};\n\n    function getBezierEasing(a, b, c, d, nm) {\n      var str = nm || ('bez_' + a + '_' + b + '_' + c + '_' + d).replace(/\\./g, 'p');\n\n      if (beziers[str]) {\n        return beziers[str];\n      }\n\n      var bezEasing = new BezierEasing([a, b, c, d]);\n      beziers[str] = bezEasing;\n      return bezEasing;\n    } // These values are established by empiricism with tests (tradeoff: performance VS precision)\n\n\n    var NEWTON_ITERATIONS = 4;\n    var NEWTON_MIN_SLOPE = 0.001;\n    var SUBDIVISION_PRECISION = 0.0000001;\n    var SUBDIVISION_MAX_ITERATIONS = 10;\n    var kSplineTableSize = 11;\n    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n    var float32ArraySupported = typeof Float32Array === 'function';\n\n    function A(aA1, aA2) {\n      return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n    }\n\n    function B(aA1, aA2) {\n      return 3.0 * aA2 - 6.0 * aA1;\n    }\n\n    function C(aA1) {\n      return 3.0 * aA1;\n    } // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n\n\n    function calcBezier(aT, aA1, aA2) {\n      return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n    } // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\n\n\n    function getSlope(aT, aA1, aA2) {\n      return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n    }\n\n    function binarySubdivide(aX, aA, aB, mX1, mX2) {\n      var currentX,\n          currentT,\n          i = 0;\n\n      do {\n        currentT = aA + (aB - aA) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\n\n        if (currentX > 0.0) {\n          aB = currentT;\n        } else {\n          aA = currentT;\n        }\n      } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n\n      return currentT;\n    }\n\n    function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n      for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n        var currentSlope = getSlope(aGuessT, mX1, mX2);\n        if (currentSlope === 0.0) return aGuessT;\n        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n      }\n\n      return aGuessT;\n    }\n    /**\r\n       * points is an array of [ mX1, mY1, mX2, mY2 ]\r\n       */\n\n\n    function BezierEasing(points) {\n      this._p = points;\n      this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n      this._precomputed = false;\n      this.get = this.get.bind(this);\n    }\n\n    BezierEasing.prototype = {\n      get: function get(x) {\n        var mX1 = this._p[0],\n            mY1 = this._p[1],\n            mX2 = this._p[2],\n            mY2 = this._p[3];\n        if (!this._precomputed) this._precompute();\n        if (mX1 === mY1 && mX2 === mY2) return x; // linear\n        // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n\n        if (x === 0) return 0;\n        if (x === 1) return 1;\n        return calcBezier(this._getTForX(x), mY1, mY2);\n      },\n      // Private part\n      _precompute: function _precompute() {\n        var mX1 = this._p[0],\n            mY1 = this._p[1],\n            mX2 = this._p[2],\n            mY2 = this._p[3];\n        this._precomputed = true;\n\n        if (mX1 !== mY1 || mX2 !== mY2) {\n          this._calcSampleValues();\n        }\n      },\n      _calcSampleValues: function _calcSampleValues() {\n        var mX1 = this._p[0],\n            mX2 = this._p[2];\n\n        for (var i = 0; i < kSplineTableSize; ++i) {\n          this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n        }\n      },\n\n      /**\r\n           * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.\r\n           */\n      _getTForX: function _getTForX(aX) {\n        var mX1 = this._p[0],\n            mX2 = this._p[2],\n            mSampleValues = this._mSampleValues;\n        var intervalStart = 0.0;\n        var currentSample = 1;\n        var lastSample = kSplineTableSize - 1;\n\n        for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {\n          intervalStart += kSampleStepSize;\n        }\n\n        --currentSample; // Interpolate to provide an initial guess for t\n\n        var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);\n        var guessForT = intervalStart + dist * kSampleStepSize;\n        var initialSlope = getSlope(guessForT, mX1, mX2);\n\n        if (initialSlope >= NEWTON_MIN_SLOPE) {\n          return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n        }\n\n        if (initialSlope === 0.0) {\n          return guessForT;\n        }\n\n        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n      }\n    };\n    return ob;\n  }();\n\n  var pooling = function () {\n    function _double(arr) {\n      return arr.concat(createSizedArray(arr.length));\n    }\n\n    return {\n      \"double\": _double\n    };\n  }();\n\n  var poolFactory = function () {\n    return function (initialLength, _create, _release) {\n      var _length = 0;\n      var _maxLength = initialLength;\n      var pool = createSizedArray(_maxLength);\n      var ob = {\n        newElement: newElement,\n        release: release\n      };\n\n      function newElement() {\n        var element;\n\n        if (_length) {\n          _length -= 1;\n          element = pool[_length];\n        } else {\n          element = _create();\n        }\n\n        return element;\n      }\n\n      function release(element) {\n        if (_length === _maxLength) {\n          pool = pooling[\"double\"](pool);\n          _maxLength *= 2;\n        }\n\n        if (_release) {\n          _release(element);\n        }\n\n        pool[_length] = element;\n        _length += 1;\n      }\n\n      return ob;\n    };\n  }();\n\n  var bezierLengthPool = function () {\n    function create() {\n      return {\n        addedLength: 0,\n        percents: createTypedArray('float32', getDefaultCurveSegments()),\n        lengths: createTypedArray('float32', getDefaultCurveSegments())\n      };\n    }\n\n    return poolFactory(8, create);\n  }();\n\n  var segmentsLengthPool = function () {\n    function create() {\n      return {\n        lengths: [],\n        totalLength: 0\n      };\n    }\n\n    function release(element) {\n      var i;\n      var len = element.lengths.length;\n\n      for (i = 0; i < len; i += 1) {\n        bezierLengthPool.release(element.lengths[i]);\n      }\n\n      element.lengths.length = 0;\n    }\n\n    return poolFactory(8, create, release);\n  }();\n\n  function bezFunction() {\n    var math = Math;\n\n    function pointOnLine2D(x1, y1, x2, y2, x3, y3) {\n      var det1 = x1 * y2 + y1 * x3 + x2 * y3 - x3 * y2 - y3 * x1 - x2 * y1;\n      return det1 > -0.001 && det1 < 0.001;\n    }\n\n    function pointOnLine3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {\n      if (z1 === 0 && z2 === 0 && z3 === 0) {\n        return pointOnLine2D(x1, y1, x2, y2, x3, y3);\n      }\n\n      var dist1 = math.sqrt(math.pow(x2 - x1, 2) + math.pow(y2 - y1, 2) + math.pow(z2 - z1, 2));\n      var dist2 = math.sqrt(math.pow(x3 - x1, 2) + math.pow(y3 - y1, 2) + math.pow(z3 - z1, 2));\n      var dist3 = math.sqrt(math.pow(x3 - x2, 2) + math.pow(y3 - y2, 2) + math.pow(z3 - z2, 2));\n      var diffDist;\n\n      if (dist1 > dist2) {\n        if (dist1 > dist3) {\n          diffDist = dist1 - dist2 - dist3;\n        } else {\n          diffDist = dist3 - dist2 - dist1;\n        }\n      } else if (dist3 > dist2) {\n        diffDist = dist3 - dist2 - dist1;\n      } else {\n        diffDist = dist2 - dist1 - dist3;\n      }\n\n      return diffDist > -0.0001 && diffDist < 0.0001;\n    }\n\n    var getBezierLength = function () {\n      return function (pt1, pt2, pt3, pt4) {\n        var curveSegments = getDefaultCurveSegments();\n        var k;\n        var i;\n        var len;\n        var ptCoord;\n        var perc;\n        var addedLength = 0;\n        var ptDistance;\n        var point = [];\n        var lastPoint = [];\n        var lengthData = bezierLengthPool.newElement();\n        len = pt3.length;\n\n        for (k = 0; k < curveSegments; k += 1) {\n          perc = k / (curveSegments - 1);\n          ptDistance = 0;\n\n          for (i = 0; i < len; i += 1) {\n            ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * pt3[i] + 3 * (1 - perc) * bmPow(perc, 2) * pt4[i] + bmPow(perc, 3) * pt2[i];\n            point[i] = ptCoord;\n\n            if (lastPoint[i] !== null) {\n              ptDistance += bmPow(point[i] - lastPoint[i], 2);\n            }\n\n            lastPoint[i] = point[i];\n          }\n\n          if (ptDistance) {\n            ptDistance = bmSqrt(ptDistance);\n            addedLength += ptDistance;\n          }\n\n          lengthData.percents[k] = perc;\n          lengthData.lengths[k] = addedLength;\n        }\n\n        lengthData.addedLength = addedLength;\n        return lengthData;\n      };\n    }();\n\n    function getSegmentsLength(shapeData) {\n      var segmentsLength = segmentsLengthPool.newElement();\n      var closed = shapeData.c;\n      var pathV = shapeData.v;\n      var pathO = shapeData.o;\n      var pathI = shapeData.i;\n      var i;\n      var len = shapeData._length;\n      var lengths = segmentsLength.lengths;\n      var totalLength = 0;\n\n      for (i = 0; i < len - 1; i += 1) {\n        lengths[i] = getBezierLength(pathV[i], pathV[i + 1], pathO[i], pathI[i + 1]);\n        totalLength += lengths[i].addedLength;\n      }\n\n      if (closed && len) {\n        lengths[i] = getBezierLength(pathV[i], pathV[0], pathO[i], pathI[0]);\n        totalLength += lengths[i].addedLength;\n      }\n\n      segmentsLength.totalLength = totalLength;\n      return segmentsLength;\n    }\n\n    function BezierData(length) {\n      this.segmentLength = 0;\n      this.points = new Array(length);\n    }\n\n    function PointData(partial, point) {\n      this.partialLength = partial;\n      this.point = point;\n    }\n\n    var buildBezierData = function () {\n      var storedData = {};\n      return function (pt1, pt2, pt3, pt4) {\n        var bezierName = (pt1[0] + '_' + pt1[1] + '_' + pt2[0] + '_' + pt2[1] + '_' + pt3[0] + '_' + pt3[1] + '_' + pt4[0] + '_' + pt4[1]).replace(/\\./g, 'p');\n\n        if (!storedData[bezierName]) {\n          var curveSegments = getDefaultCurveSegments();\n          var k;\n          var i;\n          var len;\n          var ptCoord;\n          var perc;\n          var addedLength = 0;\n          var ptDistance;\n          var point;\n          var lastPoint = null;\n\n          if (pt1.length === 2 && (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])) {\n            curveSegments = 2;\n          }\n\n          var bezierData = new BezierData(curveSegments);\n          len = pt3.length;\n\n          for (k = 0; k < curveSegments; k += 1) {\n            point = createSizedArray(len);\n            perc = k / (curveSegments - 1);\n            ptDistance = 0;\n\n            for (i = 0; i < len; i += 1) {\n              ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * (pt1[i] + pt3[i]) + 3 * (1 - perc) * bmPow(perc, 2) * (pt2[i] + pt4[i]) + bmPow(perc, 3) * pt2[i];\n              point[i] = ptCoord;\n\n              if (lastPoint !== null) {\n                ptDistance += bmPow(point[i] - lastPoint[i], 2);\n              }\n            }\n\n            ptDistance = bmSqrt(ptDistance);\n            addedLength += ptDistance;\n            bezierData.points[k] = new PointData(ptDistance, point);\n            lastPoint = point;\n          }\n\n          bezierData.segmentLength = addedLength;\n          storedData[bezierName] = bezierData;\n        }\n\n        return storedData[bezierName];\n      };\n    }();\n\n    function getDistancePerc(perc, bezierData) {\n      var percents = bezierData.percents;\n      var lengths = bezierData.lengths;\n      var len = percents.length;\n      var initPos = bmFloor((len - 1) * perc);\n      var lengthPos = perc * bezierData.addedLength;\n      var lPerc = 0;\n\n      if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) {\n        return percents[initPos];\n      }\n\n      var dir = lengths[initPos] > lengthPos ? -1 : 1;\n      var flag = true;\n\n      while (flag) {\n        if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {\n          lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]);\n          flag = false;\n        } else {\n          initPos += dir;\n        }\n\n        if (initPos < 0 || initPos >= len - 1) {\n          // FIX for TypedArrays that don't store floating point values with enough accuracy\n          if (initPos === len - 1) {\n            return percents[initPos];\n          }\n\n          flag = false;\n        }\n      }\n\n      return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc;\n    }\n\n    function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {\n      var t1 = getDistancePerc(percent, bezierData);\n      var u1 = 1 - t1;\n      var ptX = math.round((u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0]) * 1000) / 1000;\n      var ptY = math.round((u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1]) * 1000) / 1000;\n      return [ptX, ptY];\n    }\n\n    var bezierSegmentPoints = createTypedArray('float32', 8);\n\n    function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {\n      if (startPerc < 0) {\n        startPerc = 0;\n      } else if (startPerc > 1) {\n        startPerc = 1;\n      }\n\n      var t0 = getDistancePerc(startPerc, bezierData);\n      endPerc = endPerc > 1 ? 1 : endPerc;\n      var t1 = getDistancePerc(endPerc, bezierData);\n      var i;\n      var len = pt1.length;\n      var u0 = 1 - t0;\n      var u1 = 1 - t1;\n      var u0u0u0 = u0 * u0 * u0;\n      var t0u0u0_3 = t0 * u0 * u0 * 3; // eslint-disable-line camelcase\n\n      var t0t0u0_3 = t0 * t0 * u0 * 3; // eslint-disable-line camelcase\n\n      var t0t0t0 = t0 * t0 * t0; //\n\n      var u0u0u1 = u0 * u0 * u1;\n      var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1; // eslint-disable-line camelcase\n\n      var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1; // eslint-disable-line camelcase\n\n      var t0t0t1 = t0 * t0 * t1; //\n\n      var u0u1u1 = u0 * u1 * u1;\n      var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1; // eslint-disable-line camelcase\n\n      var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1; // eslint-disable-line camelcase\n\n      var t0t1t1 = t0 * t1 * t1; //\n\n      var u1u1u1 = u1 * u1 * u1;\n      var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1; // eslint-disable-line camelcase\n\n      var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1; // eslint-disable-line camelcase\n\n      var t1t1t1 = t1 * t1 * t1;\n\n      for (i = 0; i < len; i += 1) {\n        bezierSegmentPoints[i * 4] = math.round((u0u0u0 * pt1[i] + t0u0u0_3 * pt3[i] + t0t0u0_3 * pt4[i] + t0t0t0 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase\n\n        bezierSegmentPoints[i * 4 + 1] = math.round((u0u0u1 * pt1[i] + t0u0u1_3 * pt3[i] + t0t0u1_3 * pt4[i] + t0t0t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase\n\n        bezierSegmentPoints[i * 4 + 2] = math.round((u0u1u1 * pt1[i] + t0u1u1_3 * pt3[i] + t0t1u1_3 * pt4[i] + t0t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase\n\n        bezierSegmentPoints[i * 4 + 3] = math.round((u1u1u1 * pt1[i] + t1u1u1_3 * pt3[i] + t1t1u1_3 * pt4[i] + t1t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase\n      }\n\n      return bezierSegmentPoints;\n    }\n\n    return {\n      getSegmentsLength: getSegmentsLength,\n      getNewSegment: getNewSegment,\n      getPointInSegment: getPointInSegment,\n      buildBezierData: buildBezierData,\n      pointOnLine2D: pointOnLine2D,\n      pointOnLine3D: pointOnLine3D\n    };\n  }\n\n  var bez = bezFunction();\n\n  var initFrame = initialDefaultFrame;\n  var mathAbs = Math.abs;\n\n  function interpolateValue(frameNum, caching) {\n    var offsetTime = this.offsetTime;\n    var newValue;\n\n    if (this.propType === 'multidimensional') {\n      newValue = createTypedArray('float32', this.pv.length);\n    }\n\n    var iterationIndex = caching.lastIndex;\n    var i = iterationIndex;\n    var len = this.keyframes.length - 1;\n    var flag = true;\n    var keyData;\n    var nextKeyData;\n    var keyframeMetadata;\n\n    while (flag) {\n      keyData = this.keyframes[i];\n      nextKeyData = this.keyframes[i + 1];\n\n      if (i === len - 1 && frameNum >= nextKeyData.t - offsetTime) {\n        if (keyData.h) {\n          keyData = nextKeyData;\n        }\n\n        iterationIndex = 0;\n        break;\n      }\n\n      if (nextKeyData.t - offsetTime > frameNum) {\n        iterationIndex = i;\n        break;\n      }\n\n      if (i < len - 1) {\n        i += 1;\n      } else {\n        iterationIndex = 0;\n        flag = false;\n      }\n    }\n\n    keyframeMetadata = this.keyframesMetadata[i] || {};\n    var k;\n    var kLen;\n    var perc;\n    var jLen;\n    var j;\n    var fnc;\n    var nextKeyTime = nextKeyData.t - offsetTime;\n    var keyTime = keyData.t - offsetTime;\n    var endValue;\n\n    if (keyData.to) {\n      if (!keyframeMetadata.bezierData) {\n        keyframeMetadata.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);\n      }\n\n      var bezierData = keyframeMetadata.bezierData;\n\n      if (frameNum >= nextKeyTime || frameNum < keyTime) {\n        var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;\n        kLen = bezierData.points[ind].point.length;\n\n        for (k = 0; k < kLen; k += 1) {\n          newValue[k] = bezierData.points[ind].point[k];\n        } // caching._lastKeyframeIndex = -1;\n\n      } else {\n        if (keyframeMetadata.__fnct) {\n          fnc = keyframeMetadata.__fnct;\n        } else {\n          fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;\n          keyframeMetadata.__fnct = fnc;\n        }\n\n        perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));\n        var distanceInLine = bezierData.segmentLength * perc;\n        var segmentPerc;\n        var addedLength = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastAddedLength : 0;\n        j = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastPoint : 0;\n        flag = true;\n        jLen = bezierData.points.length;\n\n        while (flag) {\n          addedLength += bezierData.points[j].partialLength;\n\n          if (distanceInLine === 0 || perc === 0 || j === bezierData.points.length - 1) {\n            kLen = bezierData.points[j].point.length;\n\n            for (k = 0; k < kLen; k += 1) {\n              newValue[k] = bezierData.points[j].point[k];\n            }\n\n            break;\n          } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j + 1].partialLength) {\n            segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength;\n            kLen = bezierData.points[j].point.length;\n\n            for (k = 0; k < kLen; k += 1) {\n              newValue[k] = bezierData.points[j].point[k] + (bezierData.points[j + 1].point[k] - bezierData.points[j].point[k]) * segmentPerc;\n            }\n\n            break;\n          }\n\n          if (j < jLen - 1) {\n            j += 1;\n          } else {\n            flag = false;\n          }\n        }\n\n        caching._lastPoint = j;\n        caching._lastAddedLength = addedLength - bezierData.points[j].partialLength;\n        caching._lastKeyframeIndex = i;\n      }\n    } else {\n      var outX;\n      var outY;\n      var inX;\n      var inY;\n      var keyValue;\n      len = keyData.s.length;\n      endValue = nextKeyData.s || keyData.e;\n\n      if (this.sh && keyData.h !== 1) {\n        if (frameNum >= nextKeyTime) {\n          newValue[0] = endValue[0];\n          newValue[1] = endValue[1];\n          newValue[2] = endValue[2];\n        } else if (frameNum <= keyTime) {\n          newValue[0] = keyData.s[0];\n          newValue[1] = keyData.s[1];\n          newValue[2] = keyData.s[2];\n        } else {\n          var quatStart = createQuaternion(keyData.s);\n          var quatEnd = createQuaternion(endValue);\n          var time = (frameNum - keyTime) / (nextKeyTime - keyTime);\n          quaternionToEuler(newValue, slerp(quatStart, quatEnd, time));\n        }\n      } else {\n        for (i = 0; i < len; i += 1) {\n          if (keyData.h !== 1) {\n            if (frameNum >= nextKeyTime) {\n              perc = 1;\n            } else if (frameNum < keyTime) {\n              perc = 0;\n            } else {\n              if (keyData.o.x.constructor === Array) {\n                if (!keyframeMetadata.__fnct) {\n                  keyframeMetadata.__fnct = [];\n                }\n\n                if (!keyframeMetadata.__fnct[i]) {\n                  outX = keyData.o.x[i] === undefined ? keyData.o.x[0] : keyData.o.x[i];\n                  outY = keyData.o.y[i] === undefined ? keyData.o.y[0] : keyData.o.y[i];\n                  inX = keyData.i.x[i] === undefined ? keyData.i.x[0] : keyData.i.x[i];\n                  inY = keyData.i.y[i] === undefined ? keyData.i.y[0] : keyData.i.y[i];\n                  fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;\n                  keyframeMetadata.__fnct[i] = fnc;\n                } else {\n                  fnc = keyframeMetadata.__fnct[i];\n                }\n              } else if (!keyframeMetadata.__fnct) {\n                outX = keyData.o.x;\n                outY = keyData.o.y;\n                inX = keyData.i.x;\n                inY = keyData.i.y;\n                fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;\n                keyData.keyframeMetadata = fnc;\n              } else {\n                fnc = keyframeMetadata.__fnct;\n              }\n\n              perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));\n            }\n          }\n\n          endValue = nextKeyData.s || keyData.e;\n          keyValue = keyData.h === 1 ? keyData.s[i] : keyData.s[i] + (endValue[i] - keyData.s[i]) * perc;\n\n          if (this.propType === 'multidimensional') {\n            newValue[i] = keyValue;\n          } else {\n            newValue = keyValue;\n          }\n        }\n      }\n    }\n\n    caching.lastIndex = iterationIndex;\n    return newValue;\n  } // based on @Toji's https://github.com/toji/gl-matrix/\n\n\n  function slerp(a, b, t) {\n    var out = [];\n    var ax = a[0];\n    var ay = a[1];\n    var az = a[2];\n    var aw = a[3];\n    var bx = b[0];\n    var by = b[1];\n    var bz = b[2];\n    var bw = b[3];\n    var omega;\n    var cosom;\n    var sinom;\n    var scale0;\n    var scale1;\n    cosom = ax * bx + ay * by + az * bz + aw * bw;\n\n    if (cosom < 0.0) {\n      cosom = -cosom;\n      bx = -bx;\n      by = -by;\n      bz = -bz;\n      bw = -bw;\n    }\n\n    if (1.0 - cosom > 0.000001) {\n      omega = Math.acos(cosom);\n      sinom = Math.sin(omega);\n      scale0 = Math.sin((1.0 - t) * omega) / sinom;\n      scale1 = Math.sin(t * omega) / sinom;\n    } else {\n      scale0 = 1.0 - t;\n      scale1 = t;\n    }\n\n    out[0] = scale0 * ax + scale1 * bx;\n    out[1] = scale0 * ay + scale1 * by;\n    out[2] = scale0 * az + scale1 * bz;\n    out[3] = scale0 * aw + scale1 * bw;\n    return out;\n  }\n\n  function quaternionToEuler(out, quat) {\n    var qx = quat[0];\n    var qy = quat[1];\n    var qz = quat[2];\n    var qw = quat[3];\n    var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz);\n    var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);\n    var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);\n    out[0] = heading / degToRads;\n    out[1] = attitude / degToRads;\n    out[2] = bank / degToRads;\n  }\n\n  function createQuaternion(values) {\n    var heading = values[0] * degToRads;\n    var attitude = values[1] * degToRads;\n    var bank = values[2] * degToRads;\n    var c1 = Math.cos(heading / 2);\n    var c2 = Math.cos(attitude / 2);\n    var c3 = Math.cos(bank / 2);\n    var s1 = Math.sin(heading / 2);\n    var s2 = Math.sin(attitude / 2);\n    var s3 = Math.sin(bank / 2);\n    var w = c1 * c2 * c3 - s1 * s2 * s3;\n    var x = s1 * s2 * c3 + c1 * c2 * s3;\n    var y = s1 * c2 * c3 + c1 * s2 * s3;\n    var z = c1 * s2 * c3 - s1 * c2 * s3;\n    return [x, y, z, w];\n  }\n\n  function getValueAtCurrentTime() {\n    var frameNum = this.comp.renderedFrame - this.offsetTime;\n    var initTime = this.keyframes[0].t - this.offsetTime;\n    var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;\n\n    if (!(frameNum === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= endTime && frameNum >= endTime || this._caching.lastFrame < initTime && frameNum < initTime))) {\n      if (this._caching.lastFrame >= frameNum) {\n        this._caching._lastKeyframeIndex = -1;\n        this._caching.lastIndex = 0;\n      }\n\n      var renderResult = this.interpolateValue(frameNum, this._caching);\n      this.pv = renderResult;\n    }\n\n    this._caching.lastFrame = frameNum;\n    return this.pv;\n  }\n\n  function setVValue(val) {\n    var multipliedValue;\n\n    if (this.propType === 'unidimensional') {\n      multipliedValue = val * this.mult;\n\n      if (mathAbs(this.v - multipliedValue) > 0.00001) {\n        this.v = multipliedValue;\n        this._mdf = true;\n      }\n    } else {\n      var i = 0;\n      var len = this.v.length;\n\n      while (i < len) {\n        multipliedValue = val[i] * this.mult;\n\n        if (mathAbs(this.v[i] - multipliedValue) > 0.00001) {\n          this.v[i] = multipliedValue;\n          this._mdf = true;\n        }\n\n        i += 1;\n      }\n    }\n  }\n\n  function processEffectsSequence() {\n    if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {\n      return;\n    }\n\n    if (this.lock) {\n      this.setVValue(this.pv);\n      return;\n    }\n\n    this.lock = true;\n    this._mdf = this._isFirstFrame;\n    var i;\n    var len = this.effectsSequence.length;\n    var finalValue = this.kf ? this.pv : this.data.k;\n\n    for (i = 0; i < len; i += 1) {\n      finalValue = this.effectsSequence[i](finalValue);\n    }\n\n    this.setVValue(finalValue);\n    this._isFirstFrame = false;\n    this.lock = false;\n    this.frameId = this.elem.globalData.frameId;\n  }\n\n  function addEffect(effectFunction) {\n    this.effectsSequence.push(effectFunction);\n    this.container.addDynamicProperty(this);\n  }\n\n  function ValueProperty(elem, data, mult, container) {\n    this.propType = 'unidimensional';\n    this.mult = mult || 1;\n    this.data = data;\n    this.v = mult ? data.k * mult : data.k;\n    this.pv = data.k;\n    this._mdf = false;\n    this.elem = elem;\n    this.container = container;\n    this.comp = elem.comp;\n    this.k = false;\n    this.kf = false;\n    this.vel = 0;\n    this.effectsSequence = [];\n    this._isFirstFrame = true;\n    this.getValue = processEffectsSequence;\n    this.setVValue = setVValue;\n    this.addEffect = addEffect;\n  }\n\n  function MultiDimensionalProperty(elem, data, mult, container) {\n    this.propType = 'multidimensional';\n    this.mult = mult || 1;\n    this.data = data;\n    this._mdf = false;\n    this.elem = elem;\n    this.container = container;\n    this.comp = elem.comp;\n    this.k = false;\n    this.kf = false;\n    this.frameId = -1;\n    var i;\n    var len = data.k.length;\n    this.v = createTypedArray('float32', len);\n    this.pv = createTypedArray('float32', len);\n    this.vel = createTypedArray('float32', len);\n\n    for (i = 0; i < len; i += 1) {\n      this.v[i] = data.k[i] * this.mult;\n      this.pv[i] = data.k[i];\n    }\n\n    this._isFirstFrame = true;\n    this.effectsSequence = [];\n    this.getValue = processEffectsSequence;\n    this.setVValue = setVValue;\n    this.addEffect = addEffect;\n  }\n\n  function KeyframedValueProperty(elem, data, mult, container) {\n    this.propType = 'unidimensional';\n    this.keyframes = data.k;\n    this.keyframesMetadata = [];\n    this.offsetTime = elem.data.st;\n    this.frameId = -1;\n    this._caching = {\n      lastFrame: initFrame,\n      lastIndex: 0,\n      value: 0,\n      _lastKeyframeIndex: -1\n    };\n    this.k = true;\n    this.kf = true;\n    this.data = data;\n    this.mult = mult || 1;\n    this.elem = elem;\n    this.container = container;\n    this.comp = elem.comp;\n    this.v = initFrame;\n    this.pv = initFrame;\n    this._isFirstFrame = true;\n    this.getValue = processEffectsSequence;\n    this.setVValue = setVValue;\n    this.interpolateValue = interpolateValue;\n    this.effectsSequence = [getValueAtCurrentTime.bind(this)];\n    this.addEffect = addEffect;\n  }\n\n  function KeyframedMultidimensionalProperty(elem, data, mult, container) {\n    this.propType = 'multidimensional';\n    var i;\n    var len = data.k.length;\n    var s;\n    var e;\n    var to;\n    var ti;\n\n    for (i = 0; i < len - 1; i += 1) {\n      if (data.k[i].to && data.k[i].s && data.k[i + 1] && data.k[i + 1].s) {\n        s = data.k[i].s;\n        e = data.k[i + 1].s;\n        to = data.k[i].to;\n        ti = data.k[i].ti;\n\n        if (s.length === 2 && !(s[0] === e[0] && s[1] === e[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], s[0] + to[0], s[1] + to[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], e[0] + ti[0], e[1] + ti[1]) || s.length === 3 && !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], s[0] + to[0], s[1] + to[1], s[2] + to[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], e[0] + ti[0], e[1] + ti[1], e[2] + ti[2])) {\n          data.k[i].to = null;\n          data.k[i].ti = null;\n        }\n\n        if (s[0] === e[0] && s[1] === e[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) {\n          if (s.length === 2 || s[2] === e[2] && to[2] === 0 && ti[2] === 0) {\n            data.k[i].to = null;\n            data.k[i].ti = null;\n          }\n        }\n      }\n    }\n\n    this.effectsSequence = [getValueAtCurrentTime.bind(this)];\n    this.data = data;\n    this.keyframes = data.k;\n    this.keyframesMetadata = [];\n    this.offsetTime = elem.data.st;\n    this.k = true;\n    this.kf = true;\n    this._isFirstFrame = true;\n    this.mult = mult || 1;\n    this.elem = elem;\n    this.container = container;\n    this.comp = elem.comp;\n    this.getValue = processEffectsSequence;\n    this.setVValue = setVValue;\n    this.interpolateValue = interpolateValue;\n    this.frameId = -1;\n    var arrLen = data.k[0].s.length;\n    this.v = createTypedArray('float32', arrLen);\n    this.pv = createTypedArray('float32', arrLen);\n\n    for (i = 0; i < arrLen; i += 1) {\n      this.v[i] = initFrame;\n      this.pv[i] = initFrame;\n    }\n\n    this._caching = {\n      lastFrame: initFrame,\n      lastIndex: 0,\n      value: createTypedArray('float32', arrLen)\n    };\n    this.addEffect = addEffect;\n  }\n\n  var PropertyFactory = function () {\n    function getProp(elem, data, type, mult, container) {\n      if (data.sid) {\n        data = elem.globalData.slotManager.getProp(data);\n      }\n\n      var p;\n\n      if (!data.k.length) {\n        p = new ValueProperty(elem, data, mult, container);\n      } else if (typeof data.k[0] === 'number') {\n        p = new MultiDimensionalProperty(elem, data, mult, container);\n      } else {\n        switch (type) {\n          case 0:\n            p = new KeyframedValueProperty(elem, data, mult, container);\n            break;\n\n          case 1:\n            p = new KeyframedMultidimensionalProperty(elem, data, mult, container);\n            break;\n\n          default:\n            break;\n        }\n      }\n\n      if (p.effectsSequence.length) {\n        container.addDynamicProperty(p);\n      }\n\n      return p;\n    }\n\n    var ob = {\n      getProp: getProp\n    };\n    return ob;\n  }();\n\n  function DynamicPropertyContainer() {}\n\n  DynamicPropertyContainer.prototype = {\n    addDynamicProperty: function addDynamicProperty(prop) {\n      if (this.dynamicProperties.indexOf(prop) === -1) {\n        this.dynamicProperties.push(prop);\n        this.container.addDynamicProperty(this);\n        this._isAnimated = true;\n      }\n    },\n    iterateDynamicProperties: function iterateDynamicProperties() {\n      this._mdf = false;\n      var i;\n      var len = this.dynamicProperties.length;\n\n      for (i = 0; i < len; i += 1) {\n        this.dynamicProperties[i].getValue();\n\n        if (this.dynamicProperties[i]._mdf) {\n          this._mdf = true;\n        }\n      }\n    },\n    initDynamicPropertyContainer: function initDynamicPropertyContainer(container) {\n      this.container = container;\n      this.dynamicProperties = [];\n      this._mdf = false;\n      this._isAnimated = false;\n    }\n  };\n\n  var pointPool = function () {\n    function create() {\n      return createTypedArray('float32', 2);\n    }\n\n    return poolFactory(8, create);\n  }();\n\n  function ShapePath() {\n    this.c = false;\n    this._length = 0;\n    this._maxLength = 8;\n    this.v = createSizedArray(this._maxLength);\n    this.o = createSizedArray(this._maxLength);\n    this.i = createSizedArray(this._maxLength);\n  }\n\n  ShapePath.prototype.setPathData = function (closed, len) {\n    this.c = closed;\n    this.setLength(len);\n    var i = 0;\n\n    while (i < len) {\n      this.v[i] = pointPool.newElement();\n      this.o[i] = pointPool.newElement();\n      this.i[i] = pointPool.newElement();\n      i += 1;\n    }\n  };\n\n  ShapePath.prototype.setLength = function (len) {\n    while (this._maxLength < len) {\n      this.doubleArrayLength();\n    }\n\n    this._length = len;\n  };\n\n  ShapePath.prototype.doubleArrayLength = function () {\n    this.v = this.v.concat(createSizedArray(this._maxLength));\n    this.i = this.i.concat(createSizedArray(this._maxLength));\n    this.o = this.o.concat(createSizedArray(this._maxLength));\n    this._maxLength *= 2;\n  };\n\n  ShapePath.prototype.setXYAt = function (x, y, type, pos, replace) {\n    var arr;\n    this._length = Math.max(this._length, pos + 1);\n\n    if (this._length >= this._maxLength) {\n      this.doubleArrayLength();\n    }\n\n    switch (type) {\n      case 'v':\n        arr = this.v;\n        break;\n\n      case 'i':\n        arr = this.i;\n        break;\n\n      case 'o':\n        arr = this.o;\n        break;\n\n      default:\n        arr = [];\n        break;\n    }\n\n    if (!arr[pos] || arr[pos] && !replace) {\n      arr[pos] = pointPool.newElement();\n    }\n\n    arr[pos][0] = x;\n    arr[pos][1] = y;\n  };\n\n  ShapePath.prototype.setTripleAt = function (vX, vY, oX, oY, iX, iY, pos, replace) {\n    this.setXYAt(vX, vY, 'v', pos, replace);\n    this.setXYAt(oX, oY, 'o', pos, replace);\n    this.setXYAt(iX, iY, 'i', pos, replace);\n  };\n\n  ShapePath.prototype.reverse = function () {\n    var newPath = new ShapePath();\n    newPath.setPathData(this.c, this._length);\n    var vertices = this.v;\n    var outPoints = this.o;\n    var inPoints = this.i;\n    var init = 0;\n\n    if (this.c) {\n      newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);\n      init = 1;\n    }\n\n    var cnt = this._length - 1;\n    var len = this._length;\n    var i;\n\n    for (i = init; i < len; i += 1) {\n      newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i, false);\n      cnt -= 1;\n    }\n\n    return newPath;\n  };\n\n  ShapePath.prototype.length = function () {\n    return this._length;\n  };\n\n  var shapePool = function () {\n    function create() {\n      return new ShapePath();\n    }\n\n    function release(shapePath) {\n      var len = shapePath._length;\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        pointPool.release(shapePath.v[i]);\n        pointPool.release(shapePath.i[i]);\n        pointPool.release(shapePath.o[i]);\n        shapePath.v[i] = null;\n        shapePath.i[i] = null;\n        shapePath.o[i] = null;\n      }\n\n      shapePath._length = 0;\n      shapePath.c = false;\n    }\n\n    function clone(shape) {\n      var cloned = factory.newElement();\n      var i;\n      var len = shape._length === undefined ? shape.v.length : shape._length;\n      cloned.setLength(len);\n      cloned.c = shape.c;\n\n      for (i = 0; i < len; i += 1) {\n        cloned.setTripleAt(shape.v[i][0], shape.v[i][1], shape.o[i][0], shape.o[i][1], shape.i[i][0], shape.i[i][1], i);\n      }\n\n      return cloned;\n    }\n\n    var factory = poolFactory(4, create, release);\n    factory.clone = clone;\n    return factory;\n  }();\n\n  function ShapeCollection() {\n    this._length = 0;\n    this._maxLength = 4;\n    this.shapes = createSizedArray(this._maxLength);\n  }\n\n  ShapeCollection.prototype.addShape = function (shapeData) {\n    if (this._length === this._maxLength) {\n      this.shapes = this.shapes.concat(createSizedArray(this._maxLength));\n      this._maxLength *= 2;\n    }\n\n    this.shapes[this._length] = shapeData;\n    this._length += 1;\n  };\n\n  ShapeCollection.prototype.releaseShapes = function () {\n    var i;\n\n    for (i = 0; i < this._length; i += 1) {\n      shapePool.release(this.shapes[i]);\n    }\n\n    this._length = 0;\n  };\n\n  var shapeCollectionPool = function () {\n    var ob = {\n      newShapeCollection: newShapeCollection,\n      release: release\n    };\n    var _length = 0;\n    var _maxLength = 4;\n    var pool = createSizedArray(_maxLength);\n\n    function newShapeCollection() {\n      var shapeCollection;\n\n      if (_length) {\n        _length -= 1;\n        shapeCollection = pool[_length];\n      } else {\n        shapeCollection = new ShapeCollection();\n      }\n\n      return shapeCollection;\n    }\n\n    function release(shapeCollection) {\n      var i;\n      var len = shapeCollection._length;\n\n      for (i = 0; i < len; i += 1) {\n        shapePool.release(shapeCollection.shapes[i]);\n      }\n\n      shapeCollection._length = 0;\n\n      if (_length === _maxLength) {\n        pool = pooling[\"double\"](pool);\n        _maxLength *= 2;\n      }\n\n      pool[_length] = shapeCollection;\n      _length += 1;\n    }\n\n    return ob;\n  }();\n\n  var ShapePropertyFactory = function () {\n    var initFrame = -999999;\n\n    function interpolateShape(frameNum, previousValue, caching) {\n      var iterationIndex = caching.lastIndex;\n      var keyPropS;\n      var keyPropE;\n      var isHold;\n      var j;\n      var k;\n      var jLen;\n      var kLen;\n      var perc;\n      var vertexValue;\n      var kf = this.keyframes;\n\n      if (frameNum < kf[0].t - this.offsetTime) {\n        keyPropS = kf[0].s[0];\n        isHold = true;\n        iterationIndex = 0;\n      } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {\n        keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];\n        /* if(kf[kf.length - 1].s){\r\n                  keyPropS = kf[kf.length - 1].s[0];\r\n              }else{\r\n                  keyPropS = kf[kf.length - 2].e[0];\r\n              } */\n\n        isHold = true;\n      } else {\n        var i = iterationIndex;\n        var len = kf.length - 1;\n        var flag = true;\n        var keyData;\n        var nextKeyData;\n        var keyframeMetadata;\n\n        while (flag) {\n          keyData = kf[i];\n          nextKeyData = kf[i + 1];\n\n          if (nextKeyData.t - this.offsetTime > frameNum) {\n            break;\n          }\n\n          if (i < len - 1) {\n            i += 1;\n          } else {\n            flag = false;\n          }\n        }\n\n        keyframeMetadata = this.keyframesMetadata[i] || {};\n        isHold = keyData.h === 1;\n        iterationIndex = i;\n\n        if (!isHold) {\n          if (frameNum >= nextKeyData.t - this.offsetTime) {\n            perc = 1;\n          } else if (frameNum < keyData.t - this.offsetTime) {\n            perc = 0;\n          } else {\n            var fnc;\n\n            if (keyframeMetadata.__fnct) {\n              fnc = keyframeMetadata.__fnct;\n            } else {\n              fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get;\n              keyframeMetadata.__fnct = fnc;\n            }\n\n            perc = fnc((frameNum - (keyData.t - this.offsetTime)) / (nextKeyData.t - this.offsetTime - (keyData.t - this.offsetTime)));\n          }\n\n          keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];\n        }\n\n        keyPropS = keyData.s[0];\n      }\n\n      jLen = previousValue._length;\n      kLen = keyPropS.i[0].length;\n      caching.lastIndex = iterationIndex;\n\n      for (j = 0; j < jLen; j += 1) {\n        for (k = 0; k < kLen; k += 1) {\n          vertexValue = isHold ? keyPropS.i[j][k] : keyPropS.i[j][k] + (keyPropE.i[j][k] - keyPropS.i[j][k]) * perc;\n          previousValue.i[j][k] = vertexValue;\n          vertexValue = isHold ? keyPropS.o[j][k] : keyPropS.o[j][k] + (keyPropE.o[j][k] - keyPropS.o[j][k]) * perc;\n          previousValue.o[j][k] = vertexValue;\n          vertexValue = isHold ? keyPropS.v[j][k] : keyPropS.v[j][k] + (keyPropE.v[j][k] - keyPropS.v[j][k]) * perc;\n          previousValue.v[j][k] = vertexValue;\n        }\n      }\n    }\n\n    function interpolateShapeCurrentTime() {\n      var frameNum = this.comp.renderedFrame - this.offsetTime;\n      var initTime = this.keyframes[0].t - this.offsetTime;\n      var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;\n      var lastFrame = this._caching.lastFrame;\n\n      if (!(lastFrame !== initFrame && (lastFrame < initTime && frameNum < initTime || lastFrame > endTime && frameNum > endTime))) {\n        /// /\n        this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;\n        this.interpolateShape(frameNum, this.pv, this._caching); /// /\n      }\n\n      this._caching.lastFrame = frameNum;\n      return this.pv;\n    }\n\n    function resetShape() {\n      this.paths = this.localShapeCollection;\n    }\n\n    function shapesEqual(shape1, shape2) {\n      if (shape1._length !== shape2._length || shape1.c !== shape2.c) {\n        return false;\n      }\n\n      var i;\n      var len = shape1._length;\n\n      for (i = 0; i < len; i += 1) {\n        if (shape1.v[i][0] !== shape2.v[i][0] || shape1.v[i][1] !== shape2.v[i][1] || shape1.o[i][0] !== shape2.o[i][0] || shape1.o[i][1] !== shape2.o[i][1] || shape1.i[i][0] !== shape2.i[i][0] || shape1.i[i][1] !== shape2.i[i][1]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    function setVValue(newPath) {\n      if (!shapesEqual(this.v, newPath)) {\n        this.v = shapePool.clone(newPath);\n        this.localShapeCollection.releaseShapes();\n        this.localShapeCollection.addShape(this.v);\n        this._mdf = true;\n        this.paths = this.localShapeCollection;\n      }\n    }\n\n    function processEffectsSequence() {\n      if (this.elem.globalData.frameId === this.frameId) {\n        return;\n      }\n\n      if (!this.effectsSequence.length) {\n        this._mdf = false;\n        return;\n      }\n\n      if (this.lock) {\n        this.setVValue(this.pv);\n        return;\n      }\n\n      this.lock = true;\n      this._mdf = false;\n      var finalValue;\n\n      if (this.kf) {\n        finalValue = this.pv;\n      } else if (this.data.ks) {\n        finalValue = this.data.ks.k;\n      } else {\n        finalValue = this.data.pt.k;\n      }\n\n      var i;\n      var len = this.effectsSequence.length;\n\n      for (i = 0; i < len; i += 1) {\n        finalValue = this.effectsSequence[i](finalValue);\n      }\n\n      this.setVValue(finalValue);\n      this.lock = false;\n      this.frameId = this.elem.globalData.frameId;\n    }\n\n    function ShapeProperty(elem, data, type) {\n      this.propType = 'shape';\n      this.comp = elem.comp;\n      this.container = elem;\n      this.elem = elem;\n      this.data = data;\n      this.k = false;\n      this.kf = false;\n      this._mdf = false;\n      var pathData = type === 3 ? data.pt.k : data.ks.k;\n      this.v = shapePool.clone(pathData);\n      this.pv = shapePool.clone(this.v);\n      this.localShapeCollection = shapeCollectionPool.newShapeCollection();\n      this.paths = this.localShapeCollection;\n      this.paths.addShape(this.v);\n      this.reset = resetShape;\n      this.effectsSequence = [];\n    }\n\n    function addEffect(effectFunction) {\n      this.effectsSequence.push(effectFunction);\n      this.container.addDynamicProperty(this);\n    }\n\n    ShapeProperty.prototype.interpolateShape = interpolateShape;\n    ShapeProperty.prototype.getValue = processEffectsSequence;\n    ShapeProperty.prototype.setVValue = setVValue;\n    ShapeProperty.prototype.addEffect = addEffect;\n\n    function KeyframedShapeProperty(elem, data, type) {\n      this.propType = 'shape';\n      this.comp = elem.comp;\n      this.elem = elem;\n      this.container = elem;\n      this.offsetTime = elem.data.st;\n      this.keyframes = type === 3 ? data.pt.k : data.ks.k;\n      this.keyframesMetadata = [];\n      this.k = true;\n      this.kf = true;\n      var len = this.keyframes[0].s[0].i.length;\n      this.v = shapePool.newElement();\n      this.v.setPathData(this.keyframes[0].s[0].c, len);\n      this.pv = shapePool.clone(this.v);\n      this.localShapeCollection = shapeCollectionPool.newShapeCollection();\n      this.paths = this.localShapeCollection;\n      this.paths.addShape(this.v);\n      this.lastFrame = initFrame;\n      this.reset = resetShape;\n      this._caching = {\n        lastFrame: initFrame,\n        lastIndex: 0\n      };\n      this.effectsSequence = [interpolateShapeCurrentTime.bind(this)];\n    }\n\n    KeyframedShapeProperty.prototype.getValue = processEffectsSequence;\n    KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;\n    KeyframedShapeProperty.prototype.setVValue = setVValue;\n    KeyframedShapeProperty.prototype.addEffect = addEffect;\n\n    var EllShapeProperty = function () {\n      var cPoint = roundCorner;\n\n      function EllShapePropertyFactory(elem, data) {\n        this.v = shapePool.newElement();\n        this.v.setPathData(true, 4);\n        this.localShapeCollection = shapeCollectionPool.newShapeCollection();\n        this.paths = this.localShapeCollection;\n        this.localShapeCollection.addShape(this.v);\n        this.d = data.d;\n        this.elem = elem;\n        this.comp = elem.comp;\n        this.frameId = -1;\n        this.initDynamicPropertyContainer(elem);\n        this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);\n        this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);\n\n        if (this.dynamicProperties.length) {\n          this.k = true;\n        } else {\n          this.k = false;\n          this.convertEllToPath();\n        }\n      }\n\n      EllShapePropertyFactory.prototype = {\n        reset: resetShape,\n        getValue: function getValue() {\n          if (this.elem.globalData.frameId === this.frameId) {\n            return;\n          }\n\n          this.frameId = this.elem.globalData.frameId;\n          this.iterateDynamicProperties();\n\n          if (this._mdf) {\n            this.convertEllToPath();\n          }\n        },\n        convertEllToPath: function convertEllToPath() {\n          var p0 = this.p.v[0];\n          var p1 = this.p.v[1];\n          var s0 = this.s.v[0] / 2;\n          var s1 = this.s.v[1] / 2;\n\n          var _cw = this.d !== 3;\n\n          var _v = this.v;\n          _v.v[0][0] = p0;\n          _v.v[0][1] = p1 - s1;\n          _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;\n          _v.v[1][1] = p1;\n          _v.v[2][0] = p0;\n          _v.v[2][1] = p1 + s1;\n          _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;\n          _v.v[3][1] = p1;\n          _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;\n          _v.i[0][1] = p1 - s1;\n          _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;\n          _v.i[1][1] = p1 - s1 * cPoint;\n          _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;\n          _v.i[2][1] = p1 + s1;\n          _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;\n          _v.i[3][1] = p1 + s1 * cPoint;\n          _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;\n          _v.o[0][1] = p1 - s1;\n          _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;\n          _v.o[1][1] = p1 + s1 * cPoint;\n          _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;\n          _v.o[2][1] = p1 + s1;\n          _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;\n          _v.o[3][1] = p1 - s1 * cPoint;\n        }\n      };\n      extendPrototype([DynamicPropertyContainer], EllShapePropertyFactory);\n      return EllShapePropertyFactory;\n    }();\n\n    var StarShapeProperty = function () {\n      function StarShapePropertyFactory(elem, data) {\n        this.v = shapePool.newElement();\n        this.v.setPathData(true, 0);\n        this.elem = elem;\n        this.comp = elem.comp;\n        this.data = data;\n        this.frameId = -1;\n        this.d = data.d;\n        this.initDynamicPropertyContainer(elem);\n\n        if (data.sy === 1) {\n          this.ir = PropertyFactory.getProp(elem, data.ir, 0, 0, this);\n          this.is = PropertyFactory.getProp(elem, data.is, 0, 0.01, this);\n          this.convertToPath = this.convertStarToPath;\n        } else {\n          this.convertToPath = this.convertPolygonToPath;\n        }\n\n        this.pt = PropertyFactory.getProp(elem, data.pt, 0, 0, this);\n        this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);\n        this.r = PropertyFactory.getProp(elem, data.r, 0, degToRads, this);\n        this.or = PropertyFactory.getProp(elem, data.or, 0, 0, this);\n        this.os = PropertyFactory.getProp(elem, data.os, 0, 0.01, this);\n        this.localShapeCollection = shapeCollectionPool.newShapeCollection();\n        this.localShapeCollection.addShape(this.v);\n        this.paths = this.localShapeCollection;\n\n        if (this.dynamicProperties.length) {\n          this.k = true;\n        } else {\n          this.k = false;\n          this.convertToPath();\n        }\n      }\n\n      StarShapePropertyFactory.prototype = {\n        reset: resetShape,\n        getValue: function getValue() {\n          if (this.elem.globalData.frameId === this.frameId) {\n            return;\n          }\n\n          this.frameId = this.elem.globalData.frameId;\n          this.iterateDynamicProperties();\n\n          if (this._mdf) {\n            this.convertToPath();\n          }\n        },\n        convertStarToPath: function convertStarToPath() {\n          var numPts = Math.floor(this.pt.v) * 2;\n          var angle = Math.PI * 2 / numPts;\n          /* this.v.v.length = numPts;\r\n                  this.v.i.length = numPts;\r\n                  this.v.o.length = numPts; */\n\n          var longFlag = true;\n          var longRad = this.or.v;\n          var shortRad = this.ir.v;\n          var longRound = this.os.v;\n          var shortRound = this.is.v;\n          var longPerimSegment = 2 * Math.PI * longRad / (numPts * 2);\n          var shortPerimSegment = 2 * Math.PI * shortRad / (numPts * 2);\n          var i;\n          var rad;\n          var roundness;\n          var perimSegment;\n          var currentAng = -Math.PI / 2;\n          currentAng += this.r.v;\n          var dir = this.data.d === 3 ? -1 : 1;\n          this.v._length = 0;\n\n          for (i = 0; i < numPts; i += 1) {\n            rad = longFlag ? longRad : shortRad;\n            roundness = longFlag ? longRound : shortRound;\n            perimSegment = longFlag ? longPerimSegment : shortPerimSegment;\n            var x = rad * Math.cos(currentAng);\n            var y = rad * Math.sin(currentAng);\n            var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);\n            var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);\n            x += +this.p.v[0];\n            y += +this.p.v[1];\n            this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);\n            /* this.v.v[i] = [x,y];\r\n                      this.v.i[i] = [x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir];\r\n                      this.v.o[i] = [x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir];\r\n                      this.v._length = numPts; */\n\n            longFlag = !longFlag;\n            currentAng += angle * dir;\n          }\n        },\n        convertPolygonToPath: function convertPolygonToPath() {\n          var numPts = Math.floor(this.pt.v);\n          var angle = Math.PI * 2 / numPts;\n          var rad = this.or.v;\n          var roundness = this.os.v;\n          var perimSegment = 2 * Math.PI * rad / (numPts * 4);\n          var i;\n          var currentAng = -Math.PI * 0.5;\n          var dir = this.data.d === 3 ? -1 : 1;\n          currentAng += this.r.v;\n          this.v._length = 0;\n\n          for (i = 0; i < numPts; i += 1) {\n            var x = rad * Math.cos(currentAng);\n            var y = rad * Math.sin(currentAng);\n            var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);\n            var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);\n            x += +this.p.v[0];\n            y += +this.p.v[1];\n            this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);\n            currentAng += angle * dir;\n          }\n\n          this.paths.length = 0;\n          this.paths[0] = this.v;\n        }\n      };\n      extendPrototype([DynamicPropertyContainer], StarShapePropertyFactory);\n      return StarShapePropertyFactory;\n    }();\n\n    var RectShapeProperty = function () {\n      function RectShapePropertyFactory(elem, data) {\n        this.v = shapePool.newElement();\n        this.v.c = true;\n        this.localShapeCollection = shapeCollectionPool.newShapeCollection();\n        this.localShapeCollection.addShape(this.v);\n        this.paths = this.localShapeCollection;\n        this.elem = elem;\n        this.comp = elem.comp;\n        this.frameId = -1;\n        this.d = data.d;\n        this.initDynamicPropertyContainer(elem);\n        this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);\n        this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);\n        this.r = PropertyFactory.getProp(elem, data.r, 0, 0, this);\n\n        if (this.dynamicProperties.length) {\n          this.k = true;\n        } else {\n          this.k = false;\n          this.convertRectToPath();\n        }\n      }\n\n      RectShapePropertyFactory.prototype = {\n        convertRectToPath: function convertRectToPath() {\n          var p0 = this.p.v[0];\n          var p1 = this.p.v[1];\n          var v0 = this.s.v[0] / 2;\n          var v1 = this.s.v[1] / 2;\n          var round = bmMin(v0, v1, this.r.v);\n          var cPoint = round * (1 - roundCorner);\n          this.v._length = 0;\n\n          if (this.d === 2 || this.d === 1) {\n            this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, true);\n            this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, true);\n\n            if (round !== 0) {\n              this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true);\n              this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, true);\n              this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, true);\n              this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, true);\n              this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true);\n              this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, true);\n            } else {\n              this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2);\n              this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3);\n            }\n          } else {\n            this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, true);\n\n            if (round !== 0) {\n              this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true);\n              this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, true);\n              this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, true);\n              this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, true);\n              this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true);\n              this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, true);\n              this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, true);\n            } else {\n              this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true);\n              this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true);\n              this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true);\n            }\n          }\n        },\n        getValue: function getValue() {\n          if (this.elem.globalData.frameId === this.frameId) {\n            return;\n          }\n\n          this.frameId = this.elem.globalData.frameId;\n          this.iterateDynamicProperties();\n\n          if (this._mdf) {\n            this.convertRectToPath();\n          }\n        },\n        reset: resetShape\n      };\n      extendPrototype([DynamicPropertyContainer], RectShapePropertyFactory);\n      return RectShapePropertyFactory;\n    }();\n\n    function getShapeProp(elem, data, type) {\n      var prop;\n\n      if (type === 3 || type === 4) {\n        var dataProp = type === 3 ? data.pt : data.ks;\n        var keys = dataProp.k;\n\n        if (keys.length) {\n          prop = new KeyframedShapeProperty(elem, data, type);\n        } else {\n          prop = new ShapeProperty(elem, data, type);\n        }\n      } else if (type === 5) {\n        prop = new RectShapeProperty(elem, data);\n      } else if (type === 6) {\n        prop = new EllShapeProperty(elem, data);\n      } else if (type === 7) {\n        prop = new StarShapeProperty(elem, data);\n      }\n\n      if (prop.k) {\n        elem.addDynamicProperty(prop);\n      }\n\n      return prop;\n    }\n\n    function getConstructorFunction() {\n      return ShapeProperty;\n    }\n\n    function getKeyframedConstructorFunction() {\n      return KeyframedShapeProperty;\n    }\n\n    var ob = {};\n    ob.getShapeProp = getShapeProp;\n    ob.getConstructorFunction = getConstructorFunction;\n    ob.getKeyframedConstructorFunction = getKeyframedConstructorFunction;\n    return ob;\n  }();\n\n  /*!\r\n   Transformation Matrix v2.0\r\n   (c) Epistemex 2014-2015\r\n   www.epistemex.com\r\n   By Ken Fyrstenberg\r\n   Contributions by leeoniya.\r\n   License: MIT, header required.\r\n   */\n\n  /**\r\n   * 2D transformation matrix object initialized with identity matrix.\r\n   *\r\n   * The matrix can synchronize a canvas context by supplying the context\r\n   * as an argument, or later apply current absolute transform to an\r\n   * existing context.\r\n   *\r\n   * All values are handled as floating point values.\r\n   *\r\n   * @param {CanvasRenderingContext2D} [context] - Optional context to sync with Matrix\r\n   * @prop {number} a - scale x\r\n   * @prop {number} b - shear y\r\n   * @prop {number} c - shear x\r\n   * @prop {number} d - scale y\r\n   * @prop {number} e - translate x\r\n   * @prop {number} f - translate y\r\n   * @prop {CanvasRenderingContext2D|null} [context=null] - set or get current canvas context\r\n   * @constructor\r\n   */\n\n  var Matrix = function () {\n    var _cos = Math.cos;\n    var _sin = Math.sin;\n    var _tan = Math.tan;\n    var _rnd = Math.round;\n\n    function reset() {\n      this.props[0] = 1;\n      this.props[1] = 0;\n      this.props[2] = 0;\n      this.props[3] = 0;\n      this.props[4] = 0;\n      this.props[5] = 1;\n      this.props[6] = 0;\n      this.props[7] = 0;\n      this.props[8] = 0;\n      this.props[9] = 0;\n      this.props[10] = 1;\n      this.props[11] = 0;\n      this.props[12] = 0;\n      this.props[13] = 0;\n      this.props[14] = 0;\n      this.props[15] = 1;\n      return this;\n    }\n\n    function rotate(angle) {\n      if (angle === 0) {\n        return this;\n      }\n\n      var mCos = _cos(angle);\n\n      var mSin = _sin(angle);\n\n      return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    }\n\n    function rotateX(angle) {\n      if (angle === 0) {\n        return this;\n      }\n\n      var mCos = _cos(angle);\n\n      var mSin = _sin(angle);\n\n      return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);\n    }\n\n    function rotateY(angle) {\n      if (angle === 0) {\n        return this;\n      }\n\n      var mCos = _cos(angle);\n\n      var mSin = _sin(angle);\n\n      return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);\n    }\n\n    function rotateZ(angle) {\n      if (angle === 0) {\n        return this;\n      }\n\n      var mCos = _cos(angle);\n\n      var mSin = _sin(angle);\n\n      return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    }\n\n    function shear(sx, sy) {\n      return this._t(1, sy, sx, 1, 0, 0);\n    }\n\n    function skew(ax, ay) {\n      return this.shear(_tan(ax), _tan(ay));\n    }\n\n    function skewFromAxis(ax, angle) {\n      var mCos = _cos(angle);\n\n      var mSin = _sin(angle);\n\n      return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); // return this._t(mCos, mSin, -mSin, mCos, 0, 0)._t(1, 0, _tan(ax), 1, 0, 0)._t(mCos, -mSin, mSin, mCos, 0, 0);\n    }\n\n    function scale(sx, sy, sz) {\n      if (!sz && sz !== 0) {\n        sz = 1;\n      }\n\n      if (sx === 1 && sy === 1 && sz === 1) {\n        return this;\n      }\n\n      return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);\n    }\n\n    function setTransform(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {\n      this.props[0] = a;\n      this.props[1] = b;\n      this.props[2] = c;\n      this.props[3] = d;\n      this.props[4] = e;\n      this.props[5] = f;\n      this.props[6] = g;\n      this.props[7] = h;\n      this.props[8] = i;\n      this.props[9] = j;\n      this.props[10] = k;\n      this.props[11] = l;\n      this.props[12] = m;\n      this.props[13] = n;\n      this.props[14] = o;\n      this.props[15] = p;\n      return this;\n    }\n\n    function translate(tx, ty, tz) {\n      tz = tz || 0;\n\n      if (tx !== 0 || ty !== 0 || tz !== 0) {\n        return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);\n      }\n\n      return this;\n    }\n\n    function transform(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {\n      var _p = this.props;\n\n      if (a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0) {\n        // NOTE: commenting this condition because TurboFan deoptimizes code when present\n        // if(m2 !== 0 || n2 !== 0 || o2 !== 0){\n        _p[12] = _p[12] * a2 + _p[15] * m2;\n        _p[13] = _p[13] * f2 + _p[15] * n2;\n        _p[14] = _p[14] * k2 + _p[15] * o2;\n        _p[15] *= p2; // }\n\n        this._identityCalculated = false;\n        return this;\n      }\n\n      var a1 = _p[0];\n      var b1 = _p[1];\n      var c1 = _p[2];\n      var d1 = _p[3];\n      var e1 = _p[4];\n      var f1 = _p[5];\n      var g1 = _p[6];\n      var h1 = _p[7];\n      var i1 = _p[8];\n      var j1 = _p[9];\n      var k1 = _p[10];\n      var l1 = _p[11];\n      var m1 = _p[12];\n      var n1 = _p[13];\n      var o1 = _p[14];\n      var p1 = _p[15];\n      /* matrix order (canvas compatible):\r\n           * ace\r\n           * bdf\r\n           * 001\r\n           */\n\n      _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;\n      _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2;\n      _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2;\n      _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2;\n      _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2;\n      _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2;\n      _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2;\n      _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2;\n      _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2;\n      _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2;\n      _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2;\n      _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2;\n      _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2;\n      _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2;\n      _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2;\n      _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2;\n      this._identityCalculated = false;\n      return this;\n    }\n\n    function multiply(matrix) {\n      var matrixProps = matrix.props;\n      return this.transform(matrixProps[0], matrixProps[1], matrixProps[2], matrixProps[3], matrixProps[4], matrixProps[5], matrixProps[6], matrixProps[7], matrixProps[8], matrixProps[9], matrixProps[10], matrixProps[11], matrixProps[12], matrixProps[13], matrixProps[14], matrixProps[15]);\n    }\n\n    function isIdentity() {\n      if (!this._identityCalculated) {\n        this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);\n        this._identityCalculated = true;\n      }\n\n      return this._identity;\n    }\n\n    function equals(matr) {\n      var i = 0;\n\n      while (i < 16) {\n        if (matr.props[i] !== this.props[i]) {\n          return false;\n        }\n\n        i += 1;\n      }\n\n      return true;\n    }\n\n    function clone(matr) {\n      var i;\n\n      for (i = 0; i < 16; i += 1) {\n        matr.props[i] = this.props[i];\n      }\n\n      return matr;\n    }\n\n    function cloneFromProps(props) {\n      var i;\n\n      for (i = 0; i < 16; i += 1) {\n        this.props[i] = props[i];\n      }\n    }\n\n    function applyToPoint(x, y, z) {\n      return {\n        x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],\n        y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],\n        z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]\n      };\n      /* return {\r\n           x: x * me.a + y * me.c + me.e,\r\n           y: x * me.b + y * me.d + me.f\r\n           }; */\n    }\n\n    function applyToX(x, y, z) {\n      return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];\n    }\n\n    function applyToY(x, y, z) {\n      return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];\n    }\n\n    function applyToZ(x, y, z) {\n      return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];\n    }\n\n    function getInverseMatrix() {\n      var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];\n      var a = this.props[5] / determinant;\n      var b = -this.props[1] / determinant;\n      var c = -this.props[4] / determinant;\n      var d = this.props[0] / determinant;\n      var e = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant;\n      var f = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant;\n      var inverseMatrix = new Matrix();\n      inverseMatrix.props[0] = a;\n      inverseMatrix.props[1] = b;\n      inverseMatrix.props[4] = c;\n      inverseMatrix.props[5] = d;\n      inverseMatrix.props[12] = e;\n      inverseMatrix.props[13] = f;\n      return inverseMatrix;\n    }\n\n    function inversePoint(pt) {\n      var inverseMatrix = this.getInverseMatrix();\n      return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0);\n    }\n\n    function inversePoints(pts) {\n      var i;\n      var len = pts.length;\n      var retPts = [];\n\n      for (i = 0; i < len; i += 1) {\n        retPts[i] = inversePoint(pts[i]);\n      }\n\n      return retPts;\n    }\n\n    function applyToTriplePoints(pt1, pt2, pt3) {\n      var arr = createTypedArray('float32', 6);\n\n      if (this.isIdentity()) {\n        arr[0] = pt1[0];\n        arr[1] = pt1[1];\n        arr[2] = pt2[0];\n        arr[3] = pt2[1];\n        arr[4] = pt3[0];\n        arr[5] = pt3[1];\n      } else {\n        var p0 = this.props[0];\n        var p1 = this.props[1];\n        var p4 = this.props[4];\n        var p5 = this.props[5];\n        var p12 = this.props[12];\n        var p13 = this.props[13];\n        arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;\n        arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;\n        arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;\n        arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;\n        arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;\n        arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;\n      }\n\n      return arr;\n    }\n\n    function applyToPointArray(x, y, z) {\n      var arr;\n\n      if (this.isIdentity()) {\n        arr = [x, y, z];\n      } else {\n        arr = [x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12], x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13], x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]];\n      }\n\n      return arr;\n    }\n\n    function applyToPointStringified(x, y) {\n      if (this.isIdentity()) {\n        return x + ',' + y;\n      }\n\n      var _p = this.props;\n      return Math.round((x * _p[0] + y * _p[4] + _p[12]) * 100) / 100 + ',' + Math.round((x * _p[1] + y * _p[5] + _p[13]) * 100) / 100;\n    }\n\n    function toCSS() {\n      // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.\n\n      /* if(this.isIdentity()) {\r\n              return '';\r\n          } */\n      var i = 0;\n      var props = this.props;\n      var cssValue = 'matrix3d(';\n      var v = 10000;\n\n      while (i < 16) {\n        cssValue += _rnd(props[i] * v) / v;\n        cssValue += i === 15 ? ')' : ',';\n        i += 1;\n      }\n\n      return cssValue;\n    }\n\n    function roundMatrixProperty(val) {\n      var v = 10000;\n\n      if (val < 0.000001 && val > 0 || val > -0.000001 && val < 0) {\n        return _rnd(val * v) / v;\n      }\n\n      return val;\n    }\n\n    function to2dCSS() {\n      // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.\n\n      /* if(this.isIdentity()) {\r\n              return '';\r\n          } */\n      var props = this.props;\n\n      var _a = roundMatrixProperty(props[0]);\n\n      var _b = roundMatrixProperty(props[1]);\n\n      var _c = roundMatrixProperty(props[4]);\n\n      var _d = roundMatrixProperty(props[5]);\n\n      var _e = roundMatrixProperty(props[12]);\n\n      var _f = roundMatrixProperty(props[13]);\n\n      return 'matrix(' + _a + ',' + _b + ',' + _c + ',' + _d + ',' + _e + ',' + _f + ')';\n    }\n\n    return function () {\n      this.reset = reset;\n      this.rotate = rotate;\n      this.rotateX = rotateX;\n      this.rotateY = rotateY;\n      this.rotateZ = rotateZ;\n      this.skew = skew;\n      this.skewFromAxis = skewFromAxis;\n      this.shear = shear;\n      this.scale = scale;\n      this.setTransform = setTransform;\n      this.translate = translate;\n      this.transform = transform;\n      this.multiply = multiply;\n      this.applyToPoint = applyToPoint;\n      this.applyToX = applyToX;\n      this.applyToY = applyToY;\n      this.applyToZ = applyToZ;\n      this.applyToPointArray = applyToPointArray;\n      this.applyToTriplePoints = applyToTriplePoints;\n      this.applyToPointStringified = applyToPointStringified;\n      this.toCSS = toCSS;\n      this.to2dCSS = to2dCSS;\n      this.clone = clone;\n      this.cloneFromProps = cloneFromProps;\n      this.equals = equals;\n      this.inversePoints = inversePoints;\n      this.inversePoint = inversePoint;\n      this.getInverseMatrix = getInverseMatrix;\n      this._t = this.transform;\n      this.isIdentity = isIdentity;\n      this._identity = true;\n      this._identityCalculated = false;\n      this.props = createTypedArray('float32', 16);\n      this.reset();\n    };\n  }();\n\n  function _typeof$3(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof$3 = function _typeof(obj) { return typeof obj; }; } else { _typeof$3 = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof$3(obj); }\n  var lottie = {};\n  var standalone = '__[STANDALONE]__';\n  var animationData = '__[ANIMATIONDATA]__';\n  var renderer = '';\n\n  function setLocation(href) {\n    setLocationHref(href);\n  }\n\n  function searchAnimations() {\n    if (standalone === true) {\n      animationManager.searchAnimations(animationData, standalone, renderer);\n    } else {\n      animationManager.searchAnimations();\n    }\n  }\n\n  function setSubframeRendering(flag) {\n    setSubframeEnabled(flag);\n  }\n\n  function setPrefix(prefix) {\n    setIdPrefix(prefix);\n  }\n\n  function loadAnimation(params) {\n    if (standalone === true) {\n      params.animationData = JSON.parse(animationData);\n    }\n\n    return animationManager.loadAnimation(params);\n  }\n\n  function setQuality(value) {\n    if (typeof value === 'string') {\n      switch (value) {\n        case 'high':\n          setDefaultCurveSegments(200);\n          break;\n\n        default:\n        case 'medium':\n          setDefaultCurveSegments(50);\n          break;\n\n        case 'low':\n          setDefaultCurveSegments(10);\n          break;\n      }\n    } else if (!isNaN(value) && value > 1) {\n      setDefaultCurveSegments(value);\n    }\n\n    if (getDefaultCurveSegments() >= 50) {\n      roundValues(false);\n    } else {\n      roundValues(true);\n    }\n  }\n\n  function inBrowser() {\n    return typeof navigator !== 'undefined';\n  }\n\n  function installPlugin(type, plugin) {\n    if (type === 'expressions') {\n      setExpressionsPlugin(plugin);\n    }\n  }\n\n  function getFactory(name) {\n    switch (name) {\n      case 'propertyFactory':\n        return PropertyFactory;\n\n      case 'shapePropertyFactory':\n        return ShapePropertyFactory;\n\n      case 'matrix':\n        return Matrix;\n\n      default:\n        return null;\n    }\n  }\n\n  lottie.play = animationManager.play;\n  lottie.pause = animationManager.pause;\n  lottie.setLocationHref = setLocation;\n  lottie.togglePause = animationManager.togglePause;\n  lottie.setSpeed = animationManager.setSpeed;\n  lottie.setDirection = animationManager.setDirection;\n  lottie.stop = animationManager.stop;\n  lottie.searchAnimations = searchAnimations;\n  lottie.registerAnimation = animationManager.registerAnimation;\n  lottie.loadAnimation = loadAnimation;\n  lottie.setSubframeRendering = setSubframeRendering;\n  lottie.resize = animationManager.resize; // lottie.start = start;\n\n  lottie.goToAndStop = animationManager.goToAndStop;\n  lottie.destroy = animationManager.destroy;\n  lottie.setQuality = setQuality;\n  lottie.inBrowser = inBrowser;\n  lottie.installPlugin = installPlugin;\n  lottie.freeze = animationManager.freeze;\n  lottie.unfreeze = animationManager.unfreeze;\n  lottie.setVolume = animationManager.setVolume;\n  lottie.mute = animationManager.mute;\n  lottie.unmute = animationManager.unmute;\n  lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations;\n  lottie.useWebWorker = setWebWorker;\n  lottie.setIDPrefix = setPrefix;\n  lottie.__getFactory = getFactory;\n  lottie.version = '5.12.2';\n\n  function checkReady() {\n    if (document.readyState === 'complete') {\n      clearInterval(readyStateCheckInterval);\n      searchAnimations();\n    }\n  }\n\n  function getQueryVariable(variable) {\n    var vars = queryString.split('&');\n\n    for (var i = 0; i < vars.length; i += 1) {\n      var pair = vars[i].split('=');\n\n      if (decodeURIComponent(pair[0]) == variable) {\n        // eslint-disable-line eqeqeq\n        return decodeURIComponent(pair[1]);\n      }\n    }\n\n    return null;\n  }\n\n  var queryString = '';\n\n  if (standalone) {\n    var scripts = document.getElementsByTagName('script');\n    var index = scripts.length - 1;\n    var myScript = scripts[index] || {\n      src: ''\n    };\n    queryString = myScript.src ? myScript.src.replace(/^[^\\?]+\\??/, '') : ''; // eslint-disable-line no-useless-escape\n\n    renderer = getQueryVariable('renderer');\n  }\n\n  var readyStateCheckInterval = setInterval(checkReady, 100); // this adds bodymovin to the window object for backwards compatibility\n\n  try {\n    if (!(( false ? 0 : _typeof$3(exports)) === 'object' && \"object\" !== 'undefined') && !( true && __webpack_require__.amdO) // eslint-disable-line no-undef\n    ) {}\n  } catch (err) {//\n  }\n\n  var ShapeModifiers = function () {\n    var ob = {};\n    var modifiers = {};\n    ob.registerModifier = registerModifier;\n    ob.getModifier = getModifier;\n\n    function registerModifier(nm, factory) {\n      if (!modifiers[nm]) {\n        modifiers[nm] = factory;\n      }\n    }\n\n    function getModifier(nm, elem, data) {\n      return new modifiers[nm](elem, data);\n    }\n\n    return ob;\n  }();\n\n  function ShapeModifier() {}\n\n  ShapeModifier.prototype.initModifierProperties = function () {};\n\n  ShapeModifier.prototype.addShapeToModifier = function () {};\n\n  ShapeModifier.prototype.addShape = function (data) {\n    if (!this.closed) {\n      // Adding shape to dynamic properties. It covers the case where a shape has no effects applied, to reset it's _mdf state on every tick.\n      data.sh.container.addDynamicProperty(data.sh);\n      var shapeData = {\n        shape: data.sh,\n        data: data,\n        localShapeCollection: shapeCollectionPool.newShapeCollection()\n      };\n      this.shapes.push(shapeData);\n      this.addShapeToModifier(shapeData);\n\n      if (this._isAnimated) {\n        data.setAsAnimated();\n      }\n    }\n  };\n\n  ShapeModifier.prototype.init = function (elem, data) {\n    this.shapes = [];\n    this.elem = elem;\n    this.initDynamicPropertyContainer(elem);\n    this.initModifierProperties(elem, data);\n    this.frameId = initialDefaultFrame;\n    this.closed = false;\n    this.k = false;\n\n    if (this.dynamicProperties.length) {\n      this.k = true;\n    } else {\n      this.getValue(true);\n    }\n  };\n\n  ShapeModifier.prototype.processKeys = function () {\n    if (this.elem.globalData.frameId === this.frameId) {\n      return;\n    }\n\n    this.frameId = this.elem.globalData.frameId;\n    this.iterateDynamicProperties();\n  };\n\n  extendPrototype([DynamicPropertyContainer], ShapeModifier);\n\n  function TrimModifier() {}\n\n  extendPrototype([ShapeModifier], TrimModifier);\n\n  TrimModifier.prototype.initModifierProperties = function (elem, data) {\n    this.s = PropertyFactory.getProp(elem, data.s, 0, 0.01, this);\n    this.e = PropertyFactory.getProp(elem, data.e, 0, 0.01, this);\n    this.o = PropertyFactory.getProp(elem, data.o, 0, 0, this);\n    this.sValue = 0;\n    this.eValue = 0;\n    this.getValue = this.processKeys;\n    this.m = data.m;\n    this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;\n  };\n\n  TrimModifier.prototype.addShapeToModifier = function (shapeData) {\n    shapeData.pathsData = [];\n  };\n\n  TrimModifier.prototype.calculateShapeEdges = function (s, e, shapeLength, addedLength, totalModifierLength) {\n    var segments = [];\n\n    if (e <= 1) {\n      segments.push({\n        s: s,\n        e: e\n      });\n    } else if (s >= 1) {\n      segments.push({\n        s: s - 1,\n        e: e - 1\n      });\n    } else {\n      segments.push({\n        s: s,\n        e: 1\n      });\n      segments.push({\n        s: 0,\n        e: e - 1\n      });\n    }\n\n    var shapeSegments = [];\n    var i;\n    var len = segments.length;\n    var segmentOb;\n\n    for (i = 0; i < len; i += 1) {\n      segmentOb = segments[i];\n\n      if (!(segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength)) {\n        var shapeS;\n        var shapeE;\n\n        if (segmentOb.s * totalModifierLength <= addedLength) {\n          shapeS = 0;\n        } else {\n          shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;\n        }\n\n        if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) {\n          shapeE = 1;\n        } else {\n          shapeE = (segmentOb.e * totalModifierLength - addedLength) / shapeLength;\n        }\n\n        shapeSegments.push([shapeS, shapeE]);\n      }\n    }\n\n    if (!shapeSegments.length) {\n      shapeSegments.push([0, 0]);\n    }\n\n    return shapeSegments;\n  };\n\n  TrimModifier.prototype.releasePathsData = function (pathsData) {\n    var i;\n    var len = pathsData.length;\n\n    for (i = 0; i < len; i += 1) {\n      segmentsLengthPool.release(pathsData[i]);\n    }\n\n    pathsData.length = 0;\n    return pathsData;\n  };\n\n  TrimModifier.prototype.processShapes = function (_isFirstFrame) {\n    var s;\n    var e;\n\n    if (this._mdf || _isFirstFrame) {\n      var o = this.o.v % 360 / 360;\n\n      if (o < 0) {\n        o += 1;\n      }\n\n      if (this.s.v > 1) {\n        s = 1 + o;\n      } else if (this.s.v < 0) {\n        s = 0 + o;\n      } else {\n        s = this.s.v + o;\n      }\n\n      if (this.e.v > 1) {\n        e = 1 + o;\n      } else if (this.e.v < 0) {\n        e = 0 + o;\n      } else {\n        e = this.e.v + o;\n      }\n\n      if (s > e) {\n        var _s = s;\n        s = e;\n        e = _s;\n      }\n\n      s = Math.round(s * 10000) * 0.0001;\n      e = Math.round(e * 10000) * 0.0001;\n      this.sValue = s;\n      this.eValue = e;\n    } else {\n      s = this.sValue;\n      e = this.eValue;\n    }\n\n    var shapePaths;\n    var i;\n    var len = this.shapes.length;\n    var j;\n    var jLen;\n    var pathsData;\n    var pathData;\n    var totalShapeLength;\n    var totalModifierLength = 0;\n\n    if (e === s) {\n      for (i = 0; i < len; i += 1) {\n        this.shapes[i].localShapeCollection.releaseShapes();\n        this.shapes[i].shape._mdf = true;\n        this.shapes[i].shape.paths = this.shapes[i].localShapeCollection;\n\n        if (this._mdf) {\n          this.shapes[i].pathsData.length = 0;\n        }\n      }\n    } else if (!(e === 1 && s === 0 || e === 0 && s === 1)) {\n      var segments = [];\n      var shapeData;\n      var localShapeCollection;\n\n      for (i = 0; i < len; i += 1) {\n        shapeData = this.shapes[i]; // if shape hasn't changed and trim properties haven't changed, cached previous path can be used\n\n        if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {\n          shapeData.shape.paths = shapeData.localShapeCollection;\n        } else {\n          shapePaths = shapeData.shape.paths;\n          jLen = shapePaths._length;\n          totalShapeLength = 0;\n\n          if (!shapeData.shape._mdf && shapeData.pathsData.length) {\n            totalShapeLength = shapeData.totalShapeLength;\n          } else {\n            pathsData = this.releasePathsData(shapeData.pathsData);\n\n            for (j = 0; j < jLen; j += 1) {\n              pathData = bez.getSegmentsLength(shapePaths.shapes[j]);\n              pathsData.push(pathData);\n              totalShapeLength += pathData.totalLength;\n            }\n\n            shapeData.totalShapeLength = totalShapeLength;\n            shapeData.pathsData = pathsData;\n          }\n\n          totalModifierLength += totalShapeLength;\n          shapeData.shape._mdf = true;\n        }\n      }\n\n      var shapeS = s;\n      var shapeE = e;\n      var addedLength = 0;\n      var edges;\n\n      for (i = len - 1; i >= 0; i -= 1) {\n        shapeData = this.shapes[i];\n\n        if (shapeData.shape._mdf) {\n          localShapeCollection = shapeData.localShapeCollection;\n          localShapeCollection.releaseShapes(); // if m === 2 means paths are trimmed individually so edges need to be found for this specific shape relative to whoel group\n\n          if (this.m === 2 && len > 1) {\n            edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength);\n            addedLength += shapeData.totalShapeLength;\n          } else {\n            edges = [[shapeS, shapeE]];\n          }\n\n          jLen = edges.length;\n\n          for (j = 0; j < jLen; j += 1) {\n            shapeS = edges[j][0];\n            shapeE = edges[j][1];\n            segments.length = 0;\n\n            if (shapeE <= 1) {\n              segments.push({\n                s: shapeData.totalShapeLength * shapeS,\n                e: shapeData.totalShapeLength * shapeE\n              });\n            } else if (shapeS >= 1) {\n              segments.push({\n                s: shapeData.totalShapeLength * (shapeS - 1),\n                e: shapeData.totalShapeLength * (shapeE - 1)\n              });\n            } else {\n              segments.push({\n                s: shapeData.totalShapeLength * shapeS,\n                e: shapeData.totalShapeLength\n              });\n              segments.push({\n                s: 0,\n                e: shapeData.totalShapeLength * (shapeE - 1)\n              });\n            }\n\n            var newShapesData = this.addShapes(shapeData, segments[0]);\n\n            if (segments[0].s !== segments[0].e) {\n              if (segments.length > 1) {\n                var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];\n\n                if (lastShapeInCollection.c) {\n                  var lastShape = newShapesData.pop();\n                  this.addPaths(newShapesData, localShapeCollection);\n                  newShapesData = this.addShapes(shapeData, segments[1], lastShape);\n                } else {\n                  this.addPaths(newShapesData, localShapeCollection);\n                  newShapesData = this.addShapes(shapeData, segments[1]);\n                }\n              }\n\n              this.addPaths(newShapesData, localShapeCollection);\n            }\n          }\n\n          shapeData.shape.paths = localShapeCollection;\n        }\n      }\n    } else if (this._mdf) {\n      for (i = 0; i < len; i += 1) {\n        // Releasign Trim Cached paths data when no trim applied in case shapes are modified inbetween.\n        // Don't remove this even if it's losing cached info.\n        this.shapes[i].pathsData.length = 0;\n        this.shapes[i].shape._mdf = true;\n      }\n    }\n  };\n\n  TrimModifier.prototype.addPaths = function (newPaths, localShapeCollection) {\n    var i;\n    var len = newPaths.length;\n\n    for (i = 0; i < len; i += 1) {\n      localShapeCollection.addShape(newPaths[i]);\n    }\n  };\n\n  TrimModifier.prototype.addSegment = function (pt1, pt2, pt3, pt4, shapePath, pos, newShape) {\n    shapePath.setXYAt(pt2[0], pt2[1], 'o', pos);\n    shapePath.setXYAt(pt3[0], pt3[1], 'i', pos + 1);\n\n    if (newShape) {\n      shapePath.setXYAt(pt1[0], pt1[1], 'v', pos);\n    }\n\n    shapePath.setXYAt(pt4[0], pt4[1], 'v', pos + 1);\n  };\n\n  TrimModifier.prototype.addSegmentFromArray = function (points, shapePath, pos, newShape) {\n    shapePath.setXYAt(points[1], points[5], 'o', pos);\n    shapePath.setXYAt(points[2], points[6], 'i', pos + 1);\n\n    if (newShape) {\n      shapePath.setXYAt(points[0], points[4], 'v', pos);\n    }\n\n    shapePath.setXYAt(points[3], points[7], 'v', pos + 1);\n  };\n\n  TrimModifier.prototype.addShapes = function (shapeData, shapeSegment, shapePath) {\n    var pathsData = shapeData.pathsData;\n    var shapePaths = shapeData.shape.paths.shapes;\n    var i;\n    var len = shapeData.shape.paths._length;\n    var j;\n    var jLen;\n    var addedLength = 0;\n    var currentLengthData;\n    var segmentCount;\n    var lengths;\n    var segment;\n    var shapes = [];\n    var initPos;\n    var newShape = true;\n\n    if (!shapePath) {\n      shapePath = shapePool.newElement();\n      segmentCount = 0;\n      initPos = 0;\n    } else {\n      segmentCount = shapePath._length;\n      initPos = shapePath._length;\n    }\n\n    shapes.push(shapePath);\n\n    for (i = 0; i < len; i += 1) {\n      lengths = pathsData[i].lengths;\n      shapePath.c = shapePaths[i].c;\n      jLen = shapePaths[i].c ? lengths.length : lengths.length + 1;\n\n      for (j = 1; j < jLen; j += 1) {\n        currentLengthData = lengths[j - 1];\n\n        if (addedLength + currentLengthData.addedLength < shapeSegment.s) {\n          addedLength += currentLengthData.addedLength;\n          shapePath.c = false;\n        } else if (addedLength > shapeSegment.e) {\n          shapePath.c = false;\n          break;\n        } else {\n          if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {\n            this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[j], shapePaths[i].v[j], shapePath, segmentCount, newShape);\n            newShape = false;\n          } else {\n            segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[j], shapePaths[i].o[j - 1], shapePaths[i].i[j], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j - 1]);\n            this.addSegmentFromArray(segment, shapePath, segmentCount, newShape); // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);\n\n            newShape = false;\n            shapePath.c = false;\n          }\n\n          addedLength += currentLengthData.addedLength;\n          segmentCount += 1;\n        }\n      }\n\n      if (shapePaths[i].c && lengths.length) {\n        currentLengthData = lengths[j - 1];\n\n        if (addedLength <= shapeSegment.e) {\n          var segmentLength = lengths[j - 1].addedLength;\n\n          if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {\n            this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[0], shapePaths[i].v[0], shapePath, segmentCount, newShape);\n            newShape = false;\n          } else {\n            segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[0], shapePaths[i].o[j - 1], shapePaths[i].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j - 1]);\n            this.addSegmentFromArray(segment, shapePath, segmentCount, newShape); // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);\n\n            newShape = false;\n            shapePath.c = false;\n          }\n        } else {\n          shapePath.c = false;\n        }\n\n        addedLength += currentLengthData.addedLength;\n        segmentCount += 1;\n      }\n\n      if (shapePath._length) {\n        shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], 'i', initPos);\n        shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], 'o', shapePath._length - 1);\n      }\n\n      if (addedLength > shapeSegment.e) {\n        break;\n      }\n\n      if (i < len - 1) {\n        shapePath = shapePool.newElement();\n        newShape = true;\n        shapes.push(shapePath);\n        segmentCount = 0;\n      }\n    }\n\n    return shapes;\n  };\n\n  function PuckerAndBloatModifier() {}\n\n  extendPrototype([ShapeModifier], PuckerAndBloatModifier);\n\n  PuckerAndBloatModifier.prototype.initModifierProperties = function (elem, data) {\n    this.getValue = this.processKeys;\n    this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);\n    this._isAnimated = !!this.amount.effectsSequence.length;\n  };\n\n  PuckerAndBloatModifier.prototype.processPath = function (path, amount) {\n    var percent = amount / 100;\n    var centerPoint = [0, 0];\n    var pathLength = path._length;\n    var i = 0;\n\n    for (i = 0; i < pathLength; i += 1) {\n      centerPoint[0] += path.v[i][0];\n      centerPoint[1] += path.v[i][1];\n    }\n\n    centerPoint[0] /= pathLength;\n    centerPoint[1] /= pathLength;\n    var clonedPath = shapePool.newElement();\n    clonedPath.c = path.c;\n    var vX;\n    var vY;\n    var oX;\n    var oY;\n    var iX;\n    var iY;\n\n    for (i = 0; i < pathLength; i += 1) {\n      vX = path.v[i][0] + (centerPoint[0] - path.v[i][0]) * percent;\n      vY = path.v[i][1] + (centerPoint[1] - path.v[i][1]) * percent;\n      oX = path.o[i][0] + (centerPoint[0] - path.o[i][0]) * -percent;\n      oY = path.o[i][1] + (centerPoint[1] - path.o[i][1]) * -percent;\n      iX = path.i[i][0] + (centerPoint[0] - path.i[i][0]) * -percent;\n      iY = path.i[i][1] + (centerPoint[1] - path.i[i][1]) * -percent;\n      clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i);\n    }\n\n    return clonedPath;\n  };\n\n  PuckerAndBloatModifier.prototype.processShapes = function (_isFirstFrame) {\n    var shapePaths;\n    var i;\n    var len = this.shapes.length;\n    var j;\n    var jLen;\n    var amount = this.amount.v;\n\n    if (amount !== 0) {\n      var shapeData;\n      var localShapeCollection;\n\n      for (i = 0; i < len; i += 1) {\n        shapeData = this.shapes[i];\n        localShapeCollection = shapeData.localShapeCollection;\n\n        if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {\n          localShapeCollection.releaseShapes();\n          shapeData.shape._mdf = true;\n          shapePaths = shapeData.shape.paths.shapes;\n          jLen = shapeData.shape.paths._length;\n\n          for (j = 0; j < jLen; j += 1) {\n            localShapeCollection.addShape(this.processPath(shapePaths[j], amount));\n          }\n        }\n\n        shapeData.shape.paths = shapeData.localShapeCollection;\n      }\n    }\n\n    if (!this.dynamicProperties.length) {\n      this._mdf = false;\n    }\n  };\n\n  var TransformPropertyFactory = function () {\n    var defaultVector = [0, 0];\n\n    function applyToMatrix(mat) {\n      var _mdf = this._mdf;\n      this.iterateDynamicProperties();\n      this._mdf = this._mdf || _mdf;\n\n      if (this.a) {\n        mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);\n      }\n\n      if (this.s) {\n        mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);\n      }\n\n      if (this.sk) {\n        mat.skewFromAxis(-this.sk.v, this.sa.v);\n      }\n\n      if (this.r) {\n        mat.rotate(-this.r.v);\n      } else {\n        mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);\n      }\n\n      if (this.data.p.s) {\n        if (this.data.p.z) {\n          mat.translate(this.px.v, this.py.v, -this.pz.v);\n        } else {\n          mat.translate(this.px.v, this.py.v, 0);\n        }\n      } else {\n        mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);\n      }\n    }\n\n    function processKeys(forceRender) {\n      if (this.elem.globalData.frameId === this.frameId) {\n        return;\n      }\n\n      if (this._isDirty) {\n        this.precalculateMatrix();\n        this._isDirty = false;\n      }\n\n      this.iterateDynamicProperties();\n\n      if (this._mdf || forceRender) {\n        var frameRate;\n        this.v.cloneFromProps(this.pre.props);\n\n        if (this.appliedTransformations < 1) {\n          this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);\n        }\n\n        if (this.appliedTransformations < 2) {\n          this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);\n        }\n\n        if (this.sk && this.appliedTransformations < 3) {\n          this.v.skewFromAxis(-this.sk.v, this.sa.v);\n        }\n\n        if (this.r && this.appliedTransformations < 4) {\n          this.v.rotate(-this.r.v);\n        } else if (!this.r && this.appliedTransformations < 4) {\n          this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);\n        }\n\n        if (this.autoOriented) {\n          var v1;\n          var v2;\n          frameRate = this.elem.globalData.frameRate;\n\n          if (this.p && this.p.keyframes && this.p.getValueAtTime) {\n            if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {\n              v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate, 0);\n              v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);\n            } else if (this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {\n              v1 = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / frameRate, 0);\n              v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / frameRate, 0);\n            } else {\n              v1 = this.p.pv;\n              v2 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);\n            }\n          } else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {\n            v1 = [];\n            v2 = [];\n            var px = this.px;\n            var py = this.py;\n\n            if (px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t) {\n              v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate, 0);\n              v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate, 0);\n              v2[0] = px.getValueAtTime(px.keyframes[0].t / frameRate, 0);\n              v2[1] = py.getValueAtTime(py.keyframes[0].t / frameRate, 0);\n            } else if (px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {\n              v1[0] = px.getValueAtTime(px.keyframes[px.keyframes.length - 1].t / frameRate, 0);\n              v1[1] = py.getValueAtTime(py.keyframes[py.keyframes.length - 1].t / frameRate, 0);\n              v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate, 0);\n              v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate, 0);\n            } else {\n              v1 = [px.pv, py.pv];\n              v2[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - 0.01) / frameRate, px.offsetTime);\n              v2[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - 0.01) / frameRate, py.offsetTime);\n            }\n          } else {\n            v2 = defaultVector;\n            v1 = v2;\n          }\n\n          this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));\n        }\n\n        if (this.data.p && this.data.p.s) {\n          if (this.data.p.z) {\n            this.v.translate(this.px.v, this.py.v, -this.pz.v);\n          } else {\n            this.v.translate(this.px.v, this.py.v, 0);\n          }\n        } else {\n          this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);\n        }\n      }\n\n      this.frameId = this.elem.globalData.frameId;\n    }\n\n    function precalculateMatrix() {\n      this.appliedTransformations = 0;\n      this.pre.reset();\n\n      if (!this.a.effectsSequence.length) {\n        this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);\n        this.appliedTransformations = 1;\n      } else {\n        return;\n      }\n\n      if (!this.s.effectsSequence.length) {\n        this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);\n        this.appliedTransformations = 2;\n      } else {\n        return;\n      }\n\n      if (this.sk) {\n        if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {\n          this.pre.skewFromAxis(-this.sk.v, this.sa.v);\n          this.appliedTransformations = 3;\n        } else {\n          return;\n        }\n      }\n\n      if (this.r) {\n        if (!this.r.effectsSequence.length) {\n          this.pre.rotate(-this.r.v);\n          this.appliedTransformations = 4;\n        }\n      } else if (!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {\n        this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);\n        this.appliedTransformations = 4;\n      }\n    }\n\n    function autoOrient() {//\n      // var prevP = this.getValueAtTime();\n    }\n\n    function addDynamicProperty(prop) {\n      this._addDynamicProperty(prop);\n\n      this.elem.addDynamicProperty(prop);\n      this._isDirty = true;\n    }\n\n    function TransformProperty(elem, data, container) {\n      this.elem = elem;\n      this.frameId = -1;\n      this.propType = 'transform';\n      this.data = data;\n      this.v = new Matrix(); // Precalculated matrix with non animated properties\n\n      this.pre = new Matrix();\n      this.appliedTransformations = 0;\n      this.initDynamicPropertyContainer(container || elem);\n\n      if (data.p && data.p.s) {\n        this.px = PropertyFactory.getProp(elem, data.p.x, 0, 0, this);\n        this.py = PropertyFactory.getProp(elem, data.p.y, 0, 0, this);\n\n        if (data.p.z) {\n          this.pz = PropertyFactory.getProp(elem, data.p.z, 0, 0, this);\n        }\n      } else {\n        this.p = PropertyFactory.getProp(elem, data.p || {\n          k: [0, 0, 0]\n        }, 1, 0, this);\n      }\n\n      if (data.rx) {\n        this.rx = PropertyFactory.getProp(elem, data.rx, 0, degToRads, this);\n        this.ry = PropertyFactory.getProp(elem, data.ry, 0, degToRads, this);\n        this.rz = PropertyFactory.getProp(elem, data.rz, 0, degToRads, this);\n\n        if (data.or.k[0].ti) {\n          var i;\n          var len = data.or.k.length;\n\n          for (i = 0; i < len; i += 1) {\n            data.or.k[i].to = null;\n            data.or.k[i].ti = null;\n          }\n        }\n\n        this.or = PropertyFactory.getProp(elem, data.or, 1, degToRads, this); // sh Indicates it needs to be capped between -180 and 180\n\n        this.or.sh = true;\n      } else {\n        this.r = PropertyFactory.getProp(elem, data.r || {\n          k: 0\n        }, 0, degToRads, this);\n      }\n\n      if (data.sk) {\n        this.sk = PropertyFactory.getProp(elem, data.sk, 0, degToRads, this);\n        this.sa = PropertyFactory.getProp(elem, data.sa, 0, degToRads, this);\n      }\n\n      this.a = PropertyFactory.getProp(elem, data.a || {\n        k: [0, 0, 0]\n      }, 1, 0, this);\n      this.s = PropertyFactory.getProp(elem, data.s || {\n        k: [100, 100, 100]\n      }, 1, 0.01, this); // Opacity is not part of the transform properties, that's why it won't use this.dynamicProperties. That way transforms won't get updated if opacity changes.\n\n      if (data.o) {\n        this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, elem);\n      } else {\n        this.o = {\n          _mdf: false,\n          v: 1\n        };\n      }\n\n      this._isDirty = true;\n\n      if (!this.dynamicProperties.length) {\n        this.getValue(true);\n      }\n    }\n\n    TransformProperty.prototype = {\n      applyToMatrix: applyToMatrix,\n      getValue: processKeys,\n      precalculateMatrix: precalculateMatrix,\n      autoOrient: autoOrient\n    };\n    extendPrototype([DynamicPropertyContainer], TransformProperty);\n    TransformProperty.prototype.addDynamicProperty = addDynamicProperty;\n    TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;\n\n    function getTransformProperty(elem, data, container) {\n      return new TransformProperty(elem, data, container);\n    }\n\n    return {\n      getTransformProperty: getTransformProperty\n    };\n  }();\n\n  function RepeaterModifier() {}\n\n  extendPrototype([ShapeModifier], RepeaterModifier);\n\n  RepeaterModifier.prototype.initModifierProperties = function (elem, data) {\n    this.getValue = this.processKeys;\n    this.c = PropertyFactory.getProp(elem, data.c, 0, null, this);\n    this.o = PropertyFactory.getProp(elem, data.o, 0, null, this);\n    this.tr = TransformPropertyFactory.getTransformProperty(elem, data.tr, this);\n    this.so = PropertyFactory.getProp(elem, data.tr.so, 0, 0.01, this);\n    this.eo = PropertyFactory.getProp(elem, data.tr.eo, 0, 0.01, this);\n    this.data = data;\n\n    if (!this.dynamicProperties.length) {\n      this.getValue(true);\n    }\n\n    this._isAnimated = !!this.dynamicProperties.length;\n    this.pMatrix = new Matrix();\n    this.rMatrix = new Matrix();\n    this.sMatrix = new Matrix();\n    this.tMatrix = new Matrix();\n    this.matrix = new Matrix();\n  };\n\n  RepeaterModifier.prototype.applyTransforms = function (pMatrix, rMatrix, sMatrix, transform, perc, inv) {\n    var dir = inv ? -1 : 1;\n    var scaleX = transform.s.v[0] + (1 - transform.s.v[0]) * (1 - perc);\n    var scaleY = transform.s.v[1] + (1 - transform.s.v[1]) * (1 - perc);\n    pMatrix.translate(transform.p.v[0] * dir * perc, transform.p.v[1] * dir * perc, transform.p.v[2]);\n    rMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);\n    rMatrix.rotate(-transform.r.v * dir * perc);\n    rMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);\n    sMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);\n    sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);\n    sMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);\n  };\n\n  RepeaterModifier.prototype.init = function (elem, arr, pos, elemsData) {\n    this.elem = elem;\n    this.arr = arr;\n    this.pos = pos;\n    this.elemsData = elemsData;\n    this._currentCopies = 0;\n    this._elements = [];\n    this._groups = [];\n    this.frameId = -1;\n    this.initDynamicPropertyContainer(elem);\n    this.initModifierProperties(elem, arr[pos]);\n\n    while (pos > 0) {\n      pos -= 1; // this._elements.unshift(arr.splice(pos,1)[0]);\n\n      this._elements.unshift(arr[pos]);\n    }\n\n    if (this.dynamicProperties.length) {\n      this.k = true;\n    } else {\n      this.getValue(true);\n    }\n  };\n\n  RepeaterModifier.prototype.resetElements = function (elements) {\n    var i;\n    var len = elements.length;\n\n    for (i = 0; i < len; i += 1) {\n      elements[i]._processed = false;\n\n      if (elements[i].ty === 'gr') {\n        this.resetElements(elements[i].it);\n      }\n    }\n  };\n\n  RepeaterModifier.prototype.cloneElements = function (elements) {\n    var newElements = JSON.parse(JSON.stringify(elements));\n    this.resetElements(newElements);\n    return newElements;\n  };\n\n  RepeaterModifier.prototype.changeGroupRender = function (elements, renderFlag) {\n    var i;\n    var len = elements.length;\n\n    for (i = 0; i < len; i += 1) {\n      elements[i]._render = renderFlag;\n\n      if (elements[i].ty === 'gr') {\n        this.changeGroupRender(elements[i].it, renderFlag);\n      }\n    }\n  };\n\n  RepeaterModifier.prototype.processShapes = function (_isFirstFrame) {\n    var items;\n    var itemsTransform;\n    var i;\n    var dir;\n    var cont;\n    var hasReloaded = false;\n\n    if (this._mdf || _isFirstFrame) {\n      var copies = Math.ceil(this.c.v);\n\n      if (this._groups.length < copies) {\n        while (this._groups.length < copies) {\n          var group = {\n            it: this.cloneElements(this._elements),\n            ty: 'gr'\n          };\n          group.it.push({\n            a: {\n              a: 0,\n              ix: 1,\n              k: [0, 0]\n            },\n            nm: 'Transform',\n            o: {\n              a: 0,\n              ix: 7,\n              k: 100\n            },\n            p: {\n              a: 0,\n              ix: 2,\n              k: [0, 0]\n            },\n            r: {\n              a: 1,\n              ix: 6,\n              k: [{\n                s: 0,\n                e: 0,\n                t: 0\n              }, {\n                s: 0,\n                e: 0,\n                t: 1\n              }]\n            },\n            s: {\n              a: 0,\n              ix: 3,\n              k: [100, 100]\n            },\n            sa: {\n              a: 0,\n              ix: 5,\n              k: 0\n            },\n            sk: {\n              a: 0,\n              ix: 4,\n              k: 0\n            },\n            ty: 'tr'\n          });\n          this.arr.splice(0, 0, group);\n\n          this._groups.splice(0, 0, group);\n\n          this._currentCopies += 1;\n        }\n\n        this.elem.reloadShapes();\n        hasReloaded = true;\n      }\n\n      cont = 0;\n      var renderFlag;\n\n      for (i = 0; i <= this._groups.length - 1; i += 1) {\n        renderFlag = cont < copies;\n        this._groups[i]._render = renderFlag;\n        this.changeGroupRender(this._groups[i].it, renderFlag);\n\n        if (!renderFlag) {\n          var elems = this.elemsData[i].it;\n          var transformData = elems[elems.length - 1];\n\n          if (transformData.transform.op.v !== 0) {\n            transformData.transform.op._mdf = true;\n            transformData.transform.op.v = 0;\n          } else {\n            transformData.transform.op._mdf = false;\n          }\n        }\n\n        cont += 1;\n      }\n\n      this._currentCopies = copies; /// /\n\n      var offset = this.o.v;\n      var offsetModulo = offset % 1;\n      var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);\n      var pProps = this.pMatrix.props;\n      var rProps = this.rMatrix.props;\n      var sProps = this.sMatrix.props;\n      this.pMatrix.reset();\n      this.rMatrix.reset();\n      this.sMatrix.reset();\n      this.tMatrix.reset();\n      this.matrix.reset();\n      var iteration = 0;\n\n      if (offset > 0) {\n        while (iteration < roundOffset) {\n          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);\n          iteration += 1;\n        }\n\n        if (offsetModulo) {\n          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);\n          iteration += offsetModulo;\n        }\n      } else if (offset < 0) {\n        while (iteration > roundOffset) {\n          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);\n          iteration -= 1;\n        }\n\n        if (offsetModulo) {\n          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true);\n          iteration -= offsetModulo;\n        }\n      }\n\n      i = this.data.m === 1 ? 0 : this._currentCopies - 1;\n      dir = this.data.m === 1 ? 1 : -1;\n      cont = this._currentCopies;\n      var j;\n      var jLen;\n\n      while (cont) {\n        items = this.elemsData[i].it;\n        itemsTransform = items[items.length - 1].transform.mProps.v.props;\n        jLen = itemsTransform.length;\n        items[items.length - 1].transform.mProps._mdf = true;\n        items[items.length - 1].transform.op._mdf = true;\n        items[items.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1));\n\n        if (iteration !== 0) {\n          if (i !== 0 && dir === 1 || i !== this._currentCopies - 1 && dir === -1) {\n            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);\n          }\n\n          this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]);\n          this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]);\n          this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]);\n\n          for (j = 0; j < jLen; j += 1) {\n            itemsTransform[j] = this.matrix.props[j];\n          }\n\n          this.matrix.reset();\n        } else {\n          this.matrix.reset();\n\n          for (j = 0; j < jLen; j += 1) {\n            itemsTransform[j] = this.matrix.props[j];\n          }\n        }\n\n        iteration += 1;\n        cont -= 1;\n        i += dir;\n      }\n    } else {\n      cont = this._currentCopies;\n      i = 0;\n      dir = 1;\n\n      while (cont) {\n        items = this.elemsData[i].it;\n        itemsTransform = items[items.length - 1].transform.mProps.v.props;\n        items[items.length - 1].transform.mProps._mdf = false;\n        items[items.length - 1].transform.op._mdf = false;\n        cont -= 1;\n        i += dir;\n      }\n    }\n\n    return hasReloaded;\n  };\n\n  RepeaterModifier.prototype.addShape = function () {};\n\n  function RoundCornersModifier() {}\n\n  extendPrototype([ShapeModifier], RoundCornersModifier);\n\n  RoundCornersModifier.prototype.initModifierProperties = function (elem, data) {\n    this.getValue = this.processKeys;\n    this.rd = PropertyFactory.getProp(elem, data.r, 0, null, this);\n    this._isAnimated = !!this.rd.effectsSequence.length;\n  };\n\n  RoundCornersModifier.prototype.processPath = function (path, round) {\n    var clonedPath = shapePool.newElement();\n    clonedPath.c = path.c;\n    var i;\n    var len = path._length;\n    var currentV;\n    var currentI;\n    var currentO;\n    var closerV;\n    var distance;\n    var newPosPerc;\n    var index = 0;\n    var vX;\n    var vY;\n    var oX;\n    var oY;\n    var iX;\n    var iY;\n\n    for (i = 0; i < len; i += 1) {\n      currentV = path.v[i];\n      currentO = path.o[i];\n      currentI = path.i[i];\n\n      if (currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1]) {\n        if ((i === 0 || i === len - 1) && !path.c) {\n          clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index);\n          /* clonedPath.v[index] = currentV;\r\n                  clonedPath.o[index] = currentO;\r\n                  clonedPath.i[index] = currentI; */\n\n          index += 1;\n        } else {\n          if (i === 0) {\n            closerV = path.v[len - 1];\n          } else {\n            closerV = path.v[i - 1];\n          }\n\n          distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));\n          newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;\n          iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;\n          vX = iX;\n          iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;\n          vY = iY;\n          oX = vX - (vX - currentV[0]) * roundCorner;\n          oY = vY - (vY - currentV[1]) * roundCorner;\n          clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);\n          index += 1;\n\n          if (i === len - 1) {\n            closerV = path.v[0];\n          } else {\n            closerV = path.v[i + 1];\n          }\n\n          distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));\n          newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;\n          oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;\n          vX = oX;\n          oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;\n          vY = oY;\n          iX = vX - (vX - currentV[0]) * roundCorner;\n          iY = vY - (vY - currentV[1]) * roundCorner;\n          clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);\n          index += 1;\n        }\n      } else {\n        clonedPath.setTripleAt(path.v[i][0], path.v[i][1], path.o[i][0], path.o[i][1], path.i[i][0], path.i[i][1], index);\n        index += 1;\n      }\n    }\n\n    return clonedPath;\n  };\n\n  RoundCornersModifier.prototype.processShapes = function (_isFirstFrame) {\n    var shapePaths;\n    var i;\n    var len = this.shapes.length;\n    var j;\n    var jLen;\n    var rd = this.rd.v;\n\n    if (rd !== 0) {\n      var shapeData;\n      var localShapeCollection;\n\n      for (i = 0; i < len; i += 1) {\n        shapeData = this.shapes[i];\n        localShapeCollection = shapeData.localShapeCollection;\n\n        if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {\n          localShapeCollection.releaseShapes();\n          shapeData.shape._mdf = true;\n          shapePaths = shapeData.shape.paths.shapes;\n          jLen = shapeData.shape.paths._length;\n\n          for (j = 0; j < jLen; j += 1) {\n            localShapeCollection.addShape(this.processPath(shapePaths[j], rd));\n          }\n        }\n\n        shapeData.shape.paths = shapeData.localShapeCollection;\n      }\n    }\n\n    if (!this.dynamicProperties.length) {\n      this._mdf = false;\n    }\n  };\n\n  function floatEqual(a, b) {\n    return Math.abs(a - b) * 100000 <= Math.min(Math.abs(a), Math.abs(b));\n  }\n\n  function floatZero(f) {\n    return Math.abs(f) <= 0.00001;\n  }\n\n  function lerp(p0, p1, amount) {\n    return p0 * (1 - amount) + p1 * amount;\n  }\n\n  function lerpPoint(p0, p1, amount) {\n    return [lerp(p0[0], p1[0], amount), lerp(p0[1], p1[1], amount)];\n  }\n\n  function quadRoots(a, b, c) {\n    // no root\n    if (a === 0) return [];\n    var s = b * b - 4 * a * c; // Complex roots\n\n    if (s < 0) return [];\n    var singleRoot = -b / (2 * a); // 1 root\n\n    if (s === 0) return [singleRoot];\n    var delta = Math.sqrt(s) / (2 * a); // 2 roots\n\n    return [singleRoot - delta, singleRoot + delta];\n  }\n\n  function polynomialCoefficients(p0, p1, p2, p3) {\n    return [-p0 + 3 * p1 - 3 * p2 + p3, 3 * p0 - 6 * p1 + 3 * p2, -3 * p0 + 3 * p1, p0];\n  }\n\n  function singlePoint(p) {\n    return new PolynomialBezier(p, p, p, p, false);\n  }\n\n  function PolynomialBezier(p0, p1, p2, p3, linearize) {\n    if (linearize && pointEqual(p0, p1)) {\n      p1 = lerpPoint(p0, p3, 1 / 3);\n    }\n\n    if (linearize && pointEqual(p2, p3)) {\n      p2 = lerpPoint(p0, p3, 2 / 3);\n    }\n\n    var coeffx = polynomialCoefficients(p0[0], p1[0], p2[0], p3[0]);\n    var coeffy = polynomialCoefficients(p0[1], p1[1], p2[1], p3[1]);\n    this.a = [coeffx[0], coeffy[0]];\n    this.b = [coeffx[1], coeffy[1]];\n    this.c = [coeffx[2], coeffy[2]];\n    this.d = [coeffx[3], coeffy[3]];\n    this.points = [p0, p1, p2, p3];\n  }\n\n  PolynomialBezier.prototype.point = function (t) {\n    return [((this.a[0] * t + this.b[0]) * t + this.c[0]) * t + this.d[0], ((this.a[1] * t + this.b[1]) * t + this.c[1]) * t + this.d[1]];\n  };\n\n  PolynomialBezier.prototype.derivative = function (t) {\n    return [(3 * t * this.a[0] + 2 * this.b[0]) * t + this.c[0], (3 * t * this.a[1] + 2 * this.b[1]) * t + this.c[1]];\n  };\n\n  PolynomialBezier.prototype.tangentAngle = function (t) {\n    var p = this.derivative(t);\n    return Math.atan2(p[1], p[0]);\n  };\n\n  PolynomialBezier.prototype.normalAngle = function (t) {\n    var p = this.derivative(t);\n    return Math.atan2(p[0], p[1]);\n  };\n\n  PolynomialBezier.prototype.inflectionPoints = function () {\n    var denom = this.a[1] * this.b[0] - this.a[0] * this.b[1];\n    if (floatZero(denom)) return [];\n    var tcusp = -0.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / denom;\n    var square = tcusp * tcusp - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / denom;\n    if (square < 0) return [];\n    var root = Math.sqrt(square);\n\n    if (floatZero(root)) {\n      if (root > 0 && root < 1) return [tcusp];\n      return [];\n    }\n\n    return [tcusp - root, tcusp + root].filter(function (r) {\n      return r > 0 && r < 1;\n    });\n  };\n\n  PolynomialBezier.prototype.split = function (t) {\n    if (t <= 0) return [singlePoint(this.points[0]), this];\n    if (t >= 1) return [this, singlePoint(this.points[this.points.length - 1])];\n    var p10 = lerpPoint(this.points[0], this.points[1], t);\n    var p11 = lerpPoint(this.points[1], this.points[2], t);\n    var p12 = lerpPoint(this.points[2], this.points[3], t);\n    var p20 = lerpPoint(p10, p11, t);\n    var p21 = lerpPoint(p11, p12, t);\n    var p3 = lerpPoint(p20, p21, t);\n    return [new PolynomialBezier(this.points[0], p10, p20, p3, true), new PolynomialBezier(p3, p21, p12, this.points[3], true)];\n  };\n\n  function extrema(bez, comp) {\n    var min = bez.points[0][comp];\n    var max = bez.points[bez.points.length - 1][comp];\n\n    if (min > max) {\n      var e = max;\n      max = min;\n      min = e;\n    } // Derivative roots to find min/max\n\n\n    var f = quadRoots(3 * bez.a[comp], 2 * bez.b[comp], bez.c[comp]);\n\n    for (var i = 0; i < f.length; i += 1) {\n      if (f[i] > 0 && f[i] < 1) {\n        var val = bez.point(f[i])[comp];\n        if (val < min) min = val;else if (val > max) max = val;\n      }\n    }\n\n    return {\n      min: min,\n      max: max\n    };\n  }\n\n  PolynomialBezier.prototype.bounds = function () {\n    return {\n      x: extrema(this, 0),\n      y: extrema(this, 1)\n    };\n  };\n\n  PolynomialBezier.prototype.boundingBox = function () {\n    var bounds = this.bounds();\n    return {\n      left: bounds.x.min,\n      right: bounds.x.max,\n      top: bounds.y.min,\n      bottom: bounds.y.max,\n      width: bounds.x.max - bounds.x.min,\n      height: bounds.y.max - bounds.y.min,\n      cx: (bounds.x.max + bounds.x.min) / 2,\n      cy: (bounds.y.max + bounds.y.min) / 2\n    };\n  };\n\n  function intersectData(bez, t1, t2) {\n    var box = bez.boundingBox();\n    return {\n      cx: box.cx,\n      cy: box.cy,\n      width: box.width,\n      height: box.height,\n      bez: bez,\n      t: (t1 + t2) / 2,\n      t1: t1,\n      t2: t2\n    };\n  }\n\n  function splitData(data) {\n    var split = data.bez.split(0.5);\n    return [intersectData(split[0], data.t1, data.t), intersectData(split[1], data.t, data.t2)];\n  }\n\n  function boxIntersect(b1, b2) {\n    return Math.abs(b1.cx - b2.cx) * 2 < b1.width + b2.width && Math.abs(b1.cy - b2.cy) * 2 < b1.height + b2.height;\n  }\n\n  function intersectsImpl(d1, d2, depth, tolerance, intersections, maxRecursion) {\n    if (!boxIntersect(d1, d2)) return;\n\n    if (depth >= maxRecursion || d1.width <= tolerance && d1.height <= tolerance && d2.width <= tolerance && d2.height <= tolerance) {\n      intersections.push([d1.t, d2.t]);\n      return;\n    }\n\n    var d1s = splitData(d1);\n    var d2s = splitData(d2);\n    intersectsImpl(d1s[0], d2s[0], depth + 1, tolerance, intersections, maxRecursion);\n    intersectsImpl(d1s[0], d2s[1], depth + 1, tolerance, intersections, maxRecursion);\n    intersectsImpl(d1s[1], d2s[0], depth + 1, tolerance, intersections, maxRecursion);\n    intersectsImpl(d1s[1], d2s[1], depth + 1, tolerance, intersections, maxRecursion);\n  }\n\n  PolynomialBezier.prototype.intersections = function (other, tolerance, maxRecursion) {\n    if (tolerance === undefined) tolerance = 2;\n    if (maxRecursion === undefined) maxRecursion = 7;\n    var intersections = [];\n    intersectsImpl(intersectData(this, 0, 1), intersectData(other, 0, 1), 0, tolerance, intersections, maxRecursion);\n    return intersections;\n  };\n\n  PolynomialBezier.shapeSegment = function (shapePath, index) {\n    var nextIndex = (index + 1) % shapePath.length();\n    return new PolynomialBezier(shapePath.v[index], shapePath.o[index], shapePath.i[nextIndex], shapePath.v[nextIndex], true);\n  };\n\n  PolynomialBezier.shapeSegmentInverted = function (shapePath, index) {\n    var nextIndex = (index + 1) % shapePath.length();\n    return new PolynomialBezier(shapePath.v[nextIndex], shapePath.i[nextIndex], shapePath.o[index], shapePath.v[index], true);\n  };\n\n  function crossProduct(a, b) {\n    return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n  }\n\n  function lineIntersection(start1, end1, start2, end2) {\n    var v1 = [start1[0], start1[1], 1];\n    var v2 = [end1[0], end1[1], 1];\n    var v3 = [start2[0], start2[1], 1];\n    var v4 = [end2[0], end2[1], 1];\n    var r = crossProduct(crossProduct(v1, v2), crossProduct(v3, v4));\n    if (floatZero(r[2])) return null;\n    return [r[0] / r[2], r[1] / r[2]];\n  }\n\n  function polarOffset(p, angle, length) {\n    return [p[0] + Math.cos(angle) * length, p[1] - Math.sin(angle) * length];\n  }\n\n  function pointDistance(p1, p2) {\n    return Math.hypot(p1[0] - p2[0], p1[1] - p2[1]);\n  }\n\n  function pointEqual(p1, p2) {\n    return floatEqual(p1[0], p2[0]) && floatEqual(p1[1], p2[1]);\n  }\n\n  function ZigZagModifier() {}\n\n  extendPrototype([ShapeModifier], ZigZagModifier);\n\n  ZigZagModifier.prototype.initModifierProperties = function (elem, data) {\n    this.getValue = this.processKeys;\n    this.amplitude = PropertyFactory.getProp(elem, data.s, 0, null, this);\n    this.frequency = PropertyFactory.getProp(elem, data.r, 0, null, this);\n    this.pointsType = PropertyFactory.getProp(elem, data.pt, 0, null, this);\n    this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0;\n  };\n\n  function setPoint(outputBezier, point, angle, direction, amplitude, outAmplitude, inAmplitude) {\n    var angO = angle - Math.PI / 2;\n    var angI = angle + Math.PI / 2;\n    var px = point[0] + Math.cos(angle) * direction * amplitude;\n    var py = point[1] - Math.sin(angle) * direction * amplitude;\n    outputBezier.setTripleAt(px, py, px + Math.cos(angO) * outAmplitude, py - Math.sin(angO) * outAmplitude, px + Math.cos(angI) * inAmplitude, py - Math.sin(angI) * inAmplitude, outputBezier.length());\n  }\n\n  function getPerpendicularVector(pt1, pt2) {\n    var vector = [pt2[0] - pt1[0], pt2[1] - pt1[1]];\n    var rot = -Math.PI * 0.5;\n    var rotatedVector = [Math.cos(rot) * vector[0] - Math.sin(rot) * vector[1], Math.sin(rot) * vector[0] + Math.cos(rot) * vector[1]];\n    return rotatedVector;\n  }\n\n  function getProjectingAngle(path, cur) {\n    var prevIndex = cur === 0 ? path.length() - 1 : cur - 1;\n    var nextIndex = (cur + 1) % path.length();\n    var prevPoint = path.v[prevIndex];\n    var nextPoint = path.v[nextIndex];\n    var pVector = getPerpendicularVector(prevPoint, nextPoint);\n    return Math.atan2(0, 1) - Math.atan2(pVector[1], pVector[0]);\n  }\n\n  function zigZagCorner(outputBezier, path, cur, amplitude, frequency, pointType, direction) {\n    var angle = getProjectingAngle(path, cur);\n    var point = path.v[cur % path._length];\n    var prevPoint = path.v[cur === 0 ? path._length - 1 : cur - 1];\n    var nextPoint = path.v[(cur + 1) % path._length];\n    var prevDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - prevPoint[0], 2) + Math.pow(point[1] - prevPoint[1], 2)) : 0;\n    var nextDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - nextPoint[0], 2) + Math.pow(point[1] - nextPoint[1], 2)) : 0;\n    setPoint(outputBezier, path.v[cur % path._length], angle, direction, amplitude, nextDist / ((frequency + 1) * 2), prevDist / ((frequency + 1) * 2), pointType);\n  }\n\n  function zigZagSegment(outputBezier, segment, amplitude, frequency, pointType, direction) {\n    for (var i = 0; i < frequency; i += 1) {\n      var t = (i + 1) / (frequency + 1);\n      var dist = pointType === 2 ? Math.sqrt(Math.pow(segment.points[3][0] - segment.points[0][0], 2) + Math.pow(segment.points[3][1] - segment.points[0][1], 2)) : 0;\n      var angle = segment.normalAngle(t);\n      var point = segment.point(t);\n      setPoint(outputBezier, point, angle, direction, amplitude, dist / ((frequency + 1) * 2), dist / ((frequency + 1) * 2), pointType);\n      direction = -direction;\n    }\n\n    return direction;\n  }\n\n  ZigZagModifier.prototype.processPath = function (path, amplitude, frequency, pointType) {\n    var count = path._length;\n    var clonedPath = shapePool.newElement();\n    clonedPath.c = path.c;\n\n    if (!path.c) {\n      count -= 1;\n    }\n\n    if (count === 0) return clonedPath;\n    var direction = -1;\n    var segment = PolynomialBezier.shapeSegment(path, 0);\n    zigZagCorner(clonedPath, path, 0, amplitude, frequency, pointType, direction);\n\n    for (var i = 0; i < count; i += 1) {\n      direction = zigZagSegment(clonedPath, segment, amplitude, frequency, pointType, -direction);\n\n      if (i === count - 1 && !path.c) {\n        segment = null;\n      } else {\n        segment = PolynomialBezier.shapeSegment(path, (i + 1) % count);\n      }\n\n      zigZagCorner(clonedPath, path, i + 1, amplitude, frequency, pointType, direction);\n    }\n\n    return clonedPath;\n  };\n\n  ZigZagModifier.prototype.processShapes = function (_isFirstFrame) {\n    var shapePaths;\n    var i;\n    var len = this.shapes.length;\n    var j;\n    var jLen;\n    var amplitude = this.amplitude.v;\n    var frequency = Math.max(0, Math.round(this.frequency.v));\n    var pointType = this.pointsType.v;\n\n    if (amplitude !== 0) {\n      var shapeData;\n      var localShapeCollection;\n\n      for (i = 0; i < len; i += 1) {\n        shapeData = this.shapes[i];\n        localShapeCollection = shapeData.localShapeCollection;\n\n        if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {\n          localShapeCollection.releaseShapes();\n          shapeData.shape._mdf = true;\n          shapePaths = shapeData.shape.paths.shapes;\n          jLen = shapeData.shape.paths._length;\n\n          for (j = 0; j < jLen; j += 1) {\n            localShapeCollection.addShape(this.processPath(shapePaths[j], amplitude, frequency, pointType));\n          }\n        }\n\n        shapeData.shape.paths = shapeData.localShapeCollection;\n      }\n    }\n\n    if (!this.dynamicProperties.length) {\n      this._mdf = false;\n    }\n  };\n\n  function linearOffset(p1, p2, amount) {\n    var angle = Math.atan2(p2[0] - p1[0], p2[1] - p1[1]);\n    return [polarOffset(p1, angle, amount), polarOffset(p2, angle, amount)];\n  }\n\n  function offsetSegment(segment, amount) {\n    var p0;\n    var p1a;\n    var p1b;\n    var p2b;\n    var p2a;\n    var p3;\n    var e;\n    e = linearOffset(segment.points[0], segment.points[1], amount);\n    p0 = e[0];\n    p1a = e[1];\n    e = linearOffset(segment.points[1], segment.points[2], amount);\n    p1b = e[0];\n    p2b = e[1];\n    e = linearOffset(segment.points[2], segment.points[3], amount);\n    p2a = e[0];\n    p3 = e[1];\n    var p1 = lineIntersection(p0, p1a, p1b, p2b);\n    if (p1 === null) p1 = p1a;\n    var p2 = lineIntersection(p2a, p3, p1b, p2b);\n    if (p2 === null) p2 = p2a;\n    return new PolynomialBezier(p0, p1, p2, p3);\n  }\n\n  function joinLines(outputBezier, seg1, seg2, lineJoin, miterLimit) {\n    var p0 = seg1.points[3];\n    var p1 = seg2.points[0]; // Bevel\n\n    if (lineJoin === 3) return p0; // Connected, they don't need a joint\n\n    if (pointEqual(p0, p1)) return p0; // Round\n\n    if (lineJoin === 2) {\n      var angleOut = -seg1.tangentAngle(1);\n      var angleIn = -seg2.tangentAngle(0) + Math.PI;\n      var center = lineIntersection(p0, polarOffset(p0, angleOut + Math.PI / 2, 100), p1, polarOffset(p1, angleOut + Math.PI / 2, 100));\n      var radius = center ? pointDistance(center, p0) : pointDistance(p0, p1) / 2;\n      var tan = polarOffset(p0, angleOut, 2 * radius * roundCorner);\n      outputBezier.setXYAt(tan[0], tan[1], 'o', outputBezier.length() - 1);\n      tan = polarOffset(p1, angleIn, 2 * radius * roundCorner);\n      outputBezier.setTripleAt(p1[0], p1[1], p1[0], p1[1], tan[0], tan[1], outputBezier.length());\n      return p1;\n    } // Miter\n\n\n    var t0 = pointEqual(p0, seg1.points[2]) ? seg1.points[0] : seg1.points[2];\n    var t1 = pointEqual(p1, seg2.points[1]) ? seg2.points[3] : seg2.points[1];\n    var intersection = lineIntersection(t0, p0, p1, t1);\n\n    if (intersection && pointDistance(intersection, p0) < miterLimit) {\n      outputBezier.setTripleAt(intersection[0], intersection[1], intersection[0], intersection[1], intersection[0], intersection[1], outputBezier.length());\n      return intersection;\n    }\n\n    return p0;\n  }\n\n  function getIntersection(a, b) {\n    var intersect = a.intersections(b);\n    if (intersect.length && floatEqual(intersect[0][0], 1)) intersect.shift();\n    if (intersect.length) return intersect[0];\n    return null;\n  }\n\n  function pruneSegmentIntersection(a, b) {\n    var outa = a.slice();\n    var outb = b.slice();\n    var intersect = getIntersection(a[a.length - 1], b[0]);\n\n    if (intersect) {\n      outa[a.length - 1] = a[a.length - 1].split(intersect[0])[0];\n      outb[0] = b[0].split(intersect[1])[1];\n    }\n\n    if (a.length > 1 && b.length > 1) {\n      intersect = getIntersection(a[0], b[b.length - 1]);\n\n      if (intersect) {\n        return [[a[0].split(intersect[0])[0]], [b[b.length - 1].split(intersect[1])[1]]];\n      }\n    }\n\n    return [outa, outb];\n  }\n\n  function pruneIntersections(segments) {\n    var e;\n\n    for (var i = 1; i < segments.length; i += 1) {\n      e = pruneSegmentIntersection(segments[i - 1], segments[i]);\n      segments[i - 1] = e[0];\n      segments[i] = e[1];\n    }\n\n    if (segments.length > 1) {\n      e = pruneSegmentIntersection(segments[segments.length - 1], segments[0]);\n      segments[segments.length - 1] = e[0];\n      segments[0] = e[1];\n    }\n\n    return segments;\n  }\n\n  function offsetSegmentSplit(segment, amount) {\n    /*\r\n      We split each bezier segment into smaller pieces based\r\n      on inflection points, this ensures the control point\r\n      polygon is convex.\r\n        (A cubic bezier can have none, one, or two inflection points)\r\n    */\n    var flex = segment.inflectionPoints();\n    var left;\n    var right;\n    var split;\n    var mid;\n\n    if (flex.length === 0) {\n      return [offsetSegment(segment, amount)];\n    }\n\n    if (flex.length === 1 || floatEqual(flex[1], 1)) {\n      split = segment.split(flex[0]);\n      left = split[0];\n      right = split[1];\n      return [offsetSegment(left, amount), offsetSegment(right, amount)];\n    }\n\n    split = segment.split(flex[0]);\n    left = split[0];\n    var t = (flex[1] - flex[0]) / (1 - flex[0]);\n    split = split[1].split(t);\n    mid = split[0];\n    right = split[1];\n    return [offsetSegment(left, amount), offsetSegment(mid, amount), offsetSegment(right, amount)];\n  }\n\n  function OffsetPathModifier() {}\n\n  extendPrototype([ShapeModifier], OffsetPathModifier);\n\n  OffsetPathModifier.prototype.initModifierProperties = function (elem, data) {\n    this.getValue = this.processKeys;\n    this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);\n    this.miterLimit = PropertyFactory.getProp(elem, data.ml, 0, null, this);\n    this.lineJoin = data.lj;\n    this._isAnimated = this.amount.effectsSequence.length !== 0;\n  };\n\n  OffsetPathModifier.prototype.processPath = function (inputBezier, amount, lineJoin, miterLimit) {\n    var outputBezier = shapePool.newElement();\n    outputBezier.c = inputBezier.c;\n    var count = inputBezier.length();\n\n    if (!inputBezier.c) {\n      count -= 1;\n    }\n\n    var i;\n    var j;\n    var segment;\n    var multiSegments = [];\n\n    for (i = 0; i < count; i += 1) {\n      segment = PolynomialBezier.shapeSegment(inputBezier, i);\n      multiSegments.push(offsetSegmentSplit(segment, amount));\n    }\n\n    if (!inputBezier.c) {\n      for (i = count - 1; i >= 0; i -= 1) {\n        segment = PolynomialBezier.shapeSegmentInverted(inputBezier, i);\n        multiSegments.push(offsetSegmentSplit(segment, amount));\n      }\n    }\n\n    multiSegments = pruneIntersections(multiSegments); // Add bezier segments to the output and apply line joints\n\n    var lastPoint = null;\n    var lastSeg = null;\n\n    for (i = 0; i < multiSegments.length; i += 1) {\n      var multiSegment = multiSegments[i];\n      if (lastSeg) lastPoint = joinLines(outputBezier, lastSeg, multiSegment[0], lineJoin, miterLimit);\n      lastSeg = multiSegment[multiSegment.length - 1];\n\n      for (j = 0; j < multiSegment.length; j += 1) {\n        segment = multiSegment[j];\n\n        if (lastPoint && pointEqual(segment.points[0], lastPoint)) {\n          outputBezier.setXYAt(segment.points[1][0], segment.points[1][1], 'o', outputBezier.length() - 1);\n        } else {\n          outputBezier.setTripleAt(segment.points[0][0], segment.points[0][1], segment.points[1][0], segment.points[1][1], segment.points[0][0], segment.points[0][1], outputBezier.length());\n        }\n\n        outputBezier.setTripleAt(segment.points[3][0], segment.points[3][1], segment.points[3][0], segment.points[3][1], segment.points[2][0], segment.points[2][1], outputBezier.length());\n        lastPoint = segment.points[3];\n      }\n    }\n\n    if (multiSegments.length) joinLines(outputBezier, lastSeg, multiSegments[0][0], lineJoin, miterLimit);\n    return outputBezier;\n  };\n\n  OffsetPathModifier.prototype.processShapes = function (_isFirstFrame) {\n    var shapePaths;\n    var i;\n    var len = this.shapes.length;\n    var j;\n    var jLen;\n    var amount = this.amount.v;\n    var miterLimit = this.miterLimit.v;\n    var lineJoin = this.lineJoin;\n\n    if (amount !== 0) {\n      var shapeData;\n      var localShapeCollection;\n\n      for (i = 0; i < len; i += 1) {\n        shapeData = this.shapes[i];\n        localShapeCollection = shapeData.localShapeCollection;\n\n        if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {\n          localShapeCollection.releaseShapes();\n          shapeData.shape._mdf = true;\n          shapePaths = shapeData.shape.paths.shapes;\n          jLen = shapeData.shape.paths._length;\n\n          for (j = 0; j < jLen; j += 1) {\n            localShapeCollection.addShape(this.processPath(shapePaths[j], amount, lineJoin, miterLimit));\n          }\n        }\n\n        shapeData.shape.paths = shapeData.localShapeCollection;\n      }\n    }\n\n    if (!this.dynamicProperties.length) {\n      this._mdf = false;\n    }\n  };\n\n  function getFontProperties(fontData) {\n    var styles = fontData.fStyle ? fontData.fStyle.split(' ') : [];\n    var fWeight = 'normal';\n    var fStyle = 'normal';\n    var len = styles.length;\n    var styleName;\n\n    for (var i = 0; i < len; i += 1) {\n      styleName = styles[i].toLowerCase();\n\n      switch (styleName) {\n        case 'italic':\n          fStyle = 'italic';\n          break;\n\n        case 'bold':\n          fWeight = '700';\n          break;\n\n        case 'black':\n          fWeight = '900';\n          break;\n\n        case 'medium':\n          fWeight = '500';\n          break;\n\n        case 'regular':\n        case 'normal':\n          fWeight = '400';\n          break;\n\n        case 'light':\n        case 'thin':\n          fWeight = '200';\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    return {\n      style: fStyle,\n      weight: fontData.fWeight || fWeight\n    };\n  }\n\n  var FontManager = function () {\n    var maxWaitingTime = 5000;\n    var emptyChar = {\n      w: 0,\n      size: 0,\n      shapes: [],\n      data: {\n        shapes: []\n      }\n    };\n    var combinedCharacters = []; // Hindi characters\n\n    combinedCharacters = combinedCharacters.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);\n    var BLACK_FLAG_CODE_POINT = 127988;\n    var CANCEL_TAG_CODE_POINT = 917631;\n    var A_TAG_CODE_POINT = 917601;\n    var Z_TAG_CODE_POINT = 917626;\n    var VARIATION_SELECTOR_16_CODE_POINT = 65039;\n    var ZERO_WIDTH_JOINER_CODE_POINT = 8205;\n    var REGIONAL_CHARACTER_A_CODE_POINT = 127462;\n    var REGIONAL_CHARACTER_Z_CODE_POINT = 127487;\n    var surrogateModifiers = ['d83cdffb', 'd83cdffc', 'd83cdffd', 'd83cdffe', 'd83cdfff'];\n\n    function trimFontOptions(font) {\n      var familyArray = font.split(',');\n      var i;\n      var len = familyArray.length;\n      var enabledFamilies = [];\n\n      for (i = 0; i < len; i += 1) {\n        if (familyArray[i] !== 'sans-serif' && familyArray[i] !== 'monospace') {\n          enabledFamilies.push(familyArray[i]);\n        }\n      }\n\n      return enabledFamilies.join(',');\n    }\n\n    function setUpNode(font, family) {\n      var parentNode = createTag('span'); // Node is invisible to screen readers.\n\n      parentNode.setAttribute('aria-hidden', true);\n      parentNode.style.fontFamily = family;\n      var node = createTag('span'); // Characters that vary significantly among different fonts\n\n      node.innerText = 'giItT1WQy@!-/#'; // Visible - so we can measure it - but not on the screen\n\n      parentNode.style.position = 'absolute';\n      parentNode.style.left = '-10000px';\n      parentNode.style.top = '-10000px'; // Large font size makes even subtle changes obvious\n\n      parentNode.style.fontSize = '300px'; // Reset any font properties\n\n      parentNode.style.fontVariant = 'normal';\n      parentNode.style.fontStyle = 'normal';\n      parentNode.style.fontWeight = 'normal';\n      parentNode.style.letterSpacing = '0';\n      parentNode.appendChild(node);\n      document.body.appendChild(parentNode); // Remember width with no applied web font\n\n      var width = node.offsetWidth;\n      node.style.fontFamily = trimFontOptions(font) + ', ' + family;\n      return {\n        node: node,\n        w: width,\n        parent: parentNode\n      };\n    }\n\n    function checkLoadedFonts() {\n      var i;\n      var len = this.fonts.length;\n      var node;\n      var w;\n      var loadedCount = len;\n\n      for (i = 0; i < len; i += 1) {\n        if (this.fonts[i].loaded) {\n          loadedCount -= 1;\n        } else if (this.fonts[i].fOrigin === 'n' || this.fonts[i].origin === 0) {\n          this.fonts[i].loaded = true;\n        } else {\n          node = this.fonts[i].monoCase.node;\n          w = this.fonts[i].monoCase.w;\n\n          if (node.offsetWidth !== w) {\n            loadedCount -= 1;\n            this.fonts[i].loaded = true;\n          } else {\n            node = this.fonts[i].sansCase.node;\n            w = this.fonts[i].sansCase.w;\n\n            if (node.offsetWidth !== w) {\n              loadedCount -= 1;\n              this.fonts[i].loaded = true;\n            }\n          }\n\n          if (this.fonts[i].loaded) {\n            this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent);\n            this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent);\n          }\n        }\n      }\n\n      if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) {\n        setTimeout(this.checkLoadedFontsBinded, 20);\n      } else {\n        setTimeout(this.setIsLoadedBinded, 10);\n      }\n    }\n\n    function createHelper(fontData, def) {\n      var engine = document.body && def ? 'svg' : 'canvas';\n      var helper;\n      var fontProps = getFontProperties(fontData);\n\n      if (engine === 'svg') {\n        var tHelper = createNS('text');\n        tHelper.style.fontSize = '100px'; // tHelper.style.fontFamily = fontData.fFamily;\n\n        tHelper.setAttribute('font-family', fontData.fFamily);\n        tHelper.setAttribute('font-style', fontProps.style);\n        tHelper.setAttribute('font-weight', fontProps.weight);\n        tHelper.textContent = '1';\n\n        if (fontData.fClass) {\n          tHelper.style.fontFamily = 'inherit';\n          tHelper.setAttribute('class', fontData.fClass);\n        } else {\n          tHelper.style.fontFamily = fontData.fFamily;\n        }\n\n        def.appendChild(tHelper);\n        helper = tHelper;\n      } else {\n        var tCanvasHelper = new OffscreenCanvas(500, 500).getContext('2d');\n        tCanvasHelper.font = fontProps.style + ' ' + fontProps.weight + ' 100px ' + fontData.fFamily;\n        helper = tCanvasHelper;\n      }\n\n      function measure(text) {\n        if (engine === 'svg') {\n          helper.textContent = text;\n          return helper.getComputedTextLength();\n        }\n\n        return helper.measureText(text).width;\n      }\n\n      return {\n        measureText: measure\n      };\n    }\n\n    function addFonts(fontData, defs) {\n      if (!fontData) {\n        this.isLoaded = true;\n        return;\n      }\n\n      if (this.chars) {\n        this.isLoaded = true;\n        this.fonts = fontData.list;\n        return;\n      }\n\n      if (!document.body) {\n        this.isLoaded = true;\n        fontData.list.forEach(function (data) {\n          data.helper = createHelper(data);\n          data.cache = {};\n        });\n        this.fonts = fontData.list;\n        return;\n      }\n\n      var fontArr = fontData.list;\n      var i;\n      var len = fontArr.length;\n      var _pendingFonts = len;\n\n      for (i = 0; i < len; i += 1) {\n        var shouldLoadFont = true;\n        var loadedSelector;\n        var j;\n        fontArr[i].loaded = false;\n        fontArr[i].monoCase = setUpNode(fontArr[i].fFamily, 'monospace');\n        fontArr[i].sansCase = setUpNode(fontArr[i].fFamily, 'sans-serif');\n\n        if (!fontArr[i].fPath) {\n          fontArr[i].loaded = true;\n          _pendingFonts -= 1;\n        } else if (fontArr[i].fOrigin === 'p' || fontArr[i].origin === 3) {\n          loadedSelector = document.querySelectorAll('style[f-forigin=\"p\"][f-family=\"' + fontArr[i].fFamily + '\"], style[f-origin=\"3\"][f-family=\"' + fontArr[i].fFamily + '\"]');\n\n          if (loadedSelector.length > 0) {\n            shouldLoadFont = false;\n          }\n\n          if (shouldLoadFont) {\n            var s = createTag('style');\n            s.setAttribute('f-forigin', fontArr[i].fOrigin);\n            s.setAttribute('f-origin', fontArr[i].origin);\n            s.setAttribute('f-family', fontArr[i].fFamily);\n            s.type = 'text/css';\n            s.innerText = '@font-face {font-family: ' + fontArr[i].fFamily + \"; font-style: normal; src: url('\" + fontArr[i].fPath + \"');}\";\n            defs.appendChild(s);\n          }\n        } else if (fontArr[i].fOrigin === 'g' || fontArr[i].origin === 1) {\n          loadedSelector = document.querySelectorAll('link[f-forigin=\"g\"], link[f-origin=\"1\"]');\n\n          for (j = 0; j < loadedSelector.length; j += 1) {\n            if (loadedSelector[j].href.indexOf(fontArr[i].fPath) !== -1) {\n              // Font is already loaded\n              shouldLoadFont = false;\n            }\n          }\n\n          if (shouldLoadFont) {\n            var l = createTag('link');\n            l.setAttribute('f-forigin', fontArr[i].fOrigin);\n            l.setAttribute('f-origin', fontArr[i].origin);\n            l.type = 'text/css';\n            l.rel = 'stylesheet';\n            l.href = fontArr[i].fPath;\n            document.body.appendChild(l);\n          }\n        } else if (fontArr[i].fOrigin === 't' || fontArr[i].origin === 2) {\n          loadedSelector = document.querySelectorAll('script[f-forigin=\"t\"], script[f-origin=\"2\"]');\n\n          for (j = 0; j < loadedSelector.length; j += 1) {\n            if (fontArr[i].fPath === loadedSelector[j].src) {\n              // Font is already loaded\n              shouldLoadFont = false;\n            }\n          }\n\n          if (shouldLoadFont) {\n            var sc = createTag('link');\n            sc.setAttribute('f-forigin', fontArr[i].fOrigin);\n            sc.setAttribute('f-origin', fontArr[i].origin);\n            sc.setAttribute('rel', 'stylesheet');\n            sc.setAttribute('href', fontArr[i].fPath);\n            defs.appendChild(sc);\n          }\n        }\n\n        fontArr[i].helper = createHelper(fontArr[i], defs);\n        fontArr[i].cache = {};\n        this.fonts.push(fontArr[i]);\n      }\n\n      if (_pendingFonts === 0) {\n        this.isLoaded = true;\n      } else {\n        // On some cases even if the font is loaded, it won't load correctly when measuring text on canvas.\n        // Adding this timeout seems to fix it\n        setTimeout(this.checkLoadedFonts.bind(this), 100);\n      }\n    }\n\n    function addChars(chars) {\n      if (!chars) {\n        return;\n      }\n\n      if (!this.chars) {\n        this.chars = [];\n      }\n\n      var i;\n      var len = chars.length;\n      var j;\n      var jLen = this.chars.length;\n      var found;\n\n      for (i = 0; i < len; i += 1) {\n        j = 0;\n        found = false;\n\n        while (j < jLen) {\n          if (this.chars[j].style === chars[i].style && this.chars[j].fFamily === chars[i].fFamily && this.chars[j].ch === chars[i].ch) {\n            found = true;\n          }\n\n          j += 1;\n        }\n\n        if (!found) {\n          this.chars.push(chars[i]);\n          jLen += 1;\n        }\n      }\n    }\n\n    function getCharData(_char, style, font) {\n      var i = 0;\n      var len = this.chars.length;\n\n      while (i < len) {\n        if (this.chars[i].ch === _char && this.chars[i].style === style && this.chars[i].fFamily === font) {\n          return this.chars[i];\n        }\n\n        i += 1;\n      }\n\n      if ((typeof _char === 'string' && _char.charCodeAt(0) !== 13 || !_char) && console && console.warn // eslint-disable-line no-console\n      && !this._warned) {\n        this._warned = true;\n        console.warn('Missing character from exported characters list: ', _char, style, font); // eslint-disable-line no-console\n      }\n\n      return emptyChar;\n    }\n\n    function measureText(_char2, fontName, size) {\n      var fontData = this.getFontByName(fontName); // Using the char instead of char.charCodeAt(0)\n      // to avoid collisions between equal chars\n\n      var index = _char2;\n\n      if (!fontData.cache[index]) {\n        var tHelper = fontData.helper;\n\n        if (_char2 === ' ') {\n          var doubleSize = tHelper.measureText('|' + _char2 + '|');\n          var singleSize = tHelper.measureText('||');\n          fontData.cache[index] = (doubleSize - singleSize) / 100;\n        } else {\n          fontData.cache[index] = tHelper.measureText(_char2) / 100;\n        }\n      }\n\n      return fontData.cache[index] * size;\n    }\n\n    function getFontByName(name) {\n      var i = 0;\n      var len = this.fonts.length;\n\n      while (i < len) {\n        if (this.fonts[i].fName === name) {\n          return this.fonts[i];\n        }\n\n        i += 1;\n      }\n\n      return this.fonts[0];\n    }\n\n    function getCodePoint(string) {\n      var codePoint = 0;\n      var first = string.charCodeAt(0);\n\n      if (first >= 0xD800 && first <= 0xDBFF) {\n        var second = string.charCodeAt(1);\n\n        if (second >= 0xDC00 && second <= 0xDFFF) {\n          codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n        }\n      }\n\n      return codePoint;\n    } // Skin tone modifiers\n\n\n    function isModifier(firstCharCode, secondCharCode) {\n      var sum = firstCharCode.toString(16) + secondCharCode.toString(16);\n      return surrogateModifiers.indexOf(sum) !== -1;\n    }\n\n    function isZeroWidthJoiner(charCode) {\n      return charCode === ZERO_WIDTH_JOINER_CODE_POINT;\n    } // This codepoint may change the appearance of the preceding character.\n    // If that is a symbol, dingbat or emoji, U+FE0F forces it to be rendered\n    // as a colorful image as compared to a monochrome text variant.\n\n\n    function isVariationSelector(charCode) {\n      return charCode === VARIATION_SELECTOR_16_CODE_POINT;\n    } // The regional indicator symbols are a set of 26 alphabetic Unicode\n    /// characters (A–Z) intended to be used to encode ISO 3166-1 alpha-2\n    // two-letter country codes in a way that allows optional special treatment.\n\n\n    function isRegionalCode(string) {\n      var codePoint = getCodePoint(string);\n\n      if (codePoint >= REGIONAL_CHARACTER_A_CODE_POINT && codePoint <= REGIONAL_CHARACTER_Z_CODE_POINT) {\n        return true;\n      }\n\n      return false;\n    } // Some Emoji implementations represent combinations of\n    // two “regional indicator” letters as a single flag symbol.\n\n\n    function isFlagEmoji(string) {\n      return isRegionalCode(string.substr(0, 2)) && isRegionalCode(string.substr(2, 2));\n    }\n\n    function isCombinedCharacter(_char3) {\n      return combinedCharacters.indexOf(_char3) !== -1;\n    } // Regional flags start with a BLACK_FLAG_CODE_POINT\n    // folowed by 5 chars in the TAG range\n    // and end with a CANCEL_TAG_CODE_POINT\n\n\n    function isRegionalFlag(text, index) {\n      var codePoint = getCodePoint(text.substr(index, 2));\n\n      if (codePoint !== BLACK_FLAG_CODE_POINT) {\n        return false;\n      }\n\n      var count = 0;\n      index += 2;\n\n      while (count < 5) {\n        codePoint = getCodePoint(text.substr(index, 2));\n\n        if (codePoint < A_TAG_CODE_POINT || codePoint > Z_TAG_CODE_POINT) {\n          return false;\n        }\n\n        count += 1;\n        index += 2;\n      }\n\n      return getCodePoint(text.substr(index, 2)) === CANCEL_TAG_CODE_POINT;\n    }\n\n    function setIsLoaded() {\n      this.isLoaded = true;\n    }\n\n    var Font = function Font() {\n      this.fonts = [];\n      this.chars = null;\n      this.typekitLoaded = 0;\n      this.isLoaded = false;\n      this._warned = false;\n      this.initTime = Date.now();\n      this.setIsLoadedBinded = this.setIsLoaded.bind(this);\n      this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);\n    };\n\n    Font.isModifier = isModifier;\n    Font.isZeroWidthJoiner = isZeroWidthJoiner;\n    Font.isFlagEmoji = isFlagEmoji;\n    Font.isRegionalCode = isRegionalCode;\n    Font.isCombinedCharacter = isCombinedCharacter;\n    Font.isRegionalFlag = isRegionalFlag;\n    Font.isVariationSelector = isVariationSelector;\n    Font.BLACK_FLAG_CODE_POINT = BLACK_FLAG_CODE_POINT;\n    var fontPrototype = {\n      addChars: addChars,\n      addFonts: addFonts,\n      getCharData: getCharData,\n      getFontByName: getFontByName,\n      measureText: measureText,\n      checkLoadedFonts: checkLoadedFonts,\n      setIsLoaded: setIsLoaded\n    };\n    Font.prototype = fontPrototype;\n    return Font;\n  }();\n\n  function SlotManager(animationData) {\n    this.animationData = animationData;\n  }\n\n  SlotManager.prototype.getProp = function (data) {\n    if (this.animationData.slots && this.animationData.slots[data.sid]) {\n      return Object.assign(data, this.animationData.slots[data.sid].p);\n    }\n\n    return data;\n  };\n\n  function slotFactory(animationData) {\n    return new SlotManager(animationData);\n  }\n\n  function RenderableElement() {}\n\n  RenderableElement.prototype = {\n    initRenderable: function initRenderable() {\n      // layer's visibility related to inpoint and outpoint. Rename isVisible to isInRange\n      this.isInRange = false; // layer's display state\n\n      this.hidden = false; // If layer's transparency equals 0, it can be hidden\n\n      this.isTransparent = false; // list of animated components\n\n      this.renderableComponents = [];\n    },\n    addRenderableComponent: function addRenderableComponent(component) {\n      if (this.renderableComponents.indexOf(component) === -1) {\n        this.renderableComponents.push(component);\n      }\n    },\n    removeRenderableComponent: function removeRenderableComponent(component) {\n      if (this.renderableComponents.indexOf(component) !== -1) {\n        this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);\n      }\n    },\n    prepareRenderableFrame: function prepareRenderableFrame(num) {\n      this.checkLayerLimits(num);\n    },\n    checkTransparency: function checkTransparency() {\n      if (this.finalTransform.mProp.o.v <= 0) {\n        if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {\n          this.isTransparent = true;\n          this.hide();\n        }\n      } else if (this.isTransparent) {\n        this.isTransparent = false;\n        this.show();\n      }\n    },\n\n    /**\r\n       * @function\r\n       * Initializes frame related properties.\r\n       *\r\n       * @param {number} num\r\n       * current frame number in Layer's time\r\n       *\r\n       */\n    checkLayerLimits: function checkLayerLimits(num) {\n      if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {\n        if (this.isInRange !== true) {\n          this.globalData._mdf = true;\n          this._mdf = true;\n          this.isInRange = true;\n          this.show();\n        }\n      } else if (this.isInRange !== false) {\n        this.globalData._mdf = true;\n        this.isInRange = false;\n        this.hide();\n      }\n    },\n    renderRenderable: function renderRenderable() {\n      var i;\n      var len = this.renderableComponents.length;\n\n      for (i = 0; i < len; i += 1) {\n        this.renderableComponents[i].renderFrame(this._isFirstFrame);\n      }\n      /* this.maskManager.renderFrame(this.finalTransform.mat);\r\n          this.renderableEffectsManager.renderFrame(this._isFirstFrame); */\n\n    },\n    sourceRectAtTime: function sourceRectAtTime() {\n      return {\n        top: 0,\n        left: 0,\n        width: 100,\n        height: 100\n      };\n    },\n    getLayerSize: function getLayerSize() {\n      if (this.data.ty === 5) {\n        return {\n          w: this.data.textData.width,\n          h: this.data.textData.height\n        };\n      }\n\n      return {\n        w: this.data.width,\n        h: this.data.height\n      };\n    }\n  };\n\n  var getBlendMode = function () {\n    var blendModeEnums = {\n      0: 'source-over',\n      1: 'multiply',\n      2: 'screen',\n      3: 'overlay',\n      4: 'darken',\n      5: 'lighten',\n      6: 'color-dodge',\n      7: 'color-burn',\n      8: 'hard-light',\n      9: 'soft-light',\n      10: 'difference',\n      11: 'exclusion',\n      12: 'hue',\n      13: 'saturation',\n      14: 'color',\n      15: 'luminosity'\n    };\n    return function (mode) {\n      return blendModeEnums[mode] || '';\n    };\n  }();\n\n  function SliderEffect(data, elem, container) {\n    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);\n  }\n\n  function AngleEffect(data, elem, container) {\n    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);\n  }\n\n  function ColorEffect(data, elem, container) {\n    this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);\n  }\n\n  function PointEffect(data, elem, container) {\n    this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);\n  }\n\n  function LayerIndexEffect(data, elem, container) {\n    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);\n  }\n\n  function MaskIndexEffect(data, elem, container) {\n    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);\n  }\n\n  function CheckboxEffect(data, elem, container) {\n    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);\n  }\n\n  function NoValueEffect() {\n    this.p = {};\n  }\n\n  function EffectsManager(data, element) {\n    var effects = data.ef || [];\n    this.effectElements = [];\n    var i;\n    var len = effects.length;\n    var effectItem;\n\n    for (i = 0; i < len; i += 1) {\n      effectItem = new GroupEffect(effects[i], element);\n      this.effectElements.push(effectItem);\n    }\n  }\n\n  function GroupEffect(data, element) {\n    this.init(data, element);\n  }\n\n  extendPrototype([DynamicPropertyContainer], GroupEffect);\n  GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;\n\n  GroupEffect.prototype.init = function (data, element) {\n    this.data = data;\n    this.effectElements = [];\n    this.initDynamicPropertyContainer(element);\n    var i;\n    var len = this.data.ef.length;\n    var eff;\n    var effects = this.data.ef;\n\n    for (i = 0; i < len; i += 1) {\n      eff = null;\n\n      switch (effects[i].ty) {\n        case 0:\n          eff = new SliderEffect(effects[i], element, this);\n          break;\n\n        case 1:\n          eff = new AngleEffect(effects[i], element, this);\n          break;\n\n        case 2:\n          eff = new ColorEffect(effects[i], element, this);\n          break;\n\n        case 3:\n          eff = new PointEffect(effects[i], element, this);\n          break;\n\n        case 4:\n        case 7:\n          eff = new CheckboxEffect(effects[i], element, this);\n          break;\n\n        case 10:\n          eff = new LayerIndexEffect(effects[i], element, this);\n          break;\n\n        case 11:\n          eff = new MaskIndexEffect(effects[i], element, this);\n          break;\n\n        case 5:\n          eff = new EffectsManager(effects[i], element, this);\n          break;\n        // case 6:\n\n        default:\n          eff = new NoValueEffect(effects[i], element, this);\n          break;\n      }\n\n      if (eff) {\n        this.effectElements.push(eff);\n      }\n    }\n  };\n\n  function BaseElement() {}\n\n  BaseElement.prototype = {\n    checkMasks: function checkMasks() {\n      if (!this.data.hasMask) {\n        return false;\n      }\n\n      var i = 0;\n      var len = this.data.masksProperties.length;\n\n      while (i < len) {\n        if (this.data.masksProperties[i].mode !== 'n' && this.data.masksProperties[i].cl !== false) {\n          return true;\n        }\n\n        i += 1;\n      }\n\n      return false;\n    },\n    initExpressions: function initExpressions() {\n      var expressionsInterfaces = getExpressionInterfaces();\n\n      if (!expressionsInterfaces) {\n        return;\n      }\n\n      var LayerExpressionInterface = expressionsInterfaces('layer');\n      var EffectsExpressionInterface = expressionsInterfaces('effects');\n      var ShapeExpressionInterface = expressionsInterfaces('shape');\n      var TextExpressionInterface = expressionsInterfaces('text');\n      var CompExpressionInterface = expressionsInterfaces('comp');\n      this.layerInterface = LayerExpressionInterface(this);\n\n      if (this.data.hasMask && this.maskManager) {\n        this.layerInterface.registerMaskInterface(this.maskManager);\n      }\n\n      var effectsInterface = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface);\n      this.layerInterface.registerEffectsInterface(effectsInterface);\n\n      if (this.data.ty === 0 || this.data.xt) {\n        this.compInterface = CompExpressionInterface(this);\n      } else if (this.data.ty === 4) {\n        this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface);\n        this.layerInterface.content = this.layerInterface.shapeInterface;\n      } else if (this.data.ty === 5) {\n        this.layerInterface.textInterface = TextExpressionInterface(this);\n        this.layerInterface.text = this.layerInterface.textInterface;\n      }\n    },\n    setBlendMode: function setBlendMode() {\n      var blendModeValue = getBlendMode(this.data.bm);\n      var elem = this.baseElement || this.layerElement;\n      elem.style['mix-blend-mode'] = blendModeValue;\n    },\n    initBaseData: function initBaseData(data, globalData, comp) {\n      this.globalData = globalData;\n      this.comp = comp;\n      this.data = data;\n      this.layerId = createElementID(); // Stretch factor for old animations missing this property.\n\n      if (!this.data.sr) {\n        this.data.sr = 1;\n      } // effects manager\n\n\n      this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);\n    },\n    getType: function getType() {\n      return this.type;\n    },\n    sourceRectAtTime: function sourceRectAtTime() {}\n  };\n\n  /**\r\n   * @file\r\n   * Handles element's layer frame update.\r\n   * Checks layer in point and out point\r\n   *\r\n   */\n  function FrameElement() {}\n\n  FrameElement.prototype = {\n    /**\r\n       * @function\r\n       * Initializes frame related properties.\r\n       *\r\n       */\n    initFrame: function initFrame() {\n      // set to true when inpoint is rendered\n      this._isFirstFrame = false; // list of animated properties\n\n      this.dynamicProperties = []; // If layer has been modified in current tick this will be true\n\n      this._mdf = false;\n    },\n\n    /**\r\n       * @function\r\n       * Calculates all dynamic values\r\n       *\r\n       * @param {number} num\r\n       * current frame number in Layer's time\r\n       * @param {boolean} isVisible\r\n       * if layers is currently in range\r\n       *\r\n       */\n    prepareProperties: function prepareProperties(num, isVisible) {\n      var i;\n      var len = this.dynamicProperties.length;\n\n      for (i = 0; i < len; i += 1) {\n        if (isVisible || this._isParent && this.dynamicProperties[i].propType === 'transform') {\n          this.dynamicProperties[i].getValue();\n\n          if (this.dynamicProperties[i]._mdf) {\n            this.globalData._mdf = true;\n            this._mdf = true;\n          }\n        }\n      }\n    },\n    addDynamicProperty: function addDynamicProperty(prop) {\n      if (this.dynamicProperties.indexOf(prop) === -1) {\n        this.dynamicProperties.push(prop);\n      }\n    }\n  };\n\n  function FootageElement(data, globalData, comp) {\n    this.initFrame();\n    this.initRenderable();\n    this.assetData = globalData.getAssetData(data.refId);\n    this.footageData = globalData.imageLoader.getAsset(this.assetData);\n    this.initBaseData(data, globalData, comp);\n  }\n\n  FootageElement.prototype.prepareFrame = function () {};\n\n  extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement);\n\n  FootageElement.prototype.getBaseElement = function () {\n    return null;\n  };\n\n  FootageElement.prototype.renderFrame = function () {};\n\n  FootageElement.prototype.destroy = function () {};\n\n  FootageElement.prototype.initExpressions = function () {\n    var expressionsInterfaces = getExpressionInterfaces();\n\n    if (!expressionsInterfaces) {\n      return;\n    }\n\n    var FootageInterface = expressionsInterfaces('footage');\n    this.layerInterface = FootageInterface(this);\n  };\n\n  FootageElement.prototype.getFootageData = function () {\n    return this.footageData;\n  };\n\n  function AudioElement(data, globalData, comp) {\n    this.initFrame();\n    this.initRenderable();\n    this.assetData = globalData.getAssetData(data.refId);\n    this.initBaseData(data, globalData, comp);\n    this._isPlaying = false;\n    this._canPlay = false;\n    var assetPath = this.globalData.getAssetsPath(this.assetData);\n    this.audio = this.globalData.audioController.createAudio(assetPath);\n    this._currentTime = 0;\n    this.globalData.audioController.addAudio(this);\n    this._volumeMultiplier = 1;\n    this._volume = 1;\n    this._previousVolume = null;\n    this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {\n      _placeholder: true\n    };\n    this.lv = PropertyFactory.getProp(this, data.au && data.au.lv ? data.au.lv : {\n      k: [100]\n    }, 1, 0.01, this);\n  }\n\n  AudioElement.prototype.prepareFrame = function (num) {\n    this.prepareRenderableFrame(num, true);\n    this.prepareProperties(num, true);\n\n    if (!this.tm._placeholder) {\n      var timeRemapped = this.tm.v;\n      this._currentTime = timeRemapped;\n    } else {\n      this._currentTime = num / this.data.sr;\n    }\n\n    this._volume = this.lv.v[0];\n    var totalVolume = this._volume * this._volumeMultiplier;\n\n    if (this._previousVolume !== totalVolume) {\n      this._previousVolume = totalVolume;\n      this.audio.volume(totalVolume);\n    }\n  };\n\n  extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement);\n\n  AudioElement.prototype.renderFrame = function () {\n    if (this.isInRange && this._canPlay) {\n      if (!this._isPlaying) {\n        this.audio.play();\n        this.audio.seek(this._currentTime / this.globalData.frameRate);\n        this._isPlaying = true;\n      } else if (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1) {\n        this.audio.seek(this._currentTime / this.globalData.frameRate);\n      }\n    }\n  };\n\n  AudioElement.prototype.show = function () {// this.audio.play()\n  };\n\n  AudioElement.prototype.hide = function () {\n    this.audio.pause();\n    this._isPlaying = false;\n  };\n\n  AudioElement.prototype.pause = function () {\n    this.audio.pause();\n    this._isPlaying = false;\n    this._canPlay = false;\n  };\n\n  AudioElement.prototype.resume = function () {\n    this._canPlay = true;\n  };\n\n  AudioElement.prototype.setRate = function (rateValue) {\n    this.audio.rate(rateValue);\n  };\n\n  AudioElement.prototype.volume = function (volumeValue) {\n    this._volumeMultiplier = volumeValue;\n    this._previousVolume = volumeValue * this._volume;\n    this.audio.volume(this._previousVolume);\n  };\n\n  AudioElement.prototype.getBaseElement = function () {\n    return null;\n  };\n\n  AudioElement.prototype.destroy = function () {};\n\n  AudioElement.prototype.sourceRectAtTime = function () {};\n\n  AudioElement.prototype.initExpressions = function () {};\n\n  function BaseRenderer() {}\n\n  BaseRenderer.prototype.checkLayers = function (num) {\n    var i;\n    var len = this.layers.length;\n    var data;\n    this.completeLayers = true;\n\n    for (i = len - 1; i >= 0; i -= 1) {\n      if (!this.elements[i]) {\n        data = this.layers[i];\n\n        if (data.ip - data.st <= num - this.layers[i].st && data.op - data.st > num - this.layers[i].st) {\n          this.buildItem(i);\n        }\n      }\n\n      this.completeLayers = this.elements[i] ? this.completeLayers : false;\n    }\n\n    this.checkPendingElements();\n  };\n\n  BaseRenderer.prototype.createItem = function (layer) {\n    switch (layer.ty) {\n      case 2:\n        return this.createImage(layer);\n\n      case 0:\n        return this.createComp(layer);\n\n      case 1:\n        return this.createSolid(layer);\n\n      case 3:\n        return this.createNull(layer);\n\n      case 4:\n        return this.createShape(layer);\n\n      case 5:\n        return this.createText(layer);\n\n      case 6:\n        return this.createAudio(layer);\n\n      case 13:\n        return this.createCamera(layer);\n\n      case 15:\n        return this.createFootage(layer);\n\n      default:\n        return this.createNull(layer);\n    }\n  };\n\n  BaseRenderer.prototype.createCamera = function () {\n    throw new Error('You\\'re using a 3d camera. Try the html renderer.');\n  };\n\n  BaseRenderer.prototype.createAudio = function (data) {\n    return new AudioElement(data, this.globalData, this);\n  };\n\n  BaseRenderer.prototype.createFootage = function (data) {\n    return new FootageElement(data, this.globalData, this);\n  };\n\n  BaseRenderer.prototype.buildAllItems = function () {\n    var i;\n    var len = this.layers.length;\n\n    for (i = 0; i < len; i += 1) {\n      this.buildItem(i);\n    }\n\n    this.checkPendingElements();\n  };\n\n  BaseRenderer.prototype.includeLayers = function (newLayers) {\n    this.completeLayers = false;\n    var i;\n    var len = newLayers.length;\n    var j;\n    var jLen = this.layers.length;\n\n    for (i = 0; i < len; i += 1) {\n      j = 0;\n\n      while (j < jLen) {\n        if (this.layers[j].id === newLayers[i].id) {\n          this.layers[j] = newLayers[i];\n          break;\n        }\n\n        j += 1;\n      }\n    }\n  };\n\n  BaseRenderer.prototype.setProjectInterface = function (pInterface) {\n    this.globalData.projectInterface = pInterface;\n  };\n\n  BaseRenderer.prototype.initItems = function () {\n    if (!this.globalData.progressiveLoad) {\n      this.buildAllItems();\n    }\n  };\n\n  BaseRenderer.prototype.buildElementParenting = function (element, parentName, hierarchy) {\n    var elements = this.elements;\n    var layers = this.layers;\n    var i = 0;\n    var len = layers.length;\n\n    while (i < len) {\n      if (layers[i].ind == parentName) {\n        // eslint-disable-line eqeqeq\n        if (!elements[i] || elements[i] === true) {\n          this.buildItem(i);\n          this.addPendingElement(element);\n        } else {\n          hierarchy.push(elements[i]);\n          elements[i].setAsParent();\n\n          if (layers[i].parent !== undefined) {\n            this.buildElementParenting(element, layers[i].parent, hierarchy);\n          } else {\n            element.setHierarchy(hierarchy);\n          }\n        }\n      }\n\n      i += 1;\n    }\n  };\n\n  BaseRenderer.prototype.addPendingElement = function (element) {\n    this.pendingElements.push(element);\n  };\n\n  BaseRenderer.prototype.searchExtraCompositions = function (assets) {\n    var i;\n    var len = assets.length;\n\n    for (i = 0; i < len; i += 1) {\n      if (assets[i].xt) {\n        var comp = this.createComp(assets[i]);\n        comp.initExpressions();\n        this.globalData.projectInterface.registerComposition(comp);\n      }\n    }\n  };\n\n  BaseRenderer.prototype.getElementById = function (ind) {\n    var i;\n    var len = this.elements.length;\n\n    for (i = 0; i < len; i += 1) {\n      if (this.elements[i].data.ind === ind) {\n        return this.elements[i];\n      }\n    }\n\n    return null;\n  };\n\n  BaseRenderer.prototype.getElementByPath = function (path) {\n    var pathValue = path.shift();\n    var element;\n\n    if (typeof pathValue === 'number') {\n      element = this.elements[pathValue];\n    } else {\n      var i;\n      var len = this.elements.length;\n\n      for (i = 0; i < len; i += 1) {\n        if (this.elements[i].data.nm === pathValue) {\n          element = this.elements[i];\n          break;\n        }\n      }\n    }\n\n    if (path.length === 0) {\n      return element;\n    }\n\n    return element.getElementByPath(path);\n  };\n\n  BaseRenderer.prototype.setupGlobalData = function (animData, fontsContainer) {\n    this.globalData.fontManager = new FontManager();\n    this.globalData.slotManager = slotFactory(animData);\n    this.globalData.fontManager.addChars(animData.chars);\n    this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);\n    this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);\n    this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);\n    this.globalData.imageLoader = this.animationItem.imagePreloader;\n    this.globalData.audioController = this.animationItem.audioController;\n    this.globalData.frameId = 0;\n    this.globalData.frameRate = animData.fr;\n    this.globalData.nm = animData.nm;\n    this.globalData.compSize = {\n      w: animData.w,\n      h: animData.h\n    };\n  };\n\n  var effectTypes = {\n    TRANSFORM_EFFECT: 'transformEFfect'\n  };\n\n  function TransformElement() {}\n\n  TransformElement.prototype = {\n    initTransform: function initTransform() {\n      var mat = new Matrix();\n      this.finalTransform = {\n        mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {\n          o: 0\n        },\n        _matMdf: false,\n        _localMatMdf: false,\n        _opMdf: false,\n        mat: mat,\n        localMat: mat,\n        localOpacity: 1\n      };\n\n      if (this.data.ao) {\n        this.finalTransform.mProp.autoOriented = true;\n      } // TODO: check TYPE 11: Guided elements\n\n\n      if (this.data.ty !== 11) {// this.createElements();\n      }\n    },\n    renderTransform: function renderTransform() {\n      this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;\n      this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;\n\n      if (this.hierarchy) {\n        var mat;\n        var finalMat = this.finalTransform.mat;\n        var i = 0;\n        var len = this.hierarchy.length; // Checking if any of the transformation matrices in the hierarchy chain has changed.\n\n        if (!this.finalTransform._matMdf) {\n          while (i < len) {\n            if (this.hierarchy[i].finalTransform.mProp._mdf) {\n              this.finalTransform._matMdf = true;\n              break;\n            }\n\n            i += 1;\n          }\n        }\n\n        if (this.finalTransform._matMdf) {\n          mat = this.finalTransform.mProp.v.props;\n          finalMat.cloneFromProps(mat);\n\n          for (i = 0; i < len; i += 1) {\n            finalMat.multiply(this.hierarchy[i].finalTransform.mProp.v);\n          }\n        }\n      }\n\n      if (this.finalTransform._matMdf) {\n        this.finalTransform._localMatMdf = this.finalTransform._matMdf;\n      }\n\n      if (this.finalTransform._opMdf) {\n        this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;\n      }\n    },\n    renderLocalTransform: function renderLocalTransform() {\n      if (this.localTransforms) {\n        var i = 0;\n        var len = this.localTransforms.length;\n        this.finalTransform._localMatMdf = this.finalTransform._matMdf;\n\n        if (!this.finalTransform._localMatMdf || !this.finalTransform._opMdf) {\n          while (i < len) {\n            if (this.localTransforms[i]._mdf) {\n              this.finalTransform._localMatMdf = true;\n            }\n\n            if (this.localTransforms[i]._opMdf && !this.finalTransform._opMdf) {\n              this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;\n              this.finalTransform._opMdf = true;\n            }\n\n            i += 1;\n          }\n        }\n\n        if (this.finalTransform._localMatMdf) {\n          var localMat = this.finalTransform.localMat;\n          this.localTransforms[0].matrix.clone(localMat);\n\n          for (i = 1; i < len; i += 1) {\n            var lmat = this.localTransforms[i].matrix;\n            localMat.multiply(lmat);\n          }\n\n          localMat.multiply(this.finalTransform.mat);\n        }\n\n        if (this.finalTransform._opMdf) {\n          var localOp = this.finalTransform.localOpacity;\n\n          for (i = 0; i < len; i += 1) {\n            localOp *= this.localTransforms[i].opacity * 0.01;\n          }\n\n          this.finalTransform.localOpacity = localOp;\n        }\n      }\n    },\n    searchEffectTransforms: function searchEffectTransforms() {\n      if (this.renderableEffectsManager) {\n        var transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);\n\n        if (transformEffects.length) {\n          this.localTransforms = [];\n          this.finalTransform.localMat = new Matrix();\n          var i = 0;\n          var len = transformEffects.length;\n\n          for (i = 0; i < len; i += 1) {\n            this.localTransforms.push(transformEffects[i]);\n          }\n        }\n      }\n    },\n    globalToLocal: function globalToLocal(pt) {\n      var transforms = [];\n      transforms.push(this.finalTransform);\n      var flag = true;\n      var comp = this.comp;\n\n      while (flag) {\n        if (comp.finalTransform) {\n          if (comp.data.hasMask) {\n            transforms.splice(0, 0, comp.finalTransform);\n          }\n\n          comp = comp.comp;\n        } else {\n          flag = false;\n        }\n      }\n\n      var i;\n      var len = transforms.length;\n      var ptNew;\n\n      for (i = 0; i < len; i += 1) {\n        ptNew = transforms[i].mat.applyToPointArray(0, 0, 0); // ptNew = transforms[i].mat.applyToPointArray(pt[0],pt[1],pt[2]);\n\n        pt = [pt[0] - ptNew[0], pt[1] - ptNew[1], 0];\n      }\n\n      return pt;\n    },\n    mHelper: new Matrix()\n  };\n\n  function MaskElement(data, element, globalData) {\n    this.data = data;\n    this.element = element;\n    this.globalData = globalData;\n    this.storedData = [];\n    this.masksProperties = this.data.masksProperties || [];\n    this.maskElement = null;\n    var defs = this.globalData.defs;\n    var i;\n    var len = this.masksProperties ? this.masksProperties.length : 0;\n    this.viewData = createSizedArray(len);\n    this.solidPath = '';\n    var path;\n    var properties = this.masksProperties;\n    var count = 0;\n    var currentMasks = [];\n    var j;\n    var jLen;\n    var layerId = createElementID();\n    var rect;\n    var expansor;\n    var feMorph;\n    var x;\n    var maskType = 'clipPath';\n    var maskRef = 'clip-path';\n\n    for (i = 0; i < len; i += 1) {\n      if (properties[i].mode !== 'a' && properties[i].mode !== 'n' || properties[i].inv || properties[i].o.k !== 100 || properties[i].o.x) {\n        maskType = 'mask';\n        maskRef = 'mask';\n      }\n\n      if ((properties[i].mode === 's' || properties[i].mode === 'i') && count === 0) {\n        rect = createNS('rect');\n        rect.setAttribute('fill', '#ffffff');\n        rect.setAttribute('width', this.element.comp.data.w || 0);\n        rect.setAttribute('height', this.element.comp.data.h || 0);\n        currentMasks.push(rect);\n      } else {\n        rect = null;\n      }\n\n      path = createNS('path');\n\n      if (properties[i].mode === 'n') {\n        // TODO move this to a factory or to a constructor\n        this.viewData[i] = {\n          op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),\n          prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),\n          elem: path,\n          lastPath: ''\n        };\n        defs.appendChild(path);\n      } else {\n        count += 1;\n        path.setAttribute('fill', properties[i].mode === 's' ? '#000000' : '#ffffff');\n        path.setAttribute('clip-rule', 'nonzero');\n        var filterID;\n\n        if (properties[i].x.k !== 0) {\n          maskType = 'mask';\n          maskRef = 'mask';\n          x = PropertyFactory.getProp(this.element, properties[i].x, 0, null, this.element);\n          filterID = createElementID();\n          expansor = createNS('filter');\n          expansor.setAttribute('id', filterID);\n          feMorph = createNS('feMorphology');\n          feMorph.setAttribute('operator', 'erode');\n          feMorph.setAttribute('in', 'SourceGraphic');\n          feMorph.setAttribute('radius', '0');\n          expansor.appendChild(feMorph);\n          defs.appendChild(expansor);\n          path.setAttribute('stroke', properties[i].mode === 's' ? '#000000' : '#ffffff');\n        } else {\n          feMorph = null;\n          x = null;\n        } // TODO move this to a factory or to a constructor\n\n\n        this.storedData[i] = {\n          elem: path,\n          x: x,\n          expan: feMorph,\n          lastPath: '',\n          lastOperator: '',\n          filterId: filterID,\n          lastRadius: 0\n        };\n\n        if (properties[i].mode === 'i') {\n          jLen = currentMasks.length;\n          var g = createNS('g');\n\n          for (j = 0; j < jLen; j += 1) {\n            g.appendChild(currentMasks[j]);\n          }\n\n          var mask = createNS('mask');\n          mask.setAttribute('mask-type', 'alpha');\n          mask.setAttribute('id', layerId + '_' + count);\n          mask.appendChild(path);\n          defs.appendChild(mask);\n          g.setAttribute('mask', 'url(' + getLocationHref() + '#' + layerId + '_' + count + ')');\n          currentMasks.length = 0;\n          currentMasks.push(g);\n        } else {\n          currentMasks.push(path);\n        }\n\n        if (properties[i].inv && !this.solidPath) {\n          this.solidPath = this.createLayerSolidPath();\n        } // TODO move this to a factory or to a constructor\n\n\n        this.viewData[i] = {\n          elem: path,\n          lastPath: '',\n          op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),\n          prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),\n          invRect: rect\n        };\n\n        if (!this.viewData[i].prop.k) {\n          this.drawPath(properties[i], this.viewData[i].prop.v, this.viewData[i]);\n        }\n      }\n    }\n\n    this.maskElement = createNS(maskType);\n    len = currentMasks.length;\n\n    for (i = 0; i < len; i += 1) {\n      this.maskElement.appendChild(currentMasks[i]);\n    }\n\n    if (count > 0) {\n      this.maskElement.setAttribute('id', layerId);\n      this.element.maskedElement.setAttribute(maskRef, 'url(' + getLocationHref() + '#' + layerId + ')');\n      defs.appendChild(this.maskElement);\n    }\n\n    if (this.viewData.length) {\n      this.element.addRenderableComponent(this);\n    }\n  }\n\n  MaskElement.prototype.getMaskProperty = function (pos) {\n    return this.viewData[pos].prop;\n  };\n\n  MaskElement.prototype.renderFrame = function (isFirstFrame) {\n    var finalMat = this.element.finalTransform.mat;\n    var i;\n    var len = this.masksProperties.length;\n\n    for (i = 0; i < len; i += 1) {\n      if (this.viewData[i].prop._mdf || isFirstFrame) {\n        this.drawPath(this.masksProperties[i], this.viewData[i].prop.v, this.viewData[i]);\n      }\n\n      if (this.viewData[i].op._mdf || isFirstFrame) {\n        this.viewData[i].elem.setAttribute('fill-opacity', this.viewData[i].op.v);\n      }\n\n      if (this.masksProperties[i].mode !== 'n') {\n        if (this.viewData[i].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) {\n          this.viewData[i].invRect.setAttribute('transform', finalMat.getInverseMatrix().to2dCSS());\n        }\n\n        if (this.storedData[i].x && (this.storedData[i].x._mdf || isFirstFrame)) {\n          var feMorph = this.storedData[i].expan;\n\n          if (this.storedData[i].x.v < 0) {\n            if (this.storedData[i].lastOperator !== 'erode') {\n              this.storedData[i].lastOperator = 'erode';\n              this.storedData[i].elem.setAttribute('filter', 'url(' + getLocationHref() + '#' + this.storedData[i].filterId + ')');\n            }\n\n            feMorph.setAttribute('radius', -this.storedData[i].x.v);\n          } else {\n            if (this.storedData[i].lastOperator !== 'dilate') {\n              this.storedData[i].lastOperator = 'dilate';\n              this.storedData[i].elem.setAttribute('filter', null);\n            }\n\n            this.storedData[i].elem.setAttribute('stroke-width', this.storedData[i].x.v * 2);\n          }\n        }\n      }\n    }\n  };\n\n  MaskElement.prototype.getMaskelement = function () {\n    return this.maskElement;\n  };\n\n  MaskElement.prototype.createLayerSolidPath = function () {\n    var path = 'M0,0 ';\n    path += ' h' + this.globalData.compSize.w;\n    path += ' v' + this.globalData.compSize.h;\n    path += ' h-' + this.globalData.compSize.w;\n    path += ' v-' + this.globalData.compSize.h + ' ';\n    return path;\n  };\n\n  MaskElement.prototype.drawPath = function (pathData, pathNodes, viewData) {\n    var pathString = ' M' + pathNodes.v[0][0] + ',' + pathNodes.v[0][1];\n    var i;\n    var len;\n    len = pathNodes._length;\n\n    for (i = 1; i < len; i += 1) {\n      // pathString += \" C\"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + \" \"+pathNodes.i[i][0]+','+pathNodes.i[i][1] + \" \"+pathNodes.v[i][0]+','+pathNodes.v[i][1];\n      pathString += ' C' + pathNodes.o[i - 1][0] + ',' + pathNodes.o[i - 1][1] + ' ' + pathNodes.i[i][0] + ',' + pathNodes.i[i][1] + ' ' + pathNodes.v[i][0] + ',' + pathNodes.v[i][1];\n    } // pathString += \" C\"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + \" \"+pathNodes.i[0][0]+','+pathNodes.i[0][1] + \" \"+pathNodes.v[0][0]+','+pathNodes.v[0][1];\n\n\n    if (pathNodes.c && len > 1) {\n      pathString += ' C' + pathNodes.o[i - 1][0] + ',' + pathNodes.o[i - 1][1] + ' ' + pathNodes.i[0][0] + ',' + pathNodes.i[0][1] + ' ' + pathNodes.v[0][0] + ',' + pathNodes.v[0][1];\n    } // pathNodes.__renderedString = pathString;\n\n\n    if (viewData.lastPath !== pathString) {\n      var pathShapeValue = '';\n\n      if (viewData.elem) {\n        if (pathNodes.c) {\n          pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;\n        }\n\n        viewData.elem.setAttribute('d', pathShapeValue);\n      }\n\n      viewData.lastPath = pathString;\n    }\n  };\n\n  MaskElement.prototype.destroy = function () {\n    this.element = null;\n    this.globalData = null;\n    this.maskElement = null;\n    this.data = null;\n    this.masksProperties = null;\n  };\n\n  var filtersFactory = function () {\n    var ob = {};\n    ob.createFilter = createFilter;\n    ob.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;\n\n    function createFilter(filId, skipCoordinates) {\n      var fil = createNS('filter');\n      fil.setAttribute('id', filId);\n\n      if (skipCoordinates !== true) {\n        fil.setAttribute('filterUnits', 'objectBoundingBox');\n        fil.setAttribute('x', '0%');\n        fil.setAttribute('y', '0%');\n        fil.setAttribute('width', '100%');\n        fil.setAttribute('height', '100%');\n      }\n\n      return fil;\n    }\n\n    function createAlphaToLuminanceFilter() {\n      var feColorMatrix = createNS('feColorMatrix');\n      feColorMatrix.setAttribute('type', 'matrix');\n      feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');\n      feColorMatrix.setAttribute('values', '0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1');\n      return feColorMatrix;\n    }\n\n    return ob;\n  }();\n\n  var featureSupport = function () {\n    var ob = {\n      maskType: true,\n      svgLumaHidden: true,\n      offscreenCanvas: typeof OffscreenCanvas !== 'undefined'\n    };\n\n    if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\\/\\d./i.test(navigator.userAgent)) {\n      ob.maskType = false;\n    }\n\n    if (/firefox/i.test(navigator.userAgent)) {\n      ob.svgLumaHidden = false;\n    }\n\n    return ob;\n  }();\n\n  var registeredEffects$1 = {};\n  var idPrefix = 'filter_result_';\n\n  function SVGEffects(elem) {\n    var i;\n    var source = 'SourceGraphic';\n    var len = elem.data.ef ? elem.data.ef.length : 0;\n    var filId = createElementID();\n    var fil = filtersFactory.createFilter(filId, true);\n    var count = 0;\n    this.filters = [];\n    var filterManager;\n\n    for (i = 0; i < len; i += 1) {\n      filterManager = null;\n      var type = elem.data.ef[i].ty;\n\n      if (registeredEffects$1[type]) {\n        var Effect = registeredEffects$1[type].effect;\n        filterManager = new Effect(fil, elem.effectsManager.effectElements[i], elem, idPrefix + count, source);\n        source = idPrefix + count;\n\n        if (registeredEffects$1[type].countsAsEffect) {\n          count += 1;\n        }\n      }\n\n      if (filterManager) {\n        this.filters.push(filterManager);\n      }\n    }\n\n    if (count) {\n      elem.globalData.defs.appendChild(fil);\n      elem.layerElement.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')');\n    }\n\n    if (this.filters.length) {\n      elem.addRenderableComponent(this);\n    }\n  }\n\n  SVGEffects.prototype.renderFrame = function (_isFirstFrame) {\n    var i;\n    var len = this.filters.length;\n\n    for (i = 0; i < len; i += 1) {\n      this.filters[i].renderFrame(_isFirstFrame);\n    }\n  };\n\n  SVGEffects.prototype.getEffects = function (type) {\n    var i;\n    var len = this.filters.length;\n    var effects = [];\n\n    for (i = 0; i < len; i += 1) {\n      if (this.filters[i].type === type) {\n        effects.push(this.filters[i]);\n      }\n    }\n\n    return effects;\n  };\n\n  function registerEffect$1(id, effect, countsAsEffect) {\n    registeredEffects$1[id] = {\n      effect: effect,\n      countsAsEffect: countsAsEffect\n    };\n  }\n\n  function SVGBaseElement() {}\n\n  SVGBaseElement.prototype = {\n    initRendererElement: function initRendererElement() {\n      this.layerElement = createNS('g');\n    },\n    createContainerElements: function createContainerElements() {\n      this.matteElement = createNS('g');\n      this.transformedElement = this.layerElement;\n      this.maskedElement = this.layerElement;\n      this._sizeChanged = false;\n      var layerElementParent = null; // If this layer acts as a mask for the following layer\n\n      if (this.data.td) {\n        this.matteMasks = {};\n        var gg = createNS('g');\n        gg.setAttribute('id', this.layerId);\n        gg.appendChild(this.layerElement);\n        layerElementParent = gg;\n        this.globalData.defs.appendChild(gg);\n      } else if (this.data.tt) {\n        this.matteElement.appendChild(this.layerElement);\n        layerElementParent = this.matteElement;\n        this.baseElement = this.matteElement;\n      } else {\n        this.baseElement = this.layerElement;\n      }\n\n      if (this.data.ln) {\n        this.layerElement.setAttribute('id', this.data.ln);\n      }\n\n      if (this.data.cl) {\n        this.layerElement.setAttribute('class', this.data.cl);\n      } // Clipping compositions to hide content that exceeds boundaries. If collapsed transformations is on, component should not be clipped\n\n\n      if (this.data.ty === 0 && !this.data.hd) {\n        var cp = createNS('clipPath');\n        var pt = createNS('path');\n        pt.setAttribute('d', 'M0,0 L' + this.data.w + ',0 L' + this.data.w + ',' + this.data.h + ' L0,' + this.data.h + 'z');\n        var clipId = createElementID();\n        cp.setAttribute('id', clipId);\n        cp.appendChild(pt);\n        this.globalData.defs.appendChild(cp);\n\n        if (this.checkMasks()) {\n          var cpGroup = createNS('g');\n          cpGroup.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + clipId + ')');\n          cpGroup.appendChild(this.layerElement);\n          this.transformedElement = cpGroup;\n\n          if (layerElementParent) {\n            layerElementParent.appendChild(this.transformedElement);\n          } else {\n            this.baseElement = this.transformedElement;\n          }\n        } else {\n          this.layerElement.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + clipId + ')');\n        }\n      }\n\n      if (this.data.bm !== 0) {\n        this.setBlendMode();\n      }\n    },\n    renderElement: function renderElement() {\n      if (this.finalTransform._localMatMdf) {\n        this.transformedElement.setAttribute('transform', this.finalTransform.localMat.to2dCSS());\n      }\n\n      if (this.finalTransform._opMdf) {\n        this.transformedElement.setAttribute('opacity', this.finalTransform.localOpacity);\n      }\n    },\n    destroyBaseElement: function destroyBaseElement() {\n      this.layerElement = null;\n      this.matteElement = null;\n      this.maskManager.destroy();\n    },\n    getBaseElement: function getBaseElement() {\n      if (this.data.hd) {\n        return null;\n      }\n\n      return this.baseElement;\n    },\n    createRenderableComponents: function createRenderableComponents() {\n      this.maskManager = new MaskElement(this.data, this, this.globalData);\n      this.renderableEffectsManager = new SVGEffects(this);\n      this.searchEffectTransforms();\n    },\n    getMatte: function getMatte(matteType) {\n      // This should not be a common case. But for backward compatibility, we'll create the matte object.\n      // It solves animations that have two consecutive layers marked as matte masks.\n      // Which is an undefined behavior in AE.\n      if (!this.matteMasks) {\n        this.matteMasks = {};\n      }\n\n      if (!this.matteMasks[matteType]) {\n        var id = this.layerId + '_' + matteType;\n        var filId;\n        var fil;\n        var useElement;\n        var gg;\n\n        if (matteType === 1 || matteType === 3) {\n          var masker = createNS('mask');\n          masker.setAttribute('id', id);\n          masker.setAttribute('mask-type', matteType === 3 ? 'luminance' : 'alpha');\n          useElement = createNS('use');\n          useElement.setAttributeNS('http://www.w3.org/1999/xlink', 'href', '#' + this.layerId);\n          masker.appendChild(useElement);\n          this.globalData.defs.appendChild(masker);\n\n          if (!featureSupport.maskType && matteType === 1) {\n            masker.setAttribute('mask-type', 'luminance');\n            filId = createElementID();\n            fil = filtersFactory.createFilter(filId);\n            this.globalData.defs.appendChild(fil);\n            fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());\n            gg = createNS('g');\n            gg.appendChild(useElement);\n            masker.appendChild(gg);\n            gg.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')');\n          }\n        } else if (matteType === 2) {\n          var maskGroup = createNS('mask');\n          maskGroup.setAttribute('id', id);\n          maskGroup.setAttribute('mask-type', 'alpha');\n          var maskGrouper = createNS('g');\n          maskGroup.appendChild(maskGrouper);\n          filId = createElementID();\n          fil = filtersFactory.createFilter(filId); /// /\n\n          var feCTr = createNS('feComponentTransfer');\n          feCTr.setAttribute('in', 'SourceGraphic');\n          fil.appendChild(feCTr);\n          var feFunc = createNS('feFuncA');\n          feFunc.setAttribute('type', 'table');\n          feFunc.setAttribute('tableValues', '1.0 0.0');\n          feCTr.appendChild(feFunc); /// /\n\n          this.globalData.defs.appendChild(fil);\n          var alphaRect = createNS('rect');\n          alphaRect.setAttribute('width', this.comp.data.w);\n          alphaRect.setAttribute('height', this.comp.data.h);\n          alphaRect.setAttribute('x', '0');\n          alphaRect.setAttribute('y', '0');\n          alphaRect.setAttribute('fill', '#ffffff');\n          alphaRect.setAttribute('opacity', '0');\n          maskGrouper.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')');\n          maskGrouper.appendChild(alphaRect);\n          useElement = createNS('use');\n          useElement.setAttributeNS('http://www.w3.org/1999/xlink', 'href', '#' + this.layerId);\n          maskGrouper.appendChild(useElement);\n\n          if (!featureSupport.maskType) {\n            maskGroup.setAttribute('mask-type', 'luminance');\n            fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());\n            gg = createNS('g');\n            maskGrouper.appendChild(alphaRect);\n            gg.appendChild(this.layerElement);\n            maskGrouper.appendChild(gg);\n          }\n\n          this.globalData.defs.appendChild(maskGroup);\n        }\n\n        this.matteMasks[matteType] = id;\n      }\n\n      return this.matteMasks[matteType];\n    },\n    setMatte: function setMatte(id) {\n      if (!this.matteElement) {\n        return;\n      }\n\n      this.matteElement.setAttribute('mask', 'url(' + getLocationHref() + '#' + id + ')');\n    }\n  };\n\n  /**\r\n   * @file\r\n   * Handles AE's layer parenting property.\r\n   *\r\n   */\n  function HierarchyElement() {}\n\n  HierarchyElement.prototype = {\n    /**\r\n       * @function\r\n       * Initializes hierarchy properties\r\n       *\r\n       */\n    initHierarchy: function initHierarchy() {\n      // element's parent list\n      this.hierarchy = []; // if element is parent of another layer _isParent will be true\n\n      this._isParent = false;\n      this.checkParenting();\n    },\n\n    /**\r\n       * @function\r\n       * Sets layer's hierarchy.\r\n       * @param {array} hierarch\r\n       * layer's parent list\r\n       *\r\n       */\n    setHierarchy: function setHierarchy(hierarchy) {\n      this.hierarchy = hierarchy;\n    },\n\n    /**\r\n       * @function\r\n       * Sets layer as parent.\r\n       *\r\n       */\n    setAsParent: function setAsParent() {\n      this._isParent = true;\n    },\n\n    /**\r\n       * @function\r\n       * Searches layer's parenting chain\r\n       *\r\n       */\n    checkParenting: function checkParenting() {\n      if (this.data.parent !== undefined) {\n        this.comp.buildElementParenting(this, this.data.parent, []);\n      }\n    }\n  };\n\n  function RenderableDOMElement() {}\n\n  (function () {\n    var _prototype = {\n      initElement: function initElement(data, globalData, comp) {\n        this.initFrame();\n        this.initBaseData(data, globalData, comp);\n        this.initTransform(data, globalData, comp);\n        this.initHierarchy();\n        this.initRenderable();\n        this.initRendererElement();\n        this.createContainerElements();\n        this.createRenderableComponents();\n        this.createContent();\n        this.hide();\n      },\n      hide: function hide() {\n        // console.log('HIDE', this);\n        if (!this.hidden && (!this.isInRange || this.isTransparent)) {\n          var elem = this.baseElement || this.layerElement;\n          elem.style.display = 'none';\n          this.hidden = true;\n        }\n      },\n      show: function show() {\n        // console.log('SHOW', this);\n        if (this.isInRange && !this.isTransparent) {\n          if (!this.data.hd) {\n            var elem = this.baseElement || this.layerElement;\n            elem.style.display = 'block';\n          }\n\n          this.hidden = false;\n          this._isFirstFrame = true;\n        }\n      },\n      renderFrame: function renderFrame() {\n        // If it is exported as hidden (data.hd === true) no need to render\n        // If it is not visible no need to render\n        if (this.data.hd || this.hidden) {\n          return;\n        }\n\n        this.renderTransform();\n        this.renderRenderable();\n        this.renderLocalTransform();\n        this.renderElement();\n        this.renderInnerContent();\n\n        if (this._isFirstFrame) {\n          this._isFirstFrame = false;\n        }\n      },\n      renderInnerContent: function renderInnerContent() {},\n      prepareFrame: function prepareFrame(num) {\n        this._mdf = false;\n        this.prepareRenderableFrame(num);\n        this.prepareProperties(num, this.isInRange);\n        this.checkTransparency();\n      },\n      destroy: function destroy() {\n        this.innerElem = null;\n        this.destroyBaseElement();\n      }\n    };\n    extendPrototype([RenderableElement, createProxyFunction(_prototype)], RenderableDOMElement);\n  })();\n\n  function IImageElement(data, globalData, comp) {\n    this.assetData = globalData.getAssetData(data.refId);\n\n    if (this.assetData && this.assetData.sid) {\n      this.assetData = globalData.slotManager.getProp(this.assetData);\n    }\n\n    this.initElement(data, globalData, comp);\n    this.sourceRect = {\n      top: 0,\n      left: 0,\n      width: this.assetData.w,\n      height: this.assetData.h\n    };\n  }\n\n  extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement);\n\n  IImageElement.prototype.createContent = function () {\n    var assetPath = this.globalData.getAssetsPath(this.assetData);\n    this.innerElem = createNS('image');\n    this.innerElem.setAttribute('width', this.assetData.w + 'px');\n    this.innerElem.setAttribute('height', this.assetData.h + 'px');\n    this.innerElem.setAttribute('preserveAspectRatio', this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);\n    this.innerElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath);\n    this.layerElement.appendChild(this.innerElem);\n  };\n\n  IImageElement.prototype.sourceRectAtTime = function () {\n    return this.sourceRect;\n  };\n\n  function ProcessedElement(element, position) {\n    this.elem = element;\n    this.pos = position;\n  }\n\n  function IShapeElement() {}\n\n  IShapeElement.prototype = {\n    addShapeToModifiers: function addShapeToModifiers(data) {\n      var i;\n      var len = this.shapeModifiers.length;\n\n      for (i = 0; i < len; i += 1) {\n        this.shapeModifiers[i].addShape(data);\n      }\n    },\n    isShapeInAnimatedModifiers: function isShapeInAnimatedModifiers(data) {\n      var i = 0;\n      var len = this.shapeModifiers.length;\n\n      while (i < len) {\n        if (this.shapeModifiers[i].isAnimatedWithShape(data)) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    renderModifiers: function renderModifiers() {\n      if (!this.shapeModifiers.length) {\n        return;\n      }\n\n      var i;\n      var len = this.shapes.length;\n\n      for (i = 0; i < len; i += 1) {\n        this.shapes[i].sh.reset();\n      }\n\n      len = this.shapeModifiers.length;\n      var shouldBreakProcess;\n\n      for (i = len - 1; i >= 0; i -= 1) {\n        shouldBreakProcess = this.shapeModifiers[i].processShapes(this._isFirstFrame); // workaround to fix cases where a repeater resets the shape so the following processes get called twice\n        // TODO: find a better solution for this\n\n        if (shouldBreakProcess) {\n          break;\n        }\n      }\n    },\n    searchProcessedElement: function searchProcessedElement(elem) {\n      var elements = this.processedElements;\n      var i = 0;\n      var len = elements.length;\n\n      while (i < len) {\n        if (elements[i].elem === elem) {\n          return elements[i].pos;\n        }\n\n        i += 1;\n      }\n\n      return 0;\n    },\n    addProcessedElement: function addProcessedElement(elem, pos) {\n      var elements = this.processedElements;\n      var i = elements.length;\n\n      while (i) {\n        i -= 1;\n\n        if (elements[i].elem === elem) {\n          elements[i].pos = pos;\n          return;\n        }\n      }\n\n      elements.push(new ProcessedElement(elem, pos));\n    },\n    prepareFrame: function prepareFrame(num) {\n      this.prepareRenderableFrame(num);\n      this.prepareProperties(num, this.isInRange);\n    }\n  };\n\n  var lineCapEnum = {\n    1: 'butt',\n    2: 'round',\n    3: 'square'\n  };\n  var lineJoinEnum = {\n    1: 'miter',\n    2: 'round',\n    3: 'bevel'\n  };\n\n  function SVGShapeData(transformers, level, shape) {\n    this.caches = [];\n    this.styles = [];\n    this.transformers = transformers;\n    this.lStr = '';\n    this.sh = shape;\n    this.lvl = level; // TODO find if there are some cases where _isAnimated can be false.\n    // For now, since shapes add up with other shapes. They have to be calculated every time.\n    // One way of finding out is checking if all styles associated to this shape depend only of this shape\n\n    this._isAnimated = !!shape.k; // TODO: commenting this for now since all shapes are animated\n\n    var i = 0;\n    var len = transformers.length;\n\n    while (i < len) {\n      if (transformers[i].mProps.dynamicProperties.length) {\n        this._isAnimated = true;\n        break;\n      }\n\n      i += 1;\n    }\n  }\n\n  SVGShapeData.prototype.setAsAnimated = function () {\n    this._isAnimated = true;\n  };\n\n  function SVGStyleData(data, level) {\n    this.data = data;\n    this.type = data.ty;\n    this.d = '';\n    this.lvl = level;\n    this._mdf = false;\n    this.closed = data.hd === true;\n    this.pElem = createNS('path');\n    this.msElem = null;\n  }\n\n  SVGStyleData.prototype.reset = function () {\n    this.d = '';\n    this._mdf = false;\n  };\n\n  function DashProperty(elem, data, renderer, container) {\n    this.elem = elem;\n    this.frameId = -1;\n    this.dataProps = createSizedArray(data.length);\n    this.renderer = renderer;\n    this.k = false;\n    this.dashStr = '';\n    this.dashArray = createTypedArray('float32', data.length ? data.length - 1 : 0);\n    this.dashoffset = createTypedArray('float32', 1);\n    this.initDynamicPropertyContainer(container);\n    var i;\n    var len = data.length || 0;\n    var prop;\n\n    for (i = 0; i < len; i += 1) {\n      prop = PropertyFactory.getProp(elem, data[i].v, 0, 0, this);\n      this.k = prop.k || this.k;\n      this.dataProps[i] = {\n        n: data[i].n,\n        p: prop\n      };\n    }\n\n    if (!this.k) {\n      this.getValue(true);\n    }\n\n    this._isAnimated = this.k;\n  }\n\n  DashProperty.prototype.getValue = function (forceRender) {\n    if (this.elem.globalData.frameId === this.frameId && !forceRender) {\n      return;\n    }\n\n    this.frameId = this.elem.globalData.frameId;\n    this.iterateDynamicProperties();\n    this._mdf = this._mdf || forceRender;\n\n    if (this._mdf) {\n      var i = 0;\n      var len = this.dataProps.length;\n\n      if (this.renderer === 'svg') {\n        this.dashStr = '';\n      }\n\n      for (i = 0; i < len; i += 1) {\n        if (this.dataProps[i].n !== 'o') {\n          if (this.renderer === 'svg') {\n            this.dashStr += ' ' + this.dataProps[i].p.v;\n          } else {\n            this.dashArray[i] = this.dataProps[i].p.v;\n          }\n        } else {\n          this.dashoffset[0] = this.dataProps[i].p.v;\n        }\n      }\n    }\n  };\n\n  extendPrototype([DynamicPropertyContainer], DashProperty);\n\n  function SVGStrokeStyleData(elem, data, styleOb) {\n    this.initDynamicPropertyContainer(elem);\n    this.getValue = this.iterateDynamicProperties;\n    this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);\n    this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);\n    this.d = new DashProperty(elem, data.d || {}, 'svg', this);\n    this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);\n    this.style = styleOb;\n    this._isAnimated = !!this._isAnimated;\n  }\n\n  extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);\n\n  function SVGFillStyleData(elem, data, styleOb) {\n    this.initDynamicPropertyContainer(elem);\n    this.getValue = this.iterateDynamicProperties;\n    this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);\n    this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);\n    this.style = styleOb;\n  }\n\n  extendPrototype([DynamicPropertyContainer], SVGFillStyleData);\n\n  function SVGNoStyleData(elem, data, styleOb) {\n    this.initDynamicPropertyContainer(elem);\n    this.getValue = this.iterateDynamicProperties;\n    this.style = styleOb;\n  }\n\n  extendPrototype([DynamicPropertyContainer], SVGNoStyleData);\n\n  function GradientProperty(elem, data, container) {\n    this.data = data;\n    this.c = createTypedArray('uint8c', data.p * 4);\n    var cLength = data.k.k[0].s ? data.k.k[0].s.length - data.p * 4 : data.k.k.length - data.p * 4;\n    this.o = createTypedArray('float32', cLength);\n    this._cmdf = false;\n    this._omdf = false;\n    this._collapsable = this.checkCollapsable();\n    this._hasOpacity = cLength;\n    this.initDynamicPropertyContainer(container);\n    this.prop = PropertyFactory.getProp(elem, data.k, 1, null, this);\n    this.k = this.prop.k;\n    this.getValue(true);\n  }\n\n  GradientProperty.prototype.comparePoints = function (values, points) {\n    var i = 0;\n    var len = this.o.length / 2;\n    var diff;\n\n    while (i < len) {\n      diff = Math.abs(values[i * 4] - values[points * 4 + i * 2]);\n\n      if (diff > 0.01) {\n        return false;\n      }\n\n      i += 1;\n    }\n\n    return true;\n  };\n\n  GradientProperty.prototype.checkCollapsable = function () {\n    if (this.o.length / 2 !== this.c.length / 4) {\n      return false;\n    }\n\n    if (this.data.k.k[0].s) {\n      var i = 0;\n      var len = this.data.k.k.length;\n\n      while (i < len) {\n        if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) {\n          return false;\n        }\n\n        i += 1;\n      }\n    } else if (!this.comparePoints(this.data.k.k, this.data.p)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  GradientProperty.prototype.getValue = function (forceRender) {\n    this.prop.getValue();\n    this._mdf = false;\n    this._cmdf = false;\n    this._omdf = false;\n\n    if (this.prop._mdf || forceRender) {\n      var i;\n      var len = this.data.p * 4;\n      var mult;\n      var val;\n\n      for (i = 0; i < len; i += 1) {\n        mult = i % 4 === 0 ? 100 : 255;\n        val = Math.round(this.prop.v[i] * mult);\n\n        if (this.c[i] !== val) {\n          this.c[i] = val;\n          this._cmdf = !forceRender;\n        }\n      }\n\n      if (this.o.length) {\n        len = this.prop.v.length;\n\n        for (i = this.data.p * 4; i < len; i += 1) {\n          mult = i % 2 === 0 ? 100 : 1;\n          val = i % 2 === 0 ? Math.round(this.prop.v[i] * 100) : this.prop.v[i];\n\n          if (this.o[i - this.data.p * 4] !== val) {\n            this.o[i - this.data.p * 4] = val;\n            this._omdf = !forceRender;\n          }\n        }\n      }\n\n      this._mdf = !forceRender;\n    }\n  };\n\n  extendPrototype([DynamicPropertyContainer], GradientProperty);\n\n  function SVGGradientFillStyleData(elem, data, styleOb) {\n    this.initDynamicPropertyContainer(elem);\n    this.getValue = this.iterateDynamicProperties;\n    this.initGradientData(elem, data, styleOb);\n  }\n\n  SVGGradientFillStyleData.prototype.initGradientData = function (elem, data, styleOb) {\n    this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);\n    this.s = PropertyFactory.getProp(elem, data.s, 1, null, this);\n    this.e = PropertyFactory.getProp(elem, data.e, 1, null, this);\n    this.h = PropertyFactory.getProp(elem, data.h || {\n      k: 0\n    }, 0, 0.01, this);\n    this.a = PropertyFactory.getProp(elem, data.a || {\n      k: 0\n    }, 0, degToRads, this);\n    this.g = new GradientProperty(elem, data.g, this);\n    this.style = styleOb;\n    this.stops = [];\n    this.setGradientData(styleOb.pElem, data);\n    this.setGradientOpacity(data, styleOb);\n    this._isAnimated = !!this._isAnimated;\n  };\n\n  SVGGradientFillStyleData.prototype.setGradientData = function (pathElement, data) {\n    var gradientId = createElementID();\n    var gfill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');\n    gfill.setAttribute('id', gradientId);\n    gfill.setAttribute('spreadMethod', 'pad');\n    gfill.setAttribute('gradientUnits', 'userSpaceOnUse');\n    var stops = [];\n    var stop;\n    var j;\n    var jLen;\n    jLen = data.g.p * 4;\n\n    for (j = 0; j < jLen; j += 4) {\n      stop = createNS('stop');\n      gfill.appendChild(stop);\n      stops.push(stop);\n    }\n\n    pathElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + getLocationHref() + '#' + gradientId + ')');\n    this.gf = gfill;\n    this.cst = stops;\n  };\n\n  SVGGradientFillStyleData.prototype.setGradientOpacity = function (data, styleOb) {\n    if (this.g._hasOpacity && !this.g._collapsable) {\n      var stop;\n      var j;\n      var jLen;\n      var mask = createNS('mask');\n      var maskElement = createNS('path');\n      mask.appendChild(maskElement);\n      var opacityId = createElementID();\n      var maskId = createElementID();\n      mask.setAttribute('id', maskId);\n      var opFill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');\n      opFill.setAttribute('id', opacityId);\n      opFill.setAttribute('spreadMethod', 'pad');\n      opFill.setAttribute('gradientUnits', 'userSpaceOnUse');\n      jLen = data.g.k.k[0].s ? data.g.k.k[0].s.length : data.g.k.k.length;\n      var stops = this.stops;\n\n      for (j = data.g.p * 4; j < jLen; j += 2) {\n        stop = createNS('stop');\n        stop.setAttribute('stop-color', 'rgb(255,255,255)');\n        opFill.appendChild(stop);\n        stops.push(stop);\n      }\n\n      maskElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + getLocationHref() + '#' + opacityId + ')');\n\n      if (data.ty === 'gs') {\n        maskElement.setAttribute('stroke-linecap', lineCapEnum[data.lc || 2]);\n        maskElement.setAttribute('stroke-linejoin', lineJoinEnum[data.lj || 2]);\n\n        if (data.lj === 1) {\n          maskElement.setAttribute('stroke-miterlimit', data.ml);\n        }\n      }\n\n      this.of = opFill;\n      this.ms = mask;\n      this.ost = stops;\n      this.maskId = maskId;\n      styleOb.msElem = maskElement;\n    }\n  };\n\n  extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);\n\n  function SVGGradientStrokeStyleData(elem, data, styleOb) {\n    this.initDynamicPropertyContainer(elem);\n    this.getValue = this.iterateDynamicProperties;\n    this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);\n    this.d = new DashProperty(elem, data.d || {}, 'svg', this);\n    this.initGradientData(elem, data, styleOb);\n    this._isAnimated = !!this._isAnimated;\n  }\n\n  extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);\n\n  function ShapeGroupData() {\n    this.it = [];\n    this.prevViewData = [];\n    this.gr = createNS('g');\n  }\n\n  function SVGTransformData(mProps, op, container) {\n    this.transform = {\n      mProps: mProps,\n      op: op,\n      container: container\n    };\n    this.elements = [];\n    this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;\n  }\n\n  var buildShapeString = function buildShapeString(pathNodes, length, closed, mat) {\n    if (length === 0) {\n      return '';\n    }\n\n    var _o = pathNodes.o;\n    var _i = pathNodes.i;\n    var _v = pathNodes.v;\n    var i;\n    var shapeString = ' M' + mat.applyToPointStringified(_v[0][0], _v[0][1]);\n\n    for (i = 1; i < length; i += 1) {\n      shapeString += ' C' + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + ' ' + mat.applyToPointStringified(_i[i][0], _i[i][1]) + ' ' + mat.applyToPointStringified(_v[i][0], _v[i][1]);\n    }\n\n    if (closed && length) {\n      shapeString += ' C' + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + ' ' + mat.applyToPointStringified(_i[0][0], _i[0][1]) + ' ' + mat.applyToPointStringified(_v[0][0], _v[0][1]);\n      shapeString += 'z';\n    }\n\n    return shapeString;\n  };\n\n  var SVGElementsRenderer = function () {\n    var _identityMatrix = new Matrix();\n\n    var _matrixHelper = new Matrix();\n\n    var ob = {\n      createRenderFunction: createRenderFunction\n    };\n\n    function createRenderFunction(data) {\n      switch (data.ty) {\n        case 'fl':\n          return renderFill;\n\n        case 'gf':\n          return renderGradient;\n\n        case 'gs':\n          return renderGradientStroke;\n\n        case 'st':\n          return renderStroke;\n\n        case 'sh':\n        case 'el':\n        case 'rc':\n        case 'sr':\n          return renderPath;\n\n        case 'tr':\n          return renderContentTransform;\n\n        case 'no':\n          return renderNoop;\n\n        default:\n          return null;\n      }\n    }\n\n    function renderContentTransform(styleData, itemData, isFirstFrame) {\n      if (isFirstFrame || itemData.transform.op._mdf) {\n        itemData.transform.container.setAttribute('opacity', itemData.transform.op.v);\n      }\n\n      if (isFirstFrame || itemData.transform.mProps._mdf) {\n        itemData.transform.container.setAttribute('transform', itemData.transform.mProps.v.to2dCSS());\n      }\n    }\n\n    function renderNoop() {}\n\n    function renderPath(styleData, itemData, isFirstFrame) {\n      var j;\n      var jLen;\n      var pathStringTransformed;\n      var redraw;\n      var pathNodes;\n      var l;\n      var lLen = itemData.styles.length;\n      var lvl = itemData.lvl;\n      var paths;\n      var mat;\n      var iterations;\n      var k;\n\n      for (l = 0; l < lLen; l += 1) {\n        redraw = itemData.sh._mdf || isFirstFrame;\n\n        if (itemData.styles[l].lvl < lvl) {\n          mat = _matrixHelper.reset();\n          iterations = lvl - itemData.styles[l].lvl;\n          k = itemData.transformers.length - 1;\n\n          while (!redraw && iterations > 0) {\n            redraw = itemData.transformers[k].mProps._mdf || redraw;\n            iterations -= 1;\n            k -= 1;\n          }\n\n          if (redraw) {\n            iterations = lvl - itemData.styles[l].lvl;\n            k = itemData.transformers.length - 1;\n\n            while (iterations > 0) {\n              mat.multiply(itemData.transformers[k].mProps.v);\n              iterations -= 1;\n              k -= 1;\n            }\n          }\n        } else {\n          mat = _identityMatrix;\n        }\n\n        paths = itemData.sh.paths;\n        jLen = paths._length;\n\n        if (redraw) {\n          pathStringTransformed = '';\n\n          for (j = 0; j < jLen; j += 1) {\n            pathNodes = paths.shapes[j];\n\n            if (pathNodes && pathNodes._length) {\n              pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);\n            }\n          }\n\n          itemData.caches[l] = pathStringTransformed;\n        } else {\n          pathStringTransformed = itemData.caches[l];\n        }\n\n        itemData.styles[l].d += styleData.hd === true ? '' : pathStringTransformed;\n        itemData.styles[l]._mdf = redraw || itemData.styles[l]._mdf;\n      }\n    }\n\n    function renderFill(styleData, itemData, isFirstFrame) {\n      var styleElem = itemData.style;\n\n      if (itemData.c._mdf || isFirstFrame) {\n        styleElem.pElem.setAttribute('fill', 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')');\n      }\n\n      if (itemData.o._mdf || isFirstFrame) {\n        styleElem.pElem.setAttribute('fill-opacity', itemData.o.v);\n      }\n    }\n\n    function renderGradientStroke(styleData, itemData, isFirstFrame) {\n      renderGradient(styleData, itemData, isFirstFrame);\n      renderStroke(styleData, itemData, isFirstFrame);\n    }\n\n    function renderGradient(styleData, itemData, isFirstFrame) {\n      var gfill = itemData.gf;\n      var hasOpacity = itemData.g._hasOpacity;\n      var pt1 = itemData.s.v;\n      var pt2 = itemData.e.v;\n\n      if (itemData.o._mdf || isFirstFrame) {\n        var attr = styleData.ty === 'gf' ? 'fill-opacity' : 'stroke-opacity';\n        itemData.style.pElem.setAttribute(attr, itemData.o.v);\n      }\n\n      if (itemData.s._mdf || isFirstFrame) {\n        var attr1 = styleData.t === 1 ? 'x1' : 'cx';\n        var attr2 = attr1 === 'x1' ? 'y1' : 'cy';\n        gfill.setAttribute(attr1, pt1[0]);\n        gfill.setAttribute(attr2, pt1[1]);\n\n        if (hasOpacity && !itemData.g._collapsable) {\n          itemData.of.setAttribute(attr1, pt1[0]);\n          itemData.of.setAttribute(attr2, pt1[1]);\n        }\n      }\n\n      var stops;\n      var i;\n      var len;\n      var stop;\n\n      if (itemData.g._cmdf || isFirstFrame) {\n        stops = itemData.cst;\n        var cValues = itemData.g.c;\n        len = stops.length;\n\n        for (i = 0; i < len; i += 1) {\n          stop = stops[i];\n          stop.setAttribute('offset', cValues[i * 4] + '%');\n          stop.setAttribute('stop-color', 'rgb(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ')');\n        }\n      }\n\n      if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {\n        var oValues = itemData.g.o;\n\n        if (itemData.g._collapsable) {\n          stops = itemData.cst;\n        } else {\n          stops = itemData.ost;\n        }\n\n        len = stops.length;\n\n        for (i = 0; i < len; i += 1) {\n          stop = stops[i];\n\n          if (!itemData.g._collapsable) {\n            stop.setAttribute('offset', oValues[i * 2] + '%');\n          }\n\n          stop.setAttribute('stop-opacity', oValues[i * 2 + 1]);\n        }\n      }\n\n      if (styleData.t === 1) {\n        if (itemData.e._mdf || isFirstFrame) {\n          gfill.setAttribute('x2', pt2[0]);\n          gfill.setAttribute('y2', pt2[1]);\n\n          if (hasOpacity && !itemData.g._collapsable) {\n            itemData.of.setAttribute('x2', pt2[0]);\n            itemData.of.setAttribute('y2', pt2[1]);\n          }\n        }\n      } else {\n        var rad;\n\n        if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {\n          rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));\n          gfill.setAttribute('r', rad);\n\n          if (hasOpacity && !itemData.g._collapsable) {\n            itemData.of.setAttribute('r', rad);\n          }\n        }\n\n        if (itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {\n          if (!rad) {\n            rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));\n          }\n\n          var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);\n          var percent = itemData.h.v;\n\n          if (percent >= 1) {\n            percent = 0.99;\n          } else if (percent <= -1) {\n            percent = -0.99;\n          }\n\n          var dist = rad * percent;\n          var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];\n          var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];\n          gfill.setAttribute('fx', x);\n          gfill.setAttribute('fy', y);\n\n          if (hasOpacity && !itemData.g._collapsable) {\n            itemData.of.setAttribute('fx', x);\n            itemData.of.setAttribute('fy', y);\n          }\n        } // gfill.setAttribute('fy','200');\n\n      }\n    }\n\n    function renderStroke(styleData, itemData, isFirstFrame) {\n      var styleElem = itemData.style;\n      var d = itemData.d;\n\n      if (d && (d._mdf || isFirstFrame) && d.dashStr) {\n        styleElem.pElem.setAttribute('stroke-dasharray', d.dashStr);\n        styleElem.pElem.setAttribute('stroke-dashoffset', d.dashoffset[0]);\n      }\n\n      if (itemData.c && (itemData.c._mdf || isFirstFrame)) {\n        styleElem.pElem.setAttribute('stroke', 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')');\n      }\n\n      if (itemData.o._mdf || isFirstFrame) {\n        styleElem.pElem.setAttribute('stroke-opacity', itemData.o.v);\n      }\n\n      if (itemData.w._mdf || isFirstFrame) {\n        styleElem.pElem.setAttribute('stroke-width', itemData.w.v);\n\n        if (styleElem.msElem) {\n          styleElem.msElem.setAttribute('stroke-width', itemData.w.v);\n        }\n      }\n    }\n\n    return ob;\n  }();\n\n  function SVGShapeElement(data, globalData, comp) {\n    // List of drawable elements\n    this.shapes = []; // Full shape data\n\n    this.shapesData = data.shapes; // List of styles that will be applied to shapes\n\n    this.stylesList = []; // List of modifiers that will be applied to shapes\n\n    this.shapeModifiers = []; // List of items in shape tree\n\n    this.itemsData = []; // List of items in previous shape tree\n\n    this.processedElements = []; // List of animated components\n\n    this.animatedContents = [];\n    this.initElement(data, globalData, comp); // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.\n    // List of elements that have been created\n\n    this.prevViewData = []; // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.\n  }\n\n  extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement);\n\n  SVGShapeElement.prototype.initSecondaryElement = function () {};\n\n  SVGShapeElement.prototype.identityMatrix = new Matrix();\n\n  SVGShapeElement.prototype.buildExpressionInterface = function () {};\n\n  SVGShapeElement.prototype.createContent = function () {\n    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);\n    this.filterUniqueShapes();\n  };\n  /*\r\n  This method searches for multiple shapes that affect a single element and one of them is animated\r\n  */\n\n\n  SVGShapeElement.prototype.filterUniqueShapes = function () {\n    var i;\n    var len = this.shapes.length;\n    var shape;\n    var j;\n    var jLen = this.stylesList.length;\n    var style;\n    var tempShapes = [];\n    var areAnimated = false;\n\n    for (j = 0; j < jLen; j += 1) {\n      style = this.stylesList[j];\n      areAnimated = false;\n      tempShapes.length = 0;\n\n      for (i = 0; i < len; i += 1) {\n        shape = this.shapes[i];\n\n        if (shape.styles.indexOf(style) !== -1) {\n          tempShapes.push(shape);\n          areAnimated = shape._isAnimated || areAnimated;\n        }\n      }\n\n      if (tempShapes.length > 1 && areAnimated) {\n        this.setShapesAsAnimated(tempShapes);\n      }\n    }\n  };\n\n  SVGShapeElement.prototype.setShapesAsAnimated = function (shapes) {\n    var i;\n    var len = shapes.length;\n\n    for (i = 0; i < len; i += 1) {\n      shapes[i].setAsAnimated();\n    }\n  };\n\n  SVGShapeElement.prototype.createStyleElement = function (data, level) {\n    // TODO: prevent drawing of hidden styles\n    var elementData;\n    var styleOb = new SVGStyleData(data, level);\n    var pathElement = styleOb.pElem;\n\n    if (data.ty === 'st') {\n      elementData = new SVGStrokeStyleData(this, data, styleOb);\n    } else if (data.ty === 'fl') {\n      elementData = new SVGFillStyleData(this, data, styleOb);\n    } else if (data.ty === 'gf' || data.ty === 'gs') {\n      var GradientConstructor = data.ty === 'gf' ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;\n      elementData = new GradientConstructor(this, data, styleOb);\n      this.globalData.defs.appendChild(elementData.gf);\n\n      if (elementData.maskId) {\n        this.globalData.defs.appendChild(elementData.ms);\n        this.globalData.defs.appendChild(elementData.of);\n        pathElement.setAttribute('mask', 'url(' + getLocationHref() + '#' + elementData.maskId + ')');\n      }\n    } else if (data.ty === 'no') {\n      elementData = new SVGNoStyleData(this, data, styleOb);\n    }\n\n    if (data.ty === 'st' || data.ty === 'gs') {\n      pathElement.setAttribute('stroke-linecap', lineCapEnum[data.lc || 2]);\n      pathElement.setAttribute('stroke-linejoin', lineJoinEnum[data.lj || 2]);\n      pathElement.setAttribute('fill-opacity', '0');\n\n      if (data.lj === 1) {\n        pathElement.setAttribute('stroke-miterlimit', data.ml);\n      }\n    }\n\n    if (data.r === 2) {\n      pathElement.setAttribute('fill-rule', 'evenodd');\n    }\n\n    if (data.ln) {\n      pathElement.setAttribute('id', data.ln);\n    }\n\n    if (data.cl) {\n      pathElement.setAttribute('class', data.cl);\n    }\n\n    if (data.bm) {\n      pathElement.style['mix-blend-mode'] = getBlendMode(data.bm);\n    }\n\n    this.stylesList.push(styleOb);\n    this.addToAnimatedContents(data, elementData);\n    return elementData;\n  };\n\n  SVGShapeElement.prototype.createGroupElement = function (data) {\n    var elementData = new ShapeGroupData();\n\n    if (data.ln) {\n      elementData.gr.setAttribute('id', data.ln);\n    }\n\n    if (data.cl) {\n      elementData.gr.setAttribute('class', data.cl);\n    }\n\n    if (data.bm) {\n      elementData.gr.style['mix-blend-mode'] = getBlendMode(data.bm);\n    }\n\n    return elementData;\n  };\n\n  SVGShapeElement.prototype.createTransformElement = function (data, container) {\n    var transformProperty = TransformPropertyFactory.getTransformProperty(this, data, this);\n    var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);\n    this.addToAnimatedContents(data, elementData);\n    return elementData;\n  };\n\n  SVGShapeElement.prototype.createShapeElement = function (data, ownTransformers, level) {\n    var ty = 4;\n\n    if (data.ty === 'rc') {\n      ty = 5;\n    } else if (data.ty === 'el') {\n      ty = 6;\n    } else if (data.ty === 'sr') {\n      ty = 7;\n    }\n\n    var shapeProperty = ShapePropertyFactory.getShapeProp(this, data, ty, this);\n    var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);\n    this.shapes.push(elementData);\n    this.addShapeToModifiers(elementData);\n    this.addToAnimatedContents(data, elementData);\n    return elementData;\n  };\n\n  SVGShapeElement.prototype.addToAnimatedContents = function (data, element) {\n    var i = 0;\n    var len = this.animatedContents.length;\n\n    while (i < len) {\n      if (this.animatedContents[i].element === element) {\n        return;\n      }\n\n      i += 1;\n    }\n\n    this.animatedContents.push({\n      fn: SVGElementsRenderer.createRenderFunction(data),\n      element: element,\n      data: data\n    });\n  };\n\n  SVGShapeElement.prototype.setElementStyles = function (elementData) {\n    var arr = elementData.styles;\n    var j;\n    var jLen = this.stylesList.length;\n\n    for (j = 0; j < jLen; j += 1) {\n      if (!this.stylesList[j].closed) {\n        arr.push(this.stylesList[j]);\n      }\n    }\n  };\n\n  SVGShapeElement.prototype.reloadShapes = function () {\n    this._isFirstFrame = true;\n    var i;\n    var len = this.itemsData.length;\n\n    for (i = 0; i < len; i += 1) {\n      this.prevViewData[i] = this.itemsData[i];\n    }\n\n    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);\n    this.filterUniqueShapes();\n    len = this.dynamicProperties.length;\n\n    for (i = 0; i < len; i += 1) {\n      this.dynamicProperties[i].getValue();\n    }\n\n    this.renderModifiers();\n  };\n\n  SVGShapeElement.prototype.searchShapes = function (arr, itemsData, prevViewData, container, level, transformers, render) {\n    var ownTransformers = [].concat(transformers);\n    var i;\n    var len = arr.length - 1;\n    var j;\n    var jLen;\n    var ownStyles = [];\n    var ownModifiers = [];\n    var currentTransform;\n    var modifier;\n    var processedPos;\n\n    for (i = len; i >= 0; i -= 1) {\n      processedPos = this.searchProcessedElement(arr[i]);\n\n      if (!processedPos) {\n        arr[i]._render = render;\n      } else {\n        itemsData[i] = prevViewData[processedPos - 1];\n      }\n\n      if (arr[i].ty === 'fl' || arr[i].ty === 'st' || arr[i].ty === 'gf' || arr[i].ty === 'gs' || arr[i].ty === 'no') {\n        if (!processedPos) {\n          itemsData[i] = this.createStyleElement(arr[i], level);\n        } else {\n          itemsData[i].style.closed = false;\n        }\n\n        if (arr[i]._render) {\n          if (itemsData[i].style.pElem.parentNode !== container) {\n            container.appendChild(itemsData[i].style.pElem);\n          }\n        }\n\n        ownStyles.push(itemsData[i].style);\n      } else if (arr[i].ty === 'gr') {\n        if (!processedPos) {\n          itemsData[i] = this.createGroupElement(arr[i]);\n        } else {\n          jLen = itemsData[i].it.length;\n\n          for (j = 0; j < jLen; j += 1) {\n            itemsData[i].prevViewData[j] = itemsData[i].it[j];\n          }\n        }\n\n        this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, itemsData[i].gr, level + 1, ownTransformers, render);\n\n        if (arr[i]._render) {\n          if (itemsData[i].gr.parentNode !== container) {\n            container.appendChild(itemsData[i].gr);\n          }\n        }\n      } else if (arr[i].ty === 'tr') {\n        if (!processedPos) {\n          itemsData[i] = this.createTransformElement(arr[i], container);\n        }\n\n        currentTransform = itemsData[i].transform;\n        ownTransformers.push(currentTransform);\n      } else if (arr[i].ty === 'sh' || arr[i].ty === 'rc' || arr[i].ty === 'el' || arr[i].ty === 'sr') {\n        if (!processedPos) {\n          itemsData[i] = this.createShapeElement(arr[i], ownTransformers, level);\n        }\n\n        this.setElementStyles(itemsData[i]);\n      } else if (arr[i].ty === 'tm' || arr[i].ty === 'rd' || arr[i].ty === 'ms' || arr[i].ty === 'pb' || arr[i].ty === 'zz' || arr[i].ty === 'op') {\n        if (!processedPos) {\n          modifier = ShapeModifiers.getModifier(arr[i].ty);\n          modifier.init(this, arr[i]);\n          itemsData[i] = modifier;\n          this.shapeModifiers.push(modifier);\n        } else {\n          modifier = itemsData[i];\n          modifier.closed = false;\n        }\n\n        ownModifiers.push(modifier);\n      } else if (arr[i].ty === 'rp') {\n        if (!processedPos) {\n          modifier = ShapeModifiers.getModifier(arr[i].ty);\n          itemsData[i] = modifier;\n          modifier.init(this, arr, i, itemsData);\n          this.shapeModifiers.push(modifier);\n          render = false;\n        } else {\n          modifier = itemsData[i];\n          modifier.closed = true;\n        }\n\n        ownModifiers.push(modifier);\n      }\n\n      this.addProcessedElement(arr[i], i + 1);\n    }\n\n    len = ownStyles.length;\n\n    for (i = 0; i < len; i += 1) {\n      ownStyles[i].closed = true;\n    }\n\n    len = ownModifiers.length;\n\n    for (i = 0; i < len; i += 1) {\n      ownModifiers[i].closed = true;\n    }\n  };\n\n  SVGShapeElement.prototype.renderInnerContent = function () {\n    this.renderModifiers();\n    var i;\n    var len = this.stylesList.length;\n\n    for (i = 0; i < len; i += 1) {\n      this.stylesList[i].reset();\n    }\n\n    this.renderShape();\n\n    for (i = 0; i < len; i += 1) {\n      if (this.stylesList[i]._mdf || this._isFirstFrame) {\n        if (this.stylesList[i].msElem) {\n          this.stylesList[i].msElem.setAttribute('d', this.stylesList[i].d); // Adding M0 0 fixes same mask bug on all browsers\n\n          this.stylesList[i].d = 'M0 0' + this.stylesList[i].d;\n        }\n\n        this.stylesList[i].pElem.setAttribute('d', this.stylesList[i].d || 'M0 0');\n      }\n    }\n  };\n\n  SVGShapeElement.prototype.renderShape = function () {\n    var i;\n    var len = this.animatedContents.length;\n    var animatedContent;\n\n    for (i = 0; i < len; i += 1) {\n      animatedContent = this.animatedContents[i];\n\n      if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {\n        animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);\n      }\n    }\n  };\n\n  SVGShapeElement.prototype.destroy = function () {\n    this.destroyBaseElement();\n    this.shapesData = null;\n    this.itemsData = null;\n  };\n\n  function LetterProps(o, sw, sc, fc, m, p) {\n    this.o = o;\n    this.sw = sw;\n    this.sc = sc;\n    this.fc = fc;\n    this.m = m;\n    this.p = p;\n    this._mdf = {\n      o: true,\n      sw: !!sw,\n      sc: !!sc,\n      fc: !!fc,\n      m: true,\n      p: true\n    };\n  }\n\n  LetterProps.prototype.update = function (o, sw, sc, fc, m, p) {\n    this._mdf.o = false;\n    this._mdf.sw = false;\n    this._mdf.sc = false;\n    this._mdf.fc = false;\n    this._mdf.m = false;\n    this._mdf.p = false;\n    var updated = false;\n\n    if (this.o !== o) {\n      this.o = o;\n      this._mdf.o = true;\n      updated = true;\n    }\n\n    if (this.sw !== sw) {\n      this.sw = sw;\n      this._mdf.sw = true;\n      updated = true;\n    }\n\n    if (this.sc !== sc) {\n      this.sc = sc;\n      this._mdf.sc = true;\n      updated = true;\n    }\n\n    if (this.fc !== fc) {\n      this.fc = fc;\n      this._mdf.fc = true;\n      updated = true;\n    }\n\n    if (this.m !== m) {\n      this.m = m;\n      this._mdf.m = true;\n      updated = true;\n    }\n\n    if (p.length && (this.p[0] !== p[0] || this.p[1] !== p[1] || this.p[4] !== p[4] || this.p[5] !== p[5] || this.p[12] !== p[12] || this.p[13] !== p[13])) {\n      this.p = p;\n      this._mdf.p = true;\n      updated = true;\n    }\n\n    return updated;\n  };\n\n  function TextProperty(elem, data) {\n    this._frameId = initialDefaultFrame;\n    this.pv = '';\n    this.v = '';\n    this.kf = false;\n    this._isFirstFrame = true;\n    this._mdf = false;\n\n    if (data.d && data.d.sid) {\n      data.d = elem.globalData.slotManager.getProp(data.d);\n    }\n\n    this.data = data;\n    this.elem = elem;\n    this.comp = this.elem.comp;\n    this.keysIndex = 0;\n    this.canResize = false;\n    this.minimumFontSize = 1;\n    this.effectsSequence = [];\n    this.currentData = {\n      ascent: 0,\n      boxWidth: this.defaultBoxWidth,\n      f: '',\n      fStyle: '',\n      fWeight: '',\n      fc: '',\n      j: '',\n      justifyOffset: '',\n      l: [],\n      lh: 0,\n      lineWidths: [],\n      ls: '',\n      of: '',\n      s: '',\n      sc: '',\n      sw: 0,\n      t: 0,\n      tr: 0,\n      sz: 0,\n      ps: null,\n      fillColorAnim: false,\n      strokeColorAnim: false,\n      strokeWidthAnim: false,\n      yOffset: 0,\n      finalSize: 0,\n      finalText: [],\n      finalLineHeight: 0,\n      __complete: false\n    };\n    this.copyData(this.currentData, this.data.d.k[0].s);\n\n    if (!this.searchProperty()) {\n      this.completeTextData(this.currentData);\n    }\n  }\n\n  TextProperty.prototype.defaultBoxWidth = [0, 0];\n\n  TextProperty.prototype.copyData = function (obj, data) {\n    for (var s in data) {\n      if (Object.prototype.hasOwnProperty.call(data, s)) {\n        obj[s] = data[s];\n      }\n    }\n\n    return obj;\n  };\n\n  TextProperty.prototype.setCurrentData = function (data) {\n    if (!data.__complete) {\n      this.completeTextData(data);\n    }\n\n    this.currentData = data;\n    this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;\n    this._mdf = true;\n  };\n\n  TextProperty.prototype.searchProperty = function () {\n    return this.searchKeyframes();\n  };\n\n  TextProperty.prototype.searchKeyframes = function () {\n    this.kf = this.data.d.k.length > 1;\n\n    if (this.kf) {\n      this.addEffect(this.getKeyframeValue.bind(this));\n    }\n\n    return this.kf;\n  };\n\n  TextProperty.prototype.addEffect = function (effectFunction) {\n    this.effectsSequence.push(effectFunction);\n    this.elem.addDynamicProperty(this);\n  };\n\n  TextProperty.prototype.getValue = function (_finalValue) {\n    if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {\n      return;\n    }\n\n    this.currentData.t = this.data.d.k[this.keysIndex].s.t;\n    var currentValue = this.currentData;\n    var currentIndex = this.keysIndex;\n\n    if (this.lock) {\n      this.setCurrentData(this.currentData);\n      return;\n    }\n\n    this.lock = true;\n    this._mdf = false;\n    var i;\n    var len = this.effectsSequence.length;\n    var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;\n\n    for (i = 0; i < len; i += 1) {\n      // Checking if index changed to prevent creating a new object every time the expression updates.\n      if (currentIndex !== this.keysIndex) {\n        finalValue = this.effectsSequence[i](finalValue, finalValue.t);\n      } else {\n        finalValue = this.effectsSequence[i](this.currentData, finalValue.t);\n      }\n    }\n\n    if (currentValue !== finalValue) {\n      this.setCurrentData(finalValue);\n    }\n\n    this.v = this.currentData;\n    this.pv = this.v;\n    this.lock = false;\n    this.frameId = this.elem.globalData.frameId;\n  };\n\n  TextProperty.prototype.getKeyframeValue = function () {\n    var textKeys = this.data.d.k;\n    var frameNum = this.elem.comp.renderedFrame;\n    var i = 0;\n    var len = textKeys.length;\n\n    while (i <= len - 1) {\n      if (i === len - 1 || textKeys[i + 1].t > frameNum) {\n        break;\n      }\n\n      i += 1;\n    }\n\n    if (this.keysIndex !== i) {\n      this.keysIndex = i;\n    }\n\n    return this.data.d.k[this.keysIndex].s;\n  };\n\n  TextProperty.prototype.buildFinalText = function (text) {\n    var charactersArray = [];\n    var i = 0;\n    var len = text.length;\n    var charCode;\n    var secondCharCode;\n    var shouldCombine = false;\n    var shouldCombineNext = false;\n    var currentChars = '';\n\n    while (i < len) {\n      shouldCombine = shouldCombineNext;\n      shouldCombineNext = false;\n      charCode = text.charCodeAt(i);\n      currentChars = text.charAt(i);\n\n      if (FontManager.isCombinedCharacter(charCode)) {\n        shouldCombine = true; // It's a potential surrogate pair (this is the High surrogate)\n      } else if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n        if (FontManager.isRegionalFlag(text, i)) {\n          currentChars = text.substr(i, 14);\n        } else {\n          secondCharCode = text.charCodeAt(i + 1); // It's a surrogate pair (this is the Low surrogate)\n\n          if (secondCharCode >= 0xDC00 && secondCharCode <= 0xDFFF) {\n            if (FontManager.isModifier(charCode, secondCharCode)) {\n              currentChars = text.substr(i, 2);\n              shouldCombine = true;\n            } else if (FontManager.isFlagEmoji(text.substr(i, 4))) {\n              currentChars = text.substr(i, 4);\n            } else {\n              currentChars = text.substr(i, 2);\n            }\n          }\n        }\n      } else if (charCode > 0xDBFF) {\n        secondCharCode = text.charCodeAt(i + 1);\n\n        if (FontManager.isVariationSelector(charCode)) {\n          shouldCombine = true;\n        }\n      } else if (FontManager.isZeroWidthJoiner(charCode)) {\n        shouldCombine = true;\n        shouldCombineNext = true;\n      }\n\n      if (shouldCombine) {\n        charactersArray[charactersArray.length - 1] += currentChars;\n        shouldCombine = false;\n      } else {\n        charactersArray.push(currentChars);\n      }\n\n      i += currentChars.length;\n    }\n\n    return charactersArray;\n  };\n\n  TextProperty.prototype.completeTextData = function (documentData) {\n    documentData.__complete = true;\n    var fontManager = this.elem.globalData.fontManager;\n    var data = this.data;\n    var letters = [];\n    var i;\n    var len;\n    var newLineFlag;\n    var index = 0;\n    var val;\n    var anchorGrouping = data.m.g;\n    var currentSize = 0;\n    var currentPos = 0;\n    var currentLine = 0;\n    var lineWidths = [];\n    var lineWidth = 0;\n    var maxLineWidth = 0;\n    var j;\n    var jLen;\n    var fontData = fontManager.getFontByName(documentData.f);\n    var charData;\n    var cLength = 0;\n    var fontProps = getFontProperties(fontData);\n    documentData.fWeight = fontProps.weight;\n    documentData.fStyle = fontProps.style;\n    documentData.finalSize = documentData.s;\n    documentData.finalText = this.buildFinalText(documentData.t);\n    len = documentData.finalText.length;\n    documentData.finalLineHeight = documentData.lh;\n    var trackingOffset = documentData.tr / 1000 * documentData.finalSize;\n    var charCode;\n\n    if (documentData.sz) {\n      var flag = true;\n      var boxWidth = documentData.sz[0];\n      var boxHeight = documentData.sz[1];\n      var currentHeight;\n      var finalText;\n\n      while (flag) {\n        finalText = this.buildFinalText(documentData.t);\n        currentHeight = 0;\n        lineWidth = 0;\n        len = finalText.length;\n        trackingOffset = documentData.tr / 1000 * documentData.finalSize;\n        var lastSpaceIndex = -1;\n\n        for (i = 0; i < len; i += 1) {\n          charCode = finalText[i].charCodeAt(0);\n          newLineFlag = false;\n\n          if (finalText[i] === ' ') {\n            lastSpaceIndex = i;\n          } else if (charCode === 13 || charCode === 3) {\n            lineWidth = 0;\n            newLineFlag = true;\n            currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;\n          }\n\n          if (fontManager.chars) {\n            charData = fontManager.getCharData(finalText[i], fontData.fStyle, fontData.fFamily);\n            cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;\n          } else {\n            // tCanvasHelper.font = documentData.s + 'px '+ fontData.fFamily;\n            cLength = fontManager.measureText(finalText[i], documentData.f, documentData.finalSize);\n          }\n\n          if (lineWidth + cLength > boxWidth && finalText[i] !== ' ') {\n            if (lastSpaceIndex === -1) {\n              len += 1;\n            } else {\n              i = lastSpaceIndex;\n            }\n\n            currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;\n            finalText.splice(i, lastSpaceIndex === i ? 1 : 0, '\\r'); // finalText = finalText.substr(0,i) + \"\\r\" + finalText.substr(i === lastSpaceIndex ? i + 1 : i);\n\n            lastSpaceIndex = -1;\n            lineWidth = 0;\n          } else {\n            lineWidth += cLength;\n            lineWidth += trackingOffset;\n          }\n        }\n\n        currentHeight += fontData.ascent * documentData.finalSize / 100;\n\n        if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {\n          documentData.finalSize -= 1;\n          documentData.finalLineHeight = documentData.finalSize * documentData.lh / documentData.s;\n        } else {\n          documentData.finalText = finalText;\n          len = documentData.finalText.length;\n          flag = false;\n        }\n      }\n    }\n\n    lineWidth = -trackingOffset;\n    cLength = 0;\n    var uncollapsedSpaces = 0;\n    var currentChar;\n\n    for (i = 0; i < len; i += 1) {\n      newLineFlag = false;\n      currentChar = documentData.finalText[i];\n      charCode = currentChar.charCodeAt(0);\n\n      if (charCode === 13 || charCode === 3) {\n        uncollapsedSpaces = 0;\n        lineWidths.push(lineWidth);\n        maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;\n        lineWidth = -2 * trackingOffset;\n        val = '';\n        newLineFlag = true;\n        currentLine += 1;\n      } else {\n        val = currentChar;\n      }\n\n      if (fontManager.chars) {\n        charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);\n        cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;\n      } else {\n        // var charWidth = fontManager.measureText(val, documentData.f, documentData.finalSize);\n        // tCanvasHelper.font = documentData.finalSize + 'px '+ fontManager.getFontByName(documentData.f).fFamily;\n        cLength = fontManager.measureText(val, documentData.f, documentData.finalSize);\n      } //\n\n\n      if (currentChar === ' ') {\n        uncollapsedSpaces += cLength + trackingOffset;\n      } else {\n        lineWidth += cLength + trackingOffset + uncollapsedSpaces;\n        uncollapsedSpaces = 0;\n      }\n\n      letters.push({\n        l: cLength,\n        an: cLength,\n        add: currentSize,\n        n: newLineFlag,\n        anIndexes: [],\n        val: val,\n        line: currentLine,\n        animatorJustifyOffset: 0\n      });\n\n      if (anchorGrouping == 2) {\n        // eslint-disable-line eqeqeq\n        currentSize += cLength;\n\n        if (val === '' || val === ' ' || i === len - 1) {\n          if (val === '' || val === ' ') {\n            currentSize -= cLength;\n          }\n\n          while (currentPos <= i) {\n            letters[currentPos].an = currentSize;\n            letters[currentPos].ind = index;\n            letters[currentPos].extra = cLength;\n            currentPos += 1;\n          }\n\n          index += 1;\n          currentSize = 0;\n        }\n      } else if (anchorGrouping == 3) {\n        // eslint-disable-line eqeqeq\n        currentSize += cLength;\n\n        if (val === '' || i === len - 1) {\n          if (val === '') {\n            currentSize -= cLength;\n          }\n\n          while (currentPos <= i) {\n            letters[currentPos].an = currentSize;\n            letters[currentPos].ind = index;\n            letters[currentPos].extra = cLength;\n            currentPos += 1;\n          }\n\n          currentSize = 0;\n          index += 1;\n        }\n      } else {\n        letters[index].ind = index;\n        letters[index].extra = 0;\n        index += 1;\n      }\n    }\n\n    documentData.l = letters;\n    maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;\n    lineWidths.push(lineWidth);\n\n    if (documentData.sz) {\n      documentData.boxWidth = documentData.sz[0];\n      documentData.justifyOffset = 0;\n    } else {\n      documentData.boxWidth = maxLineWidth;\n\n      switch (documentData.j) {\n        case 1:\n          documentData.justifyOffset = -documentData.boxWidth;\n          break;\n\n        case 2:\n          documentData.justifyOffset = -documentData.boxWidth / 2;\n          break;\n\n        default:\n          documentData.justifyOffset = 0;\n      }\n    }\n\n    documentData.lineWidths = lineWidths;\n    var animators = data.a;\n    var animatorData;\n    var letterData;\n    jLen = animators.length;\n    var based;\n    var ind;\n    var indexes = [];\n\n    for (j = 0; j < jLen; j += 1) {\n      animatorData = animators[j];\n\n      if (animatorData.a.sc) {\n        documentData.strokeColorAnim = true;\n      }\n\n      if (animatorData.a.sw) {\n        documentData.strokeWidthAnim = true;\n      }\n\n      if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) {\n        documentData.fillColorAnim = true;\n      }\n\n      ind = 0;\n      based = animatorData.s.b;\n\n      for (i = 0; i < len; i += 1) {\n        letterData = letters[i];\n        letterData.anIndexes[j] = ind;\n\n        if (based == 1 && letterData.val !== '' || based == 2 && letterData.val !== '' && letterData.val !== ' ' || based == 3 && (letterData.n || letterData.val == ' ' || i == len - 1) || based == 4 && (letterData.n || i == len - 1)) {\n          // eslint-disable-line eqeqeq\n          if (animatorData.s.rn === 1) {\n            indexes.push(ind);\n          }\n\n          ind += 1;\n        }\n      }\n\n      data.a[j].s.totalChars = ind;\n      var currentInd = -1;\n      var newInd;\n\n      if (animatorData.s.rn === 1) {\n        for (i = 0; i < len; i += 1) {\n          letterData = letters[i];\n\n          if (currentInd != letterData.anIndexes[j]) {\n            // eslint-disable-line eqeqeq\n            currentInd = letterData.anIndexes[j];\n            newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0];\n          }\n\n          letterData.anIndexes[j] = newInd;\n        }\n      }\n    }\n\n    documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2;\n    documentData.ls = documentData.ls || 0;\n    documentData.ascent = fontData.ascent * documentData.finalSize / 100;\n  };\n\n  TextProperty.prototype.updateDocumentData = function (newData, index) {\n    index = index === undefined ? this.keysIndex : index;\n    var dData = this.copyData({}, this.data.d.k[index].s);\n    dData = this.copyData(dData, newData);\n    this.data.d.k[index].s = dData;\n    this.recalculate(index);\n    this.setCurrentData(dData);\n    this.elem.addDynamicProperty(this);\n  };\n\n  TextProperty.prototype.recalculate = function (index) {\n    var dData = this.data.d.k[index].s;\n    dData.__complete = false;\n    this.keysIndex = 0;\n    this._isFirstFrame = true;\n    this.getValue(dData);\n  };\n\n  TextProperty.prototype.canResizeFont = function (_canResize) {\n    this.canResize = _canResize;\n    this.recalculate(this.keysIndex);\n    this.elem.addDynamicProperty(this);\n  };\n\n  TextProperty.prototype.setMinimumFontSize = function (_fontValue) {\n    this.minimumFontSize = Math.floor(_fontValue) || 1;\n    this.recalculate(this.keysIndex);\n    this.elem.addDynamicProperty(this);\n  };\n\n  var TextSelectorProp = function () {\n    var max = Math.max;\n    var min = Math.min;\n    var floor = Math.floor;\n\n    function TextSelectorPropFactory(elem, data) {\n      this._currentTextLength = -1;\n      this.k = false;\n      this.data = data;\n      this.elem = elem;\n      this.comp = elem.comp;\n      this.finalS = 0;\n      this.finalE = 0;\n      this.initDynamicPropertyContainer(elem);\n      this.s = PropertyFactory.getProp(elem, data.s || {\n        k: 0\n      }, 0, 0, this);\n\n      if ('e' in data) {\n        this.e = PropertyFactory.getProp(elem, data.e, 0, 0, this);\n      } else {\n        this.e = {\n          v: 100\n        };\n      }\n\n      this.o = PropertyFactory.getProp(elem, data.o || {\n        k: 0\n      }, 0, 0, this);\n      this.xe = PropertyFactory.getProp(elem, data.xe || {\n        k: 0\n      }, 0, 0, this);\n      this.ne = PropertyFactory.getProp(elem, data.ne || {\n        k: 0\n      }, 0, 0, this);\n      this.sm = PropertyFactory.getProp(elem, data.sm || {\n        k: 100\n      }, 0, 0, this);\n      this.a = PropertyFactory.getProp(elem, data.a, 0, 0.01, this);\n\n      if (!this.dynamicProperties.length) {\n        this.getValue();\n      }\n    }\n\n    TextSelectorPropFactory.prototype = {\n      getMult: function getMult(ind) {\n        if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) {\n          this.getValue();\n        }\n\n        var x1 = 0;\n        var y1 = 0;\n        var x2 = 1;\n        var y2 = 1;\n\n        if (this.ne.v > 0) {\n          x1 = this.ne.v / 100.0;\n        } else {\n          y1 = -this.ne.v / 100.0;\n        }\n\n        if (this.xe.v > 0) {\n          x2 = 1.0 - this.xe.v / 100.0;\n        } else {\n          y2 = 1.0 + this.xe.v / 100.0;\n        }\n\n        var easer = BezierFactory.getBezierEasing(x1, y1, x2, y2).get;\n        var mult = 0;\n        var s = this.finalS;\n        var e = this.finalE;\n        var type = this.data.sh;\n\n        if (type === 2) {\n          if (e === s) {\n            mult = ind >= e ? 1 : 0;\n          } else {\n            mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));\n          }\n\n          mult = easer(mult);\n        } else if (type === 3) {\n          if (e === s) {\n            mult = ind >= e ? 0 : 1;\n          } else {\n            mult = 1 - max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));\n          }\n\n          mult = easer(mult);\n        } else if (type === 4) {\n          if (e === s) {\n            mult = 0;\n          } else {\n            mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));\n\n            if (mult < 0.5) {\n              mult *= 2;\n            } else {\n              mult = 1 - 2 * (mult - 0.5);\n            }\n          }\n\n          mult = easer(mult);\n        } else if (type === 5) {\n          if (e === s) {\n            mult = 0;\n          } else {\n            var tot = e - s;\n            /* ind += 0.5;\r\n                      mult = -4/(tot*tot)*(ind*ind)+(4/tot)*ind; */\n\n            ind = min(max(0, ind + 0.5 - s), e - s);\n            var x = -tot / 2 + ind;\n            var a = tot / 2;\n            mult = Math.sqrt(1 - x * x / (a * a));\n          }\n\n          mult = easer(mult);\n        } else if (type === 6) {\n          if (e === s) {\n            mult = 0;\n          } else {\n            ind = min(max(0, ind + 0.5 - s), e - s);\n            mult = (1 + Math.cos(Math.PI + Math.PI * 2 * ind / (e - s))) / 2; // eslint-disable-line\n          }\n\n          mult = easer(mult);\n        } else {\n          if (ind >= floor(s)) {\n            if (ind - s < 0) {\n              mult = max(0, min(min(e, 1) - (s - ind), 1));\n            } else {\n              mult = max(0, min(e - ind, 1));\n            }\n          }\n\n          mult = easer(mult);\n        } // Smoothness implementation.\n        // The smoothness represents a reduced range of the original [0; 1] range.\n        // if smoothness is 25%, the new range will be [0.375; 0.625]\n        // Steps are:\n        // - find the lower value of the new range (threshold)\n        // - if multiplier is smaller than that value, floor it to 0\n        // - if it is larger,\n        //     - subtract the threshold\n        //     - divide it by the smoothness (this will return the range to [0; 1])\n        // Note: If it doesn't work on some scenarios, consider applying it before the easer.\n\n\n        if (this.sm.v !== 100) {\n          var smoothness = this.sm.v * 0.01;\n\n          if (smoothness === 0) {\n            smoothness = 0.00000001;\n          }\n\n          var threshold = 0.5 - smoothness * 0.5;\n\n          if (mult < threshold) {\n            mult = 0;\n          } else {\n            mult = (mult - threshold) / smoothness;\n\n            if (mult > 1) {\n              mult = 1;\n            }\n          }\n        }\n\n        return mult * this.a.v;\n      },\n      getValue: function getValue(newCharsFlag) {\n        this.iterateDynamicProperties();\n        this._mdf = newCharsFlag || this._mdf;\n        this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;\n\n        if (newCharsFlag && this.data.r === 2) {\n          this.e.v = this._currentTextLength;\n        }\n\n        var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;\n        var o = this.o.v / divisor;\n        var s = this.s.v / divisor + o;\n        var e = this.e.v / divisor + o;\n\n        if (s > e) {\n          var _s = s;\n          s = e;\n          e = _s;\n        }\n\n        this.finalS = s;\n        this.finalE = e;\n      }\n    };\n    extendPrototype([DynamicPropertyContainer], TextSelectorPropFactory);\n\n    function getTextSelectorProp(elem, data, arr) {\n      return new TextSelectorPropFactory(elem, data, arr);\n    }\n\n    return {\n      getTextSelectorProp: getTextSelectorProp\n    };\n  }();\n\n  function TextAnimatorDataProperty(elem, animatorProps, container) {\n    var defaultData = {\n      propType: false\n    };\n    var getProp = PropertyFactory.getProp;\n    var textAnimatorAnimatables = animatorProps.a;\n    this.a = {\n      r: textAnimatorAnimatables.r ? getProp(elem, textAnimatorAnimatables.r, 0, degToRads, container) : defaultData,\n      rx: textAnimatorAnimatables.rx ? getProp(elem, textAnimatorAnimatables.rx, 0, degToRads, container) : defaultData,\n      ry: textAnimatorAnimatables.ry ? getProp(elem, textAnimatorAnimatables.ry, 0, degToRads, container) : defaultData,\n      sk: textAnimatorAnimatables.sk ? getProp(elem, textAnimatorAnimatables.sk, 0, degToRads, container) : defaultData,\n      sa: textAnimatorAnimatables.sa ? getProp(elem, textAnimatorAnimatables.sa, 0, degToRads, container) : defaultData,\n      s: textAnimatorAnimatables.s ? getProp(elem, textAnimatorAnimatables.s, 1, 0.01, container) : defaultData,\n      a: textAnimatorAnimatables.a ? getProp(elem, textAnimatorAnimatables.a, 1, 0, container) : defaultData,\n      o: textAnimatorAnimatables.o ? getProp(elem, textAnimatorAnimatables.o, 0, 0.01, container) : defaultData,\n      p: textAnimatorAnimatables.p ? getProp(elem, textAnimatorAnimatables.p, 1, 0, container) : defaultData,\n      sw: textAnimatorAnimatables.sw ? getProp(elem, textAnimatorAnimatables.sw, 0, 0, container) : defaultData,\n      sc: textAnimatorAnimatables.sc ? getProp(elem, textAnimatorAnimatables.sc, 1, 0, container) : defaultData,\n      fc: textAnimatorAnimatables.fc ? getProp(elem, textAnimatorAnimatables.fc, 1, 0, container) : defaultData,\n      fh: textAnimatorAnimatables.fh ? getProp(elem, textAnimatorAnimatables.fh, 0, 0, container) : defaultData,\n      fs: textAnimatorAnimatables.fs ? getProp(elem, textAnimatorAnimatables.fs, 0, 0.01, container) : defaultData,\n      fb: textAnimatorAnimatables.fb ? getProp(elem, textAnimatorAnimatables.fb, 0, 0.01, container) : defaultData,\n      t: textAnimatorAnimatables.t ? getProp(elem, textAnimatorAnimatables.t, 0, 0, container) : defaultData\n    };\n    this.s = TextSelectorProp.getTextSelectorProp(elem, animatorProps.s, container);\n    this.s.t = animatorProps.s.t;\n  }\n\n  function TextAnimatorProperty(textData, renderType, elem) {\n    this._isFirstFrame = true;\n    this._hasMaskedPath = false;\n    this._frameId = -1;\n    this._textData = textData;\n    this._renderType = renderType;\n    this._elem = elem;\n    this._animatorsData = createSizedArray(this._textData.a.length);\n    this._pathData = {};\n    this._moreOptions = {\n      alignment: {}\n    };\n    this.renderedLetters = [];\n    this.lettersChangedFlag = false;\n    this.initDynamicPropertyContainer(elem);\n  }\n\n  TextAnimatorProperty.prototype.searchProperties = function () {\n    var i;\n    var len = this._textData.a.length;\n    var animatorProps;\n    var getProp = PropertyFactory.getProp;\n\n    for (i = 0; i < len; i += 1) {\n      animatorProps = this._textData.a[i];\n      this._animatorsData[i] = new TextAnimatorDataProperty(this._elem, animatorProps, this);\n    }\n\n    if (this._textData.p && 'm' in this._textData.p) {\n      this._pathData = {\n        a: getProp(this._elem, this._textData.p.a, 0, 0, this),\n        f: getProp(this._elem, this._textData.p.f, 0, 0, this),\n        l: getProp(this._elem, this._textData.p.l, 0, 0, this),\n        r: getProp(this._elem, this._textData.p.r, 0, 0, this),\n        p: getProp(this._elem, this._textData.p.p, 0, 0, this),\n        m: this._elem.maskManager.getMaskProperty(this._textData.p.m)\n      };\n      this._hasMaskedPath = true;\n    } else {\n      this._hasMaskedPath = false;\n    }\n\n    this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this);\n  };\n\n  TextAnimatorProperty.prototype.getMeasures = function (documentData, lettersChangedFlag) {\n    this.lettersChangedFlag = lettersChangedFlag;\n\n    if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {\n      return;\n    }\n\n    this._isFirstFrame = false;\n    var alignment = this._moreOptions.alignment.v;\n    var animators = this._animatorsData;\n    var textData = this._textData;\n    var matrixHelper = this.mHelper;\n    var renderType = this._renderType;\n    var renderedLettersCount = this.renderedLetters.length;\n    var xPos;\n    var yPos;\n    var i;\n    var len;\n    var letters = documentData.l;\n    var pathInfo;\n    var currentLength;\n    var currentPoint;\n    var segmentLength;\n    var flag;\n    var pointInd;\n    var segmentInd;\n    var prevPoint;\n    var points;\n    var segments;\n    var partialLength;\n    var totalLength;\n    var perc;\n    var tanAngle;\n    var mask;\n\n    if (this._hasMaskedPath) {\n      mask = this._pathData.m;\n\n      if (!this._pathData.n || this._pathData._mdf) {\n        var paths = mask.v;\n\n        if (this._pathData.r.v) {\n          paths = paths.reverse();\n        } // TODO: release bezier data cached from previous pathInfo: this._pathData.pi\n\n\n        pathInfo = {\n          tLength: 0,\n          segments: []\n        };\n        len = paths._length - 1;\n        var bezierData;\n        totalLength = 0;\n\n        for (i = 0; i < len; i += 1) {\n          bezierData = bez.buildBezierData(paths.v[i], paths.v[i + 1], [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]], [paths.i[i + 1][0] - paths.v[i + 1][0], paths.i[i + 1][1] - paths.v[i + 1][1]]);\n          pathInfo.tLength += bezierData.segmentLength;\n          pathInfo.segments.push(bezierData);\n          totalLength += bezierData.segmentLength;\n        }\n\n        i = len;\n\n        if (mask.v.c) {\n          bezierData = bez.buildBezierData(paths.v[i], paths.v[0], [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]], [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]);\n          pathInfo.tLength += bezierData.segmentLength;\n          pathInfo.segments.push(bezierData);\n          totalLength += bezierData.segmentLength;\n        }\n\n        this._pathData.pi = pathInfo;\n      }\n\n      pathInfo = this._pathData.pi;\n      currentLength = this._pathData.f.v;\n      segmentInd = 0;\n      pointInd = 1;\n      segmentLength = 0;\n      flag = true;\n      segments = pathInfo.segments;\n\n      if (currentLength < 0 && mask.v.c) {\n        if (pathInfo.tLength < Math.abs(currentLength)) {\n          currentLength = -Math.abs(currentLength) % pathInfo.tLength;\n        }\n\n        segmentInd = segments.length - 1;\n        points = segments[segmentInd].points;\n        pointInd = points.length - 1;\n\n        while (currentLength < 0) {\n          currentLength += points[pointInd].partialLength;\n          pointInd -= 1;\n\n          if (pointInd < 0) {\n            segmentInd -= 1;\n            points = segments[segmentInd].points;\n            pointInd = points.length - 1;\n          }\n        }\n      }\n\n      points = segments[segmentInd].points;\n      prevPoint = points[pointInd - 1];\n      currentPoint = points[pointInd];\n      partialLength = currentPoint.partialLength;\n    }\n\n    len = letters.length;\n    xPos = 0;\n    yPos = 0;\n    var yOff = documentData.finalSize * 1.2 * 0.714;\n    var firstLine = true;\n    var animatorProps;\n    var animatorSelector;\n    var j;\n    var jLen;\n    var letterValue;\n    jLen = animators.length;\n    var mult;\n    var ind = -1;\n    var offf;\n    var xPathPos;\n    var yPathPos;\n    var initPathPos = currentLength;\n    var initSegmentInd = segmentInd;\n    var initPointInd = pointInd;\n    var currentLine = -1;\n    var elemOpacity;\n    var sc;\n    var sw;\n    var fc;\n    var k;\n    var letterSw;\n    var letterSc;\n    var letterFc;\n    var letterM = '';\n    var letterP = this.defaultPropsArray;\n    var letterO; //\n\n    if (documentData.j === 2 || documentData.j === 1) {\n      var animatorJustifyOffset = 0;\n      var animatorFirstCharOffset = 0;\n      var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;\n      var lastIndex = 0;\n      var isNewLine = true;\n\n      for (i = 0; i < len; i += 1) {\n        if (letters[i].n) {\n          if (animatorJustifyOffset) {\n            animatorJustifyOffset += animatorFirstCharOffset;\n          }\n\n          while (lastIndex < i) {\n            letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;\n            lastIndex += 1;\n          }\n\n          animatorJustifyOffset = 0;\n          isNewLine = true;\n        } else {\n          for (j = 0; j < jLen; j += 1) {\n            animatorProps = animators[j].a;\n\n            if (animatorProps.t.propType) {\n              if (isNewLine && documentData.j === 2) {\n                animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;\n              }\n\n              animatorSelector = animators[j].s;\n              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n\n              if (mult.length) {\n                animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult;\n              } else {\n                animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult;\n              }\n            }\n          }\n\n          isNewLine = false;\n        }\n      }\n\n      if (animatorJustifyOffset) {\n        animatorJustifyOffset += animatorFirstCharOffset;\n      }\n\n      while (lastIndex < i) {\n        letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;\n        lastIndex += 1;\n      }\n    } //\n\n\n    for (i = 0; i < len; i += 1) {\n      matrixHelper.reset();\n      elemOpacity = 1;\n\n      if (letters[i].n) {\n        xPos = 0;\n        yPos += documentData.yOffset;\n        yPos += firstLine ? 1 : 0;\n        currentLength = initPathPos;\n        firstLine = false;\n\n        if (this._hasMaskedPath) {\n          segmentInd = initSegmentInd;\n          pointInd = initPointInd;\n          points = segments[segmentInd].points;\n          prevPoint = points[pointInd - 1];\n          currentPoint = points[pointInd];\n          partialLength = currentPoint.partialLength;\n          segmentLength = 0;\n        }\n\n        letterM = '';\n        letterFc = '';\n        letterSw = '';\n        letterO = '';\n        letterP = this.defaultPropsArray;\n      } else {\n        if (this._hasMaskedPath) {\n          if (currentLine !== letters[i].line) {\n            switch (documentData.j) {\n              case 1:\n                currentLength += totalLength - documentData.lineWidths[letters[i].line];\n                break;\n\n              case 2:\n                currentLength += (totalLength - documentData.lineWidths[letters[i].line]) / 2;\n                break;\n\n              default:\n                break;\n            }\n\n            currentLine = letters[i].line;\n          }\n\n          if (ind !== letters[i].ind) {\n            if (letters[ind]) {\n              currentLength += letters[ind].extra;\n            }\n\n            currentLength += letters[i].an / 2;\n            ind = letters[i].ind;\n          }\n\n          currentLength += alignment[0] * letters[i].an * 0.005;\n          var animatorOffset = 0;\n\n          for (j = 0; j < jLen; j += 1) {\n            animatorProps = animators[j].a;\n\n            if (animatorProps.p.propType) {\n              animatorSelector = animators[j].s;\n              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n\n              if (mult.length) {\n                animatorOffset += animatorProps.p.v[0] * mult[0];\n              } else {\n                animatorOffset += animatorProps.p.v[0] * mult;\n              }\n            }\n\n            if (animatorProps.a.propType) {\n              animatorSelector = animators[j].s;\n              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n\n              if (mult.length) {\n                animatorOffset += animatorProps.a.v[0] * mult[0];\n              } else {\n                animatorOffset += animatorProps.a.v[0] * mult;\n              }\n            }\n          }\n\n          flag = true; // Force alignment only works with a single line for now\n\n          if (this._pathData.a.v) {\n            currentLength = letters[0].an * 0.5 + (totalLength - this._pathData.f.v - letters[0].an * 0.5 - letters[letters.length - 1].an * 0.5) * ind / (len - 1);\n            currentLength += this._pathData.f.v;\n          }\n\n          while (flag) {\n            if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {\n              perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;\n              xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;\n              yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;\n              matrixHelper.translate(-alignment[0] * letters[i].an * 0.005, -(alignment[1] * yOff) * 0.01);\n              flag = false;\n            } else if (points) {\n              segmentLength += currentPoint.partialLength;\n              pointInd += 1;\n\n              if (pointInd >= points.length) {\n                pointInd = 0;\n                segmentInd += 1;\n\n                if (!segments[segmentInd]) {\n                  if (mask.v.c) {\n                    pointInd = 0;\n                    segmentInd = 0;\n                    points = segments[segmentInd].points;\n                  } else {\n                    segmentLength -= currentPoint.partialLength;\n                    points = null;\n                  }\n                } else {\n                  points = segments[segmentInd].points;\n                }\n              }\n\n              if (points) {\n                prevPoint = currentPoint;\n                currentPoint = points[pointInd];\n                partialLength = currentPoint.partialLength;\n              }\n            }\n          }\n\n          offf = letters[i].an / 2 - letters[i].add;\n          matrixHelper.translate(-offf, 0, 0);\n        } else {\n          offf = letters[i].an / 2 - letters[i].add;\n          matrixHelper.translate(-offf, 0, 0); // Grouping alignment\n\n          matrixHelper.translate(-alignment[0] * letters[i].an * 0.005, -alignment[1] * yOff * 0.01, 0);\n        }\n\n        for (j = 0; j < jLen; j += 1) {\n          animatorProps = animators[j].a;\n\n          if (animatorProps.t.propType) {\n            animatorSelector = animators[j].s;\n            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars); // This condition is to prevent applying tracking to first character in each line. Might be better to use a boolean \"isNewLine\"\n\n            if (xPos !== 0 || documentData.j !== 0) {\n              if (this._hasMaskedPath) {\n                if (mult.length) {\n                  currentLength += animatorProps.t.v * mult[0];\n                } else {\n                  currentLength += animatorProps.t.v * mult;\n                }\n              } else if (mult.length) {\n                xPos += animatorProps.t.v * mult[0];\n              } else {\n                xPos += animatorProps.t.v * mult;\n              }\n            }\n          }\n        }\n\n        if (documentData.strokeWidthAnim) {\n          sw = documentData.sw || 0;\n        }\n\n        if (documentData.strokeColorAnim) {\n          if (documentData.sc) {\n            sc = [documentData.sc[0], documentData.sc[1], documentData.sc[2]];\n          } else {\n            sc = [0, 0, 0];\n          }\n        }\n\n        if (documentData.fillColorAnim && documentData.fc) {\n          fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]];\n        }\n\n        for (j = 0; j < jLen; j += 1) {\n          animatorProps = animators[j].a;\n\n          if (animatorProps.a.propType) {\n            animatorSelector = animators[j].s;\n            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n\n            if (mult.length) {\n              matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]);\n            } else {\n              matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult);\n            }\n          }\n        }\n\n        for (j = 0; j < jLen; j += 1) {\n          animatorProps = animators[j].a;\n\n          if (animatorProps.s.propType) {\n            animatorSelector = animators[j].s;\n            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n\n            if (mult.length) {\n              matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult[0], 1 + (animatorProps.s.v[1] - 1) * mult[1], 1);\n            } else {\n              matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult, 1 + (animatorProps.s.v[1] - 1) * mult, 1);\n            }\n          }\n        }\n\n        for (j = 0; j < jLen; j += 1) {\n          animatorProps = animators[j].a;\n          animatorSelector = animators[j].s;\n          mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n\n          if (animatorProps.sk.propType) {\n            if (mult.length) {\n              matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);\n            } else {\n              matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);\n            }\n          }\n\n          if (animatorProps.r.propType) {\n            if (mult.length) {\n              matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);\n            } else {\n              matrixHelper.rotateZ(-animatorProps.r.v * mult);\n            }\n          }\n\n          if (animatorProps.ry.propType) {\n            if (mult.length) {\n              matrixHelper.rotateY(animatorProps.ry.v * mult[1]);\n            } else {\n              matrixHelper.rotateY(animatorProps.ry.v * mult);\n            }\n          }\n\n          if (animatorProps.rx.propType) {\n            if (mult.length) {\n              matrixHelper.rotateX(animatorProps.rx.v * mult[0]);\n            } else {\n              matrixHelper.rotateX(animatorProps.rx.v * mult);\n            }\n          }\n\n          if (animatorProps.o.propType) {\n            if (mult.length) {\n              elemOpacity += (animatorProps.o.v * mult[0] - elemOpacity) * mult[0];\n            } else {\n              elemOpacity += (animatorProps.o.v * mult - elemOpacity) * mult;\n            }\n          }\n\n          if (documentData.strokeWidthAnim && animatorProps.sw.propType) {\n            if (mult.length) {\n              sw += animatorProps.sw.v * mult[0];\n            } else {\n              sw += animatorProps.sw.v * mult;\n            }\n          }\n\n          if (documentData.strokeColorAnim && animatorProps.sc.propType) {\n            for (k = 0; k < 3; k += 1) {\n              if (mult.length) {\n                sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult[0];\n              } else {\n                sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult;\n              }\n            }\n          }\n\n          if (documentData.fillColorAnim && documentData.fc) {\n            if (animatorProps.fc.propType) {\n              for (k = 0; k < 3; k += 1) {\n                if (mult.length) {\n                  fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult[0];\n                } else {\n                  fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult;\n                }\n              }\n            }\n\n            if (animatorProps.fh.propType) {\n              if (mult.length) {\n                fc = addHueToRGB(fc, animatorProps.fh.v * mult[0]);\n              } else {\n                fc = addHueToRGB(fc, animatorProps.fh.v * mult);\n              }\n            }\n\n            if (animatorProps.fs.propType) {\n              if (mult.length) {\n                fc = addSaturationToRGB(fc, animatorProps.fs.v * mult[0]);\n              } else {\n                fc = addSaturationToRGB(fc, animatorProps.fs.v * mult);\n              }\n            }\n\n            if (animatorProps.fb.propType) {\n              if (mult.length) {\n                fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult[0]);\n              } else {\n                fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult);\n              }\n            }\n          }\n        }\n\n        for (j = 0; j < jLen; j += 1) {\n          animatorProps = animators[j].a;\n\n          if (animatorProps.p.propType) {\n            animatorSelector = animators[j].s;\n            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n\n            if (this._hasMaskedPath) {\n              if (mult.length) {\n                matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);\n              } else {\n                matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);\n              }\n            } else if (mult.length) {\n              matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);\n            } else {\n              matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);\n            }\n          }\n        }\n\n        if (documentData.strokeWidthAnim) {\n          letterSw = sw < 0 ? 0 : sw;\n        }\n\n        if (documentData.strokeColorAnim) {\n          letterSc = 'rgb(' + Math.round(sc[0] * 255) + ',' + Math.round(sc[1] * 255) + ',' + Math.round(sc[2] * 255) + ')';\n        }\n\n        if (documentData.fillColorAnim && documentData.fc) {\n          letterFc = 'rgb(' + Math.round(fc[0] * 255) + ',' + Math.round(fc[1] * 255) + ',' + Math.round(fc[2] * 255) + ')';\n        }\n\n        if (this._hasMaskedPath) {\n          matrixHelper.translate(0, -documentData.ls);\n          matrixHelper.translate(0, alignment[1] * yOff * 0.01 + yPos, 0);\n\n          if (this._pathData.p.v) {\n            tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);\n            var rot = Math.atan(tanAngle) * 180 / Math.PI;\n\n            if (currentPoint.point[0] < prevPoint.point[0]) {\n              rot += 180;\n            }\n\n            matrixHelper.rotate(-rot * Math.PI / 180);\n          }\n\n          matrixHelper.translate(xPathPos, yPathPos, 0);\n          currentLength -= alignment[0] * letters[i].an * 0.005;\n\n          if (letters[i + 1] && ind !== letters[i + 1].ind) {\n            currentLength += letters[i].an / 2;\n            currentLength += documentData.tr * 0.001 * documentData.finalSize;\n          }\n        } else {\n          matrixHelper.translate(xPos, yPos, 0);\n\n          if (documentData.ps) {\n            // matrixHelper.translate(documentData.ps[0],documentData.ps[1],0);\n            matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);\n          }\n\n          switch (documentData.j) {\n            case 1:\n              matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]), 0, 0);\n              break;\n\n            case 2:\n              matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]) / 2, 0, 0);\n              break;\n\n            default:\n              break;\n          }\n\n          matrixHelper.translate(0, -documentData.ls);\n          matrixHelper.translate(offf, 0, 0);\n          matrixHelper.translate(alignment[0] * letters[i].an * 0.005, alignment[1] * yOff * 0.01, 0);\n          xPos += letters[i].l + documentData.tr * 0.001 * documentData.finalSize;\n        }\n\n        if (renderType === 'html') {\n          letterM = matrixHelper.toCSS();\n        } else if (renderType === 'svg') {\n          letterM = matrixHelper.to2dCSS();\n        } else {\n          letterP = [matrixHelper.props[0], matrixHelper.props[1], matrixHelper.props[2], matrixHelper.props[3], matrixHelper.props[4], matrixHelper.props[5], matrixHelper.props[6], matrixHelper.props[7], matrixHelper.props[8], matrixHelper.props[9], matrixHelper.props[10], matrixHelper.props[11], matrixHelper.props[12], matrixHelper.props[13], matrixHelper.props[14], matrixHelper.props[15]];\n        }\n\n        letterO = elemOpacity;\n      }\n\n      if (renderedLettersCount <= i) {\n        letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP);\n        this.renderedLetters.push(letterValue);\n        renderedLettersCount += 1;\n        this.lettersChangedFlag = true;\n      } else {\n        letterValue = this.renderedLetters[i];\n        this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;\n      }\n    }\n  };\n\n  TextAnimatorProperty.prototype.getValue = function () {\n    if (this._elem.globalData.frameId === this._frameId) {\n      return;\n    }\n\n    this._frameId = this._elem.globalData.frameId;\n    this.iterateDynamicProperties();\n  };\n\n  TextAnimatorProperty.prototype.mHelper = new Matrix();\n  TextAnimatorProperty.prototype.defaultPropsArray = [];\n  extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);\n\n  function ITextElement() {}\n\n  ITextElement.prototype.initElement = function (data, globalData, comp) {\n    this.lettersChangedFlag = true;\n    this.initFrame();\n    this.initBaseData(data, globalData, comp);\n    this.textProperty = new TextProperty(this, data.t, this.dynamicProperties);\n    this.textAnimator = new TextAnimatorProperty(data.t, this.renderType, this);\n    this.initTransform(data, globalData, comp);\n    this.initHierarchy();\n    this.initRenderable();\n    this.initRendererElement();\n    this.createContainerElements();\n    this.createRenderableComponents();\n    this.createContent();\n    this.hide();\n    this.textAnimator.searchProperties(this.dynamicProperties);\n  };\n\n  ITextElement.prototype.prepareFrame = function (num) {\n    this._mdf = false;\n    this.prepareRenderableFrame(num);\n    this.prepareProperties(num, this.isInRange);\n  };\n\n  ITextElement.prototype.createPathShape = function (matrixHelper, shapes) {\n    var j;\n    var jLen = shapes.length;\n    var pathNodes;\n    var shapeStr = '';\n\n    for (j = 0; j < jLen; j += 1) {\n      if (shapes[j].ty === 'sh') {\n        pathNodes = shapes[j].ks.k;\n        shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);\n      }\n    }\n\n    return shapeStr;\n  };\n\n  ITextElement.prototype.updateDocumentData = function (newData, index) {\n    this.textProperty.updateDocumentData(newData, index);\n  };\n\n  ITextElement.prototype.canResizeFont = function (_canResize) {\n    this.textProperty.canResizeFont(_canResize);\n  };\n\n  ITextElement.prototype.setMinimumFontSize = function (_fontSize) {\n    this.textProperty.setMinimumFontSize(_fontSize);\n  };\n\n  ITextElement.prototype.applyTextPropertiesToMatrix = function (documentData, matrixHelper, lineNumber, xPos, yPos) {\n    if (documentData.ps) {\n      matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);\n    }\n\n    matrixHelper.translate(0, -documentData.ls, 0);\n\n    switch (documentData.j) {\n      case 1:\n        matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);\n        break;\n\n      case 2:\n        matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0);\n        break;\n\n      default:\n        break;\n    }\n\n    matrixHelper.translate(xPos, yPos, 0);\n  };\n\n  ITextElement.prototype.buildColor = function (colorData) {\n    return 'rgb(' + Math.round(colorData[0] * 255) + ',' + Math.round(colorData[1] * 255) + ',' + Math.round(colorData[2] * 255) + ')';\n  };\n\n  ITextElement.prototype.emptyProp = new LetterProps();\n\n  ITextElement.prototype.destroy = function () {};\n\n  ITextElement.prototype.validateText = function () {\n    if (this.textProperty._mdf || this.textProperty._isFirstFrame) {\n      this.buildNewText();\n      this.textProperty._isFirstFrame = false;\n      this.textProperty._mdf = false;\n    }\n  };\n\n  var emptyShapeData = {\n    shapes: []\n  };\n\n  function SVGTextLottieElement(data, globalData, comp) {\n    this.textSpans = [];\n    this.renderType = 'svg';\n    this.initElement(data, globalData, comp);\n  }\n\n  extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement);\n\n  SVGTextLottieElement.prototype.createContent = function () {\n    if (this.data.singleShape && !this.globalData.fontManager.chars) {\n      this.textContainer = createNS('text');\n    }\n  };\n\n  SVGTextLottieElement.prototype.buildTextContents = function (textArray) {\n    var i = 0;\n    var len = textArray.length;\n    var textContents = [];\n    var currentTextContent = '';\n\n    while (i < len) {\n      if (textArray[i] === String.fromCharCode(13) || textArray[i] === String.fromCharCode(3)) {\n        textContents.push(currentTextContent);\n        currentTextContent = '';\n      } else {\n        currentTextContent += textArray[i];\n      }\n\n      i += 1;\n    }\n\n    textContents.push(currentTextContent);\n    return textContents;\n  };\n\n  SVGTextLottieElement.prototype.buildShapeData = function (data, scale) {\n    // data should probably be cloned to apply scale separately to each instance of a text on different layers\n    // but since text internal content gets only rendered once and then it's never rerendered,\n    // it's probably safe not to clone data and reuse always the same instance even if the object is mutated.\n    // Avoiding cloning is preferred since cloning each character shape data is expensive\n    if (data.shapes && data.shapes.length) {\n      var shape = data.shapes[0];\n\n      if (shape.it) {\n        var shapeItem = shape.it[shape.it.length - 1];\n\n        if (shapeItem.s) {\n          shapeItem.s.k[0] = scale;\n          shapeItem.s.k[1] = scale;\n        }\n      }\n    }\n\n    return data;\n  };\n\n  SVGTextLottieElement.prototype.buildNewText = function () {\n    this.addDynamicProperty(this);\n    var i;\n    var len;\n    var documentData = this.textProperty.currentData;\n    this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);\n\n    if (documentData.fc) {\n      this.layerElement.setAttribute('fill', this.buildColor(documentData.fc));\n    } else {\n      this.layerElement.setAttribute('fill', 'rgba(0,0,0,0)');\n    }\n\n    if (documentData.sc) {\n      this.layerElement.setAttribute('stroke', this.buildColor(documentData.sc));\n      this.layerElement.setAttribute('stroke-width', documentData.sw);\n    }\n\n    this.layerElement.setAttribute('font-size', documentData.finalSize);\n    var fontData = this.globalData.fontManager.getFontByName(documentData.f);\n\n    if (fontData.fClass) {\n      this.layerElement.setAttribute('class', fontData.fClass);\n    } else {\n      this.layerElement.setAttribute('font-family', fontData.fFamily);\n      var fWeight = documentData.fWeight;\n      var fStyle = documentData.fStyle;\n      this.layerElement.setAttribute('font-style', fStyle);\n      this.layerElement.setAttribute('font-weight', fWeight);\n    }\n\n    this.layerElement.setAttribute('aria-label', documentData.t);\n    var letters = documentData.l || [];\n    var usesGlyphs = !!this.globalData.fontManager.chars;\n    len = letters.length;\n    var tSpan;\n    var matrixHelper = this.mHelper;\n    var shapeStr = '';\n    var singleShape = this.data.singleShape;\n    var xPos = 0;\n    var yPos = 0;\n    var firstLine = true;\n    var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;\n\n    if (singleShape && !usesGlyphs && !documentData.sz) {\n      var tElement = this.textContainer;\n      var justify = 'start';\n\n      switch (documentData.j) {\n        case 1:\n          justify = 'end';\n          break;\n\n        case 2:\n          justify = 'middle';\n          break;\n\n        default:\n          justify = 'start';\n          break;\n      }\n\n      tElement.setAttribute('text-anchor', justify);\n      tElement.setAttribute('letter-spacing', trackingOffset);\n      var textContent = this.buildTextContents(documentData.finalText);\n      len = textContent.length;\n      yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;\n\n      for (i = 0; i < len; i += 1) {\n        tSpan = this.textSpans[i].span || createNS('tspan');\n        tSpan.textContent = textContent[i];\n        tSpan.setAttribute('x', 0);\n        tSpan.setAttribute('y', yPos);\n        tSpan.style.display = 'inherit';\n        tElement.appendChild(tSpan);\n\n        if (!this.textSpans[i]) {\n          this.textSpans[i] = {\n            span: null,\n            glyph: null\n          };\n        }\n\n        this.textSpans[i].span = tSpan;\n        yPos += documentData.finalLineHeight;\n      }\n\n      this.layerElement.appendChild(tElement);\n    } else {\n      var cachedSpansLength = this.textSpans.length;\n      var charData;\n\n      for (i = 0; i < len; i += 1) {\n        if (!this.textSpans[i]) {\n          this.textSpans[i] = {\n            span: null,\n            childSpan: null,\n            glyph: null\n          };\n        }\n\n        if (!usesGlyphs || !singleShape || i === 0) {\n          tSpan = cachedSpansLength > i ? this.textSpans[i].span : createNS(usesGlyphs ? 'g' : 'text');\n\n          if (cachedSpansLength <= i) {\n            tSpan.setAttribute('stroke-linecap', 'butt');\n            tSpan.setAttribute('stroke-linejoin', 'round');\n            tSpan.setAttribute('stroke-miterlimit', '4');\n            this.textSpans[i].span = tSpan;\n\n            if (usesGlyphs) {\n              var childSpan = createNS('g');\n              tSpan.appendChild(childSpan);\n              this.textSpans[i].childSpan = childSpan;\n            }\n\n            this.textSpans[i].span = tSpan;\n            this.layerElement.appendChild(tSpan);\n          }\n\n          tSpan.style.display = 'inherit';\n        }\n\n        matrixHelper.reset();\n\n        if (singleShape) {\n          if (letters[i].n) {\n            xPos = -trackingOffset;\n            yPos += documentData.yOffset;\n            yPos += firstLine ? 1 : 0;\n            firstLine = false;\n          }\n\n          this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);\n          xPos += letters[i].l || 0; // xPos += letters[i].val === ' ' ? 0 : trackingOffset;\n\n          xPos += trackingOffset;\n        }\n\n        if (usesGlyphs) {\n          charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);\n          var glyphElement; // t === 1 means the character has been replaced with an animated shaped\n\n          if (charData.t === 1) {\n            glyphElement = new SVGCompElement(charData.data, this.globalData, this);\n          } else {\n            var data = emptyShapeData;\n\n            if (charData.data && charData.data.shapes) {\n              data = this.buildShapeData(charData.data, documentData.finalSize);\n            }\n\n            glyphElement = new SVGShapeElement(data, this.globalData, this);\n          }\n\n          if (this.textSpans[i].glyph) {\n            var glyph = this.textSpans[i].glyph;\n            this.textSpans[i].childSpan.removeChild(glyph.layerElement);\n            glyph.destroy();\n          }\n\n          this.textSpans[i].glyph = glyphElement;\n          glyphElement._debug = true;\n          glyphElement.prepareFrame(0);\n          glyphElement.renderFrame();\n          this.textSpans[i].childSpan.appendChild(glyphElement.layerElement); // when using animated shapes, the layer will be scaled instead of replacing the internal scale\n          // this might have issues with strokes and might need a different solution\n\n          if (charData.t === 1) {\n            this.textSpans[i].childSpan.setAttribute('transform', 'scale(' + documentData.finalSize / 100 + ',' + documentData.finalSize / 100 + ')');\n          }\n        } else {\n          if (singleShape) {\n            tSpan.setAttribute('transform', 'translate(' + matrixHelper.props[12] + ',' + matrixHelper.props[13] + ')');\n          }\n\n          tSpan.textContent = letters[i].val;\n          tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');\n        } //\n\n      }\n\n      if (singleShape && tSpan) {\n        tSpan.setAttribute('d', shapeStr);\n      }\n    }\n\n    while (i < this.textSpans.length) {\n      this.textSpans[i].span.style.display = 'none';\n      i += 1;\n    }\n\n    this._sizeChanged = true;\n  };\n\n  SVGTextLottieElement.prototype.sourceRectAtTime = function () {\n    this.prepareFrame(this.comp.renderedFrame - this.data.st);\n    this.renderInnerContent();\n\n    if (this._sizeChanged) {\n      this._sizeChanged = false;\n      var textBox = this.layerElement.getBBox();\n      this.bbox = {\n        top: textBox.y,\n        left: textBox.x,\n        width: textBox.width,\n        height: textBox.height\n      };\n    }\n\n    return this.bbox;\n  };\n\n  SVGTextLottieElement.prototype.getValue = function () {\n    var i;\n    var len = this.textSpans.length;\n    var glyphElement;\n    this.renderedFrame = this.comp.renderedFrame;\n\n    for (i = 0; i < len; i += 1) {\n      glyphElement = this.textSpans[i].glyph;\n\n      if (glyphElement) {\n        glyphElement.prepareFrame(this.comp.renderedFrame - this.data.st);\n\n        if (glyphElement._mdf) {\n          this._mdf = true;\n        }\n      }\n    }\n  };\n\n  SVGTextLottieElement.prototype.renderInnerContent = function () {\n    this.validateText();\n\n    if (!this.data.singleShape || this._mdf) {\n      this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);\n\n      if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {\n        this._sizeChanged = true;\n        var i;\n        var len;\n        var renderedLetters = this.textAnimator.renderedLetters;\n        var letters = this.textProperty.currentData.l;\n        len = letters.length;\n        var renderedLetter;\n        var textSpan;\n        var glyphElement;\n\n        for (i = 0; i < len; i += 1) {\n          if (!letters[i].n) {\n            renderedLetter = renderedLetters[i];\n            textSpan = this.textSpans[i].span;\n            glyphElement = this.textSpans[i].glyph;\n\n            if (glyphElement) {\n              glyphElement.renderFrame();\n            }\n\n            if (renderedLetter._mdf.m) {\n              textSpan.setAttribute('transform', renderedLetter.m);\n            }\n\n            if (renderedLetter._mdf.o) {\n              textSpan.setAttribute('opacity', renderedLetter.o);\n            }\n\n            if (renderedLetter._mdf.sw) {\n              textSpan.setAttribute('stroke-width', renderedLetter.sw);\n            }\n\n            if (renderedLetter._mdf.sc) {\n              textSpan.setAttribute('stroke', renderedLetter.sc);\n            }\n\n            if (renderedLetter._mdf.fc) {\n              textSpan.setAttribute('fill', renderedLetter.fc);\n            }\n          }\n        }\n      }\n    }\n  };\n\n  function ISolidElement(data, globalData, comp) {\n    this.initElement(data, globalData, comp);\n  }\n\n  extendPrototype([IImageElement], ISolidElement);\n\n  ISolidElement.prototype.createContent = function () {\n    var rect = createNS('rect'); /// /rect.style.width = this.data.sw;\n    /// /rect.style.height = this.data.sh;\n    /// /rect.style.fill = this.data.sc;\n\n    rect.setAttribute('width', this.data.sw);\n    rect.setAttribute('height', this.data.sh);\n    rect.setAttribute('fill', this.data.sc);\n    this.layerElement.appendChild(rect);\n  };\n\n  function NullElement(data, globalData, comp) {\n    this.initFrame();\n    this.initBaseData(data, globalData, comp);\n    this.initFrame();\n    this.initTransform(data, globalData, comp);\n    this.initHierarchy();\n  }\n\n  NullElement.prototype.prepareFrame = function (num) {\n    this.prepareProperties(num, true);\n  };\n\n  NullElement.prototype.renderFrame = function () {};\n\n  NullElement.prototype.getBaseElement = function () {\n    return null;\n  };\n\n  NullElement.prototype.destroy = function () {};\n\n  NullElement.prototype.sourceRectAtTime = function () {};\n\n  NullElement.prototype.hide = function () {};\n\n  extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);\n\n  function SVGRendererBase() {}\n\n  extendPrototype([BaseRenderer], SVGRendererBase);\n\n  SVGRendererBase.prototype.createNull = function (data) {\n    return new NullElement(data, this.globalData, this);\n  };\n\n  SVGRendererBase.prototype.createShape = function (data) {\n    return new SVGShapeElement(data, this.globalData, this);\n  };\n\n  SVGRendererBase.prototype.createText = function (data) {\n    return new SVGTextLottieElement(data, this.globalData, this);\n  };\n\n  SVGRendererBase.prototype.createImage = function (data) {\n    return new IImageElement(data, this.globalData, this);\n  };\n\n  SVGRendererBase.prototype.createSolid = function (data) {\n    return new ISolidElement(data, this.globalData, this);\n  };\n\n  SVGRendererBase.prototype.configAnimation = function (animData) {\n    this.svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n    this.svgElement.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');\n\n    if (this.renderConfig.viewBoxSize) {\n      this.svgElement.setAttribute('viewBox', this.renderConfig.viewBoxSize);\n    } else {\n      this.svgElement.setAttribute('viewBox', '0 0 ' + animData.w + ' ' + animData.h);\n    }\n\n    if (!this.renderConfig.viewBoxOnly) {\n      this.svgElement.setAttribute('width', animData.w);\n      this.svgElement.setAttribute('height', animData.h);\n      this.svgElement.style.width = '100%';\n      this.svgElement.style.height = '100%';\n      this.svgElement.style.transform = 'translate3d(0,0,0)';\n      this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility;\n    }\n\n    if (this.renderConfig.width) {\n      this.svgElement.setAttribute('width', this.renderConfig.width);\n    }\n\n    if (this.renderConfig.height) {\n      this.svgElement.setAttribute('height', this.renderConfig.height);\n    }\n\n    if (this.renderConfig.className) {\n      this.svgElement.setAttribute('class', this.renderConfig.className);\n    }\n\n    if (this.renderConfig.id) {\n      this.svgElement.setAttribute('id', this.renderConfig.id);\n    }\n\n    if (this.renderConfig.focusable !== undefined) {\n      this.svgElement.setAttribute('focusable', this.renderConfig.focusable);\n    }\n\n    this.svgElement.setAttribute('preserveAspectRatio', this.renderConfig.preserveAspectRatio); // this.layerElement.style.transform = 'translate3d(0,0,0)';\n    // this.layerElement.style.transformOrigin = this.layerElement.style.mozTransformOrigin = this.layerElement.style.webkitTransformOrigin = this.layerElement.style['-webkit-transform'] = \"0px 0px 0px\";\n\n    this.animationItem.wrapper.appendChild(this.svgElement); // Mask animation\n\n    var defs = this.globalData.defs;\n    this.setupGlobalData(animData, defs);\n    this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;\n    this.data = animData;\n    var maskElement = createNS('clipPath');\n    var rect = createNS('rect');\n    rect.setAttribute('width', animData.w);\n    rect.setAttribute('height', animData.h);\n    rect.setAttribute('x', 0);\n    rect.setAttribute('y', 0);\n    var maskId = createElementID();\n    maskElement.setAttribute('id', maskId);\n    maskElement.appendChild(rect);\n    this.layerElement.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + maskId + ')');\n    defs.appendChild(maskElement);\n    this.layers = animData.layers;\n    this.elements = createSizedArray(animData.layers.length);\n  };\n\n  SVGRendererBase.prototype.destroy = function () {\n    if (this.animationItem.wrapper) {\n      this.animationItem.wrapper.innerText = '';\n    }\n\n    this.layerElement = null;\n    this.globalData.defs = null;\n    var i;\n    var len = this.layers ? this.layers.length : 0;\n\n    for (i = 0; i < len; i += 1) {\n      if (this.elements[i] && this.elements[i].destroy) {\n        this.elements[i].destroy();\n      }\n    }\n\n    this.elements.length = 0;\n    this.destroyed = true;\n    this.animationItem = null;\n  };\n\n  SVGRendererBase.prototype.updateContainerSize = function () {};\n\n  SVGRendererBase.prototype.findIndexByInd = function (ind) {\n    var i = 0;\n    var len = this.layers.length;\n\n    for (i = 0; i < len; i += 1) {\n      if (this.layers[i].ind === ind) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  SVGRendererBase.prototype.buildItem = function (pos) {\n    var elements = this.elements;\n\n    if (elements[pos] || this.layers[pos].ty === 99) {\n      return;\n    }\n\n    elements[pos] = true;\n    var element = this.createItem(this.layers[pos]);\n    elements[pos] = element;\n\n    if (getExpressionsPlugin()) {\n      if (this.layers[pos].ty === 0) {\n        this.globalData.projectInterface.registerComposition(element);\n      }\n\n      element.initExpressions();\n    }\n\n    this.appendElementInPos(element, pos);\n\n    if (this.layers[pos].tt) {\n      var elementIndex = 'tp' in this.layers[pos] ? this.findIndexByInd(this.layers[pos].tp) : pos - 1;\n\n      if (elementIndex === -1) {\n        return;\n      }\n\n      if (!this.elements[elementIndex] || this.elements[elementIndex] === true) {\n        this.buildItem(elementIndex);\n        this.addPendingElement(element);\n      } else {\n        var matteElement = elements[elementIndex];\n        var matteMask = matteElement.getMatte(this.layers[pos].tt);\n        element.setMatte(matteMask);\n      }\n    }\n  };\n\n  SVGRendererBase.prototype.checkPendingElements = function () {\n    while (this.pendingElements.length) {\n      var element = this.pendingElements.pop();\n      element.checkParenting();\n\n      if (element.data.tt) {\n        var i = 0;\n        var len = this.elements.length;\n\n        while (i < len) {\n          if (this.elements[i] === element) {\n            var elementIndex = 'tp' in element.data ? this.findIndexByInd(element.data.tp) : i - 1;\n            var matteElement = this.elements[elementIndex];\n            var matteMask = matteElement.getMatte(this.layers[i].tt);\n            element.setMatte(matteMask);\n            break;\n          }\n\n          i += 1;\n        }\n      }\n    }\n  };\n\n  SVGRendererBase.prototype.renderFrame = function (num) {\n    if (this.renderedFrame === num || this.destroyed) {\n      return;\n    }\n\n    if (num === null) {\n      num = this.renderedFrame;\n    } else {\n      this.renderedFrame = num;\n    } // console.log('-------');\n    // console.log('FRAME ',num);\n\n\n    this.globalData.frameNum = num;\n    this.globalData.frameId += 1;\n    this.globalData.projectInterface.currentFrame = num;\n    this.globalData._mdf = false;\n    var i;\n    var len = this.layers.length;\n\n    if (!this.completeLayers) {\n      this.checkLayers(num);\n    }\n\n    for (i = len - 1; i >= 0; i -= 1) {\n      if (this.completeLayers || this.elements[i]) {\n        this.elements[i].prepareFrame(num - this.layers[i].st);\n      }\n    }\n\n    if (this.globalData._mdf) {\n      for (i = 0; i < len; i += 1) {\n        if (this.completeLayers || this.elements[i]) {\n          this.elements[i].renderFrame();\n        }\n      }\n    }\n  };\n\n  SVGRendererBase.prototype.appendElementInPos = function (element, pos) {\n    var newElement = element.getBaseElement();\n\n    if (!newElement) {\n      return;\n    }\n\n    var i = 0;\n    var nextElement;\n\n    while (i < pos) {\n      if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement()) {\n        nextElement = this.elements[i].getBaseElement();\n      }\n\n      i += 1;\n    }\n\n    if (nextElement) {\n      this.layerElement.insertBefore(newElement, nextElement);\n    } else {\n      this.layerElement.appendChild(newElement);\n    }\n  };\n\n  SVGRendererBase.prototype.hide = function () {\n    this.layerElement.style.display = 'none';\n  };\n\n  SVGRendererBase.prototype.show = function () {\n    this.layerElement.style.display = 'block';\n  };\n\n  function ICompElement() {}\n\n  extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement);\n\n  ICompElement.prototype.initElement = function (data, globalData, comp) {\n    this.initFrame();\n    this.initBaseData(data, globalData, comp);\n    this.initTransform(data, globalData, comp);\n    this.initRenderable();\n    this.initHierarchy();\n    this.initRendererElement();\n    this.createContainerElements();\n    this.createRenderableComponents();\n\n    if (this.data.xt || !globalData.progressiveLoad) {\n      this.buildAllItems();\n    }\n\n    this.hide();\n  };\n  /* ICompElement.prototype.hide = function(){\r\n      if(!this.hidden){\r\n          this.hideElement();\r\n          var i,len = this.elements.length;\r\n          for( i = 0; i < len; i+=1 ){\r\n              if(this.elements[i]){\r\n                  this.elements[i].hide();\r\n              }\r\n          }\r\n      }\r\n  }; */\n\n\n  ICompElement.prototype.prepareFrame = function (num) {\n    this._mdf = false;\n    this.prepareRenderableFrame(num);\n    this.prepareProperties(num, this.isInRange);\n\n    if (!this.isInRange && !this.data.xt) {\n      return;\n    }\n\n    if (!this.tm._placeholder) {\n      var timeRemapped = this.tm.v;\n\n      if (timeRemapped === this.data.op) {\n        timeRemapped = this.data.op - 1;\n      }\n\n      this.renderedFrame = timeRemapped;\n    } else {\n      this.renderedFrame = num / this.data.sr;\n    }\n\n    var i;\n    var len = this.elements.length;\n\n    if (!this.completeLayers) {\n      this.checkLayers(this.renderedFrame);\n    } // This iteration needs to be backwards because of how expressions connect between each other\n\n\n    for (i = len - 1; i >= 0; i -= 1) {\n      if (this.completeLayers || this.elements[i]) {\n        this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st);\n\n        if (this.elements[i]._mdf) {\n          this._mdf = true;\n        }\n      }\n    }\n  };\n\n  ICompElement.prototype.renderInnerContent = function () {\n    var i;\n    var len = this.layers.length;\n\n    for (i = 0; i < len; i += 1) {\n      if (this.completeLayers || this.elements[i]) {\n        this.elements[i].renderFrame();\n      }\n    }\n  };\n\n  ICompElement.prototype.setElements = function (elems) {\n    this.elements = elems;\n  };\n\n  ICompElement.prototype.getElements = function () {\n    return this.elements;\n  };\n\n  ICompElement.prototype.destroyElements = function () {\n    var i;\n    var len = this.layers.length;\n\n    for (i = 0; i < len; i += 1) {\n      if (this.elements[i]) {\n        this.elements[i].destroy();\n      }\n    }\n  };\n\n  ICompElement.prototype.destroy = function () {\n    this.destroyElements();\n    this.destroyBaseElement();\n  };\n\n  function SVGCompElement(data, globalData, comp) {\n    this.layers = data.layers;\n    this.supports3d = true;\n    this.completeLayers = false;\n    this.pendingElements = [];\n    this.elements = this.layers ? createSizedArray(this.layers.length) : [];\n    this.initElement(data, globalData, comp);\n    this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {\n      _placeholder: true\n    };\n  }\n\n  extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement);\n\n  SVGCompElement.prototype.createComp = function (data) {\n    return new SVGCompElement(data, this.globalData, this);\n  };\n\n  function SVGRenderer(animationItem, config) {\n    this.animationItem = animationItem;\n    this.layers = null;\n    this.renderedFrame = -1;\n    this.svgElement = createNS('svg');\n    var ariaLabel = '';\n\n    if (config && config.title) {\n      var titleElement = createNS('title');\n      var titleId = createElementID();\n      titleElement.setAttribute('id', titleId);\n      titleElement.textContent = config.title;\n      this.svgElement.appendChild(titleElement);\n      ariaLabel += titleId;\n    }\n\n    if (config && config.description) {\n      var descElement = createNS('desc');\n      var descId = createElementID();\n      descElement.setAttribute('id', descId);\n      descElement.textContent = config.description;\n      this.svgElement.appendChild(descElement);\n      ariaLabel += ' ' + descId;\n    }\n\n    if (ariaLabel) {\n      this.svgElement.setAttribute('aria-labelledby', ariaLabel);\n    }\n\n    var defs = createNS('defs');\n    this.svgElement.appendChild(defs);\n    var maskElement = createNS('g');\n    this.svgElement.appendChild(maskElement);\n    this.layerElement = maskElement;\n    this.renderConfig = {\n      preserveAspectRatio: config && config.preserveAspectRatio || 'xMidYMid meet',\n      imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',\n      contentVisibility: config && config.contentVisibility || 'visible',\n      progressiveLoad: config && config.progressiveLoad || false,\n      hideOnTransparent: !(config && config.hideOnTransparent === false),\n      viewBoxOnly: config && config.viewBoxOnly || false,\n      viewBoxSize: config && config.viewBoxSize || false,\n      className: config && config.className || '',\n      id: config && config.id || '',\n      focusable: config && config.focusable,\n      filterSize: {\n        width: config && config.filterSize && config.filterSize.width || '100%',\n        height: config && config.filterSize && config.filterSize.height || '100%',\n        x: config && config.filterSize && config.filterSize.x || '0%',\n        y: config && config.filterSize && config.filterSize.y || '0%'\n      },\n      width: config && config.width,\n      height: config && config.height,\n      runExpressions: !config || config.runExpressions === undefined || config.runExpressions\n    };\n    this.globalData = {\n      _mdf: false,\n      frameNum: -1,\n      defs: defs,\n      renderConfig: this.renderConfig\n    };\n    this.elements = [];\n    this.pendingElements = [];\n    this.destroyed = false;\n    this.rendererType = 'svg';\n  }\n\n  extendPrototype([SVGRendererBase], SVGRenderer);\n\n  SVGRenderer.prototype.createComp = function (data) {\n    return new SVGCompElement(data, this.globalData, this);\n  };\n\n  function ShapeTransformManager() {\n    this.sequences = {};\n    this.sequenceList = [];\n    this.transform_key_count = 0;\n  }\n\n  ShapeTransformManager.prototype = {\n    addTransformSequence: function addTransformSequence(transforms) {\n      var i;\n      var len = transforms.length;\n      var key = '_';\n\n      for (i = 0; i < len; i += 1) {\n        key += transforms[i].transform.key + '_';\n      }\n\n      var sequence = this.sequences[key];\n\n      if (!sequence) {\n        sequence = {\n          transforms: [].concat(transforms),\n          finalTransform: new Matrix(),\n          _mdf: false\n        };\n        this.sequences[key] = sequence;\n        this.sequenceList.push(sequence);\n      }\n\n      return sequence;\n    },\n    processSequence: function processSequence(sequence, isFirstFrame) {\n      var i = 0;\n      var len = sequence.transforms.length;\n      var _mdf = isFirstFrame;\n\n      while (i < len && !isFirstFrame) {\n        if (sequence.transforms[i].transform.mProps._mdf) {\n          _mdf = true;\n          break;\n        }\n\n        i += 1;\n      }\n\n      if (_mdf) {\n        sequence.finalTransform.reset();\n\n        for (i = len - 1; i >= 0; i -= 1) {\n          sequence.finalTransform.multiply(sequence.transforms[i].transform.mProps.v);\n        }\n      }\n\n      sequence._mdf = _mdf;\n    },\n    processSequences: function processSequences(isFirstFrame) {\n      var i;\n      var len = this.sequenceList.length;\n\n      for (i = 0; i < len; i += 1) {\n        this.processSequence(this.sequenceList[i], isFirstFrame);\n      }\n    },\n    getNewKey: function getNewKey() {\n      this.transform_key_count += 1;\n      return '_' + this.transform_key_count;\n    }\n  };\n\n  var lumaLoader = function lumaLoader() {\n    var id = '__lottie_element_luma_buffer';\n    var lumaBuffer = null;\n    var lumaBufferCtx = null;\n    var svg = null; // This alternate solution has a slight delay before the filter is applied, resulting in a flicker on the first frame.\n    // Keeping this here for reference, and in the future, if offscreen canvas supports url filters, this can be used.\n    // For now, neither of them work for offscreen canvas, so canvas workers can't support the luma track matte mask.\n    // Naming it solution 2 to mark the extra comment lines.\n\n    /*\r\n    var svgString = [\r\n      '<svg xmlns=\"http://www.w3.org/2000/svg\">',\r\n      '<filter id=\"' + id + '\">',\r\n      '<feColorMatrix type=\"matrix\" color-interpolation-filters=\"sRGB\" values=\"',\r\n      '0.3, 0.3, 0.3, 0, 0, ',\r\n      '0.3, 0.3, 0.3, 0, 0, ',\r\n      '0.3, 0.3, 0.3, 0, 0, ',\r\n      '0.3, 0.3, 0.3, 0, 0',\r\n      '\"/>',\r\n      '</filter>',\r\n      '</svg>',\r\n    ].join('');\r\n    var blob = new Blob([svgString], { type: 'image/svg+xml' });\r\n    var url = URL.createObjectURL(blob);\r\n    */\n\n    function createLumaSvgFilter() {\n      var _svg = createNS('svg');\n\n      var fil = createNS('filter');\n      var matrix = createNS('feColorMatrix');\n      fil.setAttribute('id', id);\n      matrix.setAttribute('type', 'matrix');\n      matrix.setAttribute('color-interpolation-filters', 'sRGB');\n      matrix.setAttribute('values', '0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0');\n      fil.appendChild(matrix);\n\n      _svg.appendChild(fil);\n\n      _svg.setAttribute('id', id + '_svg');\n\n      if (featureSupport.svgLumaHidden) {\n        _svg.style.display = 'none';\n      }\n\n      return _svg;\n    }\n\n    function loadLuma() {\n      if (!lumaBuffer) {\n        svg = createLumaSvgFilter();\n        document.body.appendChild(svg);\n        lumaBuffer = createTag('canvas');\n        lumaBufferCtx = lumaBuffer.getContext('2d'); // lumaBufferCtx.filter = `url('${url}#__lottie_element_luma_buffer')`; // part of solution 2\n\n        lumaBufferCtx.filter = 'url(#' + id + ')';\n        lumaBufferCtx.fillStyle = 'rgba(0,0,0,0)';\n        lumaBufferCtx.fillRect(0, 0, 1, 1);\n      }\n    }\n\n    function getLuma(canvas) {\n      if (!lumaBuffer) {\n        loadLuma();\n      }\n\n      lumaBuffer.width = canvas.width;\n      lumaBuffer.height = canvas.height; // lumaBufferCtx.filter = `url('${url}#__lottie_element_luma_buffer')`; // part of solution 2\n\n      lumaBufferCtx.filter = 'url(#' + id + ')';\n      return lumaBuffer;\n    }\n\n    return {\n      load: loadLuma,\n      get: getLuma\n    };\n  };\n\n  function createCanvas(width, height) {\n    if (featureSupport.offscreenCanvas) {\n      return new OffscreenCanvas(width, height);\n    }\n\n    var canvas = createTag('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  }\n\n  var assetLoader = function () {\n    return {\n      loadLumaCanvas: lumaLoader.load,\n      getLumaCanvas: lumaLoader.get,\n      createCanvas: createCanvas\n    };\n  }();\n\n  var registeredEffects = {};\n\n  function CVEffects(elem) {\n    var i;\n    var len = elem.data.ef ? elem.data.ef.length : 0;\n    this.filters = [];\n    var filterManager;\n\n    for (i = 0; i < len; i += 1) {\n      filterManager = null;\n      var type = elem.data.ef[i].ty;\n\n      if (registeredEffects[type]) {\n        var Effect = registeredEffects[type].effect;\n        filterManager = new Effect(elem.effectsManager.effectElements[i], elem);\n      }\n\n      if (filterManager) {\n        this.filters.push(filterManager);\n      }\n    }\n\n    if (this.filters.length) {\n      elem.addRenderableComponent(this);\n    }\n  }\n\n  CVEffects.prototype.renderFrame = function (_isFirstFrame) {\n    var i;\n    var len = this.filters.length;\n\n    for (i = 0; i < len; i += 1) {\n      this.filters[i].renderFrame(_isFirstFrame);\n    }\n  };\n\n  CVEffects.prototype.getEffects = function (type) {\n    var i;\n    var len = this.filters.length;\n    var effects = [];\n\n    for (i = 0; i < len; i += 1) {\n      if (this.filters[i].type === type) {\n        effects.push(this.filters[i]);\n      }\n    }\n\n    return effects;\n  };\n\n  function registerEffect(id, effect) {\n    registeredEffects[id] = {\n      effect: effect\n    };\n  }\n\n  function CVMaskElement(data, element) {\n    this.data = data;\n    this.element = element;\n    this.masksProperties = this.data.masksProperties || [];\n    this.viewData = createSizedArray(this.masksProperties.length);\n    var i;\n    var len = this.masksProperties.length;\n    var hasMasks = false;\n\n    for (i = 0; i < len; i += 1) {\n      if (this.masksProperties[i].mode !== 'n') {\n        hasMasks = true;\n      }\n\n      this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i], 3);\n    }\n\n    this.hasMasks = hasMasks;\n\n    if (hasMasks) {\n      this.element.addRenderableComponent(this);\n    }\n  }\n\n  CVMaskElement.prototype.renderFrame = function () {\n    if (!this.hasMasks) {\n      return;\n    }\n\n    var transform = this.element.finalTransform.mat;\n    var ctx = this.element.canvasContext;\n    var i;\n    var len = this.masksProperties.length;\n    var pt;\n    var pts;\n    var data;\n    ctx.beginPath();\n\n    for (i = 0; i < len; i += 1) {\n      if (this.masksProperties[i].mode !== 'n') {\n        if (this.masksProperties[i].inv) {\n          ctx.moveTo(0, 0);\n          ctx.lineTo(this.element.globalData.compSize.w, 0);\n          ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);\n          ctx.lineTo(0, this.element.globalData.compSize.h);\n          ctx.lineTo(0, 0);\n        }\n\n        data = this.viewData[i].v;\n        pt = transform.applyToPointArray(data.v[0][0], data.v[0][1], 0);\n        ctx.moveTo(pt[0], pt[1]);\n        var j;\n        var jLen = data._length;\n\n        for (j = 1; j < jLen; j += 1) {\n          pts = transform.applyToTriplePoints(data.o[j - 1], data.i[j], data.v[j]);\n          ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);\n        }\n\n        pts = transform.applyToTriplePoints(data.o[j - 1], data.i[0], data.v[0]);\n        ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);\n      }\n    }\n\n    this.element.globalData.renderer.save(true);\n    ctx.clip();\n  };\n\n  CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;\n\n  CVMaskElement.prototype.destroy = function () {\n    this.element = null;\n  };\n\n  function CVBaseElement() {}\n\n  var operationsMap = {\n    1: 'source-in',\n    2: 'source-out',\n    3: 'source-in',\n    4: 'source-out'\n  };\n  CVBaseElement.prototype = {\n    createElements: function createElements() {},\n    initRendererElement: function initRendererElement() {},\n    createContainerElements: function createContainerElements() {\n      // If the layer is masked we will use two buffers to store each different states of the drawing\n      // This solution is not ideal for several reason. But unfortunately, because of the recursive\n      // nature of the render tree, it's the only simple way to make sure one inner mask doesn't override an outer mask.\n      // TODO: try to reduce the size of these buffers to the size of the composition contaning the layer\n      // It might be challenging because the layer most likely is transformed in some way\n      if (this.data.tt >= 1) {\n        this.buffers = [];\n        var canvasContext = this.globalData.canvasContext;\n        var bufferCanvas = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);\n        this.buffers.push(bufferCanvas);\n        var bufferCanvas2 = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);\n        this.buffers.push(bufferCanvas2);\n\n        if (this.data.tt >= 3 && !document._isProxy) {\n          assetLoader.loadLumaCanvas();\n        }\n      }\n\n      this.canvasContext = this.globalData.canvasContext;\n      this.transformCanvas = this.globalData.transformCanvas;\n      this.renderableEffectsManager = new CVEffects(this);\n      this.searchEffectTransforms();\n    },\n    createContent: function createContent() {},\n    setBlendMode: function setBlendMode() {\n      var globalData = this.globalData;\n\n      if (globalData.blendMode !== this.data.bm) {\n        globalData.blendMode = this.data.bm;\n        var blendModeValue = getBlendMode(this.data.bm);\n        globalData.canvasContext.globalCompositeOperation = blendModeValue;\n      }\n    },\n    createRenderableComponents: function createRenderableComponents() {\n      this.maskManager = new CVMaskElement(this.data, this);\n      this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);\n    },\n    hideElement: function hideElement() {\n      if (!this.hidden && (!this.isInRange || this.isTransparent)) {\n        this.hidden = true;\n      }\n    },\n    showElement: function showElement() {\n      if (this.isInRange && !this.isTransparent) {\n        this.hidden = false;\n        this._isFirstFrame = true;\n        this.maskManager._isFirstFrame = true;\n      }\n    },\n    clearCanvas: function clearCanvas(canvasContext) {\n      canvasContext.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy);\n    },\n    prepareLayer: function prepareLayer() {\n      if (this.data.tt >= 1) {\n        var buffer = this.buffers[0];\n        var bufferCtx = buffer.getContext('2d');\n        this.clearCanvas(bufferCtx); // on the first buffer we store the current state of the global drawing\n\n        bufferCtx.drawImage(this.canvasContext.canvas, 0, 0); // The next four lines are to clear the canvas\n        // TODO: Check if there is a way to clear the canvas without resetting the transform\n\n        this.currentTransform = this.canvasContext.getTransform();\n        this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);\n        this.clearCanvas(this.canvasContext);\n        this.canvasContext.setTransform(this.currentTransform);\n      }\n    },\n    exitLayer: function exitLayer() {\n      if (this.data.tt >= 1) {\n        var buffer = this.buffers[1]; // On the second buffer we store the current state of the global drawing\n        // that only contains the content of this layer\n        // (if it is a composition, it also includes the nested layers)\n\n        var bufferCtx = buffer.getContext('2d');\n        this.clearCanvas(bufferCtx);\n        bufferCtx.drawImage(this.canvasContext.canvas, 0, 0); // We clear the canvas again\n\n        this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);\n        this.clearCanvas(this.canvasContext);\n        this.canvasContext.setTransform(this.currentTransform); // We draw the mask\n\n        var mask = this.comp.getElementById('tp' in this.data ? this.data.tp : this.data.ind - 1);\n        mask.renderFrame(true); // We draw the second buffer (that contains the content of this layer)\n\n        this.canvasContext.setTransform(1, 0, 0, 1, 0, 0); // If the mask is a Luma matte, we need to do two extra painting operations\n        // the _isProxy check is to avoid drawing a fake canvas in workers that will throw an error\n\n        if (this.data.tt >= 3 && !document._isProxy) {\n          // We copy the painted mask to a buffer that has a color matrix filter applied to it\n          // that applies the rgb values to the alpha channel\n          var lumaBuffer = assetLoader.getLumaCanvas(this.canvasContext.canvas);\n          var lumaBufferCtx = lumaBuffer.getContext('2d');\n          lumaBufferCtx.drawImage(this.canvasContext.canvas, 0, 0);\n          this.clearCanvas(this.canvasContext); // we repaint the context with the mask applied to it\n\n          this.canvasContext.drawImage(lumaBuffer, 0, 0);\n        }\n\n        this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt];\n        this.canvasContext.drawImage(buffer, 0, 0); // We finally draw the first buffer (that contains the content of the global drawing)\n        // We use destination-over to draw the global drawing below the current layer\n\n        this.canvasContext.globalCompositeOperation = 'destination-over';\n        this.canvasContext.drawImage(this.buffers[0], 0, 0);\n        this.canvasContext.setTransform(this.currentTransform); // We reset the globalCompositeOperation to source-over, the standard type of operation\n\n        this.canvasContext.globalCompositeOperation = 'source-over';\n      }\n    },\n    renderFrame: function renderFrame(forceRender) {\n      if (this.hidden || this.data.hd) {\n        return;\n      }\n\n      if (this.data.td === 1 && !forceRender) {\n        return;\n      }\n\n      this.renderTransform();\n      this.renderRenderable();\n      this.renderLocalTransform();\n      this.setBlendMode();\n      var forceRealStack = this.data.ty === 0;\n      this.prepareLayer();\n      this.globalData.renderer.save(forceRealStack);\n      this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props);\n      this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity);\n      this.renderInnerContent();\n      this.globalData.renderer.restore(forceRealStack);\n      this.exitLayer();\n\n      if (this.maskManager.hasMasks) {\n        this.globalData.renderer.restore(true);\n      }\n\n      if (this._isFirstFrame) {\n        this._isFirstFrame = false;\n      }\n    },\n    destroy: function destroy() {\n      this.canvasContext = null;\n      this.data = null;\n      this.globalData = null;\n      this.maskManager.destroy();\n    },\n    mHelper: new Matrix()\n  };\n  CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;\n  CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;\n\n  function CVShapeData(element, data, styles, transformsManager) {\n    this.styledShapes = [];\n    this.tr = [0, 0, 0, 0, 0, 0];\n    var ty = 4;\n\n    if (data.ty === 'rc') {\n      ty = 5;\n    } else if (data.ty === 'el') {\n      ty = 6;\n    } else if (data.ty === 'sr') {\n      ty = 7;\n    }\n\n    this.sh = ShapePropertyFactory.getShapeProp(element, data, ty, element);\n    var i;\n    var len = styles.length;\n    var styledShape;\n\n    for (i = 0; i < len; i += 1) {\n      if (!styles[i].closed) {\n        styledShape = {\n          transforms: transformsManager.addTransformSequence(styles[i].transforms),\n          trNodes: []\n        };\n        this.styledShapes.push(styledShape);\n        styles[i].elements.push(styledShape);\n      }\n    }\n  }\n\n  CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;\n\n  function CVShapeElement(data, globalData, comp) {\n    this.shapes = [];\n    this.shapesData = data.shapes;\n    this.stylesList = [];\n    this.itemsData = [];\n    this.prevViewData = [];\n    this.shapeModifiers = [];\n    this.processedElements = [];\n    this.transformsManager = new ShapeTransformManager();\n    this.initElement(data, globalData, comp);\n  }\n\n  extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement);\n  CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;\n  CVShapeElement.prototype.transformHelper = {\n    opacity: 1,\n    _opMdf: false\n  };\n  CVShapeElement.prototype.dashResetter = [];\n\n  CVShapeElement.prototype.createContent = function () {\n    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);\n  };\n\n  CVShapeElement.prototype.createStyleElement = function (data, transforms) {\n    var styleElem = {\n      data: data,\n      type: data.ty,\n      preTransforms: this.transformsManager.addTransformSequence(transforms),\n      transforms: [],\n      elements: [],\n      closed: data.hd === true\n    };\n    var elementData = {};\n\n    if (data.ty === 'fl' || data.ty === 'st') {\n      elementData.c = PropertyFactory.getProp(this, data.c, 1, 255, this);\n\n      if (!elementData.c.k) {\n        styleElem.co = 'rgb(' + bmFloor(elementData.c.v[0]) + ',' + bmFloor(elementData.c.v[1]) + ',' + bmFloor(elementData.c.v[2]) + ')';\n      }\n    } else if (data.ty === 'gf' || data.ty === 'gs') {\n      elementData.s = PropertyFactory.getProp(this, data.s, 1, null, this);\n      elementData.e = PropertyFactory.getProp(this, data.e, 1, null, this);\n      elementData.h = PropertyFactory.getProp(this, data.h || {\n        k: 0\n      }, 0, 0.01, this);\n      elementData.a = PropertyFactory.getProp(this, data.a || {\n        k: 0\n      }, 0, degToRads, this);\n      elementData.g = new GradientProperty(this, data.g, this);\n    }\n\n    elementData.o = PropertyFactory.getProp(this, data.o, 0, 0.01, this);\n\n    if (data.ty === 'st' || data.ty === 'gs') {\n      styleElem.lc = lineCapEnum[data.lc || 2];\n      styleElem.lj = lineJoinEnum[data.lj || 2];\n\n      if (data.lj == 1) {\n        // eslint-disable-line eqeqeq\n        styleElem.ml = data.ml;\n      }\n\n      elementData.w = PropertyFactory.getProp(this, data.w, 0, null, this);\n\n      if (!elementData.w.k) {\n        styleElem.wi = elementData.w.v;\n      }\n\n      if (data.d) {\n        var d = new DashProperty(this, data.d, 'canvas', this);\n        elementData.d = d;\n\n        if (!elementData.d.k) {\n          styleElem.da = elementData.d.dashArray;\n          styleElem[\"do\"] = elementData.d.dashoffset[0];\n        }\n      }\n    } else {\n      styleElem.r = data.r === 2 ? 'evenodd' : 'nonzero';\n    }\n\n    this.stylesList.push(styleElem);\n    elementData.style = styleElem;\n    return elementData;\n  };\n\n  CVShapeElement.prototype.createGroupElement = function () {\n    var elementData = {\n      it: [],\n      prevViewData: []\n    };\n    return elementData;\n  };\n\n  CVShapeElement.prototype.createTransformElement = function (data) {\n    var elementData = {\n      transform: {\n        opacity: 1,\n        _opMdf: false,\n        key: this.transformsManager.getNewKey(),\n        op: PropertyFactory.getProp(this, data.o, 0, 0.01, this),\n        mProps: TransformPropertyFactory.getTransformProperty(this, data, this)\n      }\n    };\n    return elementData;\n  };\n\n  CVShapeElement.prototype.createShapeElement = function (data) {\n    var elementData = new CVShapeData(this, data, this.stylesList, this.transformsManager);\n    this.shapes.push(elementData);\n    this.addShapeToModifiers(elementData);\n    return elementData;\n  };\n\n  CVShapeElement.prototype.reloadShapes = function () {\n    this._isFirstFrame = true;\n    var i;\n    var len = this.itemsData.length;\n\n    for (i = 0; i < len; i += 1) {\n      this.prevViewData[i] = this.itemsData[i];\n    }\n\n    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);\n    len = this.dynamicProperties.length;\n\n    for (i = 0; i < len; i += 1) {\n      this.dynamicProperties[i].getValue();\n    }\n\n    this.renderModifiers();\n    this.transformsManager.processSequences(this._isFirstFrame);\n  };\n\n  CVShapeElement.prototype.addTransformToStyleList = function (transform) {\n    var i;\n    var len = this.stylesList.length;\n\n    for (i = 0; i < len; i += 1) {\n      if (!this.stylesList[i].closed) {\n        this.stylesList[i].transforms.push(transform);\n      }\n    }\n  };\n\n  CVShapeElement.prototype.removeTransformFromStyleList = function () {\n    var i;\n    var len = this.stylesList.length;\n\n    for (i = 0; i < len; i += 1) {\n      if (!this.stylesList[i].closed) {\n        this.stylesList[i].transforms.pop();\n      }\n    }\n  };\n\n  CVShapeElement.prototype.closeStyles = function (styles) {\n    var i;\n    var len = styles.length;\n\n    for (i = 0; i < len; i += 1) {\n      styles[i].closed = true;\n    }\n  };\n\n  CVShapeElement.prototype.searchShapes = function (arr, itemsData, prevViewData, shouldRender, transforms) {\n    var i;\n    var len = arr.length - 1;\n    var j;\n    var jLen;\n    var ownStyles = [];\n    var ownModifiers = [];\n    var processedPos;\n    var modifier;\n    var currentTransform;\n    var ownTransforms = [].concat(transforms);\n\n    for (i = len; i >= 0; i -= 1) {\n      processedPos = this.searchProcessedElement(arr[i]);\n\n      if (!processedPos) {\n        arr[i]._shouldRender = shouldRender;\n      } else {\n        itemsData[i] = prevViewData[processedPos - 1];\n      }\n\n      if (arr[i].ty === 'fl' || arr[i].ty === 'st' || arr[i].ty === 'gf' || arr[i].ty === 'gs') {\n        if (!processedPos) {\n          itemsData[i] = this.createStyleElement(arr[i], ownTransforms);\n        } else {\n          itemsData[i].style.closed = false;\n        }\n\n        ownStyles.push(itemsData[i].style);\n      } else if (arr[i].ty === 'gr') {\n        if (!processedPos) {\n          itemsData[i] = this.createGroupElement(arr[i]);\n        } else {\n          jLen = itemsData[i].it.length;\n\n          for (j = 0; j < jLen; j += 1) {\n            itemsData[i].prevViewData[j] = itemsData[i].it[j];\n          }\n        }\n\n        this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, shouldRender, ownTransforms);\n      } else if (arr[i].ty === 'tr') {\n        if (!processedPos) {\n          currentTransform = this.createTransformElement(arr[i]);\n          itemsData[i] = currentTransform;\n        }\n\n        ownTransforms.push(itemsData[i]);\n        this.addTransformToStyleList(itemsData[i]);\n      } else if (arr[i].ty === 'sh' || arr[i].ty === 'rc' || arr[i].ty === 'el' || arr[i].ty === 'sr') {\n        if (!processedPos) {\n          itemsData[i] = this.createShapeElement(arr[i]);\n        }\n      } else if (arr[i].ty === 'tm' || arr[i].ty === 'rd' || arr[i].ty === 'pb' || arr[i].ty === 'zz' || arr[i].ty === 'op') {\n        if (!processedPos) {\n          modifier = ShapeModifiers.getModifier(arr[i].ty);\n          modifier.init(this, arr[i]);\n          itemsData[i] = modifier;\n          this.shapeModifiers.push(modifier);\n        } else {\n          modifier = itemsData[i];\n          modifier.closed = false;\n        }\n\n        ownModifiers.push(modifier);\n      } else if (arr[i].ty === 'rp') {\n        if (!processedPos) {\n          modifier = ShapeModifiers.getModifier(arr[i].ty);\n          itemsData[i] = modifier;\n          modifier.init(this, arr, i, itemsData);\n          this.shapeModifiers.push(modifier);\n          shouldRender = false;\n        } else {\n          modifier = itemsData[i];\n          modifier.closed = true;\n        }\n\n        ownModifiers.push(modifier);\n      }\n\n      this.addProcessedElement(arr[i], i + 1);\n    }\n\n    this.removeTransformFromStyleList();\n    this.closeStyles(ownStyles);\n    len = ownModifiers.length;\n\n    for (i = 0; i < len; i += 1) {\n      ownModifiers[i].closed = true;\n    }\n  };\n\n  CVShapeElement.prototype.renderInnerContent = function () {\n    this.transformHelper.opacity = 1;\n    this.transformHelper._opMdf = false;\n    this.renderModifiers();\n    this.transformsManager.processSequences(this._isFirstFrame);\n    this.renderShape(this.transformHelper, this.shapesData, this.itemsData, true);\n  };\n\n  CVShapeElement.prototype.renderShapeTransform = function (parentTransform, groupTransform) {\n    if (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {\n      groupTransform.opacity = parentTransform.opacity;\n      groupTransform.opacity *= groupTransform.op.v;\n      groupTransform._opMdf = true;\n    }\n  };\n\n  CVShapeElement.prototype.drawLayer = function () {\n    var i;\n    var len = this.stylesList.length;\n    var j;\n    var jLen;\n    var k;\n    var kLen;\n    var elems;\n    var nodes;\n    var renderer = this.globalData.renderer;\n    var ctx = this.globalData.canvasContext;\n    var type;\n    var currentStyle;\n\n    for (i = 0; i < len; i += 1) {\n      currentStyle = this.stylesList[i];\n      type = currentStyle.type; // Skipping style when\n      // Stroke width equals 0\n      // style should not be rendered (extra unused repeaters)\n      // current opacity equals 0\n      // global opacity equals 0\n\n      if (!((type === 'st' || type === 'gs') && currentStyle.wi === 0 || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {\n        renderer.save();\n        elems = currentStyle.elements;\n\n        if (type === 'st' || type === 'gs') {\n          renderer.ctxStrokeStyle(type === 'st' ? currentStyle.co : currentStyle.grd); // ctx.strokeStyle = type === 'st' ? currentStyle.co : currentStyle.grd;\n\n          renderer.ctxLineWidth(currentStyle.wi); // ctx.lineWidth = currentStyle.wi;\n\n          renderer.ctxLineCap(currentStyle.lc); // ctx.lineCap = currentStyle.lc;\n\n          renderer.ctxLineJoin(currentStyle.lj); // ctx.lineJoin = currentStyle.lj;\n\n          renderer.ctxMiterLimit(currentStyle.ml || 0); // ctx.miterLimit = currentStyle.ml || 0;\n        } else {\n          renderer.ctxFillStyle(type === 'fl' ? currentStyle.co : currentStyle.grd); // ctx.fillStyle = type === 'fl' ? currentStyle.co : currentStyle.grd;\n        }\n\n        renderer.ctxOpacity(currentStyle.coOp);\n\n        if (type !== 'st' && type !== 'gs') {\n          ctx.beginPath();\n        }\n\n        renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props);\n        jLen = elems.length;\n\n        for (j = 0; j < jLen; j += 1) {\n          if (type === 'st' || type === 'gs') {\n            ctx.beginPath();\n\n            if (currentStyle.da) {\n              ctx.setLineDash(currentStyle.da);\n              ctx.lineDashOffset = currentStyle[\"do\"];\n            }\n          }\n\n          nodes = elems[j].trNodes;\n          kLen = nodes.length;\n\n          for (k = 0; k < kLen; k += 1) {\n            if (nodes[k].t === 'm') {\n              ctx.moveTo(nodes[k].p[0], nodes[k].p[1]);\n            } else if (nodes[k].t === 'c') {\n              ctx.bezierCurveTo(nodes[k].pts[0], nodes[k].pts[1], nodes[k].pts[2], nodes[k].pts[3], nodes[k].pts[4], nodes[k].pts[5]);\n            } else {\n              ctx.closePath();\n            }\n          }\n\n          if (type === 'st' || type === 'gs') {\n            // ctx.stroke();\n            renderer.ctxStroke();\n\n            if (currentStyle.da) {\n              ctx.setLineDash(this.dashResetter);\n            }\n          }\n        }\n\n        if (type !== 'st' && type !== 'gs') {\n          // ctx.fill(currentStyle.r);\n          this.globalData.renderer.ctxFill(currentStyle.r);\n        }\n\n        renderer.restore();\n      }\n    }\n  };\n\n  CVShapeElement.prototype.renderShape = function (parentTransform, items, data, isMain) {\n    var i;\n    var len = items.length - 1;\n    var groupTransform;\n    groupTransform = parentTransform;\n\n    for (i = len; i >= 0; i -= 1) {\n      if (items[i].ty === 'tr') {\n        groupTransform = data[i].transform;\n        this.renderShapeTransform(parentTransform, groupTransform);\n      } else if (items[i].ty === 'sh' || items[i].ty === 'el' || items[i].ty === 'rc' || items[i].ty === 'sr') {\n        this.renderPath(items[i], data[i]);\n      } else if (items[i].ty === 'fl') {\n        this.renderFill(items[i], data[i], groupTransform);\n      } else if (items[i].ty === 'st') {\n        this.renderStroke(items[i], data[i], groupTransform);\n      } else if (items[i].ty === 'gf' || items[i].ty === 'gs') {\n        this.renderGradientFill(items[i], data[i], groupTransform);\n      } else if (items[i].ty === 'gr') {\n        this.renderShape(groupTransform, items[i].it, data[i].it);\n      } else if (items[i].ty === 'tm') {//\n      }\n    }\n\n    if (isMain) {\n      this.drawLayer();\n    }\n  };\n\n  CVShapeElement.prototype.renderStyledShape = function (styledShape, shape) {\n    if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {\n      var shapeNodes = styledShape.trNodes;\n      var paths = shape.paths;\n      var i;\n      var len;\n      var j;\n      var jLen = paths._length;\n      shapeNodes.length = 0;\n      var groupTransformMat = styledShape.transforms.finalTransform;\n\n      for (j = 0; j < jLen; j += 1) {\n        var pathNodes = paths.shapes[j];\n\n        if (pathNodes && pathNodes.v) {\n          len = pathNodes._length;\n\n          for (i = 1; i < len; i += 1) {\n            if (i === 1) {\n              shapeNodes.push({\n                t: 'm',\n                p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)\n              });\n            }\n\n            shapeNodes.push({\n              t: 'c',\n              pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[i], pathNodes.v[i])\n            });\n          }\n\n          if (len === 1) {\n            shapeNodes.push({\n              t: 'm',\n              p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)\n            });\n          }\n\n          if (pathNodes.c && len) {\n            shapeNodes.push({\n              t: 'c',\n              pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[0], pathNodes.v[0])\n            });\n            shapeNodes.push({\n              t: 'z'\n            });\n          }\n        }\n      }\n\n      styledShape.trNodes = shapeNodes;\n    }\n  };\n\n  CVShapeElement.prototype.renderPath = function (pathData, itemData) {\n    if (pathData.hd !== true && pathData._shouldRender) {\n      var i;\n      var len = itemData.styledShapes.length;\n\n      for (i = 0; i < len; i += 1) {\n        this.renderStyledShape(itemData.styledShapes[i], itemData.sh);\n      }\n    }\n  };\n\n  CVShapeElement.prototype.renderFill = function (styleData, itemData, groupTransform) {\n    var styleElem = itemData.style;\n\n    if (itemData.c._mdf || this._isFirstFrame) {\n      styleElem.co = 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')';\n    }\n\n    if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {\n      styleElem.coOp = itemData.o.v * groupTransform.opacity;\n    }\n  };\n\n  CVShapeElement.prototype.renderGradientFill = function (styleData, itemData, groupTransform) {\n    var styleElem = itemData.style;\n    var grd;\n\n    if (!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf)) {\n      var ctx = this.globalData.canvasContext;\n      var pt1 = itemData.s.v;\n      var pt2 = itemData.e.v;\n\n      if (styleData.t === 1) {\n        grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);\n      } else {\n        var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));\n        var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);\n        var percent = itemData.h.v;\n\n        if (percent >= 1) {\n          percent = 0.99;\n        } else if (percent <= -1) {\n          percent = -0.99;\n        }\n\n        var dist = rad * percent;\n        var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];\n        var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];\n        grd = ctx.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad);\n      }\n\n      var i;\n      var len = styleData.g.p;\n      var cValues = itemData.g.c;\n      var opacity = 1;\n\n      for (i = 0; i < len; i += 1) {\n        if (itemData.g._hasOpacity && itemData.g._collapsable) {\n          opacity = itemData.g.o[i * 2 + 1];\n        }\n\n        grd.addColorStop(cValues[i * 4] / 100, 'rgba(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ',' + opacity + ')');\n      }\n\n      styleElem.grd = grd;\n    }\n\n    styleElem.coOp = itemData.o.v * groupTransform.opacity;\n  };\n\n  CVShapeElement.prototype.renderStroke = function (styleData, itemData, groupTransform) {\n    var styleElem = itemData.style;\n    var d = itemData.d;\n\n    if (d && (d._mdf || this._isFirstFrame)) {\n      styleElem.da = d.dashArray;\n      styleElem[\"do\"] = d.dashoffset[0];\n    }\n\n    if (itemData.c._mdf || this._isFirstFrame) {\n      styleElem.co = 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')';\n    }\n\n    if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {\n      styleElem.coOp = itemData.o.v * groupTransform.opacity;\n    }\n\n    if (itemData.w._mdf || this._isFirstFrame) {\n      styleElem.wi = itemData.w.v;\n    }\n  };\n\n  CVShapeElement.prototype.destroy = function () {\n    this.shapesData = null;\n    this.globalData = null;\n    this.canvasContext = null;\n    this.stylesList.length = 0;\n    this.itemsData.length = 0;\n  };\n\n  function CVTextElement(data, globalData, comp) {\n    this.textSpans = [];\n    this.yOffset = 0;\n    this.fillColorAnim = false;\n    this.strokeColorAnim = false;\n    this.strokeWidthAnim = false;\n    this.stroke = false;\n    this.fill = false;\n    this.justifyOffset = 0;\n    this.currentRender = null;\n    this.renderType = 'canvas';\n    this.values = {\n      fill: 'rgba(0,0,0,0)',\n      stroke: 'rgba(0,0,0,0)',\n      sWidth: 0,\n      fValue: ''\n    };\n    this.initElement(data, globalData, comp);\n  }\n\n  extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement);\n  CVTextElement.prototype.tHelper = createTag('canvas').getContext('2d');\n\n  CVTextElement.prototype.buildNewText = function () {\n    var documentData = this.textProperty.currentData;\n    this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);\n    var hasFill = false;\n\n    if (documentData.fc) {\n      hasFill = true;\n      this.values.fill = this.buildColor(documentData.fc);\n    } else {\n      this.values.fill = 'rgba(0,0,0,0)';\n    }\n\n    this.fill = hasFill;\n    var hasStroke = false;\n\n    if (documentData.sc) {\n      hasStroke = true;\n      this.values.stroke = this.buildColor(documentData.sc);\n      this.values.sWidth = documentData.sw;\n    }\n\n    var fontData = this.globalData.fontManager.getFontByName(documentData.f);\n    var i;\n    var len;\n    var letters = documentData.l;\n    var matrixHelper = this.mHelper;\n    this.stroke = hasStroke;\n    this.values.fValue = documentData.finalSize + 'px ' + this.globalData.fontManager.getFontByName(documentData.f).fFamily;\n    len = documentData.finalText.length; // this.tHelper.font = this.values.fValue;\n\n    var charData;\n    var shapeData;\n    var k;\n    var kLen;\n    var shapes;\n    var j;\n    var jLen;\n    var pathNodes;\n    var commands;\n    var pathArr;\n    var singleShape = this.data.singleShape;\n    var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;\n    var xPos = 0;\n    var yPos = 0;\n    var firstLine = true;\n    var cnt = 0;\n\n    for (i = 0; i < len; i += 1) {\n      charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);\n      shapeData = charData && charData.data || {};\n      matrixHelper.reset();\n\n      if (singleShape && letters[i].n) {\n        xPos = -trackingOffset;\n        yPos += documentData.yOffset;\n        yPos += firstLine ? 1 : 0;\n        firstLine = false;\n      }\n\n      shapes = shapeData.shapes ? shapeData.shapes[0].it : [];\n      jLen = shapes.length;\n      matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);\n\n      if (singleShape) {\n        this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);\n      }\n\n      commands = createSizedArray(jLen - 1);\n      var commandsCounter = 0;\n\n      for (j = 0; j < jLen; j += 1) {\n        if (shapes[j].ty === 'sh') {\n          kLen = shapes[j].ks.k.i.length;\n          pathNodes = shapes[j].ks.k;\n          pathArr = [];\n\n          for (k = 1; k < kLen; k += 1) {\n            if (k === 1) {\n              pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));\n            }\n\n            pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToY(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToX(pathNodes.v[k][0], pathNodes.v[k][1], 0), matrixHelper.applyToY(pathNodes.v[k][0], pathNodes.v[k][1], 0));\n          }\n\n          pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));\n          commands[commandsCounter] = pathArr;\n          commandsCounter += 1;\n        }\n      }\n\n      if (singleShape) {\n        xPos += letters[i].l;\n        xPos += trackingOffset;\n      }\n\n      if (this.textSpans[cnt]) {\n        this.textSpans[cnt].elem = commands;\n      } else {\n        this.textSpans[cnt] = {\n          elem: commands\n        };\n      }\n\n      cnt += 1;\n    }\n  };\n\n  CVTextElement.prototype.renderInnerContent = function () {\n    this.validateText();\n    var ctx = this.canvasContext;\n    ctx.font = this.values.fValue;\n    this.globalData.renderer.ctxLineCap('butt'); // ctx.lineCap = 'butt';\n\n    this.globalData.renderer.ctxLineJoin('miter'); // ctx.lineJoin = 'miter';\n\n    this.globalData.renderer.ctxMiterLimit(4); // ctx.miterLimit = 4;\n\n    if (!this.data.singleShape) {\n      this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);\n    }\n\n    var i;\n    var len;\n    var j;\n    var jLen;\n    var k;\n    var kLen;\n    var renderedLetters = this.textAnimator.renderedLetters;\n    var letters = this.textProperty.currentData.l;\n    len = letters.length;\n    var renderedLetter;\n    var lastFill = null;\n    var lastStroke = null;\n    var lastStrokeW = null;\n    var commands;\n    var pathArr;\n    var renderer = this.globalData.renderer;\n\n    for (i = 0; i < len; i += 1) {\n      if (!letters[i].n) {\n        renderedLetter = renderedLetters[i];\n\n        if (renderedLetter) {\n          renderer.save();\n          renderer.ctxTransform(renderedLetter.p);\n          renderer.ctxOpacity(renderedLetter.o);\n        }\n\n        if (this.fill) {\n          if (renderedLetter && renderedLetter.fc) {\n            if (lastFill !== renderedLetter.fc) {\n              renderer.ctxFillStyle(renderedLetter.fc);\n              lastFill = renderedLetter.fc; // ctx.fillStyle = renderedLetter.fc;\n            }\n          } else if (lastFill !== this.values.fill) {\n            lastFill = this.values.fill;\n            renderer.ctxFillStyle(this.values.fill); // ctx.fillStyle = this.values.fill;\n          }\n\n          commands = this.textSpans[i].elem;\n          jLen = commands.length;\n          this.globalData.canvasContext.beginPath();\n\n          for (j = 0; j < jLen; j += 1) {\n            pathArr = commands[j];\n            kLen = pathArr.length;\n            this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);\n\n            for (k = 2; k < kLen; k += 6) {\n              this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);\n            }\n          }\n\n          this.globalData.canvasContext.closePath();\n          renderer.ctxFill(); // this.globalData.canvasContext.fill();\n          /// ctx.fillText(this.textSpans[i].val,0,0);\n        }\n\n        if (this.stroke) {\n          if (renderedLetter && renderedLetter.sw) {\n            if (lastStrokeW !== renderedLetter.sw) {\n              lastStrokeW = renderedLetter.sw;\n              renderer.ctxLineWidth(renderedLetter.sw); // ctx.lineWidth = renderedLetter.sw;\n            }\n          } else if (lastStrokeW !== this.values.sWidth) {\n            lastStrokeW = this.values.sWidth;\n            renderer.ctxLineWidth(this.values.sWidth); // ctx.lineWidth = this.values.sWidth;\n          }\n\n          if (renderedLetter && renderedLetter.sc) {\n            if (lastStroke !== renderedLetter.sc) {\n              lastStroke = renderedLetter.sc;\n              renderer.ctxStrokeStyle(renderedLetter.sc); // ctx.strokeStyle = renderedLetter.sc;\n            }\n          } else if (lastStroke !== this.values.stroke) {\n            lastStroke = this.values.stroke;\n            renderer.ctxStrokeStyle(this.values.stroke); // ctx.strokeStyle = this.values.stroke;\n          }\n\n          commands = this.textSpans[i].elem;\n          jLen = commands.length;\n          this.globalData.canvasContext.beginPath();\n\n          for (j = 0; j < jLen; j += 1) {\n            pathArr = commands[j];\n            kLen = pathArr.length;\n            this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);\n\n            for (k = 2; k < kLen; k += 6) {\n              this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);\n            }\n          }\n\n          this.globalData.canvasContext.closePath();\n          renderer.ctxStroke(); // this.globalData.canvasContext.stroke();\n          /// ctx.strokeText(letters[i].val,0,0);\n        }\n\n        if (renderedLetter) {\n          this.globalData.renderer.restore();\n        }\n      }\n    }\n  };\n\n  function CVImageElement(data, globalData, comp) {\n    this.assetData = globalData.getAssetData(data.refId);\n    this.img = globalData.imageLoader.getAsset(this.assetData);\n    this.initElement(data, globalData, comp);\n  }\n\n  extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement);\n  CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;\n  CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;\n\n  CVImageElement.prototype.createContent = function () {\n    if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {\n      var canvas = createTag('canvas');\n      canvas.width = this.assetData.w;\n      canvas.height = this.assetData.h;\n      var ctx = canvas.getContext('2d');\n      var imgW = this.img.width;\n      var imgH = this.img.height;\n      var imgRel = imgW / imgH;\n      var canvasRel = this.assetData.w / this.assetData.h;\n      var widthCrop;\n      var heightCrop;\n      var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;\n\n      if (imgRel > canvasRel && par === 'xMidYMid slice' || imgRel < canvasRel && par !== 'xMidYMid slice') {\n        heightCrop = imgH;\n        widthCrop = heightCrop * canvasRel;\n      } else {\n        widthCrop = imgW;\n        heightCrop = widthCrop / canvasRel;\n      }\n\n      ctx.drawImage(this.img, (imgW - widthCrop) / 2, (imgH - heightCrop) / 2, widthCrop, heightCrop, 0, 0, this.assetData.w, this.assetData.h);\n      this.img = canvas;\n    }\n  };\n\n  CVImageElement.prototype.renderInnerContent = function () {\n    this.canvasContext.drawImage(this.img, 0, 0);\n  };\n\n  CVImageElement.prototype.destroy = function () {\n    this.img = null;\n  };\n\n  function CVSolidElement(data, globalData, comp) {\n    this.initElement(data, globalData, comp);\n  }\n\n  extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement);\n  CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;\n  CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;\n\n  CVSolidElement.prototype.renderInnerContent = function () {\n    // var ctx = this.canvasContext;\n    this.globalData.renderer.ctxFillStyle(this.data.sc); // ctx.fillStyle = this.data.sc;\n\n    this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh); // ctx.fillRect(0, 0, this.data.sw, this.data.sh);\n    //\n  };\n\n  function CanvasRendererBase() {}\n\n  extendPrototype([BaseRenderer], CanvasRendererBase);\n\n  CanvasRendererBase.prototype.createShape = function (data) {\n    return new CVShapeElement(data, this.globalData, this);\n  };\n\n  CanvasRendererBase.prototype.createText = function (data) {\n    return new CVTextElement(data, this.globalData, this);\n  };\n\n  CanvasRendererBase.prototype.createImage = function (data) {\n    return new CVImageElement(data, this.globalData, this);\n  };\n\n  CanvasRendererBase.prototype.createSolid = function (data) {\n    return new CVSolidElement(data, this.globalData, this);\n  };\n\n  CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;\n\n  CanvasRendererBase.prototype.ctxTransform = function (props) {\n    if (props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0) {\n      return;\n    }\n\n    this.canvasContext.transform(props[0], props[1], props[4], props[5], props[12], props[13]);\n  };\n\n  CanvasRendererBase.prototype.ctxOpacity = function (op) {\n    this.canvasContext.globalAlpha *= op < 0 ? 0 : op;\n  };\n\n  CanvasRendererBase.prototype.ctxFillStyle = function (value) {\n    this.canvasContext.fillStyle = value;\n  };\n\n  CanvasRendererBase.prototype.ctxStrokeStyle = function (value) {\n    this.canvasContext.strokeStyle = value;\n  };\n\n  CanvasRendererBase.prototype.ctxLineWidth = function (value) {\n    this.canvasContext.lineWidth = value;\n  };\n\n  CanvasRendererBase.prototype.ctxLineCap = function (value) {\n    this.canvasContext.lineCap = value;\n  };\n\n  CanvasRendererBase.prototype.ctxLineJoin = function (value) {\n    this.canvasContext.lineJoin = value;\n  };\n\n  CanvasRendererBase.prototype.ctxMiterLimit = function (value) {\n    this.canvasContext.miterLimit = value;\n  };\n\n  CanvasRendererBase.prototype.ctxFill = function (rule) {\n    this.canvasContext.fill(rule);\n  };\n\n  CanvasRendererBase.prototype.ctxFillRect = function (x, y, w, h) {\n    this.canvasContext.fillRect(x, y, w, h);\n  };\n\n  CanvasRendererBase.prototype.ctxStroke = function () {\n    this.canvasContext.stroke();\n  };\n\n  CanvasRendererBase.prototype.reset = function () {\n    if (!this.renderConfig.clearCanvas) {\n      this.canvasContext.restore();\n      return;\n    }\n\n    this.contextData.reset();\n  };\n\n  CanvasRendererBase.prototype.save = function () {\n    this.canvasContext.save();\n  };\n\n  CanvasRendererBase.prototype.restore = function (actionFlag) {\n    if (!this.renderConfig.clearCanvas) {\n      this.canvasContext.restore();\n      return;\n    }\n\n    if (actionFlag) {\n      this.globalData.blendMode = 'source-over';\n    }\n\n    this.contextData.restore(actionFlag);\n  };\n\n  CanvasRendererBase.prototype.configAnimation = function (animData) {\n    if (this.animationItem.wrapper) {\n      this.animationItem.container = createTag('canvas');\n      var containerStyle = this.animationItem.container.style;\n      containerStyle.width = '100%';\n      containerStyle.height = '100%';\n      var origin = '0px 0px 0px';\n      containerStyle.transformOrigin = origin;\n      containerStyle.mozTransformOrigin = origin;\n      containerStyle.webkitTransformOrigin = origin;\n      containerStyle['-webkit-transform'] = origin;\n      containerStyle.contentVisibility = this.renderConfig.contentVisibility;\n      this.animationItem.wrapper.appendChild(this.animationItem.container);\n      this.canvasContext = this.animationItem.container.getContext('2d');\n\n      if (this.renderConfig.className) {\n        this.animationItem.container.setAttribute('class', this.renderConfig.className);\n      }\n\n      if (this.renderConfig.id) {\n        this.animationItem.container.setAttribute('id', this.renderConfig.id);\n      }\n    } else {\n      this.canvasContext = this.renderConfig.context;\n    }\n\n    this.contextData.setContext(this.canvasContext);\n    this.data = animData;\n    this.layers = animData.layers;\n    this.transformCanvas = {\n      w: animData.w,\n      h: animData.h,\n      sx: 0,\n      sy: 0,\n      tx: 0,\n      ty: 0\n    };\n    this.setupGlobalData(animData, document.body);\n    this.globalData.canvasContext = this.canvasContext;\n    this.globalData.renderer = this;\n    this.globalData.isDashed = false;\n    this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;\n    this.globalData.transformCanvas = this.transformCanvas;\n    this.elements = createSizedArray(animData.layers.length);\n    this.updateContainerSize();\n  };\n\n  CanvasRendererBase.prototype.updateContainerSize = function (width, height) {\n    this.reset();\n    var elementWidth;\n    var elementHeight;\n\n    if (width) {\n      elementWidth = width;\n      elementHeight = height;\n      this.canvasContext.canvas.width = elementWidth;\n      this.canvasContext.canvas.height = elementHeight;\n    } else {\n      if (this.animationItem.wrapper && this.animationItem.container) {\n        elementWidth = this.animationItem.wrapper.offsetWidth;\n        elementHeight = this.animationItem.wrapper.offsetHeight;\n      } else {\n        elementWidth = this.canvasContext.canvas.width;\n        elementHeight = this.canvasContext.canvas.height;\n      }\n\n      this.canvasContext.canvas.width = elementWidth * this.renderConfig.dpr;\n      this.canvasContext.canvas.height = elementHeight * this.renderConfig.dpr;\n    }\n\n    var elementRel;\n    var animationRel;\n\n    if (this.renderConfig.preserveAspectRatio.indexOf('meet') !== -1 || this.renderConfig.preserveAspectRatio.indexOf('slice') !== -1) {\n      var par = this.renderConfig.preserveAspectRatio.split(' ');\n      var fillType = par[1] || 'meet';\n      var pos = par[0] || 'xMidYMid';\n      var xPos = pos.substr(0, 4);\n      var yPos = pos.substr(4);\n      elementRel = elementWidth / elementHeight;\n      animationRel = this.transformCanvas.w / this.transformCanvas.h;\n\n      if (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice') {\n        this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);\n        this.transformCanvas.sy = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);\n      } else {\n        this.transformCanvas.sx = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);\n        this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);\n      }\n\n      if (xPos === 'xMid' && (animationRel < elementRel && fillType === 'meet' || animationRel > elementRel && fillType === 'slice')) {\n        this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) / 2 * this.renderConfig.dpr;\n      } else if (xPos === 'xMax' && (animationRel < elementRel && fillType === 'meet' || animationRel > elementRel && fillType === 'slice')) {\n        this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) * this.renderConfig.dpr;\n      } else {\n        this.transformCanvas.tx = 0;\n      }\n\n      if (yPos === 'YMid' && (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice')) {\n        this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) / 2 * this.renderConfig.dpr;\n      } else if (yPos === 'YMax' && (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice')) {\n        this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) * this.renderConfig.dpr;\n      } else {\n        this.transformCanvas.ty = 0;\n      }\n    } else if (this.renderConfig.preserveAspectRatio === 'none') {\n      this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);\n      this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);\n      this.transformCanvas.tx = 0;\n      this.transformCanvas.ty = 0;\n    } else {\n      this.transformCanvas.sx = this.renderConfig.dpr;\n      this.transformCanvas.sy = this.renderConfig.dpr;\n      this.transformCanvas.tx = 0;\n      this.transformCanvas.ty = 0;\n    }\n\n    this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1];\n    /* var i, len = this.elements.length;\r\n      for(i=0;i<len;i+=1){\r\n          if(this.elements[i] && this.elements[i].data.ty === 0){\r\n              this.elements[i].resize(this.globalData.transformCanvas);\r\n          }\r\n      } */\n\n    this.ctxTransform(this.transformCanvas.props);\n    this.canvasContext.beginPath();\n    this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h);\n    this.canvasContext.closePath();\n    this.canvasContext.clip();\n    this.renderFrame(this.renderedFrame, true);\n  };\n\n  CanvasRendererBase.prototype.destroy = function () {\n    if (this.renderConfig.clearCanvas && this.animationItem.wrapper) {\n      this.animationItem.wrapper.innerText = '';\n    }\n\n    var i;\n    var len = this.layers ? this.layers.length : 0;\n\n    for (i = len - 1; i >= 0; i -= 1) {\n      if (this.elements[i] && this.elements[i].destroy) {\n        this.elements[i].destroy();\n      }\n    }\n\n    this.elements.length = 0;\n    this.globalData.canvasContext = null;\n    this.animationItem.container = null;\n    this.destroyed = true;\n  };\n\n  CanvasRendererBase.prototype.renderFrame = function (num, forceRender) {\n    if (this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender || this.destroyed || num === -1) {\n      return;\n    }\n\n    this.renderedFrame = num;\n    this.globalData.frameNum = num - this.animationItem._isFirstFrame;\n    this.globalData.frameId += 1;\n    this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender;\n    this.globalData.projectInterface.currentFrame = num; // console.log('--------');\n    // console.log('NEW: ',num);\n\n    var i;\n    var len = this.layers.length;\n\n    if (!this.completeLayers) {\n      this.checkLayers(num);\n    }\n\n    for (i = len - 1; i >= 0; i -= 1) {\n      if (this.completeLayers || this.elements[i]) {\n        this.elements[i].prepareFrame(num - this.layers[i].st);\n      }\n    }\n\n    if (this.globalData._mdf) {\n      if (this.renderConfig.clearCanvas === true) {\n        this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h);\n      } else {\n        this.save();\n      }\n\n      for (i = len - 1; i >= 0; i -= 1) {\n        if (this.completeLayers || this.elements[i]) {\n          this.elements[i].renderFrame();\n        }\n      }\n\n      if (this.renderConfig.clearCanvas !== true) {\n        this.restore();\n      }\n    }\n  };\n\n  CanvasRendererBase.prototype.buildItem = function (pos) {\n    var elements = this.elements;\n\n    if (elements[pos] || this.layers[pos].ty === 99) {\n      return;\n    }\n\n    var element = this.createItem(this.layers[pos], this, this.globalData);\n    elements[pos] = element;\n    element.initExpressions();\n    /* if(this.layers[pos].ty === 0){\r\n          element.resize(this.globalData.transformCanvas);\r\n      } */\n  };\n\n  CanvasRendererBase.prototype.checkPendingElements = function () {\n    while (this.pendingElements.length) {\n      var element = this.pendingElements.pop();\n      element.checkParenting();\n    }\n  };\n\n  CanvasRendererBase.prototype.hide = function () {\n    this.animationItem.container.style.display = 'none';\n  };\n\n  CanvasRendererBase.prototype.show = function () {\n    this.animationItem.container.style.display = 'block';\n  };\n\n  function CanvasContext() {\n    this.opacity = -1;\n    this.transform = createTypedArray('float32', 16);\n    this.fillStyle = '';\n    this.strokeStyle = '';\n    this.lineWidth = '';\n    this.lineCap = '';\n    this.lineJoin = '';\n    this.miterLimit = '';\n    this.id = Math.random();\n  }\n\n  function CVContextData() {\n    this.stack = [];\n    this.cArrPos = 0;\n    this.cTr = new Matrix();\n    var i;\n    var len = 15;\n\n    for (i = 0; i < len; i += 1) {\n      var canvasContext = new CanvasContext();\n      this.stack[i] = canvasContext;\n    }\n\n    this._length = len;\n    this.nativeContext = null;\n    this.transformMat = new Matrix();\n    this.currentOpacity = 1; //\n\n    this.currentFillStyle = '';\n    this.appliedFillStyle = ''; //\n\n    this.currentStrokeStyle = '';\n    this.appliedStrokeStyle = ''; //\n\n    this.currentLineWidth = '';\n    this.appliedLineWidth = ''; //\n\n    this.currentLineCap = '';\n    this.appliedLineCap = ''; //\n\n    this.currentLineJoin = '';\n    this.appliedLineJoin = ''; //\n\n    this.appliedMiterLimit = '';\n    this.currentMiterLimit = '';\n  }\n\n  CVContextData.prototype.duplicate = function () {\n    var newLength = this._length * 2;\n    var i = 0;\n\n    for (i = this._length; i < newLength; i += 1) {\n      this.stack[i] = new CanvasContext();\n    }\n\n    this._length = newLength;\n  };\n\n  CVContextData.prototype.reset = function () {\n    this.cArrPos = 0;\n    this.cTr.reset();\n    this.stack[this.cArrPos].opacity = 1;\n  };\n\n  CVContextData.prototype.restore = function (forceRestore) {\n    this.cArrPos -= 1;\n    var currentContext = this.stack[this.cArrPos];\n    var transform = currentContext.transform;\n    var i;\n    var arr = this.cTr.props;\n\n    for (i = 0; i < 16; i += 1) {\n      arr[i] = transform[i];\n    }\n\n    if (forceRestore) {\n      this.nativeContext.restore();\n      var prevStack = this.stack[this.cArrPos + 1];\n      this.appliedFillStyle = prevStack.fillStyle;\n      this.appliedStrokeStyle = prevStack.strokeStyle;\n      this.appliedLineWidth = prevStack.lineWidth;\n      this.appliedLineCap = prevStack.lineCap;\n      this.appliedLineJoin = prevStack.lineJoin;\n      this.appliedMiterLimit = prevStack.miterLimit;\n    }\n\n    this.nativeContext.setTransform(transform[0], transform[1], transform[4], transform[5], transform[12], transform[13]);\n\n    if (forceRestore || currentContext.opacity !== -1 && this.currentOpacity !== currentContext.opacity) {\n      this.nativeContext.globalAlpha = currentContext.opacity;\n      this.currentOpacity = currentContext.opacity;\n    }\n\n    this.currentFillStyle = currentContext.fillStyle;\n    this.currentStrokeStyle = currentContext.strokeStyle;\n    this.currentLineWidth = currentContext.lineWidth;\n    this.currentLineCap = currentContext.lineCap;\n    this.currentLineJoin = currentContext.lineJoin;\n    this.currentMiterLimit = currentContext.miterLimit;\n  };\n\n  CVContextData.prototype.save = function (saveOnNativeFlag) {\n    if (saveOnNativeFlag) {\n      this.nativeContext.save();\n    }\n\n    var props = this.cTr.props;\n\n    if (this._length <= this.cArrPos) {\n      this.duplicate();\n    }\n\n    var currentStack = this.stack[this.cArrPos];\n    var i;\n\n    for (i = 0; i < 16; i += 1) {\n      currentStack.transform[i] = props[i];\n    }\n\n    this.cArrPos += 1;\n    var newStack = this.stack[this.cArrPos];\n    newStack.opacity = currentStack.opacity;\n    newStack.fillStyle = currentStack.fillStyle;\n    newStack.strokeStyle = currentStack.strokeStyle;\n    newStack.lineWidth = currentStack.lineWidth;\n    newStack.lineCap = currentStack.lineCap;\n    newStack.lineJoin = currentStack.lineJoin;\n    newStack.miterLimit = currentStack.miterLimit;\n  };\n\n  CVContextData.prototype.setOpacity = function (value) {\n    this.stack[this.cArrPos].opacity = value;\n  };\n\n  CVContextData.prototype.setContext = function (value) {\n    this.nativeContext = value;\n  };\n\n  CVContextData.prototype.fillStyle = function (value) {\n    if (this.stack[this.cArrPos].fillStyle !== value) {\n      this.currentFillStyle = value;\n      this.stack[this.cArrPos].fillStyle = value;\n    }\n  };\n\n  CVContextData.prototype.strokeStyle = function (value) {\n    if (this.stack[this.cArrPos].strokeStyle !== value) {\n      this.currentStrokeStyle = value;\n      this.stack[this.cArrPos].strokeStyle = value;\n    }\n  };\n\n  CVContextData.prototype.lineWidth = function (value) {\n    if (this.stack[this.cArrPos].lineWidth !== value) {\n      this.currentLineWidth = value;\n      this.stack[this.cArrPos].lineWidth = value;\n    }\n  };\n\n  CVContextData.prototype.lineCap = function (value) {\n    if (this.stack[this.cArrPos].lineCap !== value) {\n      this.currentLineCap = value;\n      this.stack[this.cArrPos].lineCap = value;\n    }\n  };\n\n  CVContextData.prototype.lineJoin = function (value) {\n    if (this.stack[this.cArrPos].lineJoin !== value) {\n      this.currentLineJoin = value;\n      this.stack[this.cArrPos].lineJoin = value;\n    }\n  };\n\n  CVContextData.prototype.miterLimit = function (value) {\n    if (this.stack[this.cArrPos].miterLimit !== value) {\n      this.currentMiterLimit = value;\n      this.stack[this.cArrPos].miterLimit = value;\n    }\n  };\n\n  CVContextData.prototype.transform = function (props) {\n    this.transformMat.cloneFromProps(props); // Taking the last transform value from the stored stack of transforms\n\n    var currentTransform = this.cTr; // Applying the last transform value after the new transform to respect the order of transformations\n\n    this.transformMat.multiply(currentTransform); // Storing the new transformed value in the stored transform\n\n    currentTransform.cloneFromProps(this.transformMat.props);\n    var trProps = currentTransform.props; // Applying the new transform to the canvas\n\n    this.nativeContext.setTransform(trProps[0], trProps[1], trProps[4], trProps[5], trProps[12], trProps[13]);\n  };\n\n  CVContextData.prototype.opacity = function (op) {\n    var currentOpacity = this.stack[this.cArrPos].opacity;\n    currentOpacity *= op < 0 ? 0 : op;\n\n    if (this.stack[this.cArrPos].opacity !== currentOpacity) {\n      if (this.currentOpacity !== op) {\n        this.nativeContext.globalAlpha = op;\n        this.currentOpacity = op;\n      }\n\n      this.stack[this.cArrPos].opacity = currentOpacity;\n    }\n  };\n\n  CVContextData.prototype.fill = function (rule) {\n    if (this.appliedFillStyle !== this.currentFillStyle) {\n      this.appliedFillStyle = this.currentFillStyle;\n      this.nativeContext.fillStyle = this.appliedFillStyle;\n    }\n\n    this.nativeContext.fill(rule);\n  };\n\n  CVContextData.prototype.fillRect = function (x, y, w, h) {\n    if (this.appliedFillStyle !== this.currentFillStyle) {\n      this.appliedFillStyle = this.currentFillStyle;\n      this.nativeContext.fillStyle = this.appliedFillStyle;\n    }\n\n    this.nativeContext.fillRect(x, y, w, h);\n  };\n\n  CVContextData.prototype.stroke = function () {\n    if (this.appliedStrokeStyle !== this.currentStrokeStyle) {\n      this.appliedStrokeStyle = this.currentStrokeStyle;\n      this.nativeContext.strokeStyle = this.appliedStrokeStyle;\n    }\n\n    if (this.appliedLineWidth !== this.currentLineWidth) {\n      this.appliedLineWidth = this.currentLineWidth;\n      this.nativeContext.lineWidth = this.appliedLineWidth;\n    }\n\n    if (this.appliedLineCap !== this.currentLineCap) {\n      this.appliedLineCap = this.currentLineCap;\n      this.nativeContext.lineCap = this.appliedLineCap;\n    }\n\n    if (this.appliedLineJoin !== this.currentLineJoin) {\n      this.appliedLineJoin = this.currentLineJoin;\n      this.nativeContext.lineJoin = this.appliedLineJoin;\n    }\n\n    if (this.appliedMiterLimit !== this.currentMiterLimit) {\n      this.appliedMiterLimit = this.currentMiterLimit;\n      this.nativeContext.miterLimit = this.appliedMiterLimit;\n    }\n\n    this.nativeContext.stroke();\n  };\n\n  function CVCompElement(data, globalData, comp) {\n    this.completeLayers = false;\n    this.layers = data.layers;\n    this.pendingElements = [];\n    this.elements = createSizedArray(this.layers.length);\n    this.initElement(data, globalData, comp);\n    this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {\n      _placeholder: true\n    };\n  }\n\n  extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement);\n\n  CVCompElement.prototype.renderInnerContent = function () {\n    var ctx = this.canvasContext;\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(this.data.w, 0);\n    ctx.lineTo(this.data.w, this.data.h);\n    ctx.lineTo(0, this.data.h);\n    ctx.lineTo(0, 0);\n    ctx.clip();\n    var i;\n    var len = this.layers.length;\n\n    for (i = len - 1; i >= 0; i -= 1) {\n      if (this.completeLayers || this.elements[i]) {\n        this.elements[i].renderFrame();\n      }\n    }\n  };\n\n  CVCompElement.prototype.destroy = function () {\n    var i;\n    var len = this.layers.length;\n\n    for (i = len - 1; i >= 0; i -= 1) {\n      if (this.elements[i]) {\n        this.elements[i].destroy();\n      }\n    }\n\n    this.layers = null;\n    this.elements = null;\n  };\n\n  CVCompElement.prototype.createComp = function (data) {\n    return new CVCompElement(data, this.globalData, this);\n  };\n\n  function CanvasRenderer(animationItem, config) {\n    this.animationItem = animationItem;\n    this.renderConfig = {\n      clearCanvas: config && config.clearCanvas !== undefined ? config.clearCanvas : true,\n      context: config && config.context || null,\n      progressiveLoad: config && config.progressiveLoad || false,\n      preserveAspectRatio: config && config.preserveAspectRatio || 'xMidYMid meet',\n      imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',\n      contentVisibility: config && config.contentVisibility || 'visible',\n      className: config && config.className || '',\n      id: config && config.id || '',\n      runExpressions: !config || config.runExpressions === undefined || config.runExpressions\n    };\n    this.renderConfig.dpr = config && config.dpr || 1;\n\n    if (this.animationItem.wrapper) {\n      this.renderConfig.dpr = config && config.dpr || window.devicePixelRatio || 1;\n    }\n\n    this.renderedFrame = -1;\n    this.globalData = {\n      frameNum: -1,\n      _mdf: false,\n      renderConfig: this.renderConfig,\n      currentGlobalAlpha: -1\n    };\n    this.contextData = new CVContextData();\n    this.elements = [];\n    this.pendingElements = [];\n    this.transformMat = new Matrix();\n    this.completeLayers = false;\n    this.rendererType = 'canvas';\n\n    if (this.renderConfig.clearCanvas) {\n      this.ctxTransform = this.contextData.transform.bind(this.contextData);\n      this.ctxOpacity = this.contextData.opacity.bind(this.contextData);\n      this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData);\n      this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData);\n      this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData);\n      this.ctxLineCap = this.contextData.lineCap.bind(this.contextData);\n      this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData);\n      this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData);\n      this.ctxFill = this.contextData.fill.bind(this.contextData);\n      this.ctxFillRect = this.contextData.fillRect.bind(this.contextData);\n      this.ctxStroke = this.contextData.stroke.bind(this.contextData);\n      this.save = this.contextData.save.bind(this.contextData);\n    }\n  }\n\n  extendPrototype([CanvasRendererBase], CanvasRenderer);\n\n  CanvasRenderer.prototype.createComp = function (data) {\n    return new CVCompElement(data, this.globalData, this);\n  };\n\n  function HBaseElement() {}\n\n  HBaseElement.prototype = {\n    checkBlendMode: function checkBlendMode() {},\n    initRendererElement: function initRendererElement() {\n      this.baseElement = createTag(this.data.tg || 'div');\n\n      if (this.data.hasMask) {\n        this.svgElement = createNS('svg');\n        this.layerElement = createNS('g');\n        this.maskedElement = this.layerElement;\n        this.svgElement.appendChild(this.layerElement);\n        this.baseElement.appendChild(this.svgElement);\n      } else {\n        this.layerElement = this.baseElement;\n      }\n\n      styleDiv(this.baseElement);\n    },\n    createContainerElements: function createContainerElements() {\n      this.renderableEffectsManager = new CVEffects(this);\n      this.transformedElement = this.baseElement;\n      this.maskedElement = this.layerElement;\n\n      if (this.data.ln) {\n        this.layerElement.setAttribute('id', this.data.ln);\n      }\n\n      if (this.data.cl) {\n        this.layerElement.setAttribute('class', this.data.cl);\n      }\n\n      if (this.data.bm !== 0) {\n        this.setBlendMode();\n      }\n    },\n    renderElement: function renderElement() {\n      var transformedElementStyle = this.transformedElement ? this.transformedElement.style : {};\n\n      if (this.finalTransform._matMdf) {\n        var matrixValue = this.finalTransform.mat.toCSS();\n        transformedElementStyle.transform = matrixValue;\n        transformedElementStyle.webkitTransform = matrixValue;\n      }\n\n      if (this.finalTransform._opMdf) {\n        transformedElementStyle.opacity = this.finalTransform.mProp.o.v;\n      }\n    },\n    renderFrame: function renderFrame() {\n      // If it is exported as hidden (data.hd === true) no need to render\n      // If it is not visible no need to render\n      if (this.data.hd || this.hidden) {\n        return;\n      }\n\n      this.renderTransform();\n      this.renderRenderable();\n      this.renderElement();\n      this.renderInnerContent();\n\n      if (this._isFirstFrame) {\n        this._isFirstFrame = false;\n      }\n    },\n    destroy: function destroy() {\n      this.layerElement = null;\n      this.transformedElement = null;\n\n      if (this.matteElement) {\n        this.matteElement = null;\n      }\n\n      if (this.maskManager) {\n        this.maskManager.destroy();\n        this.maskManager = null;\n      }\n    },\n    createRenderableComponents: function createRenderableComponents() {\n      this.maskManager = new MaskElement(this.data, this, this.globalData);\n    },\n    addEffects: function addEffects() {},\n    setMatte: function setMatte() {}\n  };\n  HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;\n  HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;\n  HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;\n\n  function HSolidElement(data, globalData, comp) {\n    this.initElement(data, globalData, comp);\n  }\n\n  extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement);\n\n  HSolidElement.prototype.createContent = function () {\n    var rect;\n\n    if (this.data.hasMask) {\n      rect = createNS('rect');\n      rect.setAttribute('width', this.data.sw);\n      rect.setAttribute('height', this.data.sh);\n      rect.setAttribute('fill', this.data.sc);\n      this.svgElement.setAttribute('width', this.data.sw);\n      this.svgElement.setAttribute('height', this.data.sh);\n    } else {\n      rect = createTag('div');\n      rect.style.width = this.data.sw + 'px';\n      rect.style.height = this.data.sh + 'px';\n      rect.style.backgroundColor = this.data.sc;\n    }\n\n    this.layerElement.appendChild(rect);\n  };\n\n  function HShapeElement(data, globalData, comp) {\n    // List of drawable elements\n    this.shapes = []; // Full shape data\n\n    this.shapesData = data.shapes; // List of styles that will be applied to shapes\n\n    this.stylesList = []; // List of modifiers that will be applied to shapes\n\n    this.shapeModifiers = []; // List of items in shape tree\n\n    this.itemsData = []; // List of items in previous shape tree\n\n    this.processedElements = []; // List of animated components\n\n    this.animatedContents = [];\n    this.shapesContainer = createNS('g');\n    this.initElement(data, globalData, comp); // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.\n    // List of elements that have been created\n\n    this.prevViewData = [];\n    this.currentBBox = {\n      x: 999999,\n      y: -999999,\n      h: 0,\n      w: 0\n    };\n  }\n\n  extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement);\n  HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;\n\n  HShapeElement.prototype.createContent = function () {\n    var cont;\n    this.baseElement.style.fontSize = 0;\n\n    if (this.data.hasMask) {\n      this.layerElement.appendChild(this.shapesContainer);\n      cont = this.svgElement;\n    } else {\n      cont = createNS('svg');\n      var size = this.comp.data ? this.comp.data : this.globalData.compSize;\n      cont.setAttribute('width', size.w);\n      cont.setAttribute('height', size.h);\n      cont.appendChild(this.shapesContainer);\n      this.layerElement.appendChild(cont);\n    }\n\n    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], true);\n    this.filterUniqueShapes();\n    this.shapeCont = cont;\n  };\n\n  HShapeElement.prototype.getTransformedPoint = function (transformers, point) {\n    var i;\n    var len = transformers.length;\n\n    for (i = 0; i < len; i += 1) {\n      point = transformers[i].mProps.v.applyToPointArray(point[0], point[1], 0);\n    }\n\n    return point;\n  };\n\n  HShapeElement.prototype.calculateShapeBoundingBox = function (item, boundingBox) {\n    var shape = item.sh.v;\n    var transformers = item.transformers;\n    var i;\n    var len = shape._length;\n    var vPoint;\n    var oPoint;\n    var nextIPoint;\n    var nextVPoint;\n\n    if (len <= 1) {\n      return;\n    }\n\n    for (i = 0; i < len - 1; i += 1) {\n      vPoint = this.getTransformedPoint(transformers, shape.v[i]);\n      oPoint = this.getTransformedPoint(transformers, shape.o[i]);\n      nextIPoint = this.getTransformedPoint(transformers, shape.i[i + 1]);\n      nextVPoint = this.getTransformedPoint(transformers, shape.v[i + 1]);\n      this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);\n    }\n\n    if (shape.c) {\n      vPoint = this.getTransformedPoint(transformers, shape.v[i]);\n      oPoint = this.getTransformedPoint(transformers, shape.o[i]);\n      nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);\n      nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);\n      this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);\n    }\n  };\n\n  HShapeElement.prototype.checkBounds = function (vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {\n    this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);\n    var bounds = this.shapeBoundingBox;\n    boundingBox.x = bmMin(bounds.left, boundingBox.x);\n    boundingBox.xMax = bmMax(bounds.right, boundingBox.xMax);\n    boundingBox.y = bmMin(bounds.top, boundingBox.y);\n    boundingBox.yMax = bmMax(bounds.bottom, boundingBox.yMax);\n  };\n\n  HShapeElement.prototype.shapeBoundingBox = {\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0\n  };\n  HShapeElement.prototype.tempBoundingBox = {\n    x: 0,\n    xMax: 0,\n    y: 0,\n    yMax: 0,\n    width: 0,\n    height: 0\n  };\n\n  HShapeElement.prototype.getBoundsOfCurve = function (p0, p1, p2, p3) {\n    var bounds = [[p0[0], p3[0]], [p0[1], p3[1]]];\n\n    for (var a, b, c, t, b2ac, t1, t2, i = 0; i < 2; ++i) {\n      // eslint-disable-line no-plusplus\n      b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];\n      a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];\n      c = 3 * p1[i] - 3 * p0[i];\n      b |= 0; // eslint-disable-line no-bitwise\n\n      a |= 0; // eslint-disable-line no-bitwise\n\n      c |= 0; // eslint-disable-line no-bitwise\n\n      if (a === 0 && b === 0) {//\n      } else if (a === 0) {\n        t = -c / b;\n\n        if (t > 0 && t < 1) {\n          bounds[i].push(this.calculateF(t, p0, p1, p2, p3, i));\n        }\n      } else {\n        b2ac = b * b - 4 * c * a;\n\n        if (b2ac >= 0) {\n          t1 = (-b + bmSqrt(b2ac)) / (2 * a);\n          if (t1 > 0 && t1 < 1) bounds[i].push(this.calculateF(t1, p0, p1, p2, p3, i));\n          t2 = (-b - bmSqrt(b2ac)) / (2 * a);\n          if (t2 > 0 && t2 < 1) bounds[i].push(this.calculateF(t2, p0, p1, p2, p3, i));\n        }\n      }\n    }\n\n    this.shapeBoundingBox.left = bmMin.apply(null, bounds[0]);\n    this.shapeBoundingBox.top = bmMin.apply(null, bounds[1]);\n    this.shapeBoundingBox.right = bmMax.apply(null, bounds[0]);\n    this.shapeBoundingBox.bottom = bmMax.apply(null, bounds[1]);\n  };\n\n  HShapeElement.prototype.calculateF = function (t, p0, p1, p2, p3, i) {\n    return bmPow(1 - t, 3) * p0[i] + 3 * bmPow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * bmPow(t, 2) * p2[i] + bmPow(t, 3) * p3[i];\n  };\n\n  HShapeElement.prototype.calculateBoundingBox = function (itemsData, boundingBox) {\n    var i;\n    var len = itemsData.length;\n\n    for (i = 0; i < len; i += 1) {\n      if (itemsData[i] && itemsData[i].sh) {\n        this.calculateShapeBoundingBox(itemsData[i], boundingBox);\n      } else if (itemsData[i] && itemsData[i].it) {\n        this.calculateBoundingBox(itemsData[i].it, boundingBox);\n      } else if (itemsData[i] && itemsData[i].style && itemsData[i].w) {\n        this.expandStrokeBoundingBox(itemsData[i].w, boundingBox);\n      }\n    }\n  };\n\n  HShapeElement.prototype.expandStrokeBoundingBox = function (widthProperty, boundingBox) {\n    var width = 0;\n\n    if (widthProperty.keyframes) {\n      for (var i = 0; i < widthProperty.keyframes.length; i += 1) {\n        var kfw = widthProperty.keyframes[i].s;\n\n        if (kfw > width) {\n          width = kfw;\n        }\n      }\n\n      width *= widthProperty.mult;\n    } else {\n      width = widthProperty.v * widthProperty.mult;\n    }\n\n    boundingBox.x -= width;\n    boundingBox.xMax += width;\n    boundingBox.y -= width;\n    boundingBox.yMax += width;\n  };\n\n  HShapeElement.prototype.currentBoxContains = function (box) {\n    return this.currentBBox.x <= box.x && this.currentBBox.y <= box.y && this.currentBBox.width + this.currentBBox.x >= box.x + box.width && this.currentBBox.height + this.currentBBox.y >= box.y + box.height;\n  };\n\n  HShapeElement.prototype.renderInnerContent = function () {\n    this._renderShapeFrame();\n\n    if (!this.hidden && (this._isFirstFrame || this._mdf)) {\n      var tempBoundingBox = this.tempBoundingBox;\n      var max = 999999;\n      tempBoundingBox.x = max;\n      tempBoundingBox.xMax = -max;\n      tempBoundingBox.y = max;\n      tempBoundingBox.yMax = -max;\n      this.calculateBoundingBox(this.itemsData, tempBoundingBox);\n      tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;\n      tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y; // var tempBoundingBox = this.shapeCont.getBBox();\n\n      if (this.currentBoxContains(tempBoundingBox)) {\n        return;\n      }\n\n      var changed = false;\n\n      if (this.currentBBox.w !== tempBoundingBox.width) {\n        this.currentBBox.w = tempBoundingBox.width;\n        this.shapeCont.setAttribute('width', tempBoundingBox.width);\n        changed = true;\n      }\n\n      if (this.currentBBox.h !== tempBoundingBox.height) {\n        this.currentBBox.h = tempBoundingBox.height;\n        this.shapeCont.setAttribute('height', tempBoundingBox.height);\n        changed = true;\n      }\n\n      if (changed || this.currentBBox.x !== tempBoundingBox.x || this.currentBBox.y !== tempBoundingBox.y) {\n        this.currentBBox.w = tempBoundingBox.width;\n        this.currentBBox.h = tempBoundingBox.height;\n        this.currentBBox.x = tempBoundingBox.x;\n        this.currentBBox.y = tempBoundingBox.y;\n        this.shapeCont.setAttribute('viewBox', this.currentBBox.x + ' ' + this.currentBBox.y + ' ' + this.currentBBox.w + ' ' + this.currentBBox.h);\n        var shapeStyle = this.shapeCont.style;\n        var shapeTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';\n        shapeStyle.transform = shapeTransform;\n        shapeStyle.webkitTransform = shapeTransform;\n      }\n    }\n  };\n\n  function HTextElement(data, globalData, comp) {\n    this.textSpans = [];\n    this.textPaths = [];\n    this.currentBBox = {\n      x: 999999,\n      y: -999999,\n      h: 0,\n      w: 0\n    };\n    this.renderType = 'svg';\n    this.isMasked = false;\n    this.initElement(data, globalData, comp);\n  }\n\n  extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement);\n\n  HTextElement.prototype.createContent = function () {\n    this.isMasked = this.checkMasks();\n\n    if (this.isMasked) {\n      this.renderType = 'svg';\n      this.compW = this.comp.data.w;\n      this.compH = this.comp.data.h;\n      this.svgElement.setAttribute('width', this.compW);\n      this.svgElement.setAttribute('height', this.compH);\n      var g = createNS('g');\n      this.maskedElement.appendChild(g);\n      this.innerElem = g;\n    } else {\n      this.renderType = 'html';\n      this.innerElem = this.layerElement;\n    }\n\n    this.checkParenting();\n  };\n\n  HTextElement.prototype.buildNewText = function () {\n    var documentData = this.textProperty.currentData;\n    this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);\n    var innerElemStyle = this.innerElem.style;\n    var textColor = documentData.fc ? this.buildColor(documentData.fc) : 'rgba(0,0,0,0)';\n    innerElemStyle.fill = textColor;\n    innerElemStyle.color = textColor;\n\n    if (documentData.sc) {\n      innerElemStyle.stroke = this.buildColor(documentData.sc);\n      innerElemStyle.strokeWidth = documentData.sw + 'px';\n    }\n\n    var fontData = this.globalData.fontManager.getFontByName(documentData.f);\n\n    if (!this.globalData.fontManager.chars) {\n      innerElemStyle.fontSize = documentData.finalSize + 'px';\n      innerElemStyle.lineHeight = documentData.finalSize + 'px';\n\n      if (fontData.fClass) {\n        this.innerElem.className = fontData.fClass;\n      } else {\n        innerElemStyle.fontFamily = fontData.fFamily;\n        var fWeight = documentData.fWeight;\n        var fStyle = documentData.fStyle;\n        innerElemStyle.fontStyle = fStyle;\n        innerElemStyle.fontWeight = fWeight;\n      }\n    }\n\n    var i;\n    var len;\n    var letters = documentData.l;\n    len = letters.length;\n    var tSpan;\n    var tParent;\n    var tCont;\n    var matrixHelper = this.mHelper;\n    var shapes;\n    var shapeStr = '';\n    var cnt = 0;\n\n    for (i = 0; i < len; i += 1) {\n      if (this.globalData.fontManager.chars) {\n        if (!this.textPaths[cnt]) {\n          tSpan = createNS('path');\n          tSpan.setAttribute('stroke-linecap', lineCapEnum[1]);\n          tSpan.setAttribute('stroke-linejoin', lineJoinEnum[2]);\n          tSpan.setAttribute('stroke-miterlimit', '4');\n        } else {\n          tSpan = this.textPaths[cnt];\n        }\n\n        if (!this.isMasked) {\n          if (this.textSpans[cnt]) {\n            tParent = this.textSpans[cnt];\n            tCont = tParent.children[0];\n          } else {\n            tParent = createTag('div');\n            tParent.style.lineHeight = 0;\n            tCont = createNS('svg');\n            tCont.appendChild(tSpan);\n            styleDiv(tParent);\n          }\n        }\n      } else if (!this.isMasked) {\n        if (this.textSpans[cnt]) {\n          tParent = this.textSpans[cnt];\n          tSpan = this.textPaths[cnt];\n        } else {\n          tParent = createTag('span');\n          styleDiv(tParent);\n          tSpan = createTag('span');\n          styleDiv(tSpan);\n          tParent.appendChild(tSpan);\n        }\n      } else {\n        tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS('text');\n      } // tSpan.setAttribute('visibility', 'hidden');\n\n\n      if (this.globalData.fontManager.chars) {\n        var charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);\n        var shapeData;\n\n        if (charData) {\n          shapeData = charData.data;\n        } else {\n          shapeData = null;\n        }\n\n        matrixHelper.reset();\n\n        if (shapeData && shapeData.shapes && shapeData.shapes.length) {\n          shapes = shapeData.shapes[0].it;\n          matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);\n          shapeStr = this.createPathShape(matrixHelper, shapes);\n          tSpan.setAttribute('d', shapeStr);\n        }\n\n        if (!this.isMasked) {\n          this.innerElem.appendChild(tParent);\n\n          if (shapeData && shapeData.shapes) {\n            // document.body.appendChild is needed to get exact measure of shape\n            document.body.appendChild(tCont);\n            var boundingBox = tCont.getBBox();\n            tCont.setAttribute('width', boundingBox.width + 2);\n            tCont.setAttribute('height', boundingBox.height + 2);\n            tCont.setAttribute('viewBox', boundingBox.x - 1 + ' ' + (boundingBox.y - 1) + ' ' + (boundingBox.width + 2) + ' ' + (boundingBox.height + 2));\n            var tContStyle = tCont.style;\n            var tContTranslation = 'translate(' + (boundingBox.x - 1) + 'px,' + (boundingBox.y - 1) + 'px)';\n            tContStyle.transform = tContTranslation;\n            tContStyle.webkitTransform = tContTranslation;\n            letters[i].yOffset = boundingBox.y - 1;\n          } else {\n            tCont.setAttribute('width', 1);\n            tCont.setAttribute('height', 1);\n          }\n\n          tParent.appendChild(tCont);\n        } else {\n          this.innerElem.appendChild(tSpan);\n        }\n      } else {\n        tSpan.textContent = letters[i].val;\n        tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');\n\n        if (!this.isMasked) {\n          this.innerElem.appendChild(tParent); //\n\n          var tStyle = tSpan.style;\n          var tSpanTranslation = 'translate3d(0,' + -documentData.finalSize / 1.2 + 'px,0)';\n          tStyle.transform = tSpanTranslation;\n          tStyle.webkitTransform = tSpanTranslation;\n        } else {\n          this.innerElem.appendChild(tSpan);\n        }\n      } //\n\n\n      if (!this.isMasked) {\n        this.textSpans[cnt] = tParent;\n      } else {\n        this.textSpans[cnt] = tSpan;\n      }\n\n      this.textSpans[cnt].style.display = 'block';\n      this.textPaths[cnt] = tSpan;\n      cnt += 1;\n    }\n\n    while (cnt < this.textSpans.length) {\n      this.textSpans[cnt].style.display = 'none';\n      cnt += 1;\n    }\n  };\n\n  HTextElement.prototype.renderInnerContent = function () {\n    this.validateText();\n    var svgStyle;\n\n    if (this.data.singleShape) {\n      if (!this._isFirstFrame && !this.lettersChangedFlag) {\n        return;\n      }\n\n      if (this.isMasked && this.finalTransform._matMdf) {\n        // Todo Benchmark if using this is better than getBBox\n        this.svgElement.setAttribute('viewBox', -this.finalTransform.mProp.p.v[0] + ' ' + -this.finalTransform.mProp.p.v[1] + ' ' + this.compW + ' ' + this.compH);\n        svgStyle = this.svgElement.style;\n        var translation = 'translate(' + -this.finalTransform.mProp.p.v[0] + 'px,' + -this.finalTransform.mProp.p.v[1] + 'px)';\n        svgStyle.transform = translation;\n        svgStyle.webkitTransform = translation;\n      }\n    }\n\n    this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);\n\n    if (!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag) {\n      return;\n    }\n\n    var i;\n    var len;\n    var count = 0;\n    var renderedLetters = this.textAnimator.renderedLetters;\n    var letters = this.textProperty.currentData.l;\n    len = letters.length;\n    var renderedLetter;\n    var textSpan;\n    var textPath;\n\n    for (i = 0; i < len; i += 1) {\n      if (letters[i].n) {\n        count += 1;\n      } else {\n        textSpan = this.textSpans[i];\n        textPath = this.textPaths[i];\n        renderedLetter = renderedLetters[count];\n        count += 1;\n\n        if (renderedLetter._mdf.m) {\n          if (!this.isMasked) {\n            textSpan.style.webkitTransform = renderedLetter.m;\n            textSpan.style.transform = renderedLetter.m;\n          } else {\n            textSpan.setAttribute('transform', renderedLetter.m);\n          }\n        } /// /textSpan.setAttribute('opacity',renderedLetter.o);\n\n\n        textSpan.style.opacity = renderedLetter.o;\n\n        if (renderedLetter.sw && renderedLetter._mdf.sw) {\n          textPath.setAttribute('stroke-width', renderedLetter.sw);\n        }\n\n        if (renderedLetter.sc && renderedLetter._mdf.sc) {\n          textPath.setAttribute('stroke', renderedLetter.sc);\n        }\n\n        if (renderedLetter.fc && renderedLetter._mdf.fc) {\n          textPath.setAttribute('fill', renderedLetter.fc);\n          textPath.style.color = renderedLetter.fc;\n        }\n      }\n    }\n\n    if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {\n      var boundingBox = this.innerElem.getBBox();\n\n      if (this.currentBBox.w !== boundingBox.width) {\n        this.currentBBox.w = boundingBox.width;\n        this.svgElement.setAttribute('width', boundingBox.width);\n      }\n\n      if (this.currentBBox.h !== boundingBox.height) {\n        this.currentBBox.h = boundingBox.height;\n        this.svgElement.setAttribute('height', boundingBox.height);\n      }\n\n      var margin = 1;\n\n      if (this.currentBBox.w !== boundingBox.width + margin * 2 || this.currentBBox.h !== boundingBox.height + margin * 2 || this.currentBBox.x !== boundingBox.x - margin || this.currentBBox.y !== boundingBox.y - margin) {\n        this.currentBBox.w = boundingBox.width + margin * 2;\n        this.currentBBox.h = boundingBox.height + margin * 2;\n        this.currentBBox.x = boundingBox.x - margin;\n        this.currentBBox.y = boundingBox.y - margin;\n        this.svgElement.setAttribute('viewBox', this.currentBBox.x + ' ' + this.currentBBox.y + ' ' + this.currentBBox.w + ' ' + this.currentBBox.h);\n        svgStyle = this.svgElement.style;\n        var svgTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';\n        svgStyle.transform = svgTransform;\n        svgStyle.webkitTransform = svgTransform;\n      }\n    }\n  };\n\n  function HCameraElement(data, globalData, comp) {\n    this.initFrame();\n    this.initBaseData(data, globalData, comp);\n    this.initHierarchy();\n    var getProp = PropertyFactory.getProp;\n    this.pe = getProp(this, data.pe, 0, 0, this);\n\n    if (data.ks.p.s) {\n      this.px = getProp(this, data.ks.p.x, 1, 0, this);\n      this.py = getProp(this, data.ks.p.y, 1, 0, this);\n      this.pz = getProp(this, data.ks.p.z, 1, 0, this);\n    } else {\n      this.p = getProp(this, data.ks.p, 1, 0, this);\n    }\n\n    if (data.ks.a) {\n      this.a = getProp(this, data.ks.a, 1, 0, this);\n    }\n\n    if (data.ks.or.k.length && data.ks.or.k[0].to) {\n      var i;\n      var len = data.ks.or.k.length;\n\n      for (i = 0; i < len; i += 1) {\n        data.ks.or.k[i].to = null;\n        data.ks.or.k[i].ti = null;\n      }\n    }\n\n    this.or = getProp(this, data.ks.or, 1, degToRads, this);\n    this.or.sh = true;\n    this.rx = getProp(this, data.ks.rx, 0, degToRads, this);\n    this.ry = getProp(this, data.ks.ry, 0, degToRads, this);\n    this.rz = getProp(this, data.ks.rz, 0, degToRads, this);\n    this.mat = new Matrix();\n    this._prevMat = new Matrix();\n    this._isFirstFrame = true; // TODO: find a better way to make the HCamera element to be compatible with the LayerInterface and TransformInterface.\n\n    this.finalTransform = {\n      mProp: this\n    };\n  }\n\n  extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement);\n\n  HCameraElement.prototype.setup = function () {\n    var i;\n    var len = this.comp.threeDElements.length;\n    var comp;\n    var perspectiveStyle;\n    var containerStyle;\n\n    for (i = 0; i < len; i += 1) {\n      // [perspectiveElem,container]\n      comp = this.comp.threeDElements[i];\n\n      if (comp.type === '3d') {\n        perspectiveStyle = comp.perspectiveElem.style;\n        containerStyle = comp.container.style;\n        var perspective = this.pe.v + 'px';\n        var origin = '0px 0px 0px';\n        var matrix = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';\n        perspectiveStyle.perspective = perspective;\n        perspectiveStyle.webkitPerspective = perspective;\n        containerStyle.transformOrigin = origin;\n        containerStyle.mozTransformOrigin = origin;\n        containerStyle.webkitTransformOrigin = origin;\n        perspectiveStyle.transform = matrix;\n        perspectiveStyle.webkitTransform = matrix;\n      }\n    }\n  };\n\n  HCameraElement.prototype.createElements = function () {};\n\n  HCameraElement.prototype.hide = function () {};\n\n  HCameraElement.prototype.renderFrame = function () {\n    var _mdf = this._isFirstFrame;\n    var i;\n    var len;\n\n    if (this.hierarchy) {\n      len = this.hierarchy.length;\n\n      for (i = 0; i < len; i += 1) {\n        _mdf = this.hierarchy[i].finalTransform.mProp._mdf || _mdf;\n      }\n    }\n\n    if (_mdf || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {\n      this.mat.reset();\n\n      if (this.hierarchy) {\n        len = this.hierarchy.length - 1;\n\n        for (i = len; i >= 0; i -= 1) {\n          var mTransf = this.hierarchy[i].finalTransform.mProp;\n          this.mat.translate(-mTransf.p.v[0], -mTransf.p.v[1], mTransf.p.v[2]);\n          this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);\n          this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);\n          this.mat.scale(1 / mTransf.s.v[0], 1 / mTransf.s.v[1], 1 / mTransf.s.v[2]);\n          this.mat.translate(mTransf.a.v[0], mTransf.a.v[1], mTransf.a.v[2]);\n        }\n      }\n\n      if (this.p) {\n        this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]);\n      } else {\n        this.mat.translate(-this.px.v, -this.py.v, this.pz.v);\n      }\n\n      if (this.a) {\n        var diffVector;\n\n        if (this.p) {\n          diffVector = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]];\n        } else {\n          diffVector = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];\n        }\n\n        var mag = Math.sqrt(Math.pow(diffVector[0], 2) + Math.pow(diffVector[1], 2) + Math.pow(diffVector[2], 2)); // var lookDir = getNormalizedPoint(getDiffVector(this.a.v,this.p.v));\n\n        var lookDir = [diffVector[0] / mag, diffVector[1] / mag, diffVector[2] / mag];\n        var lookLengthOnXZ = Math.sqrt(lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]);\n        var mRotationX = Math.atan2(lookDir[1], lookLengthOnXZ);\n        var mRotationY = Math.atan2(lookDir[0], -lookDir[2]);\n        this.mat.rotateY(mRotationY).rotateX(-mRotationX);\n      }\n\n      this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);\n      this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);\n      this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0);\n      this.mat.translate(0, 0, this.pe.v);\n      var hasMatrixChanged = !this._prevMat.equals(this.mat);\n\n      if ((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {\n        len = this.comp.threeDElements.length;\n        var comp;\n        var perspectiveStyle;\n        var containerStyle;\n\n        for (i = 0; i < len; i += 1) {\n          comp = this.comp.threeDElements[i];\n\n          if (comp.type === '3d') {\n            if (hasMatrixChanged) {\n              var matValue = this.mat.toCSS();\n              containerStyle = comp.container.style;\n              containerStyle.transform = matValue;\n              containerStyle.webkitTransform = matValue;\n            }\n\n            if (this.pe._mdf) {\n              perspectiveStyle = comp.perspectiveElem.style;\n              perspectiveStyle.perspective = this.pe.v + 'px';\n              perspectiveStyle.webkitPerspective = this.pe.v + 'px';\n            }\n          }\n        }\n\n        this.mat.clone(this._prevMat);\n      }\n    }\n\n    this._isFirstFrame = false;\n  };\n\n  HCameraElement.prototype.prepareFrame = function (num) {\n    this.prepareProperties(num, true);\n  };\n\n  HCameraElement.prototype.destroy = function () {};\n\n  HCameraElement.prototype.getBaseElement = function () {\n    return null;\n  };\n\n  function HImageElement(data, globalData, comp) {\n    this.assetData = globalData.getAssetData(data.refId);\n    this.initElement(data, globalData, comp);\n  }\n\n  extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement);\n\n  HImageElement.prototype.createContent = function () {\n    var assetPath = this.globalData.getAssetsPath(this.assetData);\n    var img = new Image();\n\n    if (this.data.hasMask) {\n      this.imageElem = createNS('image');\n      this.imageElem.setAttribute('width', this.assetData.w + 'px');\n      this.imageElem.setAttribute('height', this.assetData.h + 'px');\n      this.imageElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath);\n      this.layerElement.appendChild(this.imageElem);\n      this.baseElement.setAttribute('width', this.assetData.w);\n      this.baseElement.setAttribute('height', this.assetData.h);\n    } else {\n      this.layerElement.appendChild(img);\n    }\n\n    img.crossOrigin = 'anonymous';\n    img.src = assetPath;\n\n    if (this.data.ln) {\n      this.baseElement.setAttribute('id', this.data.ln);\n    }\n  };\n\n  function HybridRendererBase(animationItem, config) {\n    this.animationItem = animationItem;\n    this.layers = null;\n    this.renderedFrame = -1;\n    this.renderConfig = {\n      className: config && config.className || '',\n      imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',\n      hideOnTransparent: !(config && config.hideOnTransparent === false),\n      filterSize: {\n        width: config && config.filterSize && config.filterSize.width || '400%',\n        height: config && config.filterSize && config.filterSize.height || '400%',\n        x: config && config.filterSize && config.filterSize.x || '-100%',\n        y: config && config.filterSize && config.filterSize.y || '-100%'\n      }\n    };\n    this.globalData = {\n      _mdf: false,\n      frameNum: -1,\n      renderConfig: this.renderConfig\n    };\n    this.pendingElements = [];\n    this.elements = [];\n    this.threeDElements = [];\n    this.destroyed = false;\n    this.camera = null;\n    this.supports3d = true;\n    this.rendererType = 'html';\n  }\n\n  extendPrototype([BaseRenderer], HybridRendererBase);\n  HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem;\n\n  HybridRendererBase.prototype.checkPendingElements = function () {\n    while (this.pendingElements.length) {\n      var element = this.pendingElements.pop();\n      element.checkParenting();\n    }\n  };\n\n  HybridRendererBase.prototype.appendElementInPos = function (element, pos) {\n    var newDOMElement = element.getBaseElement();\n\n    if (!newDOMElement) {\n      return;\n    }\n\n    var layer = this.layers[pos];\n\n    if (!layer.ddd || !this.supports3d) {\n      if (this.threeDElements) {\n        this.addTo3dContainer(newDOMElement, pos);\n      } else {\n        var i = 0;\n        var nextDOMElement;\n        var nextLayer;\n        var tmpDOMElement;\n\n        while (i < pos) {\n          if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement) {\n            nextLayer = this.elements[i];\n            tmpDOMElement = this.layers[i].ddd ? this.getThreeDContainerByPos(i) : nextLayer.getBaseElement();\n            nextDOMElement = tmpDOMElement || nextDOMElement;\n          }\n\n          i += 1;\n        }\n\n        if (nextDOMElement) {\n          if (!layer.ddd || !this.supports3d) {\n            this.layerElement.insertBefore(newDOMElement, nextDOMElement);\n          }\n        } else if (!layer.ddd || !this.supports3d) {\n          this.layerElement.appendChild(newDOMElement);\n        }\n      }\n    } else {\n      this.addTo3dContainer(newDOMElement, pos);\n    }\n  };\n\n  HybridRendererBase.prototype.createShape = function (data) {\n    if (!this.supports3d) {\n      return new SVGShapeElement(data, this.globalData, this);\n    }\n\n    return new HShapeElement(data, this.globalData, this);\n  };\n\n  HybridRendererBase.prototype.createText = function (data) {\n    if (!this.supports3d) {\n      return new SVGTextLottieElement(data, this.globalData, this);\n    }\n\n    return new HTextElement(data, this.globalData, this);\n  };\n\n  HybridRendererBase.prototype.createCamera = function (data) {\n    this.camera = new HCameraElement(data, this.globalData, this);\n    return this.camera;\n  };\n\n  HybridRendererBase.prototype.createImage = function (data) {\n    if (!this.supports3d) {\n      return new IImageElement(data, this.globalData, this);\n    }\n\n    return new HImageElement(data, this.globalData, this);\n  };\n\n  HybridRendererBase.prototype.createSolid = function (data) {\n    if (!this.supports3d) {\n      return new ISolidElement(data, this.globalData, this);\n    }\n\n    return new HSolidElement(data, this.globalData, this);\n  };\n\n  HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;\n\n  HybridRendererBase.prototype.getThreeDContainerByPos = function (pos) {\n    var i = 0;\n    var len = this.threeDElements.length;\n\n    while (i < len) {\n      if (this.threeDElements[i].startPos <= pos && this.threeDElements[i].endPos >= pos) {\n        return this.threeDElements[i].perspectiveElem;\n      }\n\n      i += 1;\n    }\n\n    return null;\n  };\n\n  HybridRendererBase.prototype.createThreeDContainer = function (pos, type) {\n    var perspectiveElem = createTag('div');\n    var style;\n    var containerStyle;\n    styleDiv(perspectiveElem);\n    var container = createTag('div');\n    styleDiv(container);\n\n    if (type === '3d') {\n      style = perspectiveElem.style;\n      style.width = this.globalData.compSize.w + 'px';\n      style.height = this.globalData.compSize.h + 'px';\n      var center = '50% 50%';\n      style.webkitTransformOrigin = center;\n      style.mozTransformOrigin = center;\n      style.transformOrigin = center;\n      containerStyle = container.style;\n      var matrix = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';\n      containerStyle.transform = matrix;\n      containerStyle.webkitTransform = matrix;\n    }\n\n    perspectiveElem.appendChild(container); // this.resizerElem.appendChild(perspectiveElem);\n\n    var threeDContainerData = {\n      container: container,\n      perspectiveElem: perspectiveElem,\n      startPos: pos,\n      endPos: pos,\n      type: type\n    };\n    this.threeDElements.push(threeDContainerData);\n    return threeDContainerData;\n  };\n\n  HybridRendererBase.prototype.build3dContainers = function () {\n    var i;\n    var len = this.layers.length;\n    var lastThreeDContainerData;\n    var currentContainer = '';\n\n    for (i = 0; i < len; i += 1) {\n      if (this.layers[i].ddd && this.layers[i].ty !== 3) {\n        if (currentContainer !== '3d') {\n          currentContainer = '3d';\n          lastThreeDContainerData = this.createThreeDContainer(i, '3d');\n        }\n\n        lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);\n      } else {\n        if (currentContainer !== '2d') {\n          currentContainer = '2d';\n          lastThreeDContainerData = this.createThreeDContainer(i, '2d');\n        }\n\n        lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);\n      }\n    }\n\n    len = this.threeDElements.length;\n\n    for (i = len - 1; i >= 0; i -= 1) {\n      this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem);\n    }\n  };\n\n  HybridRendererBase.prototype.addTo3dContainer = function (elem, pos) {\n    var i = 0;\n    var len = this.threeDElements.length;\n\n    while (i < len) {\n      if (pos <= this.threeDElements[i].endPos) {\n        var j = this.threeDElements[i].startPos;\n        var nextElement;\n\n        while (j < pos) {\n          if (this.elements[j] && this.elements[j].getBaseElement) {\n            nextElement = this.elements[j].getBaseElement();\n          }\n\n          j += 1;\n        }\n\n        if (nextElement) {\n          this.threeDElements[i].container.insertBefore(elem, nextElement);\n        } else {\n          this.threeDElements[i].container.appendChild(elem);\n        }\n\n        break;\n      }\n\n      i += 1;\n    }\n  };\n\n  HybridRendererBase.prototype.configAnimation = function (animData) {\n    var resizerElem = createTag('div');\n    var wrapper = this.animationItem.wrapper;\n    var style = resizerElem.style;\n    style.width = animData.w + 'px';\n    style.height = animData.h + 'px';\n    this.resizerElem = resizerElem;\n    styleDiv(resizerElem);\n    style.transformStyle = 'flat';\n    style.mozTransformStyle = 'flat';\n    style.webkitTransformStyle = 'flat';\n\n    if (this.renderConfig.className) {\n      resizerElem.setAttribute('class', this.renderConfig.className);\n    }\n\n    wrapper.appendChild(resizerElem);\n    style.overflow = 'hidden';\n    var svg = createNS('svg');\n    svg.setAttribute('width', '1');\n    svg.setAttribute('height', '1');\n    styleDiv(svg);\n    this.resizerElem.appendChild(svg);\n    var defs = createNS('defs');\n    svg.appendChild(defs);\n    this.data = animData; // Mask animation\n\n    this.setupGlobalData(animData, svg);\n    this.globalData.defs = defs;\n    this.layers = animData.layers;\n    this.layerElement = this.resizerElem;\n    this.build3dContainers();\n    this.updateContainerSize();\n  };\n\n  HybridRendererBase.prototype.destroy = function () {\n    if (this.animationItem.wrapper) {\n      this.animationItem.wrapper.innerText = '';\n    }\n\n    this.animationItem.container = null;\n    this.globalData.defs = null;\n    var i;\n    var len = this.layers ? this.layers.length : 0;\n\n    for (i = 0; i < len; i += 1) {\n      if (this.elements[i] && this.elements[i].destroy) {\n        this.elements[i].destroy();\n      }\n    }\n\n    this.elements.length = 0;\n    this.destroyed = true;\n    this.animationItem = null;\n  };\n\n  HybridRendererBase.prototype.updateContainerSize = function () {\n    var elementWidth = this.animationItem.wrapper.offsetWidth;\n    var elementHeight = this.animationItem.wrapper.offsetHeight;\n    var elementRel = elementWidth / elementHeight;\n    var animationRel = this.globalData.compSize.w / this.globalData.compSize.h;\n    var sx;\n    var sy;\n    var tx;\n    var ty;\n\n    if (animationRel > elementRel) {\n      sx = elementWidth / this.globalData.compSize.w;\n      sy = elementWidth / this.globalData.compSize.w;\n      tx = 0;\n      ty = (elementHeight - this.globalData.compSize.h * (elementWidth / this.globalData.compSize.w)) / 2;\n    } else {\n      sx = elementHeight / this.globalData.compSize.h;\n      sy = elementHeight / this.globalData.compSize.h;\n      tx = (elementWidth - this.globalData.compSize.w * (elementHeight / this.globalData.compSize.h)) / 2;\n      ty = 0;\n    }\n\n    var style = this.resizerElem.style;\n    style.webkitTransform = 'matrix3d(' + sx + ',0,0,0,0,' + sy + ',0,0,0,0,1,0,' + tx + ',' + ty + ',0,1)';\n    style.transform = style.webkitTransform;\n  };\n\n  HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame;\n\n  HybridRendererBase.prototype.hide = function () {\n    this.resizerElem.style.display = 'none';\n  };\n\n  HybridRendererBase.prototype.show = function () {\n    this.resizerElem.style.display = 'block';\n  };\n\n  HybridRendererBase.prototype.initItems = function () {\n    this.buildAllItems();\n\n    if (this.camera) {\n      this.camera.setup();\n    } else {\n      var cWidth = this.globalData.compSize.w;\n      var cHeight = this.globalData.compSize.h;\n      var i;\n      var len = this.threeDElements.length;\n\n      for (i = 0; i < len; i += 1) {\n        var style = this.threeDElements[i].perspectiveElem.style;\n        style.webkitPerspective = Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + 'px';\n        style.perspective = style.webkitPerspective;\n      }\n    }\n  };\n\n  HybridRendererBase.prototype.searchExtraCompositions = function (assets) {\n    var i;\n    var len = assets.length;\n    var floatingContainer = createTag('div');\n\n    for (i = 0; i < len; i += 1) {\n      if (assets[i].xt) {\n        var comp = this.createComp(assets[i], floatingContainer, this.globalData.comp, null);\n        comp.initExpressions();\n        this.globalData.projectInterface.registerComposition(comp);\n      }\n    }\n  };\n\n  function HCompElement(data, globalData, comp) {\n    this.layers = data.layers;\n    this.supports3d = !data.hasMask;\n    this.completeLayers = false;\n    this.pendingElements = [];\n    this.elements = this.layers ? createSizedArray(this.layers.length) : [];\n    this.initElement(data, globalData, comp);\n    this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {\n      _placeholder: true\n    };\n  }\n\n  extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement);\n  HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;\n\n  HCompElement.prototype.createContainerElements = function () {\n    this._createBaseContainerElements(); // divElement.style.clip = 'rect(0px, '+this.data.w+'px, '+this.data.h+'px, 0px)';\n\n\n    if (this.data.hasMask) {\n      this.svgElement.setAttribute('width', this.data.w);\n      this.svgElement.setAttribute('height', this.data.h);\n      this.transformedElement = this.baseElement;\n    } else {\n      this.transformedElement = this.layerElement;\n    }\n  };\n\n  HCompElement.prototype.addTo3dContainer = function (elem, pos) {\n    var j = 0;\n    var nextElement;\n\n    while (j < pos) {\n      if (this.elements[j] && this.elements[j].getBaseElement) {\n        nextElement = this.elements[j].getBaseElement();\n      }\n\n      j += 1;\n    }\n\n    if (nextElement) {\n      this.layerElement.insertBefore(elem, nextElement);\n    } else {\n      this.layerElement.appendChild(elem);\n    }\n  };\n\n  HCompElement.prototype.createComp = function (data) {\n    if (!this.supports3d) {\n      return new SVGCompElement(data, this.globalData, this);\n    }\n\n    return new HCompElement(data, this.globalData, this);\n  };\n\n  function HybridRenderer(animationItem, config) {\n    this.animationItem = animationItem;\n    this.layers = null;\n    this.renderedFrame = -1;\n    this.renderConfig = {\n      className: config && config.className || '',\n      imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',\n      hideOnTransparent: !(config && config.hideOnTransparent === false),\n      filterSize: {\n        width: config && config.filterSize && config.filterSize.width || '400%',\n        height: config && config.filterSize && config.filterSize.height || '400%',\n        x: config && config.filterSize && config.filterSize.x || '-100%',\n        y: config && config.filterSize && config.filterSize.y || '-100%'\n      },\n      runExpressions: !config || config.runExpressions === undefined || config.runExpressions\n    };\n    this.globalData = {\n      _mdf: false,\n      frameNum: -1,\n      renderConfig: this.renderConfig\n    };\n    this.pendingElements = [];\n    this.elements = [];\n    this.threeDElements = [];\n    this.destroyed = false;\n    this.camera = null;\n    this.supports3d = true;\n    this.rendererType = 'html';\n  }\n\n  extendPrototype([HybridRendererBase], HybridRenderer);\n\n  HybridRenderer.prototype.createComp = function (data) {\n    if (!this.supports3d) {\n      return new SVGCompElement(data, this.globalData, this);\n    }\n\n    return new HCompElement(data, this.globalData, this);\n  };\n\n  var CompExpressionInterface = function () {\n    return function (comp) {\n      function _thisLayerFunction(name) {\n        var i = 0;\n        var len = comp.layers.length;\n\n        while (i < len) {\n          if (comp.layers[i].nm === name || comp.layers[i].ind === name) {\n            return comp.elements[i].layerInterface;\n          }\n\n          i += 1;\n        }\n\n        return null; // return {active:false};\n      }\n\n      Object.defineProperty(_thisLayerFunction, '_name', {\n        value: comp.data.nm\n      });\n      _thisLayerFunction.layer = _thisLayerFunction;\n      _thisLayerFunction.pixelAspect = 1;\n      _thisLayerFunction.height = comp.data.h || comp.globalData.compSize.h;\n      _thisLayerFunction.width = comp.data.w || comp.globalData.compSize.w;\n      _thisLayerFunction.pixelAspect = 1;\n      _thisLayerFunction.frameDuration = 1 / comp.globalData.frameRate;\n      _thisLayerFunction.displayStartTime = 0;\n      _thisLayerFunction.numLayers = comp.layers.length;\n      return _thisLayerFunction;\n    };\n  }();\n\n  function _typeof$2(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof$2 = function _typeof(obj) { return typeof obj; }; } else { _typeof$2 = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof$2(obj); }\n\n  /* eslint-disable */\n\n  /*\r\n   Copyright 2014 David Bau.\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining\r\n   a copy of this software and associated documentation files (the\r\n   \"Software\"), to deal in the Software without restriction, including\r\n   without limitation the rights to use, copy, modify, merge, publish,\r\n   distribute, sublicense, and/or sell copies of the Software, and to\r\n   permit persons to whom the Software is furnished to do so, subject to\r\n   the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be\r\n   included in all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   */\n  function seedRandom(pool, math) {\n    //\n    // The following constants are related to IEEE 754 limits.\n    //\n    var global = this,\n        width = 256,\n        // each RC4 output is 0 <= x < 256\n    chunks = 6,\n        // at least six RC4 outputs for each double\n    digits = 52,\n        // there are 52 significant digits in a double\n    rngname = 'random',\n        // rngname: name for Math.random and Math.seedrandom\n    startdenom = math.pow(width, chunks),\n        significance = math.pow(2, digits),\n        overflow = significance * 2,\n        mask = width - 1,\n        nodecrypto; // node.js crypto module, initialized at the bottom.\n    //\n    // seedrandom()\n    // This is the seedrandom function described above.\n    //\n\n    function seedrandom(seed, options, callback) {\n      var key = [];\n      options = options === true ? {\n        entropy: true\n      } : options || {}; // Flatten the seed string or build one from local entropy if needed.\n\n      var shortseed = mixkey(flatten(options.entropy ? [seed, tostring(pool)] : seed === null ? autoseed() : seed, 3), key); // Use the seed to initialize an ARC4 generator.\n\n      var arc4 = new ARC4(key); // This function returns a random double in [0, 1) that contains\n      // randomness in every bit of the mantissa of the IEEE 754 value.\n\n      var prng = function prng() {\n        var n = arc4.g(chunks),\n            // Start with a numerator n < 2 ^ 48\n        d = startdenom,\n            //   and denominator d = 2 ^ 48.\n        x = 0; //   and no 'extra last byte'.\n\n        while (n < significance) {\n          // Fill up all significant digits by\n          n = (n + x) * width; //   shifting numerator and\n\n          d *= width; //   denominator and generating a\n\n          x = arc4.g(1); //   new least-significant-byte.\n        }\n\n        while (n >= overflow) {\n          // To avoid rounding up, before adding\n          n /= 2; //   last byte, shift everything\n\n          d /= 2; //   right using integer math until\n\n          x >>>= 1; //   we have exactly the desired bits.\n        }\n\n        return (n + x) / d; // Form the number within [0, 1).\n      };\n\n      prng.int32 = function () {\n        return arc4.g(4) | 0;\n      };\n\n      prng.quick = function () {\n        return arc4.g(4) / 0x100000000;\n      };\n\n      prng[\"double\"] = prng; // Mix the randomness into accumulated entropy.\n\n      mixkey(tostring(arc4.S), pool); // Calling convention: what to return as a function of prng, seed, is_math.\n\n      return (options.pass || callback || function (prng, seed, is_math_call, state) {\n        if (state) {\n          // Load the arc4 state from the given state if it has an S array.\n          if (state.S) {\n            copy(state, arc4);\n          } // Only provide the .state method if requested via options.state.\n\n\n          prng.state = function () {\n            return copy(arc4, {});\n          };\n        } // If called as a method of Math (Math.seedrandom()), mutate\n        // Math.random because that is how seedrandom.js has worked since v1.0.\n\n\n        if (is_math_call) {\n          math[rngname] = prng;\n          return seed;\n        } // Otherwise, it is a newer calling convention, so return the\n        // prng directly.\n        else return prng;\n      })(prng, shortseed, 'global' in options ? options.global : this == math, options.state);\n    }\n\n    math['seed' + rngname] = seedrandom; //\n    // ARC4\n    //\n    // An ARC4 implementation.  The constructor takes a key in the form of\n    // an array of at most (width) integers that should be 0 <= x < (width).\n    //\n    // The g(count) method returns a pseudorandom integer that concatenates\n    // the next (count) outputs from ARC4.  Its return value is a number x\n    // that is in the range 0 <= x < (width ^ count).\n    //\n\n    function ARC4(key) {\n      var t,\n          keylen = key.length,\n          me = this,\n          i = 0,\n          j = me.i = me.j = 0,\n          s = me.S = []; // The empty key [] is treated as [0].\n\n      if (!keylen) {\n        key = [keylen++];\n      } // Set up S using the standard key scheduling algorithm.\n\n\n      while (i < width) {\n        s[i] = i++;\n      }\n\n      for (i = 0; i < width; i++) {\n        s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];\n        s[j] = t;\n      } // The \"g\" method returns the next (count) outputs as one number.\n\n\n      me.g = function (count) {\n        // Using instance members instead of closure state nearly doubles speed.\n        var t,\n            r = 0,\n            i = me.i,\n            j = me.j,\n            s = me.S;\n\n        while (count--) {\n          t = s[i = mask & i + 1];\n          r = r * width + s[mask & (s[i] = s[j = mask & j + t]) + (s[j] = t)];\n        }\n\n        me.i = i;\n        me.j = j;\n        return r; // For robust unpredictability, the function call below automatically\n        // discards an initial batch of values.  This is called RC4-drop[256].\n        // See http://google.com/search?q=rsa+fluhrer+response&btnI\n      };\n    } //\n    // copy()\n    // Copies internal state of ARC4 to or from a plain object.\n    //\n\n\n    function copy(f, t) {\n      t.i = f.i;\n      t.j = f.j;\n      t.S = f.S.slice();\n      return t;\n    } //\n    // flatten()\n    // Converts an object tree to nested arrays of strings.\n    //\n\n\n    function flatten(obj, depth) {\n      var result = [],\n          typ = _typeof$2(obj),\n          prop;\n\n      if (depth && typ == 'object') {\n        for (prop in obj) {\n          try {\n            result.push(flatten(obj[prop], depth - 1));\n          } catch (e) {}\n        }\n      }\n\n      return result.length ? result : typ == 'string' ? obj : obj + '\\0';\n    } //\n    // mixkey()\n    // Mixes a string seed into a key that is an array of integers, and\n    // returns a shortened string seed that is equivalent to the result key.\n    //\n\n\n    function mixkey(seed, key) {\n      var stringseed = seed + '',\n          smear,\n          j = 0;\n\n      while (j < stringseed.length) {\n        key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);\n      }\n\n      return tostring(key);\n    } //\n    // autoseed()\n    // Returns an object for autoseeding, using window.crypto and Node crypto\n    // module if available.\n    //\n\n\n    function autoseed() {\n      try {\n        if (nodecrypto) {\n          return tostring(nodecrypto.randomBytes(width));\n        }\n\n        var out = new Uint8Array(width);\n        (global.crypto || global.msCrypto).getRandomValues(out);\n        return tostring(out);\n      } catch (e) {\n        var browser = global.navigator,\n            plugins = browser && browser.plugins;\n        return [+new Date(), global, plugins, global.screen, tostring(pool)];\n      }\n    } //\n    // tostring()\n    // Converts an array of charcodes to a string\n    //\n\n\n    function tostring(a) {\n      return String.fromCharCode.apply(0, a);\n    } //\n    // When seedrandom.js is loaded, we immediately mix a few bits\n    // from the built-in RNG into the entropy pool.  Because we do\n    // not want to interfere with deterministic PRNG state later,\n    // seedrandom will not call math.random on its own again after\n    // initialization.\n    //\n\n\n    mixkey(math.random(), pool); //\n    // Nodejs and AMD support: export the implementation as a module using\n    // either convention.\n    //\n    // End anonymous scope, and pass initial values.\n  }\n\n  ;\n\n  function initialize$2(BMMath) {\n    seedRandom([], BMMath);\n  }\n\n  var propTypes = {\n    SHAPE: 'shape'\n  };\n\n  function _typeof$1(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof$1(obj); }\n\n  var ExpressionManager = function () {\n    'use strict';\n\n    var ob = {};\n    var Math = BMMath;\n    var window = null;\n    var document = null;\n    var XMLHttpRequest = null;\n    var fetch = null;\n    var frames = null;\n    var _lottieGlobal = {};\n    initialize$2(BMMath);\n\n    function resetFrame() {\n      _lottieGlobal = {};\n    }\n\n    function $bm_isInstanceOfArray(arr) {\n      return arr.constructor === Array || arr.constructor === Float32Array;\n    }\n\n    function isNumerable(tOfV, v) {\n      return tOfV === 'number' || v instanceof Number || tOfV === 'boolean' || tOfV === 'string';\n    }\n\n    function $bm_neg(a) {\n      var tOfA = _typeof$1(a);\n\n      if (tOfA === 'number' || a instanceof Number || tOfA === 'boolean') {\n        return -a;\n      }\n\n      if ($bm_isInstanceOfArray(a)) {\n        var i;\n        var lenA = a.length;\n        var retArr = [];\n\n        for (i = 0; i < lenA; i += 1) {\n          retArr[i] = -a[i];\n        }\n\n        return retArr;\n      }\n\n      if (a.propType) {\n        return a.v;\n      }\n\n      return -a;\n    }\n\n    var easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, 'easeIn').get;\n    var easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, 'easeOut').get;\n    var easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, 'easeInOut').get;\n\n    function sum(a, b) {\n      var tOfA = _typeof$1(a);\n\n      var tOfB = _typeof$1(b);\n\n      if (isNumerable(tOfA, a) && isNumerable(tOfB, b) || tOfA === 'string' || tOfB === 'string') {\n        return a + b;\n      }\n\n      if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {\n        a = a.slice(0);\n        a[0] += b;\n        return a;\n      }\n\n      if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {\n        b = b.slice(0);\n        b[0] = a + b[0];\n        return b;\n      }\n\n      if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {\n        var i = 0;\n        var lenA = a.length;\n        var lenB = b.length;\n        var retArr = [];\n\n        while (i < lenA || i < lenB) {\n          if ((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)) {\n            retArr[i] = a[i] + b[i];\n          } else {\n            retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];\n          }\n\n          i += 1;\n        }\n\n        return retArr;\n      }\n\n      return 0;\n    }\n\n    var add = sum;\n\n    function sub(a, b) {\n      var tOfA = _typeof$1(a);\n\n      var tOfB = _typeof$1(b);\n\n      if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {\n        if (tOfA === 'string') {\n          a = parseInt(a, 10);\n        }\n\n        if (tOfB === 'string') {\n          b = parseInt(b, 10);\n        }\n\n        return a - b;\n      }\n\n      if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {\n        a = a.slice(0);\n        a[0] -= b;\n        return a;\n      }\n\n      if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {\n        b = b.slice(0);\n        b[0] = a - b[0];\n        return b;\n      }\n\n      if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {\n        var i = 0;\n        var lenA = a.length;\n        var lenB = b.length;\n        var retArr = [];\n\n        while (i < lenA || i < lenB) {\n          if ((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)) {\n            retArr[i] = a[i] - b[i];\n          } else {\n            retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];\n          }\n\n          i += 1;\n        }\n\n        return retArr;\n      }\n\n      return 0;\n    }\n\n    function mul(a, b) {\n      var tOfA = _typeof$1(a);\n\n      var tOfB = _typeof$1(b);\n\n      var arr;\n\n      if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {\n        return a * b;\n      }\n\n      var i;\n      var len;\n\n      if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {\n        len = a.length;\n        arr = createTypedArray('float32', len);\n\n        for (i = 0; i < len; i += 1) {\n          arr[i] = a[i] * b;\n        }\n\n        return arr;\n      }\n\n      if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {\n        len = b.length;\n        arr = createTypedArray('float32', len);\n\n        for (i = 0; i < len; i += 1) {\n          arr[i] = a * b[i];\n        }\n\n        return arr;\n      }\n\n      return 0;\n    }\n\n    function div(a, b) {\n      var tOfA = _typeof$1(a);\n\n      var tOfB = _typeof$1(b);\n\n      var arr;\n\n      if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {\n        return a / b;\n      }\n\n      var i;\n      var len;\n\n      if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {\n        len = a.length;\n        arr = createTypedArray('float32', len);\n\n        for (i = 0; i < len; i += 1) {\n          arr[i] = a[i] / b;\n        }\n\n        return arr;\n      }\n\n      if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {\n        len = b.length;\n        arr = createTypedArray('float32', len);\n\n        for (i = 0; i < len; i += 1) {\n          arr[i] = a / b[i];\n        }\n\n        return arr;\n      }\n\n      return 0;\n    }\n\n    function mod(a, b) {\n      if (typeof a === 'string') {\n        a = parseInt(a, 10);\n      }\n\n      if (typeof b === 'string') {\n        b = parseInt(b, 10);\n      }\n\n      return a % b;\n    }\n\n    var $bm_sum = sum;\n    var $bm_sub = sub;\n    var $bm_mul = mul;\n    var $bm_div = div;\n    var $bm_mod = mod;\n\n    function clamp(num, min, max) {\n      if (min > max) {\n        var mm = max;\n        max = min;\n        min = mm;\n      }\n\n      return Math.min(Math.max(num, min), max);\n    }\n\n    function radiansToDegrees(val) {\n      return val / degToRads;\n    }\n\n    var radians_to_degrees = radiansToDegrees;\n\n    function degreesToRadians(val) {\n      return val * degToRads;\n    }\n\n    var degrees_to_radians = radiansToDegrees;\n    var helperLengthArray = [0, 0, 0, 0, 0, 0];\n\n    function length(arr1, arr2) {\n      if (typeof arr1 === 'number' || arr1 instanceof Number) {\n        arr2 = arr2 || 0;\n        return Math.abs(arr1 - arr2);\n      }\n\n      if (!arr2) {\n        arr2 = helperLengthArray;\n      }\n\n      var i;\n      var len = Math.min(arr1.length, arr2.length);\n      var addedLength = 0;\n\n      for (i = 0; i < len; i += 1) {\n        addedLength += Math.pow(arr2[i] - arr1[i], 2);\n      }\n\n      return Math.sqrt(addedLength);\n    }\n\n    function normalize(vec) {\n      return div(vec, length(vec));\n    }\n\n    function rgbToHsl(val) {\n      var r = val[0];\n      var g = val[1];\n      var b = val[2];\n      var max = Math.max(r, g, b);\n      var min = Math.min(r, g, b);\n      var h;\n      var s;\n      var l = (max + min) / 2;\n\n      if (max === min) {\n        h = 0; // achromatic\n\n        s = 0; // achromatic\n      } else {\n        var d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n        switch (max) {\n          case r:\n            h = (g - b) / d + (g < b ? 6 : 0);\n            break;\n\n          case g:\n            h = (b - r) / d + 2;\n            break;\n\n          case b:\n            h = (r - g) / d + 4;\n            break;\n\n          default:\n            break;\n        }\n\n        h /= 6;\n      }\n\n      return [h, s, l, val[3]];\n    }\n\n    function hue2rgb(p, q, t) {\n      if (t < 0) t += 1;\n      if (t > 1) t -= 1;\n      if (t < 1 / 6) return p + (q - p) * 6 * t;\n      if (t < 1 / 2) return q;\n      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n      return p;\n    }\n\n    function hslToRgb(val) {\n      var h = val[0];\n      var s = val[1];\n      var l = val[2];\n      var r;\n      var g;\n      var b;\n\n      if (s === 0) {\n        r = l; // achromatic\n\n        b = l; // achromatic\n\n        g = l; // achromatic\n      } else {\n        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        var p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n      }\n\n      return [r, g, b, val[3]];\n    }\n\n    function linear(t, tMin, tMax, value1, value2) {\n      if (value1 === undefined || value2 === undefined) {\n        value1 = tMin;\n        value2 = tMax;\n        tMin = 0;\n        tMax = 1;\n      }\n\n      if (tMax < tMin) {\n        var _tMin = tMax;\n        tMax = tMin;\n        tMin = _tMin;\n      }\n\n      if (t <= tMin) {\n        return value1;\n      }\n\n      if (t >= tMax) {\n        return value2;\n      }\n\n      var perc = tMax === tMin ? 0 : (t - tMin) / (tMax - tMin);\n\n      if (!value1.length) {\n        return value1 + (value2 - value1) * perc;\n      }\n\n      var i;\n      var len = value1.length;\n      var arr = createTypedArray('float32', len);\n\n      for (i = 0; i < len; i += 1) {\n        arr[i] = value1[i] + (value2[i] - value1[i]) * perc;\n      }\n\n      return arr;\n    }\n\n    function random(min, max) {\n      if (max === undefined) {\n        if (min === undefined) {\n          min = 0;\n          max = 1;\n        } else {\n          max = min;\n          min = undefined;\n        }\n      }\n\n      if (max.length) {\n        var i;\n        var len = max.length;\n\n        if (!min) {\n          min = createTypedArray('float32', len);\n        }\n\n        var arr = createTypedArray('float32', len);\n        var rnd = BMMath.random();\n\n        for (i = 0; i < len; i += 1) {\n          arr[i] = min[i] + rnd * (max[i] - min[i]);\n        }\n\n        return arr;\n      }\n\n      if (min === undefined) {\n        min = 0;\n      }\n\n      var rndm = BMMath.random();\n      return min + rndm * (max - min);\n    }\n\n    function createPath(points, inTangents, outTangents, closed) {\n      var i;\n      var len = points.length;\n      var path = shapePool.newElement();\n      path.setPathData(!!closed, len);\n      var arrPlaceholder = [0, 0];\n      var inVertexPoint;\n      var outVertexPoint;\n\n      for (i = 0; i < len; i += 1) {\n        inVertexPoint = inTangents && inTangents[i] ? inTangents[i] : arrPlaceholder;\n        outVertexPoint = outTangents && outTangents[i] ? outTangents[i] : arrPlaceholder;\n        path.setTripleAt(points[i][0], points[i][1], outVertexPoint[0] + points[i][0], outVertexPoint[1] + points[i][1], inVertexPoint[0] + points[i][0], inVertexPoint[1] + points[i][1], i, true);\n      }\n\n      return path;\n    }\n\n    function initiateExpression(elem, data, property) {\n      // Bail out if we don't want expressions\n      function noOp(_value) {\n        return _value;\n      }\n\n      if (!elem.globalData.renderConfig.runExpressions) {\n        return noOp;\n      }\n\n      var val = data.x;\n      var needsVelocity = /velocity(?![\\w\\d])/.test(val);\n\n      var _needsRandom = val.indexOf('random') !== -1;\n\n      var elemType = elem.data.ty;\n      var transform;\n      var $bm_transform;\n      var content;\n      var effect;\n      var thisProperty = property;\n      thisProperty.valueAtTime = thisProperty.getValueAtTime;\n      Object.defineProperty(thisProperty, 'value', {\n        get: function get() {\n          return thisProperty.v;\n        }\n      });\n      elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate;\n      elem.comp.displayStartTime = 0;\n      var inPoint = elem.data.ip / elem.comp.globalData.frameRate;\n      var outPoint = elem.data.op / elem.comp.globalData.frameRate;\n      var width = elem.data.sw ? elem.data.sw : 0;\n      var height = elem.data.sh ? elem.data.sh : 0;\n      var name = elem.data.nm;\n      var loopIn;\n      var loop_in;\n      var loopOut;\n      var loop_out;\n      var smooth;\n      var toWorld;\n      var fromWorld;\n      var fromComp;\n      var toComp;\n      var fromCompToSurface;\n      var position;\n      var rotation;\n      var anchorPoint;\n      var scale;\n      var thisLayer;\n      var thisComp;\n      var mask;\n      var valueAtTime;\n      var velocityAtTime;\n      var scoped_bm_rt; // val = val.replace(/(\\\\?\"|')((http)(s)?(:\\/))?\\/.*?(\\\\?\"|')/g, \"\\\"\\\"\"); // deter potential network calls\n\n      var expression_function = eval('[function _expression_function(){' + val + ';scoped_bm_rt=$bm_rt}]')[0]; // eslint-disable-line no-eval\n\n      var numKeys = property.kf ? data.k.length : 0;\n      var active = !this.data || this.data.hd !== true;\n\n      var wiggle = function wiggle(freq, amp) {\n        var iWiggle;\n        var j;\n        var lenWiggle = this.pv.length ? this.pv.length : 1;\n        var addedAmps = createTypedArray('float32', lenWiggle);\n        freq = 5;\n        var iterations = Math.floor(time * freq);\n        iWiggle = 0;\n        j = 0;\n\n        while (iWiggle < iterations) {\n          // var rnd = BMMath.random();\n          for (j = 0; j < lenWiggle; j += 1) {\n            addedAmps[j] += -amp + amp * 2 * BMMath.random(); // addedAmps[j] += -amp + amp*2*rnd;\n          }\n\n          iWiggle += 1;\n        } // var rnd2 = BMMath.random();\n\n\n        var periods = time * freq;\n        var perc = periods - Math.floor(periods);\n        var arr = createTypedArray('float32', lenWiggle);\n\n        if (lenWiggle > 1) {\n          for (j = 0; j < lenWiggle; j += 1) {\n            arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp * 2 * BMMath.random()) * perc; // arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*rnd)*perc;\n            // arr[i] = this.pv[i] + addedAmp + amp1*perc + amp2*(1-perc);\n          }\n\n          return arr;\n        }\n\n        return this.pv + addedAmps[0] + (-amp + amp * 2 * BMMath.random()) * perc;\n      }.bind(this);\n\n      if (thisProperty.loopIn) {\n        loopIn = thisProperty.loopIn.bind(thisProperty);\n        loop_in = loopIn;\n      }\n\n      if (thisProperty.loopOut) {\n        loopOut = thisProperty.loopOut.bind(thisProperty);\n        loop_out = loopOut;\n      }\n\n      if (thisProperty.smooth) {\n        smooth = thisProperty.smooth.bind(thisProperty);\n      }\n\n      function loopInDuration(type, duration) {\n        return loopIn(type, duration, true);\n      }\n\n      function loopOutDuration(type, duration) {\n        return loopOut(type, duration, true);\n      }\n\n      if (this.getValueAtTime) {\n        valueAtTime = this.getValueAtTime.bind(this);\n      }\n\n      if (this.getVelocityAtTime) {\n        velocityAtTime = this.getVelocityAtTime.bind(this);\n      }\n\n      var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);\n\n      function lookAt(elem1, elem2) {\n        var fVec = [elem2[0] - elem1[0], elem2[1] - elem1[1], elem2[2] - elem1[2]];\n        var pitch = Math.atan2(fVec[0], Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])) / degToRads;\n        var yaw = -Math.atan2(fVec[1], fVec[2]) / degToRads;\n        return [yaw, pitch, 0];\n      }\n\n      function easeOut(t, tMin, tMax, val1, val2) {\n        return applyEase(easeOutBez, t, tMin, tMax, val1, val2);\n      }\n\n      function easeIn(t, tMin, tMax, val1, val2) {\n        return applyEase(easeInBez, t, tMin, tMax, val1, val2);\n      }\n\n      function ease(t, tMin, tMax, val1, val2) {\n        return applyEase(easeInOutBez, t, tMin, tMax, val1, val2);\n      }\n\n      function applyEase(fn, t, tMin, tMax, val1, val2) {\n        if (val1 === undefined) {\n          val1 = tMin;\n          val2 = tMax;\n        } else {\n          t = (t - tMin) / (tMax - tMin);\n        }\n\n        if (t > 1) {\n          t = 1;\n        } else if (t < 0) {\n          t = 0;\n        }\n\n        var mult = fn(t);\n\n        if ($bm_isInstanceOfArray(val1)) {\n          var iKey;\n          var lenKey = val1.length;\n          var arr = createTypedArray('float32', lenKey);\n\n          for (iKey = 0; iKey < lenKey; iKey += 1) {\n            arr[iKey] = (val2[iKey] - val1[iKey]) * mult + val1[iKey];\n          }\n\n          return arr;\n        }\n\n        return (val2 - val1) * mult + val1;\n      }\n\n      function nearestKey(time) {\n        var iKey;\n        var lenKey = data.k.length;\n        var index;\n        var keyTime;\n\n        if (!data.k.length || typeof data.k[0] === 'number') {\n          index = 0;\n          keyTime = 0;\n        } else {\n          index = -1;\n          time *= elem.comp.globalData.frameRate;\n\n          if (time < data.k[0].t) {\n            index = 1;\n            keyTime = data.k[0].t;\n          } else {\n            for (iKey = 0; iKey < lenKey - 1; iKey += 1) {\n              if (time === data.k[iKey].t) {\n                index = iKey + 1;\n                keyTime = data.k[iKey].t;\n                break;\n              } else if (time > data.k[iKey].t && time < data.k[iKey + 1].t) {\n                if (time - data.k[iKey].t > data.k[iKey + 1].t - time) {\n                  index = iKey + 2;\n                  keyTime = data.k[iKey + 1].t;\n                } else {\n                  index = iKey + 1;\n                  keyTime = data.k[iKey].t;\n                }\n\n                break;\n              }\n            }\n\n            if (index === -1) {\n              index = iKey + 1;\n              keyTime = data.k[iKey].t;\n            }\n          }\n        }\n\n        var obKey = {};\n        obKey.index = index;\n        obKey.time = keyTime / elem.comp.globalData.frameRate;\n        return obKey;\n      }\n\n      function key(ind) {\n        var obKey;\n        var iKey;\n        var lenKey;\n\n        if (!data.k.length || typeof data.k[0] === 'number') {\n          throw new Error('The property has no keyframe at index ' + ind);\n        }\n\n        ind -= 1;\n        obKey = {\n          time: data.k[ind].t / elem.comp.globalData.frameRate,\n          value: []\n        };\n        var arr = Object.prototype.hasOwnProperty.call(data.k[ind], 's') ? data.k[ind].s : data.k[ind - 1].e;\n        lenKey = arr.length;\n\n        for (iKey = 0; iKey < lenKey; iKey += 1) {\n          obKey[iKey] = arr[iKey];\n          obKey.value[iKey] = arr[iKey];\n        }\n\n        return obKey;\n      }\n\n      function framesToTime(fr, fps) {\n        if (!fps) {\n          fps = elem.comp.globalData.frameRate;\n        }\n\n        return fr / fps;\n      }\n\n      function timeToFrames(t, fps) {\n        if (!t && t !== 0) {\n          t = time;\n        }\n\n        if (!fps) {\n          fps = elem.comp.globalData.frameRate;\n        }\n\n        return t * fps;\n      }\n\n      function seedRandom(seed) {\n        BMMath.seedrandom(randSeed + seed);\n      }\n\n      function sourceRectAtTime() {\n        return elem.sourceRectAtTime();\n      }\n\n      function substring(init, end) {\n        if (typeof value === 'string') {\n          if (end === undefined) {\n            return value.substring(init);\n          }\n\n          return value.substring(init, end);\n        }\n\n        return '';\n      }\n\n      function substr(init, end) {\n        if (typeof value === 'string') {\n          if (end === undefined) {\n            return value.substr(init);\n          }\n\n          return value.substr(init, end);\n        }\n\n        return '';\n      }\n\n      function posterizeTime(framesPerSecond) {\n        time = framesPerSecond === 0 ? 0 : Math.floor(time * framesPerSecond) / framesPerSecond;\n        value = valueAtTime(time);\n      }\n\n      var time;\n      var velocity;\n      var value;\n      var text;\n      var textIndex;\n      var textTotal;\n      var selectorValue;\n      var index = elem.data.ind;\n      var hasParent = !!(elem.hierarchy && elem.hierarchy.length);\n      var parent;\n      var randSeed = Math.floor(Math.random() * 1000000);\n      var globalData = elem.globalData;\n\n      function executeExpression(_value) {\n        // globalData.pushExpression();\n        value = _value;\n\n        if (this.frameExpressionId === elem.globalData.frameId && this.propType !== 'textSelector') {\n          return value;\n        }\n\n        if (this.propType === 'textSelector') {\n          textIndex = this.textIndex;\n          textTotal = this.textTotal;\n          selectorValue = this.selectorValue;\n        }\n\n        if (!thisLayer) {\n          text = elem.layerInterface.text;\n          thisLayer = elem.layerInterface;\n          thisComp = elem.comp.compInterface;\n          toWorld = thisLayer.toWorld.bind(thisLayer);\n          fromWorld = thisLayer.fromWorld.bind(thisLayer);\n          fromComp = thisLayer.fromComp.bind(thisLayer);\n          toComp = thisLayer.toComp.bind(thisLayer);\n          mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;\n          fromCompToSurface = fromComp;\n        }\n\n        if (!transform) {\n          transform = elem.layerInterface('ADBE Transform Group');\n          $bm_transform = transform;\n\n          if (transform) {\n            anchorPoint = transform.anchorPoint;\n            /* position = transform.position;\r\n                      rotation = transform.rotation;\r\n                      scale = transform.scale; */\n          }\n        }\n\n        if (elemType === 4 && !content) {\n          content = thisLayer('ADBE Root Vectors Group');\n        }\n\n        if (!effect) {\n          effect = thisLayer(4);\n        }\n\n        hasParent = !!(elem.hierarchy && elem.hierarchy.length);\n\n        if (hasParent && !parent) {\n          parent = elem.hierarchy[0].layerInterface;\n        }\n\n        time = this.comp.renderedFrame / this.comp.globalData.frameRate;\n\n        if (_needsRandom) {\n          seedRandom(randSeed + time);\n        }\n\n        if (needsVelocity) {\n          velocity = velocityAtTime(time);\n        }\n\n        expression_function();\n        this.frameExpressionId = elem.globalData.frameId; // TODO: Check if it's possible to return on ShapeInterface the .v value\n        // Changed this to a ternary operation because Rollup failed compiling it correctly\n\n        scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt;\n        return scoped_bm_rt;\n      } // Bundlers will see these as dead code and unless we reference them\n\n\n      executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData];\n      return executeExpression;\n    }\n\n    ob.initiateExpression = initiateExpression;\n    ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal];\n    ob.resetFrame = resetFrame;\n    return ob;\n  }();\n\n  var Expressions = function () {\n    var ob = {};\n    ob.initExpressions = initExpressions;\n    ob.resetFrame = ExpressionManager.resetFrame;\n\n    function initExpressions(animation) {\n      var stackCount = 0;\n      var registers = [];\n\n      function pushExpression() {\n        stackCount += 1;\n      }\n\n      function popExpression() {\n        stackCount -= 1;\n\n        if (stackCount === 0) {\n          releaseInstances();\n        }\n      }\n\n      function registerExpressionProperty(expression) {\n        if (registers.indexOf(expression) === -1) {\n          registers.push(expression);\n        }\n      }\n\n      function releaseInstances() {\n        var i;\n        var len = registers.length;\n\n        for (i = 0; i < len; i += 1) {\n          registers[i].release();\n        }\n\n        registers.length = 0;\n      }\n\n      animation.renderer.compInterface = CompExpressionInterface(animation.renderer);\n      animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);\n      animation.renderer.globalData.pushExpression = pushExpression;\n      animation.renderer.globalData.popExpression = popExpression;\n      animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;\n    }\n\n    return ob;\n  }();\n\n  var MaskManagerInterface = function () {\n    function MaskInterface(mask, data) {\n      this._mask = mask;\n      this._data = data;\n    }\n\n    Object.defineProperty(MaskInterface.prototype, 'maskPath', {\n      get: function get() {\n        if (this._mask.prop.k) {\n          this._mask.prop.getValue();\n        }\n\n        return this._mask.prop;\n      }\n    });\n    Object.defineProperty(MaskInterface.prototype, 'maskOpacity', {\n      get: function get() {\n        if (this._mask.op.k) {\n          this._mask.op.getValue();\n        }\n\n        return this._mask.op.v * 100;\n      }\n    });\n\n    var MaskManager = function MaskManager(maskManager) {\n      var _masksInterfaces = createSizedArray(maskManager.viewData.length);\n\n      var i;\n      var len = maskManager.viewData.length;\n\n      for (i = 0; i < len; i += 1) {\n        _masksInterfaces[i] = new MaskInterface(maskManager.viewData[i], maskManager.masksProperties[i]);\n      }\n\n      var maskFunction = function maskFunction(name) {\n        i = 0;\n\n        while (i < len) {\n          if (maskManager.masksProperties[i].nm === name) {\n            return _masksInterfaces[i];\n          }\n\n          i += 1;\n        }\n\n        return null;\n      };\n\n      return maskFunction;\n    };\n\n    return MaskManager;\n  }();\n\n  var ExpressionPropertyInterface = function () {\n    var defaultUnidimensionalValue = {\n      pv: 0,\n      v: 0,\n      mult: 1\n    };\n    var defaultMultidimensionalValue = {\n      pv: [0, 0, 0],\n      v: [0, 0, 0],\n      mult: 1\n    };\n\n    function completeProperty(expressionValue, property, type) {\n      Object.defineProperty(expressionValue, 'velocity', {\n        get: function get() {\n          return property.getVelocityAtTime(property.comp.currentFrame);\n        }\n      });\n      expressionValue.numKeys = property.keyframes ? property.keyframes.length : 0;\n\n      expressionValue.key = function (pos) {\n        if (!expressionValue.numKeys) {\n          return 0;\n        }\n\n        var value = '';\n\n        if ('s' in property.keyframes[pos - 1]) {\n          value = property.keyframes[pos - 1].s;\n        } else if ('e' in property.keyframes[pos - 2]) {\n          value = property.keyframes[pos - 2].e;\n        } else {\n          value = property.keyframes[pos - 2].s;\n        }\n\n        var valueProp = type === 'unidimensional' ? new Number(value) : Object.assign({}, value); // eslint-disable-line no-new-wrappers\n\n        valueProp.time = property.keyframes[pos - 1].t / property.elem.comp.globalData.frameRate;\n        valueProp.value = type === 'unidimensional' ? value[0] : value;\n        return valueProp;\n      };\n\n      expressionValue.valueAtTime = property.getValueAtTime;\n      expressionValue.speedAtTime = property.getSpeedAtTime;\n      expressionValue.velocityAtTime = property.getVelocityAtTime;\n      expressionValue.propertyGroup = property.propertyGroup;\n    }\n\n    function UnidimensionalPropertyInterface(property) {\n      if (!property || !('pv' in property)) {\n        property = defaultUnidimensionalValue;\n      }\n\n      var mult = 1 / property.mult;\n      var val = property.pv * mult;\n      var expressionValue = new Number(val); // eslint-disable-line no-new-wrappers\n\n      expressionValue.value = val;\n      completeProperty(expressionValue, property, 'unidimensional');\n      return function () {\n        if (property.k) {\n          property.getValue();\n        }\n\n        val = property.v * mult;\n\n        if (expressionValue.value !== val) {\n          expressionValue = new Number(val); // eslint-disable-line no-new-wrappers\n\n          expressionValue.value = val;\n          completeProperty(expressionValue, property, 'unidimensional');\n        }\n\n        return expressionValue;\n      };\n    }\n\n    function MultidimensionalPropertyInterface(property) {\n      if (!property || !('pv' in property)) {\n        property = defaultMultidimensionalValue;\n      }\n\n      var mult = 1 / property.mult;\n      var len = property.data && property.data.l || property.pv.length;\n      var expressionValue = createTypedArray('float32', len);\n      var arrValue = createTypedArray('float32', len);\n      expressionValue.value = arrValue;\n      completeProperty(expressionValue, property, 'multidimensional');\n      return function () {\n        if (property.k) {\n          property.getValue();\n        }\n\n        for (var i = 0; i < len; i += 1) {\n          arrValue[i] = property.v[i] * mult;\n          expressionValue[i] = arrValue[i];\n        }\n\n        return expressionValue;\n      };\n    } // TODO: try to avoid using this getter\n\n\n    function defaultGetter() {\n      return defaultUnidimensionalValue;\n    }\n\n    return function (property) {\n      if (!property) {\n        return defaultGetter;\n      }\n\n      if (property.propType === 'unidimensional') {\n        return UnidimensionalPropertyInterface(property);\n      }\n\n      return MultidimensionalPropertyInterface(property);\n    };\n  }();\n\n  var TransformExpressionInterface = function () {\n    return function (transform) {\n      function _thisFunction(name) {\n        switch (name) {\n          case 'scale':\n          case 'Scale':\n          case 'ADBE Scale':\n          case 6:\n            return _thisFunction.scale;\n\n          case 'rotation':\n          case 'Rotation':\n          case 'ADBE Rotation':\n          case 'ADBE Rotate Z':\n          case 10:\n            return _thisFunction.rotation;\n\n          case 'ADBE Rotate X':\n            return _thisFunction.xRotation;\n\n          case 'ADBE Rotate Y':\n            return _thisFunction.yRotation;\n\n          case 'position':\n          case 'Position':\n          case 'ADBE Position':\n          case 2:\n            return _thisFunction.position;\n\n          case 'ADBE Position_0':\n            return _thisFunction.xPosition;\n\n          case 'ADBE Position_1':\n            return _thisFunction.yPosition;\n\n          case 'ADBE Position_2':\n            return _thisFunction.zPosition;\n\n          case 'anchorPoint':\n          case 'AnchorPoint':\n          case 'Anchor Point':\n          case 'ADBE AnchorPoint':\n          case 1:\n            return _thisFunction.anchorPoint;\n\n          case 'opacity':\n          case 'Opacity':\n          case 11:\n            return _thisFunction.opacity;\n\n          default:\n            return null;\n        }\n      }\n\n      Object.defineProperty(_thisFunction, 'rotation', {\n        get: ExpressionPropertyInterface(transform.r || transform.rz)\n      });\n      Object.defineProperty(_thisFunction, 'zRotation', {\n        get: ExpressionPropertyInterface(transform.rz || transform.r)\n      });\n      Object.defineProperty(_thisFunction, 'xRotation', {\n        get: ExpressionPropertyInterface(transform.rx)\n      });\n      Object.defineProperty(_thisFunction, 'yRotation', {\n        get: ExpressionPropertyInterface(transform.ry)\n      });\n      Object.defineProperty(_thisFunction, 'scale', {\n        get: ExpressionPropertyInterface(transform.s)\n      });\n\n      var _px;\n\n      var _py;\n\n      var _pz;\n\n      var _transformFactory;\n\n      if (transform.p) {\n        _transformFactory = ExpressionPropertyInterface(transform.p);\n      } else {\n        _px = ExpressionPropertyInterface(transform.px);\n        _py = ExpressionPropertyInterface(transform.py);\n\n        if (transform.pz) {\n          _pz = ExpressionPropertyInterface(transform.pz);\n        }\n      }\n\n      Object.defineProperty(_thisFunction, 'position', {\n        get: function get() {\n          if (transform.p) {\n            return _transformFactory();\n          }\n\n          return [_px(), _py(), _pz ? _pz() : 0];\n        }\n      });\n      Object.defineProperty(_thisFunction, 'xPosition', {\n        get: ExpressionPropertyInterface(transform.px)\n      });\n      Object.defineProperty(_thisFunction, 'yPosition', {\n        get: ExpressionPropertyInterface(transform.py)\n      });\n      Object.defineProperty(_thisFunction, 'zPosition', {\n        get: ExpressionPropertyInterface(transform.pz)\n      });\n      Object.defineProperty(_thisFunction, 'anchorPoint', {\n        get: ExpressionPropertyInterface(transform.a)\n      });\n      Object.defineProperty(_thisFunction, 'opacity', {\n        get: ExpressionPropertyInterface(transform.o)\n      });\n      Object.defineProperty(_thisFunction, 'skew', {\n        get: ExpressionPropertyInterface(transform.sk)\n      });\n      Object.defineProperty(_thisFunction, 'skewAxis', {\n        get: ExpressionPropertyInterface(transform.sa)\n      });\n      Object.defineProperty(_thisFunction, 'orientation', {\n        get: ExpressionPropertyInterface(transform.or)\n      });\n      return _thisFunction;\n    };\n  }();\n\n  var LayerExpressionInterface = function () {\n    function getMatrix(time) {\n      var toWorldMat = new Matrix();\n\n      if (time !== undefined) {\n        var propMatrix = this._elem.finalTransform.mProp.getValueAtTime(time);\n\n        propMatrix.clone(toWorldMat);\n      } else {\n        var transformMat = this._elem.finalTransform.mProp;\n        transformMat.applyToMatrix(toWorldMat);\n      }\n\n      return toWorldMat;\n    }\n\n    function toWorldVec(arr, time) {\n      var toWorldMat = this.getMatrix(time);\n      toWorldMat.props[12] = 0;\n      toWorldMat.props[13] = 0;\n      toWorldMat.props[14] = 0;\n      return this.applyPoint(toWorldMat, arr);\n    }\n\n    function toWorld(arr, time) {\n      var toWorldMat = this.getMatrix(time);\n      return this.applyPoint(toWorldMat, arr);\n    }\n\n    function fromWorldVec(arr, time) {\n      var toWorldMat = this.getMatrix(time);\n      toWorldMat.props[12] = 0;\n      toWorldMat.props[13] = 0;\n      toWorldMat.props[14] = 0;\n      return this.invertPoint(toWorldMat, arr);\n    }\n\n    function fromWorld(arr, time) {\n      var toWorldMat = this.getMatrix(time);\n      return this.invertPoint(toWorldMat, arr);\n    }\n\n    function applyPoint(matrix, arr) {\n      if (this._elem.hierarchy && this._elem.hierarchy.length) {\n        var i;\n        var len = this._elem.hierarchy.length;\n\n        for (i = 0; i < len; i += 1) {\n          this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);\n        }\n      }\n\n      return matrix.applyToPointArray(arr[0], arr[1], arr[2] || 0);\n    }\n\n    function invertPoint(matrix, arr) {\n      if (this._elem.hierarchy && this._elem.hierarchy.length) {\n        var i;\n        var len = this._elem.hierarchy.length;\n\n        for (i = 0; i < len; i += 1) {\n          this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);\n        }\n      }\n\n      return matrix.inversePoint(arr);\n    }\n\n    function fromComp(arr) {\n      var toWorldMat = new Matrix();\n      toWorldMat.reset();\n\n      this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);\n\n      if (this._elem.hierarchy && this._elem.hierarchy.length) {\n        var i;\n        var len = this._elem.hierarchy.length;\n\n        for (i = 0; i < len; i += 1) {\n          this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);\n        }\n\n        return toWorldMat.inversePoint(arr);\n      }\n\n      return toWorldMat.inversePoint(arr);\n    }\n\n    function sampleImage() {\n      return [1, 1, 1, 1];\n    }\n\n    return function (elem) {\n      var transformInterface;\n\n      function _registerMaskInterface(maskManager) {\n        _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem);\n      }\n\n      function _registerEffectsInterface(effects) {\n        _thisLayerFunction.effect = effects;\n      }\n\n      function _thisLayerFunction(name) {\n        switch (name) {\n          case 'ADBE Root Vectors Group':\n          case 'Contents':\n          case 2:\n            return _thisLayerFunction.shapeInterface;\n\n          case 1:\n          case 6:\n          case 'Transform':\n          case 'transform':\n          case 'ADBE Transform Group':\n            return transformInterface;\n\n          case 4:\n          case 'ADBE Effect Parade':\n          case 'effects':\n          case 'Effects':\n            return _thisLayerFunction.effect;\n\n          case 'ADBE Text Properties':\n            return _thisLayerFunction.textInterface;\n\n          default:\n            return null;\n        }\n      }\n\n      _thisLayerFunction.getMatrix = getMatrix;\n      _thisLayerFunction.invertPoint = invertPoint;\n      _thisLayerFunction.applyPoint = applyPoint;\n      _thisLayerFunction.toWorld = toWorld;\n      _thisLayerFunction.toWorldVec = toWorldVec;\n      _thisLayerFunction.fromWorld = fromWorld;\n      _thisLayerFunction.fromWorldVec = fromWorldVec;\n      _thisLayerFunction.toComp = toWorld;\n      _thisLayerFunction.fromComp = fromComp;\n      _thisLayerFunction.sampleImage = sampleImage;\n      _thisLayerFunction.sourceRectAtTime = elem.sourceRectAtTime.bind(elem);\n      _thisLayerFunction._elem = elem;\n      transformInterface = TransformExpressionInterface(elem.finalTransform.mProp);\n      var anchorPointDescriptor = getDescriptor(transformInterface, 'anchorPoint');\n      Object.defineProperties(_thisLayerFunction, {\n        hasParent: {\n          get: function get() {\n            return elem.hierarchy.length;\n          }\n        },\n        parent: {\n          get: function get() {\n            return elem.hierarchy[0].layerInterface;\n          }\n        },\n        rotation: getDescriptor(transformInterface, 'rotation'),\n        scale: getDescriptor(transformInterface, 'scale'),\n        position: getDescriptor(transformInterface, 'position'),\n        opacity: getDescriptor(transformInterface, 'opacity'),\n        anchorPoint: anchorPointDescriptor,\n        anchor_point: anchorPointDescriptor,\n        transform: {\n          get: function get() {\n            return transformInterface;\n          }\n        },\n        active: {\n          get: function get() {\n            return elem.isInRange;\n          }\n        }\n      });\n      _thisLayerFunction.startTime = elem.data.st;\n      _thisLayerFunction.index = elem.data.ind;\n      _thisLayerFunction.source = elem.data.refId;\n      _thisLayerFunction.height = elem.data.ty === 0 ? elem.data.h : 100;\n      _thisLayerFunction.width = elem.data.ty === 0 ? elem.data.w : 100;\n      _thisLayerFunction.inPoint = elem.data.ip / elem.comp.globalData.frameRate;\n      _thisLayerFunction.outPoint = elem.data.op / elem.comp.globalData.frameRate;\n      _thisLayerFunction._name = elem.data.nm;\n      _thisLayerFunction.registerMaskInterface = _registerMaskInterface;\n      _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;\n      return _thisLayerFunction;\n    };\n  }();\n\n  var propertyGroupFactory = function () {\n    return function (interfaceFunction, parentPropertyGroup) {\n      return function (val) {\n        val = val === undefined ? 1 : val;\n\n        if (val <= 0) {\n          return interfaceFunction;\n        }\n\n        return parentPropertyGroup(val - 1);\n      };\n    };\n  }();\n\n  var PropertyInterface = function () {\n    return function (propertyName, propertyGroup) {\n      var interfaceFunction = {\n        _name: propertyName\n      };\n\n      function _propertyGroup(val) {\n        val = val === undefined ? 1 : val;\n\n        if (val <= 0) {\n          return interfaceFunction;\n        }\n\n        return propertyGroup(val - 1);\n      }\n\n      return _propertyGroup;\n    };\n  }();\n\n  var EffectsExpressionInterface = function () {\n    var ob = {\n      createEffectsInterface: createEffectsInterface\n    };\n\n    function createEffectsInterface(elem, propertyGroup) {\n      if (elem.effectsManager) {\n        var effectElements = [];\n        var effectsData = elem.data.ef;\n        var i;\n        var len = elem.effectsManager.effectElements.length;\n\n        for (i = 0; i < len; i += 1) {\n          effectElements.push(createGroupInterface(effectsData[i], elem.effectsManager.effectElements[i], propertyGroup, elem));\n        }\n\n        var effects = elem.data.ef || [];\n\n        var groupInterface = function groupInterface(name) {\n          i = 0;\n          len = effects.length;\n\n          while (i < len) {\n            if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {\n              return effectElements[i];\n            }\n\n            i += 1;\n          }\n\n          return null;\n        };\n\n        Object.defineProperty(groupInterface, 'numProperties', {\n          get: function get() {\n            return effects.length;\n          }\n        });\n        return groupInterface;\n      }\n\n      return null;\n    }\n\n    function createGroupInterface(data, elements, propertyGroup, elem) {\n      function groupInterface(name) {\n        var effects = data.ef;\n        var i = 0;\n        var len = effects.length;\n\n        while (i < len) {\n          if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {\n            if (effects[i].ty === 5) {\n              return effectElements[i];\n            }\n\n            return effectElements[i]();\n          }\n\n          i += 1;\n        }\n\n        throw new Error();\n      }\n\n      var _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup);\n\n      var effectElements = [];\n      var i;\n      var len = data.ef.length;\n\n      for (i = 0; i < len; i += 1) {\n        if (data.ef[i].ty === 5) {\n          effectElements.push(createGroupInterface(data.ef[i], elements.effectElements[i], elements.effectElements[i].propertyGroup, elem));\n        } else {\n          effectElements.push(createValueInterface(elements.effectElements[i], data.ef[i].ty, elem, _propertyGroup));\n        }\n      }\n\n      if (data.mn === 'ADBE Color Control') {\n        Object.defineProperty(groupInterface, 'color', {\n          get: function get() {\n            return effectElements[0]();\n          }\n        });\n      }\n\n      Object.defineProperties(groupInterface, {\n        numProperties: {\n          get: function get() {\n            return data.np;\n          }\n        },\n        _name: {\n          value: data.nm\n        },\n        propertyGroup: {\n          value: _propertyGroup\n        }\n      });\n      groupInterface.enabled = data.en !== 0;\n      groupInterface.active = groupInterface.enabled;\n      return groupInterface;\n    }\n\n    function createValueInterface(element, type, elem, propertyGroup) {\n      var expressionProperty = ExpressionPropertyInterface(element.p);\n\n      function interfaceFunction() {\n        if (type === 10) {\n          return elem.comp.compInterface(element.p.v);\n        }\n\n        return expressionProperty();\n      }\n\n      if (element.p.setGroupProperty) {\n        element.p.setGroupProperty(PropertyInterface('', propertyGroup));\n      }\n\n      return interfaceFunction;\n    }\n\n    return ob;\n  }();\n\n  var ShapePathInterface = function () {\n    return function pathInterfaceFactory(shape, view, propertyGroup) {\n      var prop = view.sh;\n\n      function interfaceFunction(val) {\n        if (val === 'Shape' || val === 'shape' || val === 'Path' || val === 'path' || val === 'ADBE Vector Shape' || val === 2) {\n          return interfaceFunction.path;\n        }\n\n        return null;\n      }\n\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n\n      prop.setGroupProperty(PropertyInterface('Path', _propertyGroup));\n      Object.defineProperties(interfaceFunction, {\n        path: {\n          get: function get() {\n            if (prop.k) {\n              prop.getValue();\n            }\n\n            return prop;\n          }\n        },\n        shape: {\n          get: function get() {\n            if (prop.k) {\n              prop.getValue();\n            }\n\n            return prop;\n          }\n        },\n        _name: {\n          value: shape.nm\n        },\n        ix: {\n          value: shape.ix\n        },\n        propertyIndex: {\n          value: shape.ix\n        },\n        mn: {\n          value: shape.mn\n        },\n        propertyGroup: {\n          value: propertyGroup\n        }\n      });\n      return interfaceFunction;\n    };\n  }();\n\n  var ShapeExpressionInterface = function () {\n    function iterateElements(shapes, view, propertyGroup) {\n      var arr = [];\n      var i;\n      var len = shapes ? shapes.length : 0;\n\n      for (i = 0; i < len; i += 1) {\n        if (shapes[i].ty === 'gr') {\n          arr.push(groupInterfaceFactory(shapes[i], view[i], propertyGroup));\n        } else if (shapes[i].ty === 'fl') {\n          arr.push(fillInterfaceFactory(shapes[i], view[i], propertyGroup));\n        } else if (shapes[i].ty === 'st') {\n          arr.push(strokeInterfaceFactory(shapes[i], view[i], propertyGroup));\n        } else if (shapes[i].ty === 'tm') {\n          arr.push(trimInterfaceFactory(shapes[i], view[i], propertyGroup));\n        } else if (shapes[i].ty === 'tr') {// arr.push(transformInterfaceFactory(shapes[i],view[i],propertyGroup));\n        } else if (shapes[i].ty === 'el') {\n          arr.push(ellipseInterfaceFactory(shapes[i], view[i], propertyGroup));\n        } else if (shapes[i].ty === 'sr') {\n          arr.push(starInterfaceFactory(shapes[i], view[i], propertyGroup));\n        } else if (shapes[i].ty === 'sh') {\n          arr.push(ShapePathInterface(shapes[i], view[i], propertyGroup));\n        } else if (shapes[i].ty === 'rc') {\n          arr.push(rectInterfaceFactory(shapes[i], view[i], propertyGroup));\n        } else if (shapes[i].ty === 'rd') {\n          arr.push(roundedInterfaceFactory(shapes[i], view[i], propertyGroup));\n        } else if (shapes[i].ty === 'rp') {\n          arr.push(repeaterInterfaceFactory(shapes[i], view[i], propertyGroup));\n        } else if (shapes[i].ty === 'gf') {\n          arr.push(gradientFillInterfaceFactory(shapes[i], view[i], propertyGroup));\n        } else {\n          arr.push(defaultInterfaceFactory(shapes[i], view[i], propertyGroup));\n        }\n      }\n\n      return arr;\n    }\n\n    function contentsInterfaceFactory(shape, view, propertyGroup) {\n      var interfaces;\n\n      var interfaceFunction = function _interfaceFunction(value) {\n        var i = 0;\n        var len = interfaces.length;\n\n        while (i < len) {\n          if (interfaces[i]._name === value || interfaces[i].mn === value || interfaces[i].propertyIndex === value || interfaces[i].ix === value || interfaces[i].ind === value) {\n            return interfaces[i];\n          }\n\n          i += 1;\n        }\n\n        if (typeof value === 'number') {\n          return interfaces[value - 1];\n        }\n\n        return null;\n      };\n\n      interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n      interfaces = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);\n      interfaceFunction.numProperties = interfaces.length;\n      var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);\n      interfaceFunction.transform = transformInterface;\n      interfaceFunction.propertyIndex = shape.cix;\n      interfaceFunction._name = shape.nm;\n      return interfaceFunction;\n    }\n\n    function groupInterfaceFactory(shape, view, propertyGroup) {\n      var interfaceFunction = function _interfaceFunction(value) {\n        switch (value) {\n          case 'ADBE Vectors Group':\n          case 'Contents':\n          case 2:\n            return interfaceFunction.content;\n          // Not necessary for now. Keeping them here in case a new case appears\n          // case 'ADBE Vector Transform Group':\n          // case 3:\n\n          default:\n            return interfaceFunction.transform;\n        }\n      };\n\n      interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n      var content = contentsInterfaceFactory(shape, view, interfaceFunction.propertyGroup);\n      var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);\n      interfaceFunction.content = content;\n      interfaceFunction.transform = transformInterface;\n      Object.defineProperty(interfaceFunction, '_name', {\n        get: function get() {\n          return shape.nm;\n        }\n      }); // interfaceFunction.content = interfaceFunction;\n\n      interfaceFunction.numProperties = shape.np;\n      interfaceFunction.propertyIndex = shape.ix;\n      interfaceFunction.nm = shape.nm;\n      interfaceFunction.mn = shape.mn;\n      return interfaceFunction;\n    }\n\n    function fillInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(val) {\n        if (val === 'Color' || val === 'color') {\n          return interfaceFunction.color;\n        }\n\n        if (val === 'Opacity' || val === 'opacity') {\n          return interfaceFunction.opacity;\n        }\n\n        return null;\n      }\n\n      Object.defineProperties(interfaceFunction, {\n        color: {\n          get: ExpressionPropertyInterface(view.c)\n        },\n        opacity: {\n          get: ExpressionPropertyInterface(view.o)\n        },\n        _name: {\n          value: shape.nm\n        },\n        mn: {\n          value: shape.mn\n        }\n      });\n      view.c.setGroupProperty(PropertyInterface('Color', propertyGroup));\n      view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));\n      return interfaceFunction;\n    }\n\n    function gradientFillInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(val) {\n        if (val === 'Start Point' || val === 'start point') {\n          return interfaceFunction.startPoint;\n        }\n\n        if (val === 'End Point' || val === 'end point') {\n          return interfaceFunction.endPoint;\n        }\n\n        if (val === 'Opacity' || val === 'opacity') {\n          return interfaceFunction.opacity;\n        }\n\n        return null;\n      }\n\n      Object.defineProperties(interfaceFunction, {\n        startPoint: {\n          get: ExpressionPropertyInterface(view.s)\n        },\n        endPoint: {\n          get: ExpressionPropertyInterface(view.e)\n        },\n        opacity: {\n          get: ExpressionPropertyInterface(view.o)\n        },\n        type: {\n          get: function get() {\n            return 'a';\n          }\n        },\n        _name: {\n          value: shape.nm\n        },\n        mn: {\n          value: shape.mn\n        }\n      });\n      view.s.setGroupProperty(PropertyInterface('Start Point', propertyGroup));\n      view.e.setGroupProperty(PropertyInterface('End Point', propertyGroup));\n      view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));\n      return interfaceFunction;\n    }\n\n    function defaultInterfaceFactory() {\n      function interfaceFunction() {\n        return null;\n      }\n\n      return interfaceFunction;\n    }\n\n    function strokeInterfaceFactory(shape, view, propertyGroup) {\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n\n      var _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup);\n\n      function addPropertyToDashOb(i) {\n        Object.defineProperty(dashOb, shape.d[i].nm, {\n          get: ExpressionPropertyInterface(view.d.dataProps[i].p)\n        });\n      }\n\n      var i;\n      var len = shape.d ? shape.d.length : 0;\n      var dashOb = {};\n\n      for (i = 0; i < len; i += 1) {\n        addPropertyToDashOb(i);\n        view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);\n      }\n\n      function interfaceFunction(val) {\n        if (val === 'Color' || val === 'color') {\n          return interfaceFunction.color;\n        }\n\n        if (val === 'Opacity' || val === 'opacity') {\n          return interfaceFunction.opacity;\n        }\n\n        if (val === 'Stroke Width' || val === 'stroke width') {\n          return interfaceFunction.strokeWidth;\n        }\n\n        return null;\n      }\n\n      Object.defineProperties(interfaceFunction, {\n        color: {\n          get: ExpressionPropertyInterface(view.c)\n        },\n        opacity: {\n          get: ExpressionPropertyInterface(view.o)\n        },\n        strokeWidth: {\n          get: ExpressionPropertyInterface(view.w)\n        },\n        dash: {\n          get: function get() {\n            return dashOb;\n          }\n        },\n        _name: {\n          value: shape.nm\n        },\n        mn: {\n          value: shape.mn\n        }\n      });\n      view.c.setGroupProperty(PropertyInterface('Color', _propertyGroup));\n      view.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));\n      view.w.setGroupProperty(PropertyInterface('Stroke Width', _propertyGroup));\n      return interfaceFunction;\n    }\n\n    function trimInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(val) {\n        if (val === shape.e.ix || val === 'End' || val === 'end') {\n          return interfaceFunction.end;\n        }\n\n        if (val === shape.s.ix) {\n          return interfaceFunction.start;\n        }\n\n        if (val === shape.o.ix) {\n          return interfaceFunction.offset;\n        }\n\n        return null;\n      }\n\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n\n      interfaceFunction.propertyIndex = shape.ix;\n      view.s.setGroupProperty(PropertyInterface('Start', _propertyGroup));\n      view.e.setGroupProperty(PropertyInterface('End', _propertyGroup));\n      view.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));\n      interfaceFunction.propertyIndex = shape.ix;\n      interfaceFunction.propertyGroup = propertyGroup;\n      Object.defineProperties(interfaceFunction, {\n        start: {\n          get: ExpressionPropertyInterface(view.s)\n        },\n        end: {\n          get: ExpressionPropertyInterface(view.e)\n        },\n        offset: {\n          get: ExpressionPropertyInterface(view.o)\n        },\n        _name: {\n          value: shape.nm\n        }\n      });\n      interfaceFunction.mn = shape.mn;\n      return interfaceFunction;\n    }\n\n    function transformInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(value) {\n        if (shape.a.ix === value || value === 'Anchor Point') {\n          return interfaceFunction.anchorPoint;\n        }\n\n        if (shape.o.ix === value || value === 'Opacity') {\n          return interfaceFunction.opacity;\n        }\n\n        if (shape.p.ix === value || value === 'Position') {\n          return interfaceFunction.position;\n        }\n\n        if (shape.r.ix === value || value === 'Rotation' || value === 'ADBE Vector Rotation') {\n          return interfaceFunction.rotation;\n        }\n\n        if (shape.s.ix === value || value === 'Scale') {\n          return interfaceFunction.scale;\n        }\n\n        if (shape.sk && shape.sk.ix === value || value === 'Skew') {\n          return interfaceFunction.skew;\n        }\n\n        if (shape.sa && shape.sa.ix === value || value === 'Skew Axis') {\n          return interfaceFunction.skewAxis;\n        }\n\n        return null;\n      }\n\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n\n      view.transform.mProps.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));\n      view.transform.mProps.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));\n      view.transform.mProps.a.setGroupProperty(PropertyInterface('Anchor Point', _propertyGroup));\n      view.transform.mProps.s.setGroupProperty(PropertyInterface('Scale', _propertyGroup));\n      view.transform.mProps.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));\n\n      if (view.transform.mProps.sk) {\n        view.transform.mProps.sk.setGroupProperty(PropertyInterface('Skew', _propertyGroup));\n        view.transform.mProps.sa.setGroupProperty(PropertyInterface('Skew Angle', _propertyGroup));\n      }\n\n      view.transform.op.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));\n      Object.defineProperties(interfaceFunction, {\n        opacity: {\n          get: ExpressionPropertyInterface(view.transform.mProps.o)\n        },\n        position: {\n          get: ExpressionPropertyInterface(view.transform.mProps.p)\n        },\n        anchorPoint: {\n          get: ExpressionPropertyInterface(view.transform.mProps.a)\n        },\n        scale: {\n          get: ExpressionPropertyInterface(view.transform.mProps.s)\n        },\n        rotation: {\n          get: ExpressionPropertyInterface(view.transform.mProps.r)\n        },\n        skew: {\n          get: ExpressionPropertyInterface(view.transform.mProps.sk)\n        },\n        skewAxis: {\n          get: ExpressionPropertyInterface(view.transform.mProps.sa)\n        },\n        _name: {\n          value: shape.nm\n        }\n      });\n      interfaceFunction.ty = 'tr';\n      interfaceFunction.mn = shape.mn;\n      interfaceFunction.propertyGroup = propertyGroup;\n      return interfaceFunction;\n    }\n\n    function ellipseInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(value) {\n        if (shape.p.ix === value) {\n          return interfaceFunction.position;\n        }\n\n        if (shape.s.ix === value) {\n          return interfaceFunction.size;\n        }\n\n        return null;\n      }\n\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n\n      interfaceFunction.propertyIndex = shape.ix;\n      var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;\n      prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));\n      prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));\n      Object.defineProperties(interfaceFunction, {\n        size: {\n          get: ExpressionPropertyInterface(prop.s)\n        },\n        position: {\n          get: ExpressionPropertyInterface(prop.p)\n        },\n        _name: {\n          value: shape.nm\n        }\n      });\n      interfaceFunction.mn = shape.mn;\n      return interfaceFunction;\n    }\n\n    function starInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(value) {\n        if (shape.p.ix === value) {\n          return interfaceFunction.position;\n        }\n\n        if (shape.r.ix === value) {\n          return interfaceFunction.rotation;\n        }\n\n        if (shape.pt.ix === value) {\n          return interfaceFunction.points;\n        }\n\n        if (shape.or.ix === value || value === 'ADBE Vector Star Outer Radius') {\n          return interfaceFunction.outerRadius;\n        }\n\n        if (shape.os.ix === value) {\n          return interfaceFunction.outerRoundness;\n        }\n\n        if (shape.ir && (shape.ir.ix === value || value === 'ADBE Vector Star Inner Radius')) {\n          return interfaceFunction.innerRadius;\n        }\n\n        if (shape.is && shape.is.ix === value) {\n          return interfaceFunction.innerRoundness;\n        }\n\n        return null;\n      }\n\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n\n      var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;\n      interfaceFunction.propertyIndex = shape.ix;\n      prop.or.setGroupProperty(PropertyInterface('Outer Radius', _propertyGroup));\n      prop.os.setGroupProperty(PropertyInterface('Outer Roundness', _propertyGroup));\n      prop.pt.setGroupProperty(PropertyInterface('Points', _propertyGroup));\n      prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));\n      prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));\n\n      if (shape.ir) {\n        prop.ir.setGroupProperty(PropertyInterface('Inner Radius', _propertyGroup));\n        prop.is.setGroupProperty(PropertyInterface('Inner Roundness', _propertyGroup));\n      }\n\n      Object.defineProperties(interfaceFunction, {\n        position: {\n          get: ExpressionPropertyInterface(prop.p)\n        },\n        rotation: {\n          get: ExpressionPropertyInterface(prop.r)\n        },\n        points: {\n          get: ExpressionPropertyInterface(prop.pt)\n        },\n        outerRadius: {\n          get: ExpressionPropertyInterface(prop.or)\n        },\n        outerRoundness: {\n          get: ExpressionPropertyInterface(prop.os)\n        },\n        innerRadius: {\n          get: ExpressionPropertyInterface(prop.ir)\n        },\n        innerRoundness: {\n          get: ExpressionPropertyInterface(prop.is)\n        },\n        _name: {\n          value: shape.nm\n        }\n      });\n      interfaceFunction.mn = shape.mn;\n      return interfaceFunction;\n    }\n\n    function rectInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(value) {\n        if (shape.p.ix === value) {\n          return interfaceFunction.position;\n        }\n\n        if (shape.r.ix === value) {\n          return interfaceFunction.roundness;\n        }\n\n        if (shape.s.ix === value || value === 'Size' || value === 'ADBE Vector Rect Size') {\n          return interfaceFunction.size;\n        }\n\n        return null;\n      }\n\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n\n      var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;\n      interfaceFunction.propertyIndex = shape.ix;\n      prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));\n      prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));\n      prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));\n      Object.defineProperties(interfaceFunction, {\n        position: {\n          get: ExpressionPropertyInterface(prop.p)\n        },\n        roundness: {\n          get: ExpressionPropertyInterface(prop.r)\n        },\n        size: {\n          get: ExpressionPropertyInterface(prop.s)\n        },\n        _name: {\n          value: shape.nm\n        }\n      });\n      interfaceFunction.mn = shape.mn;\n      return interfaceFunction;\n    }\n\n    function roundedInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(value) {\n        if (shape.r.ix === value || value === 'Round Corners 1') {\n          return interfaceFunction.radius;\n        }\n\n        return null;\n      }\n\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n\n      var prop = view;\n      interfaceFunction.propertyIndex = shape.ix;\n      prop.rd.setGroupProperty(PropertyInterface('Radius', _propertyGroup));\n      Object.defineProperties(interfaceFunction, {\n        radius: {\n          get: ExpressionPropertyInterface(prop.rd)\n        },\n        _name: {\n          value: shape.nm\n        }\n      });\n      interfaceFunction.mn = shape.mn;\n      return interfaceFunction;\n    }\n\n    function repeaterInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(value) {\n        if (shape.c.ix === value || value === 'Copies') {\n          return interfaceFunction.copies;\n        }\n\n        if (shape.o.ix === value || value === 'Offset') {\n          return interfaceFunction.offset;\n        }\n\n        return null;\n      }\n\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n\n      var prop = view;\n      interfaceFunction.propertyIndex = shape.ix;\n      prop.c.setGroupProperty(PropertyInterface('Copies', _propertyGroup));\n      prop.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));\n      Object.defineProperties(interfaceFunction, {\n        copies: {\n          get: ExpressionPropertyInterface(prop.c)\n        },\n        offset: {\n          get: ExpressionPropertyInterface(prop.o)\n        },\n        _name: {\n          value: shape.nm\n        }\n      });\n      interfaceFunction.mn = shape.mn;\n      return interfaceFunction;\n    }\n\n    return function (shapes, view, propertyGroup) {\n      var interfaces;\n\n      function _interfaceFunction(value) {\n        if (typeof value === 'number') {\n          value = value === undefined ? 1 : value;\n\n          if (value === 0) {\n            return propertyGroup;\n          }\n\n          return interfaces[value - 1];\n        }\n\n        var i = 0;\n        var len = interfaces.length;\n\n        while (i < len) {\n          if (interfaces[i]._name === value) {\n            return interfaces[i];\n          }\n\n          i += 1;\n        }\n\n        return null;\n      }\n\n      function parentGroupWrapper() {\n        return propertyGroup;\n      }\n\n      _interfaceFunction.propertyGroup = propertyGroupFactory(_interfaceFunction, parentGroupWrapper);\n      interfaces = iterateElements(shapes, view, _interfaceFunction.propertyGroup);\n      _interfaceFunction.numProperties = interfaces.length;\n      _interfaceFunction._name = 'Contents';\n      return _interfaceFunction;\n    };\n  }();\n\n  var TextExpressionInterface = function () {\n    return function (elem) {\n      var _sourceText;\n\n      function _thisLayerFunction(name) {\n        switch (name) {\n          case 'ADBE Text Document':\n            return _thisLayerFunction.sourceText;\n\n          default:\n            return null;\n        }\n      }\n\n      Object.defineProperty(_thisLayerFunction, 'sourceText', {\n        get: function get() {\n          elem.textProperty.getValue();\n          var stringValue = elem.textProperty.currentData.t;\n\n          if (!_sourceText || stringValue !== _sourceText.value) {\n            _sourceText = new String(stringValue); // eslint-disable-line no-new-wrappers\n            // If stringValue is an empty string, eval returns undefined, so it has to be returned as a String primitive\n\n            _sourceText.value = stringValue || new String(stringValue); // eslint-disable-line no-new-wrappers\n\n            Object.defineProperty(_sourceText, 'style', {\n              get: function get() {\n                return {\n                  fillColor: elem.textProperty.currentData.fc\n                };\n              }\n            });\n          }\n\n          return _sourceText;\n        }\n      });\n      return _thisLayerFunction;\n    };\n  }();\n\n  function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n  var FootageInterface = function () {\n    var outlineInterfaceFactory = function outlineInterfaceFactory(elem) {\n      var currentPropertyName = '';\n      var currentProperty = elem.getFootageData();\n\n      function init() {\n        currentPropertyName = '';\n        currentProperty = elem.getFootageData();\n        return searchProperty;\n      }\n\n      function searchProperty(value) {\n        if (currentProperty[value]) {\n          currentPropertyName = value;\n          currentProperty = currentProperty[value];\n\n          if (_typeof(currentProperty) === 'object') {\n            return searchProperty;\n          }\n\n          return currentProperty;\n        }\n\n        var propertyNameIndex = value.indexOf(currentPropertyName);\n\n        if (propertyNameIndex !== -1) {\n          var index = parseInt(value.substr(propertyNameIndex + currentPropertyName.length), 10);\n          currentProperty = currentProperty[index];\n\n          if (_typeof(currentProperty) === 'object') {\n            return searchProperty;\n          }\n\n          return currentProperty;\n        }\n\n        return '';\n      }\n\n      return init;\n    };\n\n    var dataInterfaceFactory = function dataInterfaceFactory(elem) {\n      function interfaceFunction(value) {\n        if (value === 'Outline') {\n          return interfaceFunction.outlineInterface();\n        }\n\n        return null;\n      }\n\n      interfaceFunction._name = 'Outline';\n      interfaceFunction.outlineInterface = outlineInterfaceFactory(elem);\n      return interfaceFunction;\n    };\n\n    return function (elem) {\n      function _interfaceFunction(value) {\n        if (value === 'Data') {\n          return _interfaceFunction.dataInterface;\n        }\n\n        return null;\n      }\n\n      _interfaceFunction._name = 'Data';\n      _interfaceFunction.dataInterface = dataInterfaceFactory(elem);\n      return _interfaceFunction;\n    };\n  }();\n\n  var interfaces = {\n    layer: LayerExpressionInterface,\n    effects: EffectsExpressionInterface,\n    comp: CompExpressionInterface,\n    shape: ShapeExpressionInterface,\n    text: TextExpressionInterface,\n    footage: FootageInterface\n  };\n\n  function getInterface(type) {\n    return interfaces[type] || null;\n  }\n\n  var expressionHelpers = function () {\n    function searchExpressions(elem, data, prop) {\n      if (data.x) {\n        prop.k = true;\n        prop.x = true;\n        prop.initiateExpression = ExpressionManager.initiateExpression;\n        prop.effectsSequence.push(prop.initiateExpression(elem, data, prop).bind(prop));\n      }\n    }\n\n    function getValueAtTime(frameNum) {\n      frameNum *= this.elem.globalData.frameRate;\n      frameNum -= this.offsetTime;\n\n      if (frameNum !== this._cachingAtTime.lastFrame) {\n        this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;\n        this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);\n        this._cachingAtTime.lastFrame = frameNum;\n      }\n\n      return this._cachingAtTime.value;\n    }\n\n    function getSpeedAtTime(frameNum) {\n      var delta = -0.01;\n      var v1 = this.getValueAtTime(frameNum);\n      var v2 = this.getValueAtTime(frameNum + delta);\n      var speed = 0;\n\n      if (v1.length) {\n        var i;\n\n        for (i = 0; i < v1.length; i += 1) {\n          speed += Math.pow(v2[i] - v1[i], 2);\n        }\n\n        speed = Math.sqrt(speed) * 100;\n      } else {\n        speed = 0;\n      }\n\n      return speed;\n    }\n\n    function getVelocityAtTime(frameNum) {\n      if (this.vel !== undefined) {\n        return this.vel;\n      }\n\n      var delta = -0.001; // frameNum += this.elem.data.st;\n\n      var v1 = this.getValueAtTime(frameNum);\n      var v2 = this.getValueAtTime(frameNum + delta);\n      var velocity;\n\n      if (v1.length) {\n        velocity = createTypedArray('float32', v1.length);\n        var i;\n\n        for (i = 0; i < v1.length; i += 1) {\n          // removing frameRate\n          // if needed, don't add it here\n          // velocity[i] = this.elem.globalData.frameRate*((v2[i] - v1[i])/delta);\n          velocity[i] = (v2[i] - v1[i]) / delta;\n        }\n      } else {\n        velocity = (v2 - v1) / delta;\n      }\n\n      return velocity;\n    }\n\n    function getStaticValueAtTime() {\n      return this.pv;\n    }\n\n    function setGroupProperty(propertyGroup) {\n      this.propertyGroup = propertyGroup;\n    }\n\n    return {\n      searchExpressions: searchExpressions,\n      getSpeedAtTime: getSpeedAtTime,\n      getVelocityAtTime: getVelocityAtTime,\n      getValueAtTime: getValueAtTime,\n      getStaticValueAtTime: getStaticValueAtTime,\n      setGroupProperty: setGroupProperty\n    };\n  }();\n\n  function addPropertyDecorator() {\n    function loopOut(type, duration, durationFlag) {\n      if (!this.k || !this.keyframes) {\n        return this.pv;\n      }\n\n      type = type ? type.toLowerCase() : '';\n      var currentFrame = this.comp.renderedFrame;\n      var keyframes = this.keyframes;\n      var lastKeyFrame = keyframes[keyframes.length - 1].t;\n\n      if (currentFrame <= lastKeyFrame) {\n        return this.pv;\n      }\n\n      var cycleDuration;\n      var firstKeyFrame;\n\n      if (!durationFlag) {\n        if (!duration || duration > keyframes.length - 1) {\n          duration = keyframes.length - 1;\n        }\n\n        firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;\n        cycleDuration = lastKeyFrame - firstKeyFrame;\n      } else {\n        if (!duration) {\n          cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip);\n        } else {\n          cycleDuration = Math.abs(lastKeyFrame - this.elem.comp.globalData.frameRate * duration);\n        }\n\n        firstKeyFrame = lastKeyFrame - cycleDuration;\n      }\n\n      var i;\n      var len;\n      var ret;\n\n      if (type === 'pingpong') {\n        var iterations = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);\n\n        if (iterations % 2 !== 0) {\n          return this.getValueAtTime((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line\n        }\n      } else if (type === 'offset') {\n        var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);\n        var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);\n        var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line\n\n        var repeats = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);\n\n        if (this.pv.length) {\n          ret = new Array(initV.length);\n          len = ret.length;\n\n          for (i = 0; i < len; i += 1) {\n            ret[i] = (endV[i] - initV[i]) * repeats + current[i];\n          }\n\n          return ret;\n        }\n\n        return (endV - initV) * repeats + current;\n      } else if (type === 'continue') {\n        var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);\n        var nextLastValue = this.getValueAtTime((lastKeyFrame - 0.001) / this.comp.globalData.frameRate, 0);\n\n        if (this.pv.length) {\n          ret = new Array(lastValue.length);\n          len = ret.length;\n\n          for (i = 0; i < len; i += 1) {\n            ret[i] = lastValue[i] + (lastValue[i] - nextLastValue[i]) * ((currentFrame - lastKeyFrame) / this.comp.globalData.frameRate) / 0.0005; // eslint-disable-line\n          }\n\n          return ret;\n        }\n\n        return lastValue + (lastValue - nextLastValue) * ((currentFrame - lastKeyFrame) / 0.001);\n      }\n\n      return this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line\n    }\n\n    function loopIn(type, duration, durationFlag) {\n      if (!this.k) {\n        return this.pv;\n      }\n\n      type = type ? type.toLowerCase() : '';\n      var currentFrame = this.comp.renderedFrame;\n      var keyframes = this.keyframes;\n      var firstKeyFrame = keyframes[0].t;\n\n      if (currentFrame >= firstKeyFrame) {\n        return this.pv;\n      }\n\n      var cycleDuration;\n      var lastKeyFrame;\n\n      if (!durationFlag) {\n        if (!duration || duration > keyframes.length - 1) {\n          duration = keyframes.length - 1;\n        }\n\n        lastKeyFrame = keyframes[duration].t;\n        cycleDuration = lastKeyFrame - firstKeyFrame;\n      } else {\n        if (!duration) {\n          cycleDuration = Math.max(0, this.elem.data.op - firstKeyFrame);\n        } else {\n          cycleDuration = Math.abs(this.elem.comp.globalData.frameRate * duration);\n        }\n\n        lastKeyFrame = firstKeyFrame + cycleDuration;\n      }\n\n      var i;\n      var len;\n      var ret;\n\n      if (type === 'pingpong') {\n        var iterations = Math.floor((firstKeyFrame - currentFrame) / cycleDuration);\n\n        if (iterations % 2 === 0) {\n          return this.getValueAtTime(((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line\n        }\n      } else if (type === 'offset') {\n        var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);\n        var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);\n        var current = this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);\n        var repeats = Math.floor((firstKeyFrame - currentFrame) / cycleDuration) + 1;\n\n        if (this.pv.length) {\n          ret = new Array(initV.length);\n          len = ret.length;\n\n          for (i = 0; i < len; i += 1) {\n            ret[i] = current[i] - (endV[i] - initV[i]) * repeats;\n          }\n\n          return ret;\n        }\n\n        return current - (endV - initV) * repeats;\n      } else if (type === 'continue') {\n        var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);\n        var nextFirstValue = this.getValueAtTime((firstKeyFrame + 0.001) / this.comp.globalData.frameRate, 0);\n\n        if (this.pv.length) {\n          ret = new Array(firstValue.length);\n          len = ret.length;\n\n          for (i = 0; i < len; i += 1) {\n            ret[i] = firstValue[i] + (firstValue[i] - nextFirstValue[i]) * (firstKeyFrame - currentFrame) / 0.001;\n          }\n\n          return ret;\n        }\n\n        return firstValue + (firstValue - nextFirstValue) * (firstKeyFrame - currentFrame) / 0.001;\n      }\n\n      return this.getValueAtTime((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0); // eslint-disable-line\n    }\n\n    function smooth(width, samples) {\n      if (!this.k) {\n        return this.pv;\n      }\n\n      width = (width || 0.4) * 0.5;\n      samples = Math.floor(samples || 5);\n\n      if (samples <= 1) {\n        return this.pv;\n      }\n\n      var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;\n      var initFrame = currentTime - width;\n      var endFrame = currentTime + width;\n      var sampleFrequency = samples > 1 ? (endFrame - initFrame) / (samples - 1) : 1;\n      var i = 0;\n      var j = 0;\n      var value;\n\n      if (this.pv.length) {\n        value = createTypedArray('float32', this.pv.length);\n      } else {\n        value = 0;\n      }\n\n      var sampleValue;\n\n      while (i < samples) {\n        sampleValue = this.getValueAtTime(initFrame + i * sampleFrequency);\n\n        if (this.pv.length) {\n          for (j = 0; j < this.pv.length; j += 1) {\n            value[j] += sampleValue[j];\n          }\n        } else {\n          value += sampleValue;\n        }\n\n        i += 1;\n      }\n\n      if (this.pv.length) {\n        for (j = 0; j < this.pv.length; j += 1) {\n          value[j] /= samples;\n        }\n      } else {\n        value /= samples;\n      }\n\n      return value;\n    }\n\n    function getTransformValueAtTime(time) {\n      if (!this._transformCachingAtTime) {\n        this._transformCachingAtTime = {\n          v: new Matrix()\n        };\n      } /// /\n\n\n      var matrix = this._transformCachingAtTime.v;\n      matrix.cloneFromProps(this.pre.props);\n\n      if (this.appliedTransformations < 1) {\n        var anchor = this.a.getValueAtTime(time);\n        matrix.translate(-anchor[0] * this.a.mult, -anchor[1] * this.a.mult, anchor[2] * this.a.mult);\n      }\n\n      if (this.appliedTransformations < 2) {\n        var scale = this.s.getValueAtTime(time);\n        matrix.scale(scale[0] * this.s.mult, scale[1] * this.s.mult, scale[2] * this.s.mult);\n      }\n\n      if (this.sk && this.appliedTransformations < 3) {\n        var skew = this.sk.getValueAtTime(time);\n        var skewAxis = this.sa.getValueAtTime(time);\n        matrix.skewFromAxis(-skew * this.sk.mult, skewAxis * this.sa.mult);\n      }\n\n      if (this.r && this.appliedTransformations < 4) {\n        var rotation = this.r.getValueAtTime(time);\n        matrix.rotate(-rotation * this.r.mult);\n      } else if (!this.r && this.appliedTransformations < 4) {\n        var rotationZ = this.rz.getValueAtTime(time);\n        var rotationY = this.ry.getValueAtTime(time);\n        var rotationX = this.rx.getValueAtTime(time);\n        var orientation = this.or.getValueAtTime(time);\n        matrix.rotateZ(-rotationZ * this.rz.mult).rotateY(rotationY * this.ry.mult).rotateX(rotationX * this.rx.mult).rotateZ(-orientation[2] * this.or.mult).rotateY(orientation[1] * this.or.mult).rotateX(orientation[0] * this.or.mult);\n      }\n\n      if (this.data.p && this.data.p.s) {\n        var positionX = this.px.getValueAtTime(time);\n        var positionY = this.py.getValueAtTime(time);\n\n        if (this.data.p.z) {\n          var positionZ = this.pz.getValueAtTime(time);\n          matrix.translate(positionX * this.px.mult, positionY * this.py.mult, -positionZ * this.pz.mult);\n        } else {\n          matrix.translate(positionX * this.px.mult, positionY * this.py.mult, 0);\n        }\n      } else {\n        var position = this.p.getValueAtTime(time);\n        matrix.translate(position[0] * this.p.mult, position[1] * this.p.mult, -position[2] * this.p.mult);\n      }\n\n      return matrix; /// /\n    }\n\n    function getTransformStaticValueAtTime() {\n      return this.v.clone(new Matrix());\n    }\n\n    var getTransformProperty = TransformPropertyFactory.getTransformProperty;\n\n    TransformPropertyFactory.getTransformProperty = function (elem, data, container) {\n      var prop = getTransformProperty(elem, data, container);\n\n      if (prop.dynamicProperties.length) {\n        prop.getValueAtTime = getTransformValueAtTime.bind(prop);\n      } else {\n        prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);\n      }\n\n      prop.setGroupProperty = expressionHelpers.setGroupProperty;\n      return prop;\n    };\n\n    var propertyGetProp = PropertyFactory.getProp;\n\n    PropertyFactory.getProp = function (elem, data, type, mult, container) {\n      var prop = propertyGetProp(elem, data, type, mult, container); // prop.getVelocityAtTime = getVelocityAtTime;\n      // prop.loopOut = loopOut;\n      // prop.loopIn = loopIn;\n\n      if (prop.kf) {\n        prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop);\n      } else {\n        prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);\n      }\n\n      prop.setGroupProperty = expressionHelpers.setGroupProperty;\n      prop.loopOut = loopOut;\n      prop.loopIn = loopIn;\n      prop.smooth = smooth;\n      prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);\n      prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);\n      prop.numKeys = data.a === 1 ? data.k.length : 0;\n      prop.propertyIndex = data.ix;\n      var value = 0;\n\n      if (type !== 0) {\n        value = createTypedArray('float32', data.a === 1 ? data.k[0].s.length : data.k.length);\n      }\n\n      prop._cachingAtTime = {\n        lastFrame: initialDefaultFrame,\n        lastIndex: 0,\n        value: value\n      };\n      expressionHelpers.searchExpressions(elem, data, prop);\n\n      if (prop.k) {\n        container.addDynamicProperty(prop);\n      }\n\n      return prop;\n    };\n\n    function getShapeValueAtTime(frameNum) {\n      // For now this caching object is created only when needed instead of creating it when the shape is initialized.\n      if (!this._cachingAtTime) {\n        this._cachingAtTime = {\n          shapeValue: shapePool.clone(this.pv),\n          lastIndex: 0,\n          lastTime: initialDefaultFrame\n        };\n      }\n\n      frameNum *= this.elem.globalData.frameRate;\n      frameNum -= this.offsetTime;\n\n      if (frameNum !== this._cachingAtTime.lastTime) {\n        this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;\n        this._cachingAtTime.lastTime = frameNum;\n        this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);\n      }\n\n      return this._cachingAtTime.shapeValue;\n    }\n\n    var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();\n    var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();\n\n    function ShapeExpressions() {}\n\n    ShapeExpressions.prototype = {\n      vertices: function vertices(prop, time) {\n        if (this.k) {\n          this.getValue();\n        }\n\n        var shapePath = this.v;\n\n        if (time !== undefined) {\n          shapePath = this.getValueAtTime(time, 0);\n        }\n\n        var i;\n        var len = shapePath._length;\n        var vertices = shapePath[prop];\n        var points = shapePath.v;\n        var arr = createSizedArray(len);\n\n        for (i = 0; i < len; i += 1) {\n          if (prop === 'i' || prop === 'o') {\n            arr[i] = [vertices[i][0] - points[i][0], vertices[i][1] - points[i][1]];\n          } else {\n            arr[i] = [vertices[i][0], vertices[i][1]];\n          }\n        }\n\n        return arr;\n      },\n      points: function points(time) {\n        return this.vertices('v', time);\n      },\n      inTangents: function inTangents(time) {\n        return this.vertices('i', time);\n      },\n      outTangents: function outTangents(time) {\n        return this.vertices('o', time);\n      },\n      isClosed: function isClosed() {\n        return this.v.c;\n      },\n      pointOnPath: function pointOnPath(perc, time) {\n        var shapePath = this.v;\n\n        if (time !== undefined) {\n          shapePath = this.getValueAtTime(time, 0);\n        }\n\n        if (!this._segmentsLength) {\n          this._segmentsLength = bez.getSegmentsLength(shapePath);\n        }\n\n        var segmentsLength = this._segmentsLength;\n        var lengths = segmentsLength.lengths;\n        var lengthPos = segmentsLength.totalLength * perc;\n        var i = 0;\n        var len = lengths.length;\n        var accumulatedLength = 0;\n        var pt;\n\n        while (i < len) {\n          if (accumulatedLength + lengths[i].addedLength > lengthPos) {\n            var initIndex = i;\n            var endIndex = shapePath.c && i === len - 1 ? 0 : i + 1;\n            var segmentPerc = (lengthPos - accumulatedLength) / lengths[i].addedLength;\n            pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i]);\n            break;\n          } else {\n            accumulatedLength += lengths[i].addedLength;\n          }\n\n          i += 1;\n        }\n\n        if (!pt) {\n          pt = shapePath.c ? [shapePath.v[0][0], shapePath.v[0][1]] : [shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1]];\n        }\n\n        return pt;\n      },\n      vectorOnPath: function vectorOnPath(perc, time, vectorType) {\n        // perc doesn't use triple equality because it can be a Number object as well as a primitive.\n        if (perc == 1) {\n          // eslint-disable-line eqeqeq\n          perc = this.v.c;\n        } else if (perc == 0) {\n          // eslint-disable-line eqeqeq\n          perc = 0.999;\n        }\n\n        var pt1 = this.pointOnPath(perc, time);\n        var pt2 = this.pointOnPath(perc + 0.001, time);\n        var xLength = pt2[0] - pt1[0];\n        var yLength = pt2[1] - pt1[1];\n        var magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2));\n\n        if (magnitude === 0) {\n          return [0, 0];\n        }\n\n        var unitVector = vectorType === 'tangent' ? [xLength / magnitude, yLength / magnitude] : [-yLength / magnitude, xLength / magnitude];\n        return unitVector;\n      },\n      tangentOnPath: function tangentOnPath(perc, time) {\n        return this.vectorOnPath(perc, time, 'tangent');\n      },\n      normalOnPath: function normalOnPath(perc, time) {\n        return this.vectorOnPath(perc, time, 'normal');\n      },\n      setGroupProperty: expressionHelpers.setGroupProperty,\n      getValueAtTime: expressionHelpers.getStaticValueAtTime\n    };\n    extendPrototype([ShapeExpressions], ShapePropertyConstructorFunction);\n    extendPrototype([ShapeExpressions], KeyframedShapePropertyConstructorFunction);\n    KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;\n    KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;\n    var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;\n\n    ShapePropertyFactory.getShapeProp = function (elem, data, type, arr, trims) {\n      var prop = propertyGetShapeProp(elem, data, type, arr, trims);\n      prop.propertyIndex = data.ix;\n      prop.lock = false;\n\n      if (type === 3) {\n        expressionHelpers.searchExpressions(elem, data.pt, prop);\n      } else if (type === 4) {\n        expressionHelpers.searchExpressions(elem, data.ks, prop);\n      }\n\n      if (prop.k) {\n        elem.addDynamicProperty(prop);\n      }\n\n      return prop;\n    };\n  }\n\n  function initialize$1() {\n    addPropertyDecorator();\n  }\n\n  function addDecorator() {\n    function searchExpressions() {\n      if (this.data.d.x) {\n        this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this);\n        this.addEffect(this.getExpressionValue.bind(this));\n        return true;\n      }\n\n      return null;\n    }\n\n    TextProperty.prototype.getExpressionValue = function (currentValue, text) {\n      var newValue = this.calculateExpression(text);\n\n      if (currentValue.t !== newValue) {\n        var newData = {};\n        this.copyData(newData, currentValue);\n        newData.t = newValue.toString();\n        newData.__complete = false;\n        return newData;\n      }\n\n      return currentValue;\n    };\n\n    TextProperty.prototype.searchProperty = function () {\n      var isKeyframed = this.searchKeyframes();\n      var hasExpressions = this.searchExpressions();\n      this.kf = isKeyframed || hasExpressions;\n      return this.kf;\n    };\n\n    TextProperty.prototype.searchExpressions = searchExpressions;\n  }\n\n  function initialize() {\n    addDecorator();\n  }\n\n  function SVGComposableEffect() {}\n\n  SVGComposableEffect.prototype = {\n    createMergeNode: function createMergeNode(resultId, ins) {\n      var feMerge = createNS('feMerge');\n      feMerge.setAttribute('result', resultId);\n      var feMergeNode;\n      var i;\n\n      for (i = 0; i < ins.length; i += 1) {\n        feMergeNode = createNS('feMergeNode');\n        feMergeNode.setAttribute('in', ins[i]);\n        feMerge.appendChild(feMergeNode);\n        feMerge.appendChild(feMergeNode);\n      }\n\n      return feMerge;\n    }\n  };\n\n  var linearFilterValue = '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0';\n\n  function SVGTintFilter(filter, filterManager, elem, id, source) {\n    this.filterManager = filterManager;\n    var feColorMatrix = createNS('feColorMatrix');\n    feColorMatrix.setAttribute('type', 'matrix');\n    feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');\n    feColorMatrix.setAttribute('values', linearFilterValue + ' 1 0');\n    this.linearFilter = feColorMatrix;\n    feColorMatrix.setAttribute('result', id + '_tint_1');\n    filter.appendChild(feColorMatrix);\n    feColorMatrix = createNS('feColorMatrix');\n    feColorMatrix.setAttribute('type', 'matrix');\n    feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');\n    feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');\n    feColorMatrix.setAttribute('result', id + '_tint_2');\n    filter.appendChild(feColorMatrix);\n    this.matrixFilter = feColorMatrix;\n    var feMerge = this.createMergeNode(id, [source, id + '_tint_1', id + '_tint_2']);\n    filter.appendChild(feMerge);\n  }\n\n  extendPrototype([SVGComposableEffect], SVGTintFilter);\n\n  SVGTintFilter.prototype.renderFrame = function (forceRender) {\n    if (forceRender || this.filterManager._mdf) {\n      var colorBlack = this.filterManager.effectElements[0].p.v;\n      var colorWhite = this.filterManager.effectElements[1].p.v;\n      var opacity = this.filterManager.effectElements[2].p.v / 100;\n      this.linearFilter.setAttribute('values', linearFilterValue + ' ' + opacity + ' 0');\n      this.matrixFilter.setAttribute('values', colorWhite[0] - colorBlack[0] + ' 0 0 0 ' + colorBlack[0] + ' ' + (colorWhite[1] - colorBlack[1]) + ' 0 0 0 ' + colorBlack[1] + ' ' + (colorWhite[2] - colorBlack[2]) + ' 0 0 0 ' + colorBlack[2] + ' 0 0 0 1 0');\n    }\n  };\n\n  function SVGFillFilter(filter, filterManager, elem, id) {\n    this.filterManager = filterManager;\n    var feColorMatrix = createNS('feColorMatrix');\n    feColorMatrix.setAttribute('type', 'matrix');\n    feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');\n    feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');\n    feColorMatrix.setAttribute('result', id);\n    filter.appendChild(feColorMatrix);\n    this.matrixFilter = feColorMatrix;\n  }\n\n  SVGFillFilter.prototype.renderFrame = function (forceRender) {\n    if (forceRender || this.filterManager._mdf) {\n      var color = this.filterManager.effectElements[2].p.v;\n      var opacity = this.filterManager.effectElements[6].p.v;\n      this.matrixFilter.setAttribute('values', '0 0 0 0 ' + color[0] + ' 0 0 0 0 ' + color[1] + ' 0 0 0 0 ' + color[2] + ' 0 0 0 ' + opacity + ' 0');\n    }\n  };\n\n  function SVGStrokeEffect(fil, filterManager, elem) {\n    this.initialized = false;\n    this.filterManager = filterManager;\n    this.elem = elem;\n    this.paths = [];\n  }\n\n  SVGStrokeEffect.prototype.initialize = function () {\n    var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;\n    var path;\n    var groupPath;\n    var i;\n    var len;\n\n    if (this.filterManager.effectElements[1].p.v === 1) {\n      len = this.elem.maskManager.masksProperties.length;\n      i = 0;\n    } else {\n      i = this.filterManager.effectElements[0].p.v - 1;\n      len = i + 1;\n    }\n\n    groupPath = createNS('g');\n    groupPath.setAttribute('fill', 'none');\n    groupPath.setAttribute('stroke-linecap', 'round');\n    groupPath.setAttribute('stroke-dashoffset', 1);\n\n    for (i; i < len; i += 1) {\n      path = createNS('path');\n      groupPath.appendChild(path);\n      this.paths.push({\n        p: path,\n        m: i\n      });\n    }\n\n    if (this.filterManager.effectElements[10].p.v === 3) {\n      var mask = createNS('mask');\n      var id = createElementID();\n      mask.setAttribute('id', id);\n      mask.setAttribute('mask-type', 'alpha');\n      mask.appendChild(groupPath);\n      this.elem.globalData.defs.appendChild(mask);\n      var g = createNS('g');\n      g.setAttribute('mask', 'url(' + getLocationHref() + '#' + id + ')');\n\n      while (elemChildren[0]) {\n        g.appendChild(elemChildren[0]);\n      }\n\n      this.elem.layerElement.appendChild(g);\n      this.masker = mask;\n      groupPath.setAttribute('stroke', '#fff');\n    } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {\n      if (this.filterManager.effectElements[10].p.v === 2) {\n        elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;\n\n        while (elemChildren.length) {\n          this.elem.layerElement.removeChild(elemChildren[0]);\n        }\n      }\n\n      this.elem.layerElement.appendChild(groupPath);\n      this.elem.layerElement.removeAttribute('mask');\n      groupPath.setAttribute('stroke', '#fff');\n    }\n\n    this.initialized = true;\n    this.pathMasker = groupPath;\n  };\n\n  SVGStrokeEffect.prototype.renderFrame = function (forceRender) {\n    if (!this.initialized) {\n      this.initialize();\n    }\n\n    var i;\n    var len = this.paths.length;\n    var mask;\n    var path;\n\n    for (i = 0; i < len; i += 1) {\n      if (this.paths[i].m !== -1) {\n        mask = this.elem.maskManager.viewData[this.paths[i].m];\n        path = this.paths[i].p;\n\n        if (forceRender || this.filterManager._mdf || mask.prop._mdf) {\n          path.setAttribute('d', mask.lastPath);\n        }\n\n        if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask.prop._mdf) {\n          var dasharrayValue;\n\n          if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {\n            var s = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;\n            var e = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;\n            var l = path.getTotalLength();\n            dasharrayValue = '0 0 0 ' + l * s + ' ';\n            var lineLength = l * (e - s);\n            var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;\n            var units = Math.floor(lineLength / segment);\n            var j;\n\n            for (j = 0; j < units; j += 1) {\n              dasharrayValue += '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + ' ';\n            }\n\n            dasharrayValue += '0 ' + l * 10 + ' 0 0';\n          } else {\n            dasharrayValue = '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;\n          }\n\n          path.setAttribute('stroke-dasharray', dasharrayValue);\n        }\n      }\n    }\n\n    if (forceRender || this.filterManager.effectElements[4].p._mdf) {\n      this.pathMasker.setAttribute('stroke-width', this.filterManager.effectElements[4].p.v * 2);\n    }\n\n    if (forceRender || this.filterManager.effectElements[6].p._mdf) {\n      this.pathMasker.setAttribute('opacity', this.filterManager.effectElements[6].p.v);\n    }\n\n    if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {\n      if (forceRender || this.filterManager.effectElements[3].p._mdf) {\n        var color = this.filterManager.effectElements[3].p.v;\n        this.pathMasker.setAttribute('stroke', 'rgb(' + bmFloor(color[0] * 255) + ',' + bmFloor(color[1] * 255) + ',' + bmFloor(color[2] * 255) + ')');\n      }\n    }\n  };\n\n  function SVGTritoneFilter(filter, filterManager, elem, id) {\n    this.filterManager = filterManager;\n    var feColorMatrix = createNS('feColorMatrix');\n    feColorMatrix.setAttribute('type', 'matrix');\n    feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');\n    feColorMatrix.setAttribute('values', '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');\n    filter.appendChild(feColorMatrix);\n    var feComponentTransfer = createNS('feComponentTransfer');\n    feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');\n    feComponentTransfer.setAttribute('result', id);\n    this.matrixFilter = feComponentTransfer;\n    var feFuncR = createNS('feFuncR');\n    feFuncR.setAttribute('type', 'table');\n    feComponentTransfer.appendChild(feFuncR);\n    this.feFuncR = feFuncR;\n    var feFuncG = createNS('feFuncG');\n    feFuncG.setAttribute('type', 'table');\n    feComponentTransfer.appendChild(feFuncG);\n    this.feFuncG = feFuncG;\n    var feFuncB = createNS('feFuncB');\n    feFuncB.setAttribute('type', 'table');\n    feComponentTransfer.appendChild(feFuncB);\n    this.feFuncB = feFuncB;\n    filter.appendChild(feComponentTransfer);\n  }\n\n  SVGTritoneFilter.prototype.renderFrame = function (forceRender) {\n    if (forceRender || this.filterManager._mdf) {\n      var color1 = this.filterManager.effectElements[0].p.v;\n      var color2 = this.filterManager.effectElements[1].p.v;\n      var color3 = this.filterManager.effectElements[2].p.v;\n      var tableR = color3[0] + ' ' + color2[0] + ' ' + color1[0];\n      var tableG = color3[1] + ' ' + color2[1] + ' ' + color1[1];\n      var tableB = color3[2] + ' ' + color2[2] + ' ' + color1[2];\n      this.feFuncR.setAttribute('tableValues', tableR);\n      this.feFuncG.setAttribute('tableValues', tableG);\n      this.feFuncB.setAttribute('tableValues', tableB);\n    }\n  };\n\n  function SVGProLevelsFilter(filter, filterManager, elem, id) {\n    this.filterManager = filterManager;\n    var effectElements = this.filterManager.effectElements;\n    var feComponentTransfer = createNS('feComponentTransfer'); // Red\n\n    if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) {\n      this.feFuncR = this.createFeFunc('feFuncR', feComponentTransfer);\n    } // Green\n\n\n    if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) {\n      this.feFuncG = this.createFeFunc('feFuncG', feComponentTransfer);\n    } // Blue\n\n\n    if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) {\n      this.feFuncB = this.createFeFunc('feFuncB', feComponentTransfer);\n    } // Alpha\n\n\n    if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) {\n      this.feFuncA = this.createFeFunc('feFuncA', feComponentTransfer);\n    } // RGB\n\n\n    if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {\n      feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');\n      filter.appendChild(feComponentTransfer);\n    }\n\n    if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {\n      feComponentTransfer = createNS('feComponentTransfer');\n      feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');\n      feComponentTransfer.setAttribute('result', id);\n      filter.appendChild(feComponentTransfer);\n      this.feFuncRComposed = this.createFeFunc('feFuncR', feComponentTransfer);\n      this.feFuncGComposed = this.createFeFunc('feFuncG', feComponentTransfer);\n      this.feFuncBComposed = this.createFeFunc('feFuncB', feComponentTransfer);\n    }\n  }\n\n  SVGProLevelsFilter.prototype.createFeFunc = function (type, feComponentTransfer) {\n    var feFunc = createNS(type);\n    feFunc.setAttribute('type', 'table');\n    feComponentTransfer.appendChild(feFunc);\n    return feFunc;\n  };\n\n  SVGProLevelsFilter.prototype.getTableValue = function (inputBlack, inputWhite, gamma, outputBlack, outputWhite) {\n    var cnt = 0;\n    var segments = 256;\n    var perc;\n    var min = Math.min(inputBlack, inputWhite);\n    var max = Math.max(inputBlack, inputWhite);\n    var table = Array.call(null, {\n      length: segments\n    });\n    var colorValue;\n    var pos = 0;\n    var outputDelta = outputWhite - outputBlack;\n    var inputDelta = inputWhite - inputBlack;\n\n    while (cnt <= 256) {\n      perc = cnt / 256;\n\n      if (perc <= min) {\n        colorValue = inputDelta < 0 ? outputWhite : outputBlack;\n      } else if (perc >= max) {\n        colorValue = inputDelta < 0 ? outputBlack : outputWhite;\n      } else {\n        colorValue = outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma);\n      }\n\n      table[pos] = colorValue;\n      pos += 1;\n      cnt += 256 / (segments - 1);\n    }\n\n    return table.join(' ');\n  };\n\n  SVGProLevelsFilter.prototype.renderFrame = function (forceRender) {\n    if (forceRender || this.filterManager._mdf) {\n      var val;\n      var effectElements = this.filterManager.effectElements;\n\n      if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {\n        val = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);\n        this.feFuncRComposed.setAttribute('tableValues', val);\n        this.feFuncGComposed.setAttribute('tableValues', val);\n        this.feFuncBComposed.setAttribute('tableValues', val);\n      }\n\n      if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {\n        val = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);\n        this.feFuncR.setAttribute('tableValues', val);\n      }\n\n      if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {\n        val = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);\n        this.feFuncG.setAttribute('tableValues', val);\n      }\n\n      if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {\n        val = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);\n        this.feFuncB.setAttribute('tableValues', val);\n      }\n\n      if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {\n        val = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);\n        this.feFuncA.setAttribute('tableValues', val);\n      }\n    }\n  };\n\n  function SVGDropShadowEffect(filter, filterManager, elem, id, source) {\n    var globalFilterSize = filterManager.container.globalData.renderConfig.filterSize;\n    var filterSize = filterManager.data.fs || globalFilterSize;\n    filter.setAttribute('x', filterSize.x || globalFilterSize.x);\n    filter.setAttribute('y', filterSize.y || globalFilterSize.y);\n    filter.setAttribute('width', filterSize.width || globalFilterSize.width);\n    filter.setAttribute('height', filterSize.height || globalFilterSize.height);\n    this.filterManager = filterManager;\n    var feGaussianBlur = createNS('feGaussianBlur');\n    feGaussianBlur.setAttribute('in', 'SourceAlpha');\n    feGaussianBlur.setAttribute('result', id + '_drop_shadow_1');\n    feGaussianBlur.setAttribute('stdDeviation', '0');\n    this.feGaussianBlur = feGaussianBlur;\n    filter.appendChild(feGaussianBlur);\n    var feOffset = createNS('feOffset');\n    feOffset.setAttribute('dx', '25');\n    feOffset.setAttribute('dy', '0');\n    feOffset.setAttribute('in', id + '_drop_shadow_1');\n    feOffset.setAttribute('result', id + '_drop_shadow_2');\n    this.feOffset = feOffset;\n    filter.appendChild(feOffset);\n    var feFlood = createNS('feFlood');\n    feFlood.setAttribute('flood-color', '#00ff00');\n    feFlood.setAttribute('flood-opacity', '1');\n    feFlood.setAttribute('result', id + '_drop_shadow_3');\n    this.feFlood = feFlood;\n    filter.appendChild(feFlood);\n    var feComposite = createNS('feComposite');\n    feComposite.setAttribute('in', id + '_drop_shadow_3');\n    feComposite.setAttribute('in2', id + '_drop_shadow_2');\n    feComposite.setAttribute('operator', 'in');\n    feComposite.setAttribute('result', id + '_drop_shadow_4');\n    filter.appendChild(feComposite);\n    var feMerge = this.createMergeNode(id, [id + '_drop_shadow_4', source]);\n    filter.appendChild(feMerge); //\n  }\n\n  extendPrototype([SVGComposableEffect], SVGDropShadowEffect);\n\n  SVGDropShadowEffect.prototype.renderFrame = function (forceRender) {\n    if (forceRender || this.filterManager._mdf) {\n      if (forceRender || this.filterManager.effectElements[4].p._mdf) {\n        this.feGaussianBlur.setAttribute('stdDeviation', this.filterManager.effectElements[4].p.v / 4);\n      }\n\n      if (forceRender || this.filterManager.effectElements[0].p._mdf) {\n        var col = this.filterManager.effectElements[0].p.v;\n        this.feFlood.setAttribute('flood-color', rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));\n      }\n\n      if (forceRender || this.filterManager.effectElements[1].p._mdf) {\n        this.feFlood.setAttribute('flood-opacity', this.filterManager.effectElements[1].p.v / 255);\n      }\n\n      if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {\n        var distance = this.filterManager.effectElements[3].p.v;\n        var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;\n        var x = distance * Math.cos(angle);\n        var y = distance * Math.sin(angle);\n        this.feOffset.setAttribute('dx', x);\n        this.feOffset.setAttribute('dy', y);\n      }\n    }\n  };\n\n  var _svgMatteSymbols = [];\n\n  function SVGMatte3Effect(filterElem, filterManager, elem) {\n    this.initialized = false;\n    this.filterManager = filterManager;\n    this.filterElem = filterElem;\n    this.elem = elem;\n    elem.matteElement = createNS('g');\n    elem.matteElement.appendChild(elem.layerElement);\n    elem.matteElement.appendChild(elem.transformedElement);\n    elem.baseElement = elem.matteElement;\n  }\n\n  SVGMatte3Effect.prototype.findSymbol = function (mask) {\n    var i = 0;\n    var len = _svgMatteSymbols.length;\n\n    while (i < len) {\n      if (_svgMatteSymbols[i] === mask) {\n        return _svgMatteSymbols[i];\n      }\n\n      i += 1;\n    }\n\n    return null;\n  };\n\n  SVGMatte3Effect.prototype.replaceInParent = function (mask, symbolId) {\n    var parentNode = mask.layerElement.parentNode;\n\n    if (!parentNode) {\n      return;\n    }\n\n    var children = parentNode.children;\n    var i = 0;\n    var len = children.length;\n\n    while (i < len) {\n      if (children[i] === mask.layerElement) {\n        break;\n      }\n\n      i += 1;\n    }\n\n    var nextChild;\n\n    if (i <= len - 2) {\n      nextChild = children[i + 1];\n    }\n\n    var useElem = createNS('use');\n    useElem.setAttribute('href', '#' + symbolId);\n\n    if (nextChild) {\n      parentNode.insertBefore(useElem, nextChild);\n    } else {\n      parentNode.appendChild(useElem);\n    }\n  };\n\n  SVGMatte3Effect.prototype.setElementAsMask = function (elem, mask) {\n    if (!this.findSymbol(mask)) {\n      var symbolId = createElementID();\n      var masker = createNS('mask');\n      masker.setAttribute('id', mask.layerId);\n      masker.setAttribute('mask-type', 'alpha');\n\n      _svgMatteSymbols.push(mask);\n\n      var defs = elem.globalData.defs;\n      defs.appendChild(masker);\n      var symbol = createNS('symbol');\n      symbol.setAttribute('id', symbolId);\n      this.replaceInParent(mask, symbolId);\n      symbol.appendChild(mask.layerElement);\n      defs.appendChild(symbol);\n      var useElem = createNS('use');\n      useElem.setAttribute('href', '#' + symbolId);\n      masker.appendChild(useElem);\n      mask.data.hd = false;\n      mask.show();\n    }\n\n    elem.setMatte(mask.layerId);\n  };\n\n  SVGMatte3Effect.prototype.initialize = function () {\n    var ind = this.filterManager.effectElements[0].p.v;\n    var elements = this.elem.comp.elements;\n    var i = 0;\n    var len = elements.length;\n\n    while (i < len) {\n      if (elements[i] && elements[i].data.ind === ind) {\n        this.setElementAsMask(this.elem, elements[i]);\n      }\n\n      i += 1;\n    }\n\n    this.initialized = true;\n  };\n\n  SVGMatte3Effect.prototype.renderFrame = function () {\n    if (!this.initialized) {\n      this.initialize();\n    }\n  };\n\n  function SVGGaussianBlurEffect(filter, filterManager, elem, id) {\n    // Outset the filter region by 100% on all sides to accommodate blur expansion.\n    filter.setAttribute('x', '-100%');\n    filter.setAttribute('y', '-100%');\n    filter.setAttribute('width', '300%');\n    filter.setAttribute('height', '300%');\n    this.filterManager = filterManager;\n    var feGaussianBlur = createNS('feGaussianBlur');\n    feGaussianBlur.setAttribute('result', id);\n    filter.appendChild(feGaussianBlur);\n    this.feGaussianBlur = feGaussianBlur;\n  }\n\n  SVGGaussianBlurEffect.prototype.renderFrame = function (forceRender) {\n    if (forceRender || this.filterManager._mdf) {\n      // Empirical value, matching AE's blur appearance.\n      var kBlurrinessToSigma = 0.3;\n      var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma; // Dimensions mapping:\n      //\n      //   1 -> horizontal & vertical\n      //   2 -> horizontal only\n      //   3 -> vertical only\n      //\n\n      var dimensions = this.filterManager.effectElements[1].p.v;\n      var sigmaX = dimensions == 3 ? 0 : sigma; // eslint-disable-line eqeqeq\n\n      var sigmaY = dimensions == 2 ? 0 : sigma; // eslint-disable-line eqeqeq\n\n      this.feGaussianBlur.setAttribute('stdDeviation', sigmaX + ' ' + sigmaY); // Repeat edges mapping:\n      //\n      //   0 -> off -> duplicate\n      //   1 -> on  -> wrap\n\n      var edgeMode = this.filterManager.effectElements[2].p.v == 1 ? 'wrap' : 'duplicate'; // eslint-disable-line eqeqeq\n\n      this.feGaussianBlur.setAttribute('edgeMode', edgeMode);\n    }\n  };\n\n  function TransformEffect() {}\n\n  TransformEffect.prototype.init = function (effectsManager) {\n    this.effectsManager = effectsManager;\n    this.type = effectTypes.TRANSFORM_EFFECT;\n    this.matrix = new Matrix();\n    this.opacity = -1;\n    this._mdf = false;\n    this._opMdf = false;\n  };\n\n  TransformEffect.prototype.renderFrame = function (forceFrame) {\n    this._opMdf = false;\n    this._mdf = false;\n\n    if (forceFrame || this.effectsManager._mdf) {\n      var effectElements = this.effectsManager.effectElements;\n      var anchor = effectElements[0].p.v;\n      var position = effectElements[1].p.v;\n      var isUniformScale = effectElements[2].p.v === 1;\n      var scaleHeight = effectElements[3].p.v;\n      var scaleWidth = isUniformScale ? scaleHeight : effectElements[4].p.v;\n      var skew = effectElements[5].p.v;\n      var skewAxis = effectElements[6].p.v;\n      var rotation = effectElements[7].p.v;\n      this.matrix.reset();\n      this.matrix.translate(-anchor[0], -anchor[1], anchor[2]);\n      this.matrix.scale(scaleWidth * 0.01, scaleHeight * 0.01, 1);\n      this.matrix.rotate(-rotation * degToRads);\n      this.matrix.skewFromAxis(-skew * degToRads, (skewAxis + 90) * degToRads);\n      this.matrix.translate(position[0], position[1], 0);\n      this._mdf = true;\n\n      if (this.opacity !== effectElements[8].p.v) {\n        this.opacity = effectElements[8].p.v;\n        this._opMdf = true;\n      }\n    }\n  };\n\n  function SVGTransformEffect(_, filterManager) {\n    this.init(filterManager);\n  }\n\n  extendPrototype([TransformEffect], SVGTransformEffect);\n\n  function CVTransformEffect(effectsManager) {\n    this.init(effectsManager);\n  }\n\n  extendPrototype([TransformEffect], CVTransformEffect);\n\n  registerRenderer('canvas', CanvasRenderer);\n  registerRenderer('html', HybridRenderer);\n  registerRenderer('svg', SVGRenderer); // Registering shape modifiers\n\n  ShapeModifiers.registerModifier('tm', TrimModifier);\n  ShapeModifiers.registerModifier('pb', PuckerAndBloatModifier);\n  ShapeModifiers.registerModifier('rp', RepeaterModifier);\n  ShapeModifiers.registerModifier('rd', RoundCornersModifier);\n  ShapeModifiers.registerModifier('zz', ZigZagModifier);\n  ShapeModifiers.registerModifier('op', OffsetPathModifier); // Registering expression plugin\n\n  setExpressionsPlugin(Expressions);\n  setExpressionInterfaces(getInterface);\n  initialize$1();\n  initialize(); // Registering svg effects\n\n  registerEffect$1(20, SVGTintFilter, true);\n  registerEffect$1(21, SVGFillFilter, true);\n  registerEffect$1(22, SVGStrokeEffect, false);\n  registerEffect$1(23, SVGTritoneFilter, true);\n  registerEffect$1(24, SVGProLevelsFilter, true);\n  registerEffect$1(25, SVGDropShadowEffect, true);\n  registerEffect$1(28, SVGMatte3Effect, false);\n  registerEffect$1(29, SVGGaussianBlurEffect, true);\n  registerEffect$1(35, SVGTransformEffect, false);\n  registerEffect(35, CVTransformEffect);\n\n  return lottie;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb3R0aWUtd2ViL2J1aWxkL3BsYXllci9sb3R0aWUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxFQUFFLEtBQTREO0FBQzlELEVBQUUsQ0FDcUc7QUFDdkcsQ0FBQyx1QkFBdUI7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsd0JBQXdCLDBCQUEwQjtBQUNqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYLHdDQUF3QztBQUN4QyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSw0QkFBNEIsMkJBQTJCLDJFQUEyRSxvQ0FBb0Msd0JBQXdCLE9BQU8sb0NBQW9DLG1JQUFtSTtBQUM1VztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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OztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGtCQUFrQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QiwyQkFBMkIsMkVBQTJFLG9DQUFvQyx3QkFBd0IsT0FBTyxvQ0FBb0MsbUlBQW1JOztBQUU1VztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFVBQVU7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdHQUFnRzs7QUFFaEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLHlCQUF5QjtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxlQUFlO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7O0FBRUE7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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFVBQVU7QUFDNUIsb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMEJBQTBCO0FBQ3ZDLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksK0JBQStCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw2TUFBNk07QUFDN007O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCw0QkFBNEIsMkJBQTJCLDJFQUEyRSxvQ0FBb0Msd0JBQXdCLE9BQU8sb0NBQW9DLG1JQUFtSTtBQUM1VztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixXQUFXO0FBQy9COztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EO0FBQ25EOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7O0FBR0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCLDJCQUEyQjs7QUFFM0Isa0NBQWtDOztBQUVsQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0EseUVBQXlFOztBQUV6RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQyxtQ0FBbUM7O0FBRW5DO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsUUFBUTtBQUNoQyx1RkFBdUY7QUFDdkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsVUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFVBQVU7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixVQUFVO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QixtQ0FBbUM7O0FBRW5DLDBCQUEwQjs7QUFFMUIsOEJBQThCOztBQUU5Qix5QkFBeUI7O0FBRXpCLGlDQUFpQzs7QUFFakM7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUEsNEJBQTRCO0FBQzVCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFFBQVE7QUFDMUI7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0EsNkVBQTZFOztBQUU3RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUIsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBOztBQUVBLG9CQUFvQixVQUFVO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7O0FBRVY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0dBQWdHO0FBQ2hHOztBQUVBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUI7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsa0NBQWtDLElBQUksa0NBQWtDOztBQUU3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLGtDQUFrQyxJQUFJLGtDQUFrQzs7QUFFakg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckMsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQSw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0EsZ0NBQWdDOztBQUVoQywyREFBMkQ7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBOztBQUVBO0FBQ0Esb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdC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QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFD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Q0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCLG1DQUFtQzs7QUFFbkMsMEJBQTBCOztBQUUxQiw4QkFBOEI7O0FBRTlCLHlCQUF5Qjs7QUFFekIsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQsY0FBYzs7QUFFZCxjQUFjOztBQUVkLCtCQUErQjtBQUMvQixRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixvQ0FBb0M7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdIQUF3SDs7QUFFeEg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7OztBQUdWOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLG1IQUFtSDs7QUFFbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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QUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlOztBQUVmLGVBQWU7O0FBRWYsZUFBZTtBQUNmLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBFQUEwRTs7QUFFbEcsdUVBQXVFLFlBQVksb0JBQW9CLFFBQVE7O0FBRS9HO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQyw4REFBOEQ7QUFDOUQ7O0FBRUE7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQyw0RkFBNEY7QUFDNUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQ7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSx3RkFBd0YsVUFBVTs7QUFFbEc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVLGlDQUFpQztBQUMzQyxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxHQUFHOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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OztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0SUFBNEk7QUFDNUk7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwSkFBMEo7QUFDMUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7O0FBRS9EO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEOztBQUVoRCxnREFBZ0Q7O0FBRWhELCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7O0FBRUEsMkZBQTJGOztBQUUzRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvdHRpZS13ZWIvYnVpbGQvcGxheWVyL2xvdHRpZS5qcz8zMGRhIl0sInNvdXJjZXNDb250ZW50IjpbIih0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiKSAmJiAoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5sb3R0aWUgPSBmYWN0b3J5KCkpO1xufSkodGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBzdmdOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4gIHZhciBsb2NhdGlvbkhyZWYgPSAnJztcbiAgdmFyIF91c2VXZWJXb3JrZXIgPSBmYWxzZTtcbiAgdmFyIGluaXRpYWxEZWZhdWx0RnJhbWUgPSAtOTk5OTk5O1xuXG4gIHZhciBzZXRXZWJXb3JrZXIgPSBmdW5jdGlvbiBzZXRXZWJXb3JrZXIoZmxhZykge1xuICAgIF91c2VXZWJXb3JrZXIgPSAhIWZsYWc7XG4gIH07XG5cbiAgdmFyIGdldFdlYldvcmtlciA9IGZ1bmN0aW9uIGdldFdlYldvcmtlcigpIHtcbiAgICByZXR1cm4gX3VzZVdlYldvcmtlcjtcbiAgfTtcblxuICB2YXIgc2V0TG9jYXRpb25IcmVmID0gZnVuY3Rpb24gc2V0TG9jYXRpb25IcmVmKHZhbHVlKSB7XG4gICAgbG9jYXRpb25IcmVmID0gdmFsdWU7XG4gIH07XG5cbiAgdmFyIGdldExvY2F0aW9uSHJlZiA9IGZ1bmN0aW9uIGdldExvY2F0aW9uSHJlZigpIHtcbiAgICByZXR1cm4gbG9jYXRpb25IcmVmO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVRhZyh0eXBlKSB7XG4gICAgLy8gcmV0dXJuIHthcHBlbmRDaGlsZDpmdW5jdGlvbigpe30sc2V0QXR0cmlidXRlOmZ1bmN0aW9uKCl7fSxzdHlsZTp7fX1cbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZFByb3RvdHlwZShzb3VyY2VzLCBkZXN0aW5hdGlvbikge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBzb3VyY2VzLmxlbmd0aDtcbiAgICB2YXIgc291cmNlUHJvdG90eXBlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBzb3VyY2VQcm90b3R5cGUgPSBzb3VyY2VzW2ldLnByb3RvdHlwZTtcblxuICAgICAgZm9yICh2YXIgYXR0ciBpbiBzb3VyY2VQcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2VQcm90b3R5cGUsIGF0dHIpKSBkZXN0aW5hdGlvbi5wcm90b3R5cGVbYXR0cl0gPSBzb3VyY2VQcm90b3R5cGVbYXR0cl07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGVzY3JpcHRvcihvYmplY3QsIHByb3ApIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3ApO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJveHlGdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICBmdW5jdGlvbiBQcm94eUZ1bmN0aW9uKCkge31cblxuICAgIFByb3h5RnVuY3Rpb24ucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHJldHVybiBQcm94eUZ1bmN0aW9uO1xuICB9XG5cbiAgLy8gaW1wb3J0IEhvd2wgZnJvbSAnLi4vLi4vM3JkX3BhcnR5L2hvd2xlcic7XG4gIHZhciBhdWRpb0NvbnRyb2xsZXJGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF1ZGlvQ29udHJvbGxlcihhdWRpb0ZhY3RvcnkpIHtcbiAgICAgIHRoaXMuYXVkaW9zID0gW107XG4gICAgICB0aGlzLmF1ZGlvRmFjdG9yeSA9IGF1ZGlvRmFjdG9yeTtcbiAgICAgIHRoaXMuX3ZvbHVtZSA9IDE7XG4gICAgICB0aGlzLl9pc011dGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgQXVkaW9Db250cm9sbGVyLnByb3RvdHlwZSA9IHtcbiAgICAgIGFkZEF1ZGlvOiBmdW5jdGlvbiBhZGRBdWRpbyhhdWRpbykge1xuICAgICAgICB0aGlzLmF1ZGlvcy5wdXNoKGF1ZGlvKTtcbiAgICAgIH0sXG4gICAgICBwYXVzZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5hdWRpb3MubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIHRoaXMuYXVkaW9zW2ldLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXN1bWU6IGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmF1ZGlvcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgdGhpcy5hdWRpb3NbaV0ucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXRSYXRlOiBmdW5jdGlvbiBzZXRSYXRlKHJhdGVWYWx1ZSkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuYXVkaW9zLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICB0aGlzLmF1ZGlvc1tpXS5zZXRSYXRlKHJhdGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjcmVhdGVBdWRpbzogZnVuY3Rpb24gY3JlYXRlQXVkaW8oYXNzZXRQYXRoKSB7XG4gICAgICAgIGlmICh0aGlzLmF1ZGlvRmFjdG9yeSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmF1ZGlvRmFjdG9yeShhc3NldFBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdpbmRvdy5Ib3dsKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuSG93bCh7XG4gICAgICAgICAgICBzcmM6IFthc3NldFBhdGhdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzUGxheWluZzogZmFsc2UsXG4gICAgICAgICAgcGxheTogZnVuY3Rpb24gcGxheSgpIHtcbiAgICAgICAgICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNlZWs6IGZ1bmN0aW9uIHNlZWsoKSB7XG4gICAgICAgICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcGxheWluZzogZnVuY3Rpb24gcGxheWluZygpIHt9LFxuICAgICAgICAgIHJhdGU6IGZ1bmN0aW9uIHJhdGUoKSB7fSxcbiAgICAgICAgICBzZXRWb2x1bWU6IGZ1bmN0aW9uIHNldFZvbHVtZSgpIHt9XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgc2V0QXVkaW9GYWN0b3J5OiBmdW5jdGlvbiBzZXRBdWRpb0ZhY3RvcnkoYXVkaW9GYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuYXVkaW9GYWN0b3J5ID0gYXVkaW9GYWN0b3J5O1xuICAgICAgfSxcbiAgICAgIHNldFZvbHVtZTogZnVuY3Rpb24gc2V0Vm9sdW1lKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZvbHVtZSA9IHZhbHVlO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVZvbHVtZSgpO1xuICAgICAgfSxcbiAgICAgIG11dGU6IGZ1bmN0aW9uIG11dGUoKSB7XG4gICAgICAgIHRoaXMuX2lzTXV0ZWQgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVZvbHVtZSgpO1xuICAgICAgfSxcbiAgICAgIHVubXV0ZTogZnVuY3Rpb24gdW5tdXRlKCkge1xuICAgICAgICB0aGlzLl9pc011dGVkID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlVm9sdW1lKCk7XG4gICAgICB9LFxuICAgICAgZ2V0Vm9sdW1lOiBmdW5jdGlvbiBnZXRWb2x1bWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92b2x1bWU7XG4gICAgICB9LFxuICAgICAgX3VwZGF0ZVZvbHVtZTogZnVuY3Rpb24gX3VwZGF0ZVZvbHVtZSgpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmF1ZGlvcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgdGhpcy5hdWRpb3NbaV0udm9sdW1lKHRoaXMuX3ZvbHVtZSAqICh0aGlzLl9pc011dGVkID8gMCA6IDEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgQXVkaW9Db250cm9sbGVyKCk7XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBjcmVhdGVUeXBlZEFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlZ3VsYXJBcnJheSh0eXBlLCBsZW4pIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgICAgY2FzZSAndWludDhjJzpcbiAgICAgICAgICB2YWx1ZSA9IDE7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB2YWx1ZSA9IDEuMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGFyci5wdXNoKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVUeXBlZEFycmF5RmFjdG9yeSh0eXBlLCBsZW4pIHtcbiAgICAgIGlmICh0eXBlID09PSAnZmxvYXQzMicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkobGVuKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICdpbnQxNicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KGxlbik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSAndWludDhjJykge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGxlbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjcmVhdGVSZWd1bGFyQXJyYXkodHlwZSwgbGVuKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBjcmVhdGVUeXBlZEFycmF5RmFjdG9yeTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlUmVndWxhckFycmF5O1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2l6ZWRBcnJheShsZW4pIHtcbiAgICByZXR1cm4gQXJyYXkuYXBwbHkobnVsbCwge1xuICAgICAgbGVuZ3RoOiBsZW5cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90eXBlb2YkNihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiQ2ID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YkNiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mJDYob2JqKTsgfVxuICB2YXIgc3ViZnJhbWVFbmFibGVkID0gdHJ1ZTtcbiAgdmFyIGV4cHJlc3Npb25zUGx1Z2luID0gbnVsbDtcbiAgdmFyIGV4cHJlc3Npb25zSW50ZXJmYWNlcyA9IG51bGw7XG4gIHZhciBpZFByZWZpeCQxID0gJyc7XG4gIHZhciBpc1NhZmFyaSA9IC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHZhciBfc2hvdWxkUm91bmRWYWx1ZXMgPSBmYWxzZTtcbiAgdmFyIGJtUG93ID0gTWF0aC5wb3c7XG4gIHZhciBibVNxcnQgPSBNYXRoLnNxcnQ7XG4gIHZhciBibUZsb29yID0gTWF0aC5mbG9vcjtcbiAgdmFyIGJtTWF4ID0gTWF0aC5tYXg7XG4gIHZhciBibU1pbiA9IE1hdGgubWluO1xuICB2YXIgQk1NYXRoID0ge307XG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvcGVydHlOYW1lcyA9IFsnYWJzJywgJ2Fjb3MnLCAnYWNvc2gnLCAnYXNpbicsICdhc2luaCcsICdhdGFuJywgJ2F0YW5oJywgJ2F0YW4yJywgJ2NlaWwnLCAnY2JydCcsICdleHBtMScsICdjbHozMicsICdjb3MnLCAnY29zaCcsICdleHAnLCAnZmxvb3InLCAnZnJvdW5kJywgJ2h5cG90JywgJ2ltdWwnLCAnbG9nJywgJ2xvZzFwJywgJ2xvZzInLCAnbG9nMTAnLCAnbWF4JywgJ21pbicsICdwb3cnLCAncmFuZG9tJywgJ3JvdW5kJywgJ3NpZ24nLCAnc2luJywgJ3NpbmgnLCAnc3FydCcsICd0YW4nLCAndGFuaCcsICd0cnVuYycsICdFJywgJ0xOMTAnLCAnTE4yJywgJ0xPRzEwRScsICdMT0cyRScsICdQSScsICdTUVJUMV8yJywgJ1NRUlQyJ107XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHByb3BlcnR5TmFtZXMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBCTU1hdGhbcHJvcGVydHlOYW1lc1tpXV0gPSBNYXRoW3Byb3BlcnR5TmFtZXNbaV1dO1xuICAgIH1cbiAgfSkoKTtcblxuICBmdW5jdGlvbiBQcm9qZWN0SW50ZXJmYWNlJDEoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgQk1NYXRoLnJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG4gIEJNTWF0aC5hYnMgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFyIHRPZlZhbCA9IF90eXBlb2YkNih2YWwpO1xuXG4gICAgaWYgKHRPZlZhbCA9PT0gJ29iamVjdCcgJiYgdmFsLmxlbmd0aCkge1xuICAgICAgdmFyIGFic0FyciA9IGNyZWF0ZVNpemVkQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSB2YWwubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYWJzQXJyW2ldID0gTWF0aC5hYnModmFsW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFic0FycjtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5hYnModmFsKTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdEN1cnZlU2VnbWVudHMgPSAxNTA7XG4gIHZhciBkZWdUb1JhZHMgPSBNYXRoLlBJIC8gMTgwO1xuICB2YXIgcm91bmRDb3JuZXIgPSAwLjU1MTk7XG5cbiAgZnVuY3Rpb24gcm91bmRWYWx1ZXMoZmxhZykge1xuICAgIF9zaG91bGRSb3VuZFZhbHVlcyA9ICEhZmxhZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGJtUm5kKHZhbHVlKSB7XG4gICAgaWYgKF9zaG91bGRSb3VuZFZhbHVlcykge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0eWxlRGl2KGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBlbGVtZW50LnN0eWxlLnRvcCA9IDA7XG4gICAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gMDtcbiAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAgMCc7XG4gICAgZWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm1PcmlnaW4gPSAnMCAwJztcbiAgICBlbGVtZW50LnN0eWxlLmJhY2tmYWNlVmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICBlbGVtZW50LnN0eWxlLndlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybVN0eWxlID0gJ3ByZXNlcnZlLTNkJztcbiAgICBlbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybVN0eWxlID0gJ3ByZXNlcnZlLTNkJztcbiAgICBlbGVtZW50LnN0eWxlLm1velRyYW5zZm9ybVN0eWxlID0gJ3ByZXNlcnZlLTNkJztcbiAgfVxuXG4gIGZ1bmN0aW9uIEJNRW50ZXJGcmFtZUV2ZW50KHR5cGUsIGN1cnJlbnRUaW1lLCB0b3RhbFRpbWUsIGZyYW1lTXVsdGlwbGllcikge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5jdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIHRoaXMudG90YWxUaW1lID0gdG90YWxUaW1lO1xuICAgIHRoaXMuZGlyZWN0aW9uID0gZnJhbWVNdWx0aXBsaWVyIDwgMCA/IC0xIDogMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEJNQ29tcGxldGVFdmVudCh0eXBlLCBmcmFtZU11bHRpcGxpZXIpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuZGlyZWN0aW9uID0gZnJhbWVNdWx0aXBsaWVyIDwgMCA/IC0xIDogMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEJNQ29tcGxldGVMb29wRXZlbnQodHlwZSwgdG90YWxMb29wcywgY3VycmVudExvb3AsIGZyYW1lTXVsdGlwbGllcikge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5jdXJyZW50TG9vcCA9IGN1cnJlbnRMb29wO1xuICAgIHRoaXMudG90YWxMb29wcyA9IHRvdGFsTG9vcHM7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSBmcmFtZU11bHRpcGxpZXIgPCAwID8gLTEgOiAxO1xuICB9XG5cbiAgZnVuY3Rpb24gQk1TZWdtZW50U3RhcnRFdmVudCh0eXBlLCBmaXJzdEZyYW1lLCB0b3RhbEZyYW1lcykge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5maXJzdEZyYW1lID0gZmlyc3RGcmFtZTtcbiAgICB0aGlzLnRvdGFsRnJhbWVzID0gdG90YWxGcmFtZXM7XG4gIH1cblxuICBmdW5jdGlvbiBCTURlc3Ryb3lFdmVudCh0eXBlLCB0YXJnZXQpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gQk1SZW5kZXJGcmFtZUVycm9yRXZlbnQobmF0aXZlRXJyb3IsIGN1cnJlbnRUaW1lKSB7XG4gICAgdGhpcy50eXBlID0gJ3JlbmRlckZyYW1lRXJyb3InO1xuICAgIHRoaXMubmF0aXZlRXJyb3IgPSBuYXRpdmVFcnJvcjtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiBCTUNvbmZpZ0Vycm9yRXZlbnQobmF0aXZlRXJyb3IpIHtcbiAgICB0aGlzLnR5cGUgPSAnY29uZmlnRXJyb3InO1xuICAgIHRoaXMubmF0aXZlRXJyb3IgPSBuYXRpdmVFcnJvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIEJNQW5pbWF0aW9uQ29uZmlnRXJyb3JFdmVudCh0eXBlLCBuYXRpdmVFcnJvcikge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5uYXRpdmVFcnJvciA9IG5hdGl2ZUVycm9yO1xuICB9XG5cbiAgdmFyIGNyZWF0ZUVsZW1lbnRJRCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2NvdW50ID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlSUQoKSB7XG4gICAgICBfY291bnQgKz0gMTtcbiAgICAgIHJldHVybiBpZFByZWZpeCQxICsgJ19fbG90dGllX2VsZW1lbnRfJyArIF9jb3VudDtcbiAgICB9O1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gSFNWdG9SR0IoaCwgcywgdikge1xuICAgIHZhciByO1xuICAgIHZhciBnO1xuICAgIHZhciBiO1xuICAgIHZhciBpO1xuICAgIHZhciBmO1xuICAgIHZhciBwO1xuICAgIHZhciBxO1xuICAgIHZhciB0O1xuICAgIGkgPSBNYXRoLmZsb29yKGggKiA2KTtcbiAgICBmID0gaCAqIDYgLSBpO1xuICAgIHAgPSB2ICogKDEgLSBzKTtcbiAgICBxID0gdiAqICgxIC0gZiAqIHMpO1xuICAgIHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyk7XG5cbiAgICBzd2l0Y2ggKGkgJSA2KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHIgPSB2O1xuICAgICAgICBnID0gdDtcbiAgICAgICAgYiA9IHA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDE6XG4gICAgICAgIHIgPSBxO1xuICAgICAgICBnID0gdjtcbiAgICAgICAgYiA9IHA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIHIgPSBwO1xuICAgICAgICBnID0gdjtcbiAgICAgICAgYiA9IHQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM6XG4gICAgICAgIHIgPSBwO1xuICAgICAgICBnID0gcTtcbiAgICAgICAgYiA9IHY7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHIgPSB0O1xuICAgICAgICBnID0gcDtcbiAgICAgICAgYiA9IHY7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDU6XG4gICAgICAgIHIgPSB2O1xuICAgICAgICBnID0gcDtcbiAgICAgICAgYiA9IHE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gW3IsIGcsIGJdO1xuICB9XG5cbiAgZnVuY3Rpb24gUkdCdG9IU1YociwgZywgYikge1xuICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICB2YXIgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgdmFyIGQgPSBtYXggLSBtaW47XG4gICAgdmFyIGg7XG4gICAgdmFyIHMgPSBtYXggPT09IDAgPyAwIDogZCAvIG1heDtcbiAgICB2YXIgdiA9IG1heCAvIDI1NTtcblxuICAgIHN3aXRjaCAobWF4KSB7XG4gICAgICBjYXNlIG1pbjpcbiAgICAgICAgaCA9IDA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIHI6XG4gICAgICAgIGggPSBnIC0gYiArIGQgKiAoZyA8IGIgPyA2IDogMCk7XG4gICAgICAgIGggLz0gNiAqIGQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIGc6XG4gICAgICAgIGggPSBiIC0gciArIGQgKiAyO1xuICAgICAgICBoIC89IDYgKiBkO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBiOlxuICAgICAgICBoID0gciAtIGcgKyBkICogNDtcbiAgICAgICAgaCAvPSA2ICogZDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBbaCwgcywgdl07XG4gIH1cblxuICBmdW5jdGlvbiBhZGRTYXR1cmF0aW9uVG9SR0IoY29sb3IsIG9mZnNldCkge1xuICAgIHZhciBoc3YgPSBSR0J0b0hTVihjb2xvclswXSAqIDI1NSwgY29sb3JbMV0gKiAyNTUsIGNvbG9yWzJdICogMjU1KTtcbiAgICBoc3ZbMV0gKz0gb2Zmc2V0O1xuXG4gICAgaWYgKGhzdlsxXSA+IDEpIHtcbiAgICAgIGhzdlsxXSA9IDE7XG4gICAgfSBlbHNlIGlmIChoc3ZbMV0gPD0gMCkge1xuICAgICAgaHN2WzFdID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gSFNWdG9SR0IoaHN2WzBdLCBoc3ZbMV0sIGhzdlsyXSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRCcmlnaHRuZXNzVG9SR0IoY29sb3IsIG9mZnNldCkge1xuICAgIHZhciBoc3YgPSBSR0J0b0hTVihjb2xvclswXSAqIDI1NSwgY29sb3JbMV0gKiAyNTUsIGNvbG9yWzJdICogMjU1KTtcbiAgICBoc3ZbMl0gKz0gb2Zmc2V0O1xuXG4gICAgaWYgKGhzdlsyXSA+IDEpIHtcbiAgICAgIGhzdlsyXSA9IDE7XG4gICAgfSBlbHNlIGlmIChoc3ZbMl0gPCAwKSB7XG4gICAgICBoc3ZbMl0gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBIU1Z0b1JHQihoc3ZbMF0sIGhzdlsxXSwgaHN2WzJdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEh1ZVRvUkdCKGNvbG9yLCBvZmZzZXQpIHtcbiAgICB2YXIgaHN2ID0gUkdCdG9IU1YoY29sb3JbMF0gKiAyNTUsIGNvbG9yWzFdICogMjU1LCBjb2xvclsyXSAqIDI1NSk7XG4gICAgaHN2WzBdICs9IG9mZnNldCAvIDM2MDtcblxuICAgIGlmIChoc3ZbMF0gPiAxKSB7XG4gICAgICBoc3ZbMF0gLT0gMTtcbiAgICB9IGVsc2UgaWYgKGhzdlswXSA8IDApIHtcbiAgICAgIGhzdlswXSArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBIU1Z0b1JHQihoc3ZbMF0sIGhzdlsxXSwgaHN2WzJdKTtcbiAgfVxuXG4gIHZhciByZ2JUb0hleCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29sb3JNYXAgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgaGV4O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSArPSAxKSB7XG4gICAgICBoZXggPSBpLnRvU3RyaW5nKDE2KTtcbiAgICAgIGNvbG9yTWFwW2ldID0gaGV4Lmxlbmd0aCA9PT0gMSA/ICcwJyArIGhleCA6IGhleDtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHIsIGcsIGIpIHtcbiAgICAgIGlmIChyIDwgMCkge1xuICAgICAgICByID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGcgPCAwKSB7XG4gICAgICAgIGcgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoYiA8IDApIHtcbiAgICAgICAgYiA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnIycgKyBjb2xvck1hcFtyXSArIGNvbG9yTWFwW2ddICsgY29sb3JNYXBbYl07XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBzZXRTdWJmcmFtZUVuYWJsZWQgPSBmdW5jdGlvbiBzZXRTdWJmcmFtZUVuYWJsZWQoZmxhZykge1xuICAgIHN1YmZyYW1lRW5hYmxlZCA9ICEhZmxhZztcbiAgfTtcblxuICB2YXIgZ2V0U3ViZnJhbWVFbmFibGVkID0gZnVuY3Rpb24gZ2V0U3ViZnJhbWVFbmFibGVkKCkge1xuICAgIHJldHVybiBzdWJmcmFtZUVuYWJsZWQ7XG4gIH07XG5cbiAgdmFyIHNldEV4cHJlc3Npb25zUGx1Z2luID0gZnVuY3Rpb24gc2V0RXhwcmVzc2lvbnNQbHVnaW4odmFsdWUpIHtcbiAgICBleHByZXNzaW9uc1BsdWdpbiA9IHZhbHVlO1xuICB9O1xuXG4gIHZhciBnZXRFeHByZXNzaW9uc1BsdWdpbiA9IGZ1bmN0aW9uIGdldEV4cHJlc3Npb25zUGx1Z2luKCkge1xuICAgIHJldHVybiBleHByZXNzaW9uc1BsdWdpbjtcbiAgfTtcblxuICB2YXIgc2V0RXhwcmVzc2lvbkludGVyZmFjZXMgPSBmdW5jdGlvbiBzZXRFeHByZXNzaW9uSW50ZXJmYWNlcyh2YWx1ZSkge1xuICAgIGV4cHJlc3Npb25zSW50ZXJmYWNlcyA9IHZhbHVlO1xuICB9O1xuXG4gIHZhciBnZXRFeHByZXNzaW9uSW50ZXJmYWNlcyA9IGZ1bmN0aW9uIGdldEV4cHJlc3Npb25JbnRlcmZhY2VzKCkge1xuICAgIHJldHVybiBleHByZXNzaW9uc0ludGVyZmFjZXM7XG4gIH07XG5cbiAgdmFyIHNldERlZmF1bHRDdXJ2ZVNlZ21lbnRzID0gZnVuY3Rpb24gc2V0RGVmYXVsdEN1cnZlU2VnbWVudHModmFsdWUpIHtcbiAgICBkZWZhdWx0Q3VydmVTZWdtZW50cyA9IHZhbHVlO1xuICB9O1xuXG4gIHZhciBnZXREZWZhdWx0Q3VydmVTZWdtZW50cyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDdXJ2ZVNlZ21lbnRzKCkge1xuICAgIHJldHVybiBkZWZhdWx0Q3VydmVTZWdtZW50cztcbiAgfTtcblxuICB2YXIgc2V0SWRQcmVmaXggPSBmdW5jdGlvbiBzZXRJZFByZWZpeCh2YWx1ZSkge1xuICAgIGlkUHJlZml4JDEgPSB2YWx1ZTtcbiAgfTtcblxuICB2YXIgZ2V0SWRQcmVmaXggPSBmdW5jdGlvbiBnZXRJZFByZWZpeCgpIHtcbiAgICByZXR1cm4gaWRQcmVmaXgkMTtcbiAgfTtcblxuICBmdW5jdGlvbiBjcmVhdGVOUyh0eXBlKSB7XG4gICAgLy8gcmV0dXJuIHthcHBlbmRDaGlsZDpmdW5jdGlvbigpe30sc2V0QXR0cmlidXRlOmZ1bmN0aW9uKCl7fSxzdHlsZTp7fX1cbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCB0eXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90eXBlb2YkNShvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiQ1ID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YkNSA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mJDUob2JqKTsgfVxuXG4gIHZhciBkYXRhTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2NvdW50ZXJJZCA9IDE7XG4gICAgdmFyIHByb2Nlc3NlcyA9IFtdO1xuICAgIHZhciB3b3JrZXJGbjtcbiAgICB2YXIgd29ya2VySW5zdGFuY2U7XG4gICAgdmFyIHdvcmtlclByb3h5ID0ge1xuICAgICAgb25tZXNzYWdlOiBmdW5jdGlvbiBvbm1lc3NhZ2UoKSB7fSxcbiAgICAgIHBvc3RNZXNzYWdlOiBmdW5jdGlvbiBwb3N0TWVzc2FnZShwYXRoKSB7XG4gICAgICAgIHdvcmtlckZuKHtcbiAgICAgICAgICBkYXRhOiBwYXRoXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIF93b3JrZXJTZWxmID0ge1xuICAgICAgcG9zdE1lc3NhZ2U6IGZ1bmN0aW9uIHBvc3RNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgd29ya2VyUHJveHkub25tZXNzYWdlKHtcbiAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVXb3JrZXIoZm4pIHtcbiAgICAgIGlmICh3aW5kb3cuV29ya2VyICYmIHdpbmRvdy5CbG9iICYmIGdldFdlYldvcmtlcigpKSB7XG4gICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoWyd2YXIgX3dvcmtlclNlbGYgPSBzZWxmOyBzZWxmLm9ubWVzc2FnZSA9ICcsIGZuLnRvU3RyaW5nKCldLCB7XG4gICAgICAgICAgdHlwZTogJ3RleHQvamF2YXNjcmlwdCdcbiAgICAgICAgfSk7IC8vIHZhciBibG9iID0gbmV3IEJsb2IoWydzZWxmLm9ubWVzc2FnZSA9ICcsIGZuLnRvU3RyaW5nKCldLCB7IHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnIH0pO1xuXG4gICAgICAgIHZhciB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICByZXR1cm4gbmV3IFdvcmtlcih1cmwpO1xuICAgICAgfVxuXG4gICAgICB3b3JrZXJGbiA9IGZuO1xuICAgICAgcmV0dXJuIHdvcmtlclByb3h5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldHVwV29ya2VyKCkge1xuICAgICAgaWYgKCF3b3JrZXJJbnN0YW5jZSkge1xuICAgICAgICB3b3JrZXJJbnN0YW5jZSA9IGNyZWF0ZVdvcmtlcihmdW5jdGlvbiB3b3JrZXJTdGFydChlKSB7XG4gICAgICAgICAgZnVuY3Rpb24gZGF0YUZ1bmN0aW9uTWFuYWdlcigpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlTGF5ZXJzKGxheWVycywgY29tcHMpIHtcbiAgICAgICAgICAgICAgdmFyIGxheWVyRGF0YTtcbiAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgIHZhciBsZW4gPSBsYXllcnMubGVuZ3RoO1xuICAgICAgICAgICAgICB2YXIgajtcbiAgICAgICAgICAgICAgdmFyIGpMZW47XG4gICAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgICB2YXIga0xlbjtcblxuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBsYXllckRhdGEgPSBsYXllcnNbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAoJ2tzJyBpbiBsYXllckRhdGEgJiYgIWxheWVyRGF0YS5jb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIGxheWVyRGF0YS5jb21wbGV0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICBpZiAobGF5ZXJEYXRhLmhhc01hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hc2tQcm9wcyA9IGxheWVyRGF0YS5tYXNrc1Byb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgICAgIGpMZW4gPSBtYXNrUHJvcHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobWFza1Byb3BzW2pdLnB0LmsuaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydFBhdGhzVG9BYnNvbHV0ZVZhbHVlcyhtYXNrUHJvcHNbal0ucHQuayk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtMZW4gPSBtYXNrUHJvcHNbal0ucHQuay5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBrTGVuOyBrICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2tQcm9wc1tqXS5wdC5rW2tdLnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0UGF0aHNUb0Fic29sdXRlVmFsdWVzKG1hc2tQcm9wc1tqXS5wdC5rW2tdLnNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2tQcm9wc1tqXS5wdC5rW2tdLmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0UGF0aHNUb0Fic29sdXRlVmFsdWVzKG1hc2tQcm9wc1tqXS5wdC5rW2tdLmVbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmIChsYXllckRhdGEudHkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJEYXRhLmxheWVycyA9IGZpbmRDb21wTGF5ZXJzKGxheWVyRGF0YS5yZWZJZCwgY29tcHMpO1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUxheWVycyhsYXllckRhdGEubGF5ZXJzLCBjb21wcyk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxheWVyRGF0YS50eSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZVNoYXBlcyhsYXllckRhdGEuc2hhcGVzKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGF5ZXJEYXRhLnR5ID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlVGV4dChsYXllckRhdGEpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjb21wbGV0ZUNoYXJzKGNoYXJzLCBhc3NldHMpIHtcbiAgICAgICAgICAgICAgaWYgKGNoYXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBjaGFycy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyc1tpXS50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciBjb21wRGF0YSA9IGZpbmRDb21wKGNoYXJzW2ldLmRhdGEucmVmSWQsIGFzc2V0cyk7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJzW2ldLmRhdGEubGF5ZXJzID0gZmluZENvbXBMYXllcnMoY2hhcnNbaV0uZGF0YS5yZWZJZCwgYXNzZXRzKTsgLy8gY2hhcnNbaV0uZGF0YS5pcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoYXJzW2ldLmRhdGEub3AgPSA5OTk5OTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhcnNbaV0uZGF0YS5zdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoYXJzW2ldLmRhdGEuc3IgPSAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGFyc1tpXS53ID0gY29tcERhdGEudztcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhcnNbaV0uZGF0YS5rcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICBhOiB7IGs6IFswLCAwLCAwXSwgYTogMCB9LFxuICAgICAgICAgICAgICAgICAgICAvLyAgIHA6IHsgazogWzAsIC1jb21wRGF0YS5oLCAwXSwgYTogMCB9LFxuICAgICAgICAgICAgICAgICAgICAvLyAgIHI6IHsgazogMCwgYTogMCB9LFxuICAgICAgICAgICAgICAgICAgICAvLyAgIHM6IHsgazogWzEwMCwgMTAwXSwgYTogMCB9LFxuICAgICAgICAgICAgICAgICAgICAvLyAgIG86IHsgazogMTAwLCBhOiAwIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vIH07XG5cbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVMYXllcnMoY2hhcnNbaV0uZGF0YS5sYXllcnMsIGFzc2V0cyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRDb21wKGlkLCBjb21wcykge1xuICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgIHZhciBsZW4gPSBjb21wcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcHNbaV0uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29tcHNbaV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRDb21wTGF5ZXJzKGlkLCBjb21wcykge1xuICAgICAgICAgICAgICB2YXIgY29tcCA9IGZpbmRDb21wKGlkLCBjb21wcyk7XG5cbiAgICAgICAgICAgICAgaWYgKGNvbXApIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXAubGF5ZXJzLl9fdXNlZCkge1xuICAgICAgICAgICAgICAgICAgY29tcC5sYXllcnMuX191c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wLmxheWVycztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjb21wLmxheWVycykpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlU2hhcGVzKGFycikge1xuICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgICAgICAgIHZhciBqO1xuICAgICAgICAgICAgICB2YXIgakxlbjtcblxuICAgICAgICAgICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChhcnJbaV0udHkgPT09ICdzaCcpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChhcnJbaV0ua3Muay5pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnRQYXRoc1RvQWJzb2x1dGVWYWx1ZXMoYXJyW2ldLmtzLmspO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgakxlbiA9IGFycltpXS5rcy5rLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFycltpXS5rcy5rW2pdLnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRQYXRoc1RvQWJzb2x1dGVWYWx1ZXMoYXJyW2ldLmtzLmtbal0uc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFycltpXS5rcy5rW2pdLmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRQYXRoc1RvQWJzb2x1dGVWYWx1ZXMoYXJyW2ldLmtzLmtbal0uZVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICdncicpIHtcbiAgICAgICAgICAgICAgICAgIGNvbXBsZXRlU2hhcGVzKGFycltpXS5pdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbnZlcnRQYXRoc1RvQWJzb2x1dGVWYWx1ZXMocGF0aCkge1xuICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgdmFyIGxlbiA9IHBhdGguaS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5pW2ldWzBdICs9IHBhdGgudltpXVswXTtcbiAgICAgICAgICAgICAgICBwYXRoLmlbaV1bMV0gKz0gcGF0aC52W2ldWzFdO1xuICAgICAgICAgICAgICAgIHBhdGgub1tpXVswXSArPSBwYXRoLnZbaV1bMF07XG4gICAgICAgICAgICAgICAgcGF0aC5vW2ldWzFdICs9IHBhdGgudltpXVsxXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjaGVja1ZlcnNpb24obWluaW11bSwgYW5pbVZlcnNpb25TdHJpbmcpIHtcbiAgICAgICAgICAgICAgdmFyIGFuaW1WZXJzaW9uID0gYW5pbVZlcnNpb25TdHJpbmcgPyBhbmltVmVyc2lvblN0cmluZy5zcGxpdCgnLicpIDogWzEwMCwgMTAwLCAxMDBdO1xuXG4gICAgICAgICAgICAgIGlmIChtaW5pbXVtWzBdID4gYW5pbVZlcnNpb25bMF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChhbmltVmVyc2lvblswXSA+IG1pbmltdW1bMF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobWluaW11bVsxXSA+IGFuaW1WZXJzaW9uWzFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoYW5pbVZlcnNpb25bMV0gPiBtaW5pbXVtWzFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKG1pbmltdW1bMl0gPiBhbmltVmVyc2lvblsyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGFuaW1WZXJzaW9uWzJdID4gbWluaW11bVsyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2hlY2tUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgbWluaW11bVZlcnNpb24gPSBbNCwgNCwgMTRdO1xuXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRleHRMYXllcih0ZXh0TGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9jdW1lbnREYXRhID0gdGV4dExheWVyLnQuZDtcbiAgICAgICAgICAgICAgICB0ZXh0TGF5ZXIudC5kID0ge1xuICAgICAgICAgICAgICAgICAgazogW3tcbiAgICAgICAgICAgICAgICAgICAgczogZG9jdW1lbnREYXRhLFxuICAgICAgICAgICAgICAgICAgICB0OiAwXG4gICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmdW5jdGlvbiBpdGVyYXRlTGF5ZXJzKGxheWVycykge1xuICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBsYXllcnMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobGF5ZXJzW2ldLnR5ID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRleHRMYXllcihsYXllcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYW5pbWF0aW9uRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja1ZlcnNpb24obWluaW11bVZlcnNpb24sIGFuaW1hdGlvbkRhdGEudikpIHtcbiAgICAgICAgICAgICAgICAgIGl0ZXJhdGVMYXllcnMoYW5pbWF0aW9uRGF0YS5sYXllcnMpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uRGF0YS5hc3NldHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBhbmltYXRpb25EYXRhLmFzc2V0cy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkRhdGEuYXNzZXRzW2ldLmxheWVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZUxheWVycyhhbmltYXRpb25EYXRhLmFzc2V0c1tpXS5sYXllcnMpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgdmFyIGNoZWNrQ2hhcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBtaW5pbXVtVmVyc2lvbiA9IFs0LCA3LCA5OV07XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYW5pbWF0aW9uRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25EYXRhLmNoYXJzICYmICFjaGVja1ZlcnNpb24obWluaW11bVZlcnNpb24sIGFuaW1hdGlvbkRhdGEudikpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGFuaW1hdGlvbkRhdGEuY2hhcnMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXJEYXRhID0gYW5pbWF0aW9uRGF0YS5jaGFyc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckRhdGEuZGF0YSAmJiBjaGFyRGF0YS5kYXRhLnNoYXBlcykge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlU2hhcGVzKGNoYXJEYXRhLmRhdGEuc2hhcGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyRGF0YS5kYXRhLmlwID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyRGF0YS5kYXRhLm9wID0gOTk5OTk7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckRhdGEuZGF0YS5zdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckRhdGEuZGF0YS5zciA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckRhdGEuZGF0YS5rcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgazogWzAsIDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBrOiBbMTAwLCAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBrOiBbMCwgMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGs6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGs6IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFuaW1hdGlvbkRhdGEuY2hhcnNbaV0udCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhckRhdGEuZGF0YS5zaGFwZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5OiAnbm8nXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJEYXRhLmRhdGEuc2hhcGVzWzBdLml0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgazogWzAsIDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGs6IFsxMDAsIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgazogWzAsIDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGs6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBvOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgazogMTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2s6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2E6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHk6ICd0cidcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgdmFyIGNoZWNrUGF0aFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBtaW5pbXVtVmVyc2lvbiA9IFs1LCA3LCAxNV07XG5cbiAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlVGV4dExheWVyKHRleHRMYXllcikge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHRleHRMYXllci50LnA7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhdGhEYXRhLmEgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICBwYXRoRGF0YS5hID0ge1xuICAgICAgICAgICAgICAgICAgICBhOiAwLFxuICAgICAgICAgICAgICAgICAgICBrOiBwYXRoRGF0YS5hXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGF0aERhdGEucCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgIHBhdGhEYXRhLnAgPSB7XG4gICAgICAgICAgICAgICAgICAgIGE6IDAsXG4gICAgICAgICAgICAgICAgICAgIGs6IHBhdGhEYXRhLnBcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXRoRGF0YS5yID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgcGF0aERhdGEuciA9IHtcbiAgICAgICAgICAgICAgICAgICAgYTogMCxcbiAgICAgICAgICAgICAgICAgICAgazogcGF0aERhdGEuclxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmdW5jdGlvbiBpdGVyYXRlTGF5ZXJzKGxheWVycykge1xuICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBsYXllcnMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobGF5ZXJzW2ldLnR5ID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRleHRMYXllcihsYXllcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYW5pbWF0aW9uRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja1ZlcnNpb24obWluaW11bVZlcnNpb24sIGFuaW1hdGlvbkRhdGEudikpIHtcbiAgICAgICAgICAgICAgICAgIGl0ZXJhdGVMYXllcnMoYW5pbWF0aW9uRGF0YS5sYXllcnMpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uRGF0YS5hc3NldHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBhbmltYXRpb25EYXRhLmFzc2V0cy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkRhdGEuYXNzZXRzW2ldLmxheWVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZUxheWVycyhhbmltYXRpb25EYXRhLmFzc2V0c1tpXS5sYXllcnMpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgdmFyIGNoZWNrQ29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgbWluaW11bVZlcnNpb24gPSBbNCwgMSwgOV07XG5cbiAgICAgICAgICAgICAgZnVuY3Rpb24gaXRlcmF0ZVNoYXBlcyhzaGFwZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gc2hhcGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgajtcbiAgICAgICAgICAgICAgICB2YXIgakxlbjtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ2dyJykge1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRlU2hhcGVzKHNoYXBlc1tpXS5pdCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ2ZsJyB8fCBzaGFwZXNbaV0udHkgPT09ICdzdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlc1tpXS5jLmsgJiYgc2hhcGVzW2ldLmMua1swXS5pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgakxlbiA9IHNoYXBlc1tpXS5jLmsubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlc1tpXS5jLmtbal0ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLnNbMF0gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLnNbMV0gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLnNbMl0gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLnNbM10gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcGVzW2ldLmMua1tqXS5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbal0uZVswXSAvPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbal0uZVsxXSAvPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbal0uZVsyXSAvPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbal0uZVszXSAvPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbMF0gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbMV0gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbMl0gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbM10gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZnVuY3Rpb24gaXRlcmF0ZUxheWVycyhsYXllcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gbGF5ZXJzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGxheWVyc1tpXS50eSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRlU2hhcGVzKGxheWVyc1tpXS5zaGFwZXMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYW5pbWF0aW9uRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja1ZlcnNpb24obWluaW11bVZlcnNpb24sIGFuaW1hdGlvbkRhdGEudikpIHtcbiAgICAgICAgICAgICAgICAgIGl0ZXJhdGVMYXllcnMoYW5pbWF0aW9uRGF0YS5sYXllcnMpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uRGF0YS5hc3NldHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBhbmltYXRpb25EYXRhLmFzc2V0cy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkRhdGEuYXNzZXRzW2ldLmxheWVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZUxheWVycyhhbmltYXRpb25EYXRhLmFzc2V0c1tpXS5sYXllcnMpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgdmFyIGNoZWNrU2hhcGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgbWluaW11bVZlcnNpb24gPSBbNCwgNCwgMThdO1xuXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlQ2xvc2luZ1NoYXBlcyhhcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgajtcbiAgICAgICAgICAgICAgICB2YXIgakxlbjtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoYXJyW2ldLnR5ID09PSAnc2gnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcnJbaV0ua3Muay5pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYXJyW2ldLmtzLmsuYyA9IGFycltpXS5jbG9zZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgakxlbiA9IGFycltpXS5rcy5rLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcnJbaV0ua3Mua1tqXS5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFycltpXS5rcy5rW2pdLnNbMF0uYyA9IGFycltpXS5jbG9zZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcnJbaV0ua3Mua1tqXS5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFycltpXS5rcy5rW2pdLmVbMF0uYyA9IGFycltpXS5jbG9zZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFycltpXS50eSA9PT0gJ2dyJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUNsb3NpbmdTaGFwZXMoYXJyW2ldLml0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmdW5jdGlvbiBpdGVyYXRlTGF5ZXJzKGxheWVycykge1xuICAgICAgICAgICAgICAgIHZhciBsYXllckRhdGE7XG4gICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IGxheWVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIGo7XG4gICAgICAgICAgICAgICAgdmFyIGpMZW47XG4gICAgICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICAgICAgdmFyIGtMZW47XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgIGxheWVyRGF0YSA9IGxheWVyc1tpXTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGxheWVyRGF0YS5oYXNNYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXNrUHJvcHMgPSBsYXllckRhdGEubWFza3NQcm9wZXJ0aWVzO1xuICAgICAgICAgICAgICAgICAgICBqTGVuID0gbWFza1Byb3BzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2tQcm9wc1tqXS5wdC5rLmkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tQcm9wc1tqXS5wdC5rLmMgPSBtYXNrUHJvcHNbal0uY2w7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtMZW4gPSBtYXNrUHJvcHNbal0ucHQuay5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBrTGVuOyBrICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2tQcm9wc1tqXS5wdC5rW2tdLnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrUHJvcHNbal0ucHQua1trXS5zWzBdLmMgPSBtYXNrUHJvcHNbal0uY2w7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFza1Byb3BzW2pdLnB0Lmtba10uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tQcm9wc1tqXS5wdC5rW2tdLmVbMF0uYyA9IG1hc2tQcm9wc1tqXS5jbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAobGF5ZXJEYXRhLnR5ID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlQ2xvc2luZ1NoYXBlcyhsYXllckRhdGEuc2hhcGVzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFuaW1hdGlvbkRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tWZXJzaW9uKG1pbmltdW1WZXJzaW9uLCBhbmltYXRpb25EYXRhLnYpKSB7XG4gICAgICAgICAgICAgICAgICBpdGVyYXRlTGF5ZXJzKGFuaW1hdGlvbkRhdGEubGF5ZXJzKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkRhdGEuYXNzZXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gYW5pbWF0aW9uRGF0YS5hc3NldHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25EYXRhLmFzc2V0c1tpXS5sYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGVMYXllcnMoYW5pbWF0aW9uRGF0YS5hc3NldHNbaV0ubGF5ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlRGF0YShhbmltYXRpb25EYXRhKSB7XG4gICAgICAgICAgICAgIGlmIChhbmltYXRpb25EYXRhLl9fY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjaGVja0NvbG9ycyhhbmltYXRpb25EYXRhKTtcbiAgICAgICAgICAgICAgY2hlY2tUZXh0KGFuaW1hdGlvbkRhdGEpO1xuICAgICAgICAgICAgICBjaGVja0NoYXJzKGFuaW1hdGlvbkRhdGEpO1xuICAgICAgICAgICAgICBjaGVja1BhdGhQcm9wZXJ0aWVzKGFuaW1hdGlvbkRhdGEpO1xuICAgICAgICAgICAgICBjaGVja1NoYXBlcyhhbmltYXRpb25EYXRhKTtcbiAgICAgICAgICAgICAgY29tcGxldGVMYXllcnMoYW5pbWF0aW9uRGF0YS5sYXllcnMsIGFuaW1hdGlvbkRhdGEuYXNzZXRzKTtcbiAgICAgICAgICAgICAgY29tcGxldGVDaGFycyhhbmltYXRpb25EYXRhLmNoYXJzLCBhbmltYXRpb25EYXRhLmFzc2V0cyk7XG4gICAgICAgICAgICAgIGFuaW1hdGlvbkRhdGEuX19jb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlVGV4dChkYXRhKSB7XG4gICAgICAgICAgICAgIGlmIChkYXRhLnQuYS5sZW5ndGggPT09IDAgJiYgISgnbScgaW4gZGF0YS50LnApKSB7Ly8gZGF0YS5zaW5nbGVTaGFwZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1vZHVsZU9iID0ge307XG4gICAgICAgICAgICBtb2R1bGVPYi5jb21wbGV0ZURhdGEgPSBjb21wbGV0ZURhdGE7XG4gICAgICAgICAgICBtb2R1bGVPYi5jaGVja0NvbG9ycyA9IGNoZWNrQ29sb3JzO1xuICAgICAgICAgICAgbW9kdWxlT2IuY2hlY2tDaGFycyA9IGNoZWNrQ2hhcnM7XG4gICAgICAgICAgICBtb2R1bGVPYi5jaGVja1BhdGhQcm9wZXJ0aWVzID0gY2hlY2tQYXRoUHJvcGVydGllcztcbiAgICAgICAgICAgIG1vZHVsZU9iLmNoZWNrU2hhcGVzID0gY2hlY2tTaGFwZXM7XG4gICAgICAgICAgICBtb2R1bGVPYi5jb21wbGV0ZUxheWVycyA9IGNvbXBsZXRlTGF5ZXJzO1xuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZU9iO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghX3dvcmtlclNlbGYuZGF0YU1hbmFnZXIpIHtcbiAgICAgICAgICAgIF93b3JrZXJTZWxmLmRhdGFNYW5hZ2VyID0gZGF0YUZ1bmN0aW9uTWFuYWdlcigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghX3dvcmtlclNlbGYuYXNzZXRMb2FkZXIpIHtcbiAgICAgICAgICAgIF93b3JrZXJTZWxmLmFzc2V0TG9hZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBmdW5jdGlvbiBmb3JtYXRSZXNwb25zZSh4aHIpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2luZyB0eXBlb2YgZG91YmxlcyB0aGUgdGltZSBvZiBleGVjdXRpb24gb2YgdGhpcyBtZXRob2QsXG4gICAgICAgICAgICAgICAgLy8gc28gaWYgYXZhaWxhYmxlLCBpdCdzIGJldHRlciB0byB1c2UgdGhlIGhlYWRlciB0byB2YWxpZGF0ZSB0aGUgdHlwZVxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50VHlwZUhlYWRlciA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC10eXBlJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGVIZWFkZXIgJiYgeGhyLnJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nICYmIGNvbnRlbnRUeXBlSGVhZGVyLmluZGV4T2YoJ2pzb24nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB4aHIucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHhoci5yZXNwb25zZSAmJiBfdHlwZW9mJDUoeGhyLnJlc3BvbnNlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB4aHIucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHhoci5yZXNwb25zZSAmJiB0eXBlb2YgeGhyLnJlc3BvbnNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoeGhyLnJlc3BvbnNlVGV4dCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmdW5jdGlvbiBsb2FkQXNzZXQocGF0aCwgZnVsbFBhdGgsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTsgLy8gc2V0IHJlc3BvbnNlVHlwZSBhZnRlciBjYWxsaW5nIG9wZW4gb3IgSUUgd2lsbCBicmVhay5cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGlzIGNyYXNoZXMgb24gQW5kcm9pZCBXZWJWaWV3IHByaW9yIHRvIEtpdEthdFxuICAgICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcblxuXG4gICAgICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBmb3JtYXRSZXNwb25zZSh4aHIpO1xuICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBmb3JtYXRSZXNwb25zZSh4aHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgLy8gSGFjayB0byB3b3JrYXJvdW5kIGJhbm5lciB2YWxpZGF0aW9uXG4gICAgICAgICAgICAgICAgICB4aHIub3BlbihbJ0cnLCAnRScsICdUJ10uam9pbignJyksIHBhdGgsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAvLyBIYWNrIHRvIHdvcmthcm91bmQgYmFubmVyIHZhbGlkYXRpb25cbiAgICAgICAgICAgICAgICAgIHhoci5vcGVuKFsnRycsICdFJywgJ1QnXS5qb2luKCcnKSwgZnVsbFBhdGggKyAnLycgKyBwYXRoLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsb2FkOiBsb2FkQXNzZXRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZS5kYXRhLnR5cGUgPT09ICdsb2FkQW5pbWF0aW9uJykge1xuICAgICAgICAgICAgX3dvcmtlclNlbGYuYXNzZXRMb2FkZXIubG9hZChlLmRhdGEucGF0aCwgZS5kYXRhLmZ1bGxQYXRoLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICBfd29ya2VyU2VsZi5kYXRhTWFuYWdlci5jb21wbGV0ZURhdGEoZGF0YSk7XG5cbiAgICAgICAgICAgICAgX3dvcmtlclNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiBlLmRhdGEuaWQsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogZGF0YSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdzdWNjZXNzJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3dvcmtlclNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiBlLmRhdGEuaWQsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAnZXJyb3InXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEudHlwZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IGUuZGF0YS5hbmltYXRpb247XG5cbiAgICAgICAgICAgIF93b3JrZXJTZWxmLmRhdGFNYW5hZ2VyLmNvbXBsZXRlRGF0YShhbmltYXRpb24pO1xuXG4gICAgICAgICAgICBfd29ya2VyU2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIGlkOiBlLmRhdGEuaWQsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IGFuaW1hdGlvbixcbiAgICAgICAgICAgICAgc3RhdHVzOiAnc3VjY2VzcydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLnR5cGUgPT09ICdsb2FkRGF0YScpIHtcbiAgICAgICAgICAgIF93b3JrZXJTZWxmLmFzc2V0TG9hZGVyLmxvYWQoZS5kYXRhLnBhdGgsIGUuZGF0YS5mdWxsUGF0aCwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgX3dvcmtlclNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiBlLmRhdGEuaWQsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogZGF0YSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdzdWNjZXNzJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3dvcmtlclNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiBlLmRhdGEuaWQsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAnZXJyb3InXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB3b3JrZXJJbnN0YW5jZS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgdmFyIGlkID0gZGF0YS5pZDtcbiAgICAgICAgICB2YXIgcHJvY2VzcyA9IHByb2Nlc3Nlc1tpZF07XG4gICAgICAgICAgcHJvY2Vzc2VzW2lkXSA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoZGF0YS5zdGF0dXMgPT09ICdzdWNjZXNzJykge1xuICAgICAgICAgICAgcHJvY2Vzcy5vbkNvbXBsZXRlKGRhdGEucGF5bG9hZCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLm9uRXJyb3IpIHtcbiAgICAgICAgICAgIHByb2Nlc3Mub25FcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQcm9jZXNzKG9uQ29tcGxldGUsIG9uRXJyb3IpIHtcbiAgICAgIF9jb3VudGVySWQgKz0gMTtcbiAgICAgIHZhciBpZCA9ICdwcm9jZXNzSWRfJyArIF9jb3VudGVySWQ7XG4gICAgICBwcm9jZXNzZXNbaWRdID0ge1xuICAgICAgICBvbkNvbXBsZXRlOiBvbkNvbXBsZXRlLFxuICAgICAgICBvbkVycm9yOiBvbkVycm9yXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRBbmltYXRpb24ocGF0aCwgb25Db21wbGV0ZSwgb25FcnJvcikge1xuICAgICAgc2V0dXBXb3JrZXIoKTtcbiAgICAgIHZhciBwcm9jZXNzSWQgPSBjcmVhdGVQcm9jZXNzKG9uQ29tcGxldGUsIG9uRXJyb3IpO1xuICAgICAgd29ya2VySW5zdGFuY2UucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiAnbG9hZEFuaW1hdGlvbicsXG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIGZ1bGxQYXRoOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICBpZDogcHJvY2Vzc0lkXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkRGF0YShwYXRoLCBvbkNvbXBsZXRlLCBvbkVycm9yKSB7XG4gICAgICBzZXR1cFdvcmtlcigpO1xuICAgICAgdmFyIHByb2Nlc3NJZCA9IGNyZWF0ZVByb2Nlc3Mob25Db21wbGV0ZSwgb25FcnJvcik7XG4gICAgICB3b3JrZXJJbnN0YW5jZS5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6ICdsb2FkRGF0YScsXG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIGZ1bGxQYXRoOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICBpZDogcHJvY2Vzc0lkXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wbGV0ZUFuaW1hdGlvbihhbmltLCBvbkNvbXBsZXRlLCBvbkVycm9yKSB7XG4gICAgICBzZXR1cFdvcmtlcigpO1xuICAgICAgdmFyIHByb2Nlc3NJZCA9IGNyZWF0ZVByb2Nlc3Mob25Db21wbGV0ZSwgb25FcnJvcik7XG4gICAgICB3b3JrZXJJbnN0YW5jZS5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6ICdjb21wbGV0ZScsXG4gICAgICAgIGFuaW1hdGlvbjogYW5pbSxcbiAgICAgICAgaWQ6IHByb2Nlc3NJZFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxvYWRBbmltYXRpb246IGxvYWRBbmltYXRpb24sXG4gICAgICBsb2FkRGF0YTogbG9hZERhdGEsXG4gICAgICBjb21wbGV0ZUFuaW1hdGlvbjogY29tcGxldGVBbmltYXRpb25cbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIEltYWdlUHJlbG9hZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm94eUltYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNhbnZhcyA9IGNyZWF0ZVRhZygnY2FudmFzJyk7XG4gICAgICBjYW52YXMud2lkdGggPSAxO1xuICAgICAgY2FudmFzLmhlaWdodCA9IDE7XG4gICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9KCk7XG5cbiAgICBmdW5jdGlvbiBpbWFnZUxvYWRlZCgpIHtcbiAgICAgIHRoaXMubG9hZGVkQXNzZXRzICs9IDE7XG5cbiAgICAgIGlmICh0aGlzLmxvYWRlZEFzc2V0cyA9PT0gdGhpcy50b3RhbEltYWdlcyAmJiB0aGlzLmxvYWRlZEZvb3RhZ2VzQ291bnQgPT09IHRoaXMudG90YWxGb290YWdlcykge1xuICAgICAgICBpZiAodGhpcy5pbWFnZXNMb2FkZWRDYikge1xuICAgICAgICAgIHRoaXMuaW1hZ2VzTG9hZGVkQ2IobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb290YWdlTG9hZGVkKCkge1xuICAgICAgdGhpcy5sb2FkZWRGb290YWdlc0NvdW50ICs9IDE7XG5cbiAgICAgIGlmICh0aGlzLmxvYWRlZEFzc2V0cyA9PT0gdGhpcy50b3RhbEltYWdlcyAmJiB0aGlzLmxvYWRlZEZvb3RhZ2VzQ291bnQgPT09IHRoaXMudG90YWxGb290YWdlcykge1xuICAgICAgICBpZiAodGhpcy5pbWFnZXNMb2FkZWRDYikge1xuICAgICAgICAgIHRoaXMuaW1hZ2VzTG9hZGVkQ2IobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRBc3NldHNQYXRoKGFzc2V0RGF0YSwgYXNzZXRzUGF0aCwgb3JpZ2luYWxQYXRoKSB7XG4gICAgICB2YXIgcGF0aCA9ICcnO1xuXG4gICAgICBpZiAoYXNzZXREYXRhLmUpIHtcbiAgICAgICAgcGF0aCA9IGFzc2V0RGF0YS5wO1xuICAgICAgfSBlbHNlIGlmIChhc3NldHNQYXRoKSB7XG4gICAgICAgIHZhciBpbWFnZVBhdGggPSBhc3NldERhdGEucDtcblxuICAgICAgICBpZiAoaW1hZ2VQYXRoLmluZGV4T2YoJ2ltYWdlcy8nKSAhPT0gLTEpIHtcbiAgICAgICAgICBpbWFnZVBhdGggPSBpbWFnZVBhdGguc3BsaXQoJy8nKVsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGggPSBhc3NldHNQYXRoICsgaW1hZ2VQYXRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aCA9IG9yaWdpbmFsUGF0aDtcbiAgICAgICAgcGF0aCArPSBhc3NldERhdGEudSA/IGFzc2V0RGF0YS51IDogJyc7XG4gICAgICAgIHBhdGggKz0gYXNzZXREYXRhLnA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RJbWFnZUxvYWRlZChpbWcpIHtcbiAgICAgIHZhciBfY291bnQgPSAwO1xuICAgICAgdmFyIGludGVydmFsSWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBib3ggPSBpbWcuZ2V0QkJveCgpO1xuXG4gICAgICAgIGlmIChib3gud2lkdGggfHwgX2NvdW50ID4gNTAwKSB7XG4gICAgICAgICAgdGhpcy5faW1hZ2VMb2FkZWQoKTtcblxuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgICAgIH1cblxuICAgICAgICBfY291bnQgKz0gMTtcbiAgICAgIH0uYmluZCh0aGlzKSwgNTApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUltYWdlRGF0YShhc3NldERhdGEpIHtcbiAgICAgIHZhciBwYXRoID0gZ2V0QXNzZXRzUGF0aChhc3NldERhdGEsIHRoaXMuYXNzZXRzUGF0aCwgdGhpcy5wYXRoKTtcbiAgICAgIHZhciBpbWcgPSBjcmVhdGVOUygnaW1hZ2UnKTtcblxuICAgICAgaWYgKGlzU2FmYXJpKSB7XG4gICAgICAgIHRoaXMudGVzdEltYWdlTG9hZGVkKGltZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2ltYWdlTG9hZGVkLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGltZy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2IuaW1nID0gcHJveHlJbWFnZTtcblxuICAgICAgICB0aGlzLl9pbWFnZUxvYWRlZCgpO1xuICAgICAgfS5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgICBpbWcuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCAnaHJlZicsIHBhdGgpO1xuXG4gICAgICBpZiAodGhpcy5fZWxlbWVudEhlbHBlci5hcHBlbmQpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudEhlbHBlci5hcHBlbmQoaW1nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRIZWxwZXIuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9iID0ge1xuICAgICAgICBpbWc6IGltZyxcbiAgICAgICAgYXNzZXREYXRhOiBhc3NldERhdGFcbiAgICAgIH07XG4gICAgICByZXR1cm4gb2I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW1nRGF0YShhc3NldERhdGEpIHtcbiAgICAgIHZhciBwYXRoID0gZ2V0QXNzZXRzUGF0aChhc3NldERhdGEsIHRoaXMuYXNzZXRzUGF0aCwgdGhpcy5wYXRoKTtcbiAgICAgIHZhciBpbWcgPSBjcmVhdGVUYWcoJ2ltZycpO1xuICAgICAgaW1nLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XG4gICAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2ltYWdlTG9hZGVkLCBmYWxzZSk7XG4gICAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9iLmltZyA9IHByb3h5SW1hZ2U7XG5cbiAgICAgICAgdGhpcy5faW1hZ2VMb2FkZWQoKTtcbiAgICAgIH0uYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgaW1nLnNyYyA9IHBhdGg7XG4gICAgICB2YXIgb2IgPSB7XG4gICAgICAgIGltZzogaW1nLFxuICAgICAgICBhc3NldERhdGE6IGFzc2V0RGF0YVxuICAgICAgfTtcbiAgICAgIHJldHVybiBvYjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGb290YWdlRGF0YShkYXRhKSB7XG4gICAgICB2YXIgb2IgPSB7XG4gICAgICAgIGFzc2V0RGF0YTogZGF0YVxuICAgICAgfTtcbiAgICAgIHZhciBwYXRoID0gZ2V0QXNzZXRzUGF0aChkYXRhLCB0aGlzLmFzc2V0c1BhdGgsIHRoaXMucGF0aCk7XG4gICAgICBkYXRhTWFuYWdlci5sb2FkRGF0YShwYXRoLCBmdW5jdGlvbiAoZm9vdGFnZURhdGEpIHtcbiAgICAgICAgb2IuaW1nID0gZm9vdGFnZURhdGE7XG5cbiAgICAgICAgdGhpcy5fZm9vdGFnZUxvYWRlZCgpO1xuICAgICAgfS5iaW5kKHRoaXMpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9iLmltZyA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2Zvb3RhZ2VMb2FkZWQoKTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICByZXR1cm4gb2I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZEFzc2V0cyhhc3NldHMsIGNiKSB7XG4gICAgICB0aGlzLmltYWdlc0xvYWRlZENiID0gY2I7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBhc3NldHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKCFhc3NldHNbaV0ubGF5ZXJzKSB7XG4gICAgICAgICAgaWYgKCFhc3NldHNbaV0udCB8fCBhc3NldHNbaV0udCA9PT0gJ3NlcScpIHtcbiAgICAgICAgICAgIHRoaXMudG90YWxJbWFnZXMgKz0gMTtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VzLnB1c2godGhpcy5fY3JlYXRlSW1hZ2VEYXRhKGFzc2V0c1tpXSkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYXNzZXRzW2ldLnQgPT09IDMpIHtcbiAgICAgICAgICAgIHRoaXMudG90YWxGb290YWdlcyArPSAxO1xuICAgICAgICAgICAgdGhpcy5pbWFnZXMucHVzaCh0aGlzLmNyZWF0ZUZvb3RhZ2VEYXRhKGFzc2V0c1tpXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFBhdGgocGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcGF0aCB8fCAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRBc3NldHNQYXRoKHBhdGgpIHtcbiAgICAgIHRoaXMuYXNzZXRzUGF0aCA9IHBhdGggfHwgJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QXNzZXQoYXNzZXREYXRhKSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgbGVuID0gdGhpcy5pbWFnZXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBpZiAodGhpcy5pbWFnZXNbaV0uYXNzZXREYXRhID09PSBhc3NldERhdGEpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pbWFnZXNbaV0uaW1nO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5pbWFnZXNMb2FkZWRDYiA9IG51bGw7XG4gICAgICB0aGlzLmltYWdlcy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRlZEltYWdlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvdGFsSW1hZ2VzID09PSB0aGlzLmxvYWRlZEFzc2V0cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkZWRGb290YWdlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvdGFsRm9vdGFnZXMgPT09IHRoaXMubG9hZGVkRm9vdGFnZXNDb3VudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRDYWNoZVR5cGUodHlwZSwgZWxlbWVudEhlbHBlcikge1xuICAgICAgaWYgKHR5cGUgPT09ICdzdmcnKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRIZWxwZXIgPSBlbGVtZW50SGVscGVyO1xuICAgICAgICB0aGlzLl9jcmVhdGVJbWFnZURhdGEgPSB0aGlzLmNyZWF0ZUltYWdlRGF0YS5iaW5kKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlSW1hZ2VEYXRhID0gdGhpcy5jcmVhdGVJbWdEYXRhLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSW1hZ2VQcmVsb2FkZXJGYWN0b3J5KCkge1xuICAgICAgdGhpcy5faW1hZ2VMb2FkZWQgPSBpbWFnZUxvYWRlZC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fZm9vdGFnZUxvYWRlZCA9IGZvb3RhZ2VMb2FkZWQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMudGVzdEltYWdlTG9hZGVkID0gdGVzdEltYWdlTG9hZGVkLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmNyZWF0ZUZvb3RhZ2VEYXRhID0gY3JlYXRlRm9vdGFnZURhdGEuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuYXNzZXRzUGF0aCA9ICcnO1xuICAgICAgdGhpcy5wYXRoID0gJyc7XG4gICAgICB0aGlzLnRvdGFsSW1hZ2VzID0gMDtcbiAgICAgIHRoaXMudG90YWxGb290YWdlcyA9IDA7XG4gICAgICB0aGlzLmxvYWRlZEFzc2V0cyA9IDA7XG4gICAgICB0aGlzLmxvYWRlZEZvb3RhZ2VzQ291bnQgPSAwO1xuICAgICAgdGhpcy5pbWFnZXNMb2FkZWRDYiA9IG51bGw7XG4gICAgICB0aGlzLmltYWdlcyA9IFtdO1xuICAgIH1cblxuICAgIEltYWdlUHJlbG9hZGVyRmFjdG9yeS5wcm90b3R5cGUgPSB7XG4gICAgICBsb2FkQXNzZXRzOiBsb2FkQXNzZXRzLFxuICAgICAgc2V0QXNzZXRzUGF0aDogc2V0QXNzZXRzUGF0aCxcbiAgICAgIHNldFBhdGg6IHNldFBhdGgsXG4gICAgICBsb2FkZWRJbWFnZXM6IGxvYWRlZEltYWdlcyxcbiAgICAgIGxvYWRlZEZvb3RhZ2VzOiBsb2FkZWRGb290YWdlcyxcbiAgICAgIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gICAgICBnZXRBc3NldDogZ2V0QXNzZXQsXG4gICAgICBjcmVhdGVJbWdEYXRhOiBjcmVhdGVJbWdEYXRhLFxuICAgICAgY3JlYXRlSW1hZ2VEYXRhOiBjcmVhdGVJbWFnZURhdGEsXG4gICAgICBpbWFnZUxvYWRlZDogaW1hZ2VMb2FkZWQsXG4gICAgICBmb290YWdlTG9hZGVkOiBmb290YWdlTG9hZGVkLFxuICAgICAgc2V0Q2FjaGVUeXBlOiBzZXRDYWNoZVR5cGVcbiAgICB9O1xuICAgIHJldHVybiBJbWFnZVByZWxvYWRlckZhY3Rvcnk7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBCYXNlRXZlbnQoKSB7fVxuXG4gIEJhc2VFdmVudC5wcm90b3R5cGUgPSB7XG4gICAgdHJpZ2dlckV2ZW50OiBmdW5jdGlvbiB0cmlnZ2VyRXZlbnQoZXZlbnROYW1lLCBhcmdzKSB7XG4gICAgICBpZiAodGhpcy5fY2JzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2Nic1tldmVudE5hbWVdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgY2FsbGJhY2tzW2ldKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmICghdGhpcy5fY2JzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgdGhpcy5fY2JzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2JzW2V2ZW50TmFtZV0ucHVzaChjYWxsYmFjayk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIH0uYmluZCh0aGlzKTtcbiAgICB9LFxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9jYnNbZXZlbnROYW1lXSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2Nic1tldmVudE5hbWVdKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuX2Nic1tldmVudE5hbWVdLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgIGlmICh0aGlzLl9jYnNbZXZlbnROYW1lXVtpXSA9PT0gY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX2Nic1tldmVudE5hbWVdLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgbGVuIC09IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jYnNbZXZlbnROYW1lXS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl9jYnNbZXZlbnROYW1lXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIG1hcmtlclBhcnNlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBwYXJzZVBheWxvYWRMaW5lcyhwYXlsb2FkKSB7XG4gICAgICB2YXIgbGluZXMgPSBwYXlsb2FkLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgIHZhciBrZXlzID0ge307XG4gICAgICB2YXIgbGluZTtcbiAgICAgIHZhciBrZXlzQ291bnQgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxpbmUgPSBsaW5lc1tpXS5zcGxpdCgnOicpO1xuXG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGtleXNbbGluZVswXV0gPSBsaW5lWzFdLnRyaW0oKTtcbiAgICAgICAgICBrZXlzQ291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoa2V5c0NvdW50ID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ga2V5cztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKF9tYXJrZXJzKSB7XG4gICAgICB2YXIgbWFya2VycyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9tYXJrZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBfbWFya2VyID0gX21hcmtlcnNbaV07XG4gICAgICAgIHZhciBtYXJrZXJEYXRhID0ge1xuICAgICAgICAgIHRpbWU6IF9tYXJrZXIudG0sXG4gICAgICAgICAgZHVyYXRpb246IF9tYXJrZXIuZHJcbiAgICAgICAgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIG1hcmtlckRhdGEucGF5bG9hZCA9IEpTT04ucGFyc2UoX21hcmtlcnNbaV0uY20pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1hcmtlckRhdGEucGF5bG9hZCA9IHBhcnNlUGF5bG9hZExpbmVzKF9tYXJrZXJzW2ldLmNtKTtcbiAgICAgICAgICB9IGNhdGNoIChfXykge1xuICAgICAgICAgICAgbWFya2VyRGF0YS5wYXlsb2FkID0ge1xuICAgICAgICAgICAgICBuYW1lOiBfbWFya2Vyc1tpXS5jbVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtYXJrZXJzLnB1c2gobWFya2VyRGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgUHJvamVjdEludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiByZWdpc3RlckNvbXBvc2l0aW9uKGNvbXApIHtcbiAgICAgIHRoaXMuY29tcG9zaXRpb25zLnB1c2goY29tcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF90aGlzUHJvamVjdEZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5jb21wb3NpdGlvbnMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY29tcG9zaXRpb25zW2ldLmRhdGEgJiYgdGhpcy5jb21wb3NpdGlvbnNbaV0uZGF0YS5ubSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9zaXRpb25zW2ldLnByZXBhcmVGcmFtZSAmJiB0aGlzLmNvbXBvc2l0aW9uc1tpXS5kYXRhLnh0KSB7XG4gICAgICAgICAgICAgIHRoaXMuY29tcG9zaXRpb25zW2ldLnByZXBhcmVGcmFtZSh0aGlzLmN1cnJlbnRGcmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBvc2l0aW9uc1tpXS5jb21wSW50ZXJmYWNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBfdGhpc1Byb2plY3RGdW5jdGlvbi5jb21wb3NpdGlvbnMgPSBbXTtcbiAgICAgIF90aGlzUHJvamVjdEZ1bmN0aW9uLmN1cnJlbnRGcmFtZSA9IDA7XG4gICAgICBfdGhpc1Byb2plY3RGdW5jdGlvbi5yZWdpc3RlckNvbXBvc2l0aW9uID0gcmVnaXN0ZXJDb21wb3NpdGlvbjtcbiAgICAgIHJldHVybiBfdGhpc1Byb2plY3RGdW5jdGlvbjtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIHJlbmRlcmVycyA9IHt9O1xuXG4gIHZhciByZWdpc3RlclJlbmRlcmVyID0gZnVuY3Rpb24gcmVnaXN0ZXJSZW5kZXJlcihrZXksIHZhbHVlKSB7XG4gICAgcmVuZGVyZXJzW2tleV0gPSB2YWx1ZTtcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRSZW5kZXJlcihrZXkpIHtcbiAgICByZXR1cm4gcmVuZGVyZXJzW2tleV07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSZWdpc3RlcmVkUmVuZGVyZXIoKSB7XG4gICAgLy8gUmV0dXJucyBjYW52YXMgYnkgZGVmYXVsdCBmb3IgY29tcGF0aWJpbGl0eVxuICAgIGlmIChyZW5kZXJlcnMuY2FudmFzKSB7XG4gICAgICByZXR1cm4gJ2NhbnZhcyc7XG4gICAgfSAvLyBSZXR1cm5zIGFueSByZW5kZXJlciB0aGF0IGlzIHJlZ2lzdGVyZWRcblxuXG4gICAgZm9yICh2YXIga2V5IGluIHJlbmRlcmVycykge1xuICAgICAgaWYgKHJlbmRlcmVyc1trZXldKSB7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgZnVuY3Rpb24gX3R5cGVvZiQ0KG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mJDQgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiQ0ID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2YkNChvYmopOyB9XG5cbiAgdmFyIEFuaW1hdGlvbkl0ZW0gPSBmdW5jdGlvbiBBbmltYXRpb25JdGVtKCkge1xuICAgIHRoaXMuX2NicyA9IFtdO1xuICAgIHRoaXMubmFtZSA9ICcnO1xuICAgIHRoaXMucGF0aCA9ICcnO1xuICAgIHRoaXMuaXNMb2FkZWQgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XG4gICAgdGhpcy5jdXJyZW50UmF3RnJhbWUgPSAwO1xuICAgIHRoaXMuZmlyc3RGcmFtZSA9IDA7XG4gICAgdGhpcy50b3RhbEZyYW1lcyA9IDA7XG4gICAgdGhpcy5mcmFtZVJhdGUgPSAwO1xuICAgIHRoaXMuZnJhbWVNdWx0ID0gMDtcbiAgICB0aGlzLnBsYXlTcGVlZCA9IDE7XG4gICAgdGhpcy5wbGF5RGlyZWN0aW9uID0gMTtcbiAgICB0aGlzLnBsYXlDb3VudCA9IDA7XG4gICAgdGhpcy5hbmltYXRpb25EYXRhID0ge307XG4gICAgdGhpcy5hc3NldHMgPSBbXTtcbiAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLmF1dG9wbGF5ID0gZmFsc2U7XG4gICAgdGhpcy5sb29wID0gdHJ1ZTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLmFuaW1hdGlvbklEID0gY3JlYXRlRWxlbWVudElEKCk7XG4gICAgdGhpcy5hc3NldHNQYXRoID0gJyc7XG4gICAgdGhpcy50aW1lQ29tcGxldGVkID0gMDtcbiAgICB0aGlzLnNlZ21lbnRQb3MgPSAwO1xuICAgIHRoaXMuaXNTdWJmcmFtZUVuYWJsZWQgPSBnZXRTdWJmcmFtZUVuYWJsZWQoKTtcbiAgICB0aGlzLnNlZ21lbnRzID0gW107XG4gICAgdGhpcy5faWRsZSA9IHRydWU7XG4gICAgdGhpcy5fY29tcGxldGVkTG9vcCA9IGZhbHNlO1xuICAgIHRoaXMucHJvamVjdEludGVyZmFjZSA9IFByb2plY3RJbnRlcmZhY2UoKTtcbiAgICB0aGlzLmltYWdlUHJlbG9hZGVyID0gbmV3IEltYWdlUHJlbG9hZGVyKCk7XG4gICAgdGhpcy5hdWRpb0NvbnRyb2xsZXIgPSBhdWRpb0NvbnRyb2xsZXJGYWN0b3J5KCk7XG4gICAgdGhpcy5tYXJrZXJzID0gW107XG4gICAgdGhpcy5jb25maWdBbmltYXRpb24gPSB0aGlzLmNvbmZpZ0FuaW1hdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25TZXR1cEVycm9yID0gdGhpcy5vblNldHVwRXJyb3IuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uU2VnbWVudENvbXBsZXRlID0gdGhpcy5vblNlZ21lbnRDb21wbGV0ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZHJhd25GcmFtZUV2ZW50ID0gbmV3IEJNRW50ZXJGcmFtZUV2ZW50KCdkcmF3bkZyYW1lJywgMCwgMCwgMCk7XG4gICAgdGhpcy5leHByZXNzaW9uc1BsdWdpbiA9IGdldEV4cHJlc3Npb25zUGx1Z2luKCk7XG4gIH07XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlRXZlbnRdLCBBbmltYXRpb25JdGVtKTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5zZXRQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcy53cmFwcGVyIHx8IHBhcmFtcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMud3JhcHBlciA9IHBhcmFtcy53cmFwcGVyIHx8IHBhcmFtcy5jb250YWluZXI7XG4gICAgfVxuXG4gICAgdmFyIGFuaW1UeXBlID0gJ3N2Zyc7XG5cbiAgICBpZiAocGFyYW1zLmFuaW1UeXBlKSB7XG4gICAgICBhbmltVHlwZSA9IHBhcmFtcy5hbmltVHlwZTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5yZW5kZXJlcikge1xuICAgICAgYW5pbVR5cGUgPSBwYXJhbXMucmVuZGVyZXI7XG4gICAgfVxuXG4gICAgdmFyIFJlbmRlcmVyQ2xhc3MgPSBnZXRSZW5kZXJlcihhbmltVHlwZSk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBSZW5kZXJlckNsYXNzKHRoaXMsIHBhcmFtcy5yZW5kZXJlclNldHRpbmdzKTtcbiAgICB0aGlzLmltYWdlUHJlbG9hZGVyLnNldENhY2hlVHlwZShhbmltVHlwZSwgdGhpcy5yZW5kZXJlci5nbG9iYWxEYXRhLmRlZnMpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0UHJvamVjdEludGVyZmFjZSh0aGlzLnByb2plY3RJbnRlcmZhY2UpO1xuICAgIHRoaXMuYW5pbVR5cGUgPSBhbmltVHlwZTtcblxuICAgIGlmIChwYXJhbXMubG9vcCA9PT0gJycgfHwgcGFyYW1zLmxvb3AgPT09IG51bGwgfHwgcGFyYW1zLmxvb3AgPT09IHVuZGVmaW5lZCB8fCBwYXJhbXMubG9vcCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5sb29wID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5sb29wID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5sb29wID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9vcCA9IHBhcnNlSW50KHBhcmFtcy5sb29wLCAxMCk7XG4gICAgfVxuXG4gICAgdGhpcy5hdXRvcGxheSA9ICdhdXRvcGxheScgaW4gcGFyYW1zID8gcGFyYW1zLmF1dG9wbGF5IDogdHJ1ZTtcbiAgICB0aGlzLm5hbWUgPSBwYXJhbXMubmFtZSA/IHBhcmFtcy5uYW1lIDogJyc7XG4gICAgdGhpcy5hdXRvbG9hZFNlZ21lbnRzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtcywgJ2F1dG9sb2FkU2VnbWVudHMnKSA/IHBhcmFtcy5hdXRvbG9hZFNlZ21lbnRzIDogdHJ1ZTtcbiAgICB0aGlzLmFzc2V0c1BhdGggPSBwYXJhbXMuYXNzZXRzUGF0aDtcbiAgICB0aGlzLmluaXRpYWxTZWdtZW50ID0gcGFyYW1zLmluaXRpYWxTZWdtZW50O1xuXG4gICAgaWYgKHBhcmFtcy5hdWRpb0ZhY3RvcnkpIHtcbiAgICAgIHRoaXMuYXVkaW9Db250cm9sbGVyLnNldEF1ZGlvRmFjdG9yeShwYXJhbXMuYXVkaW9GYWN0b3J5KTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmFuaW1hdGlvbkRhdGEpIHtcbiAgICAgIHRoaXMuc2V0dXBBbmltYXRpb24ocGFyYW1zLmFuaW1hdGlvbkRhdGEpO1xuICAgIH0gZWxzZSBpZiAocGFyYW1zLnBhdGgpIHtcbiAgICAgIGlmIChwYXJhbXMucGF0aC5sYXN0SW5kZXhPZignXFxcXCcpICE9PSAtMSkge1xuICAgICAgICB0aGlzLnBhdGggPSBwYXJhbXMucGF0aC5zdWJzdHIoMCwgcGFyYW1zLnBhdGgubGFzdEluZGV4T2YoJ1xcXFwnKSArIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXRoID0gcGFyYW1zLnBhdGguc3Vic3RyKDAsIHBhcmFtcy5wYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5maWxlTmFtZSA9IHBhcmFtcy5wYXRoLnN1YnN0cihwYXJhbXMucGF0aC5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gICAgICB0aGlzLmZpbGVOYW1lID0gdGhpcy5maWxlTmFtZS5zdWJzdHIoMCwgdGhpcy5maWxlTmFtZS5sYXN0SW5kZXhPZignLmpzb24nKSk7XG4gICAgICBkYXRhTWFuYWdlci5sb2FkQW5pbWF0aW9uKHBhcmFtcy5wYXRoLCB0aGlzLmNvbmZpZ0FuaW1hdGlvbiwgdGhpcy5vblNldHVwRXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5vblNldHVwRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdkYXRhX2ZhaWxlZCcpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnNldHVwQW5pbWF0aW9uID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkYXRhTWFuYWdlci5jb21wbGV0ZUFuaW1hdGlvbihkYXRhLCB0aGlzLmNvbmZpZ0FuaW1hdGlvbik7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uICh3cmFwcGVyLCBhbmltYXRpb25EYXRhKSB7XG4gICAgaWYgKGFuaW1hdGlvbkRhdGEpIHtcbiAgICAgIGlmIChfdHlwZW9mJDQoYW5pbWF0aW9uRGF0YSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGFuaW1hdGlvbkRhdGEgPSBKU09OLnBhcnNlKGFuaW1hdGlvbkRhdGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICB3cmFwcGVyOiB3cmFwcGVyLFxuICAgICAgYW5pbWF0aW9uRGF0YTogYW5pbWF0aW9uRGF0YVxuICAgIH07XG4gICAgdmFyIHdyYXBwZXJBdHRyaWJ1dGVzID0gd3JhcHBlci5hdHRyaWJ1dGVzO1xuICAgIHBhcmFtcy5wYXRoID0gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW1hdGlvbi1wYXRoJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW1hdGlvbi1wYXRoJykudmFsdWUgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tcGF0aCcpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1wYXRoJykudmFsdWUgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLXBhdGgnKSA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tcGF0aCcpLnZhbHVlIDogJyc7XG4gICAgcGFyYW1zLmFuaW1UeXBlID0gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW0tdHlwZScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1hbmltLXR5cGUnKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS10eXBlJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLXR5cGUnKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tdHlwZScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tdHlwZScpLnZhbHVlIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLXJlbmRlcmVyJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLXJlbmRlcmVyJykudmFsdWUgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLXJlbmRlcmVyJykgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLXJlbmRlcmVyJykudmFsdWUgOiBnZXRSZWdpc3RlcmVkUmVuZGVyZXIoKSB8fCAnY2FudmFzJztcbiAgICB2YXIgbG9vcCA9IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1hbmltLWxvb3AnKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYW5pbS1sb29wJykudmFsdWUgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tbG9vcCcpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1sb29wJykudmFsdWUgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLWxvb3AnKSA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tbG9vcCcpLnZhbHVlIDogJyc7XG5cbiAgICBpZiAobG9vcCA9PT0gJ2ZhbHNlJykge1xuICAgICAgcGFyYW1zLmxvb3AgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGxvb3AgPT09ICd0cnVlJykge1xuICAgICAgcGFyYW1zLmxvb3AgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAobG9vcCAhPT0gJycpIHtcbiAgICAgIHBhcmFtcy5sb29wID0gcGFyc2VJbnQobG9vcCwgMTApO1xuICAgIH1cblxuICAgIHZhciBhdXRvcGxheSA9IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1hbmltLWF1dG9wbGF5JykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW0tYXV0b3BsYXknKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1hdXRvcGxheScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1hdXRvcGxheScpLnZhbHVlIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1hdXRvcGxheScpID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1hdXRvcGxheScpLnZhbHVlIDogdHJ1ZTtcbiAgICBwYXJhbXMuYXV0b3BsYXkgPSBhdXRvcGxheSAhPT0gJ2ZhbHNlJztcbiAgICBwYXJhbXMubmFtZSA9IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1uYW1lJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLW5hbWUnKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1uYW1lJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLW5hbWUnKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tbmFtZScpID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1uYW1lJykudmFsdWUgOiAnJztcbiAgICB2YXIgcHJlcmVuZGVyID0gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW0tcHJlcmVuZGVyJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW0tcHJlcmVuZGVyJykudmFsdWUgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tcHJlcmVuZGVyJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLXByZXJlbmRlcicpLnZhbHVlIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1wcmVyZW5kZXInKSA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tcHJlcmVuZGVyJykudmFsdWUgOiAnJztcblxuICAgIGlmIChwcmVyZW5kZXIgPT09ICdmYWxzZScpIHtcbiAgICAgIHBhcmFtcy5wcmVyZW5kZXIgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5wYXRoKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2Rlc3Ryb3knKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRQYXJhbXMocGFyYW1zKTtcbiAgICB9XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuaW5jbHVkZUxheWVycyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKGRhdGEub3AgPiB0aGlzLmFuaW1hdGlvbkRhdGEub3ApIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uRGF0YS5vcCA9IGRhdGEub3A7XG4gICAgICB0aGlzLnRvdGFsRnJhbWVzID0gTWF0aC5mbG9vcihkYXRhLm9wIC0gdGhpcy5hbmltYXRpb25EYXRhLmlwKTtcbiAgICB9XG5cbiAgICB2YXIgbGF5ZXJzID0gdGhpcy5hbmltYXRpb25EYXRhLmxheWVycztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gbGF5ZXJzLmxlbmd0aDtcbiAgICB2YXIgbmV3TGF5ZXJzID0gZGF0YS5sYXllcnM7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW4gPSBuZXdMYXllcnMubGVuZ3RoO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIGlmIChsYXllcnNbaV0uaWQgPT09IG5ld0xheWVyc1tqXS5pZCkge1xuICAgICAgICAgIGxheWVyc1tpXSA9IG5ld0xheWVyc1tqXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGF0YS5jaGFycyB8fCBkYXRhLmZvbnRzKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuYWRkQ2hhcnMoZGF0YS5jaGFycyk7XG4gICAgICB0aGlzLnJlbmRlcmVyLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuYWRkRm9udHMoZGF0YS5mb250cywgdGhpcy5yZW5kZXJlci5nbG9iYWxEYXRhLmRlZnMpO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmFzc2V0cykge1xuICAgICAgbGVuID0gZGF0YS5hc3NldHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25EYXRhLmFzc2V0cy5wdXNoKGRhdGEuYXNzZXRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFuaW1hdGlvbkRhdGEuX19jb21wbGV0ZSA9IGZhbHNlO1xuICAgIGRhdGFNYW5hZ2VyLmNvbXBsZXRlQW5pbWF0aW9uKHRoaXMuYW5pbWF0aW9uRGF0YSwgdGhpcy5vblNlZ21lbnRDb21wbGV0ZSk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUub25TZWdtZW50Q29tcGxldGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRoaXMuYW5pbWF0aW9uRGF0YSA9IGRhdGE7XG4gICAgdmFyIGV4cHJlc3Npb25zUGx1Z2luID0gZ2V0RXhwcmVzc2lvbnNQbHVnaW4oKTtcblxuICAgIGlmIChleHByZXNzaW9uc1BsdWdpbikge1xuICAgICAgZXhwcmVzc2lvbnNQbHVnaW4uaW5pdEV4cHJlc3Npb25zKHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMubG9hZE5leHRTZWdtZW50KCk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUubG9hZE5leHRTZWdtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWdtZW50cyA9IHRoaXMuYW5pbWF0aW9uRGF0YS5zZWdtZW50cztcblxuICAgIGlmICghc2VnbWVudHMgfHwgc2VnbWVudHMubGVuZ3RoID09PSAwIHx8ICF0aGlzLmF1dG9sb2FkU2VnbWVudHMpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignZGF0YV9yZWFkeScpO1xuICAgICAgdGhpcy50aW1lQ29tcGxldGVkID0gdGhpcy50b3RhbEZyYW1lcztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzLnNoaWZ0KCk7XG4gICAgdGhpcy50aW1lQ29tcGxldGVkID0gc2VnbWVudC50aW1lICogdGhpcy5mcmFtZVJhdGU7XG4gICAgdmFyIHNlZ21lbnRQYXRoID0gdGhpcy5wYXRoICsgdGhpcy5maWxlTmFtZSArICdfJyArIHRoaXMuc2VnbWVudFBvcyArICcuanNvbic7XG4gICAgdGhpcy5zZWdtZW50UG9zICs9IDE7XG4gICAgZGF0YU1hbmFnZXIubG9hZERhdGEoc2VnbWVudFBhdGgsIHRoaXMuaW5jbHVkZUxheWVycy5iaW5kKHRoaXMpLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2RhdGFfZmFpbGVkJyk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5sb2FkU2VnbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlZ21lbnRzID0gdGhpcy5hbmltYXRpb25EYXRhLnNlZ21lbnRzO1xuXG4gICAgaWYgKCFzZWdtZW50cykge1xuICAgICAgdGhpcy50aW1lQ29tcGxldGVkID0gdGhpcy50b3RhbEZyYW1lcztcbiAgICB9XG5cbiAgICB0aGlzLmxvYWROZXh0U2VnbWVudCgpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmltYWdlc0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2xvYWRlZF9pbWFnZXMnKTtcbiAgICB0aGlzLmNoZWNrTG9hZGVkKCk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUucHJlbG9hZEltYWdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmltYWdlUHJlbG9hZGVyLnNldEFzc2V0c1BhdGgodGhpcy5hc3NldHNQYXRoKTtcbiAgICB0aGlzLmltYWdlUHJlbG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICB0aGlzLmltYWdlUHJlbG9hZGVyLmxvYWRBc3NldHModGhpcy5hbmltYXRpb25EYXRhLmFzc2V0cywgdGhpcy5pbWFnZXNMb2FkZWQuYmluZCh0aGlzKSk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuY29uZmlnQW5pbWF0aW9uID0gZnVuY3Rpb24gKGFuaW1EYXRhKSB7XG4gICAgaWYgKCF0aGlzLnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uRGF0YSA9IGFuaW1EYXRhO1xuXG4gICAgICBpZiAodGhpcy5pbml0aWFsU2VnbWVudCkge1xuICAgICAgICB0aGlzLnRvdGFsRnJhbWVzID0gTWF0aC5mbG9vcih0aGlzLmluaXRpYWxTZWdtZW50WzFdIC0gdGhpcy5pbml0aWFsU2VnbWVudFswXSk7XG4gICAgICAgIHRoaXMuZmlyc3RGcmFtZSA9IE1hdGgucm91bmQodGhpcy5pbml0aWFsU2VnbWVudFswXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRvdGFsRnJhbWVzID0gTWF0aC5mbG9vcih0aGlzLmFuaW1hdGlvbkRhdGEub3AgLSB0aGlzLmFuaW1hdGlvbkRhdGEuaXApO1xuICAgICAgICB0aGlzLmZpcnN0RnJhbWUgPSBNYXRoLnJvdW5kKHRoaXMuYW5pbWF0aW9uRGF0YS5pcCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVuZGVyZXIuY29uZmlnQW5pbWF0aW9uKGFuaW1EYXRhKTtcblxuICAgICAgaWYgKCFhbmltRGF0YS5hc3NldHMpIHtcbiAgICAgICAgYW5pbURhdGEuYXNzZXRzID0gW107XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXNzZXRzID0gdGhpcy5hbmltYXRpb25EYXRhLmFzc2V0cztcbiAgICAgIHRoaXMuZnJhbWVSYXRlID0gdGhpcy5hbmltYXRpb25EYXRhLmZyO1xuICAgICAgdGhpcy5mcmFtZU11bHQgPSB0aGlzLmFuaW1hdGlvbkRhdGEuZnIgLyAxMDAwO1xuICAgICAgdGhpcy5yZW5kZXJlci5zZWFyY2hFeHRyYUNvbXBvc2l0aW9ucyhhbmltRGF0YS5hc3NldHMpO1xuICAgICAgdGhpcy5tYXJrZXJzID0gbWFya2VyUGFyc2VyKGFuaW1EYXRhLm1hcmtlcnMgfHwgW10pO1xuICAgICAgdGhpcy50cmlnZ2VyKCdjb25maWdfcmVhZHknKTtcbiAgICAgIHRoaXMucHJlbG9hZEltYWdlcygpO1xuICAgICAgdGhpcy5sb2FkU2VnbWVudHMoKTtcbiAgICAgIHRoaXMudXBkYUZyYW1lTW9kaWZpZXIoKTtcbiAgICAgIHRoaXMud2FpdEZvckZvbnRzTG9hZGVkKCk7XG5cbiAgICAgIGlmICh0aGlzLmlzUGF1c2VkKSB7XG4gICAgICAgIHRoaXMuYXVkaW9Db250cm9sbGVyLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMudHJpZ2dlckNvbmZpZ0Vycm9yKGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUud2FpdEZvckZvbnRzTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5yZW5kZXJlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlbmRlcmVyLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuaXNMb2FkZWQpIHtcbiAgICAgIHRoaXMuY2hlY2tMb2FkZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dCh0aGlzLndhaXRGb3JGb250c0xvYWRlZC5iaW5kKHRoaXMpLCAyMCk7XG4gICAgfVxuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmNoZWNrTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc0xvYWRlZCAmJiB0aGlzLnJlbmRlcmVyLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuaXNMb2FkZWQgJiYgKHRoaXMuaW1hZ2VQcmVsb2FkZXIubG9hZGVkSW1hZ2VzKCkgfHwgdGhpcy5yZW5kZXJlci5yZW5kZXJlclR5cGUgIT09ICdjYW52YXMnKSAmJiB0aGlzLmltYWdlUHJlbG9hZGVyLmxvYWRlZEZvb3RhZ2VzKCkpIHtcbiAgICAgIHRoaXMuaXNMb2FkZWQgPSB0cnVlO1xuICAgICAgdmFyIGV4cHJlc3Npb25zUGx1Z2luID0gZ2V0RXhwcmVzc2lvbnNQbHVnaW4oKTtcblxuICAgICAgaWYgKGV4cHJlc3Npb25zUGx1Z2luKSB7XG4gICAgICAgIGV4cHJlc3Npb25zUGx1Z2luLmluaXRFeHByZXNzaW9ucyh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZW5kZXJlci5pbml0SXRlbXMoKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ0RPTUxvYWRlZCcpO1xuICAgICAgfS5iaW5kKHRoaXMpLCAwKTtcbiAgICAgIHRoaXMuZ290b0ZyYW1lKCk7XG5cbiAgICAgIGlmICh0aGlzLmF1dG9wbGF5KSB7XG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgIC8vIEFkZGluZyB0aGlzIHZhbGlkYXRpb24gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGluIGNhc2UgYW4gZXZlbnQgb2JqZWN0IHdhcyBiZWluZyBwYXNzZWQgZG93blxuICAgIHZhciBfd2lkdGggPSB0eXBlb2Ygd2lkdGggPT09ICdudW1iZXInID8gd2lkdGggOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgX2hlaWdodCA9IHR5cGVvZiBoZWlnaHQgPT09ICdudW1iZXInID8gaGVpZ2h0IDogdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5yZW5kZXJlci51cGRhdGVDb250YWluZXJTaXplKF93aWR0aCwgX2hlaWdodCk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2V0U3ViZnJhbWUgPSBmdW5jdGlvbiAoZmxhZykge1xuICAgIHRoaXMuaXNTdWJmcmFtZUVuYWJsZWQgPSAhIWZsYWc7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ290b0ZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY3VycmVudEZyYW1lID0gdGhpcy5pc1N1YmZyYW1lRW5hYmxlZCA/IHRoaXMuY3VycmVudFJhd0ZyYW1lIDogfn50aGlzLmN1cnJlbnRSYXdGcmFtZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1iaXR3aXNlXG5cbiAgICBpZiAodGhpcy50aW1lQ29tcGxldGVkICE9PSB0aGlzLnRvdGFsRnJhbWVzICYmIHRoaXMuY3VycmVudEZyYW1lID4gdGhpcy50aW1lQ29tcGxldGVkKSB7XG4gICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IHRoaXMudGltZUNvbXBsZXRlZDtcbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2VudGVyRnJhbWUnKTtcbiAgICB0aGlzLnJlbmRlckZyYW1lKCk7XG4gICAgdGhpcy50cmlnZ2VyKCdkcmF3bkZyYW1lJyk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNMb2FkZWQgPT09IGZhbHNlIHx8ICF0aGlzLnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmV4cHJlc3Npb25zUGx1Z2luKSB7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnNQbHVnaW4ucmVzZXRGcmFtZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbmRlcmVyLnJlbmRlckZyYW1lKHRoaXMuY3VycmVudEZyYW1lICsgdGhpcy5maXJzdEZyYW1lKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy50cmlnZ2VyUmVuZGVyRnJhbWVFcnJvcihlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzUGF1c2VkID09PSB0cnVlKSB7XG4gICAgICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XG4gICAgICB0aGlzLnRyaWdnZXIoJ19wbGF5Jyk7XG4gICAgICB0aGlzLmF1ZGlvQ29udHJvbGxlci5yZXN1bWUoKTtcblxuICAgICAgaWYgKHRoaXMuX2lkbGUpIHtcbiAgICAgICAgdGhpcy5faWRsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ19hY3RpdmUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzUGF1c2VkID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XG4gICAgICB0aGlzLnRyaWdnZXIoJ19wYXVzZScpO1xuICAgICAgdGhpcy5faWRsZSA9IHRydWU7XG4gICAgICB0aGlzLnRyaWdnZXIoJ19pZGxlJyk7XG4gICAgICB0aGlzLmF1ZGlvQ29udHJvbGxlci5wYXVzZSgpO1xuICAgIH1cbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS50b2dnbGVQYXVzZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUgJiYgdGhpcy5uYW1lICE9PSBuYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNQYXVzZWQgPT09IHRydWUpIHtcbiAgICAgIHRoaXMucGxheSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgfVxuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucGF1c2UoKTtcbiAgICB0aGlzLnBsYXlDb3VudCA9IDA7XG4gICAgdGhpcy5fY29tcGxldGVkTG9vcCA9IGZhbHNlO1xuICAgIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUoMCk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ2V0TWFya2VyRGF0YSA9IGZ1bmN0aW9uIChtYXJrZXJOYW1lKSB7XG4gICAgdmFyIG1hcmtlcjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXJrZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBtYXJrZXIgPSB0aGlzLm1hcmtlcnNbaV07XG5cbiAgICAgIGlmIChtYXJrZXIucGF5bG9hZCAmJiBtYXJrZXIucGF5bG9hZC5uYW1lID09PSBtYXJrZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ29Ub0FuZFN0b3AgPSBmdW5jdGlvbiAodmFsdWUsIGlzRnJhbWUsIG5hbWUpIHtcbiAgICBpZiAobmFtZSAmJiB0aGlzLm5hbWUgIT09IG5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbnVtVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuXG4gICAgaWYgKGlzTmFOKG51bVZhbHVlKSkge1xuICAgICAgdmFyIG1hcmtlciA9IHRoaXMuZ2V0TWFya2VyRGF0YSh2YWx1ZSk7XG5cbiAgICAgIGlmIChtYXJrZXIpIHtcbiAgICAgICAgdGhpcy5nb1RvQW5kU3RvcChtYXJrZXIudGltZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0ZyYW1lKSB7XG4gICAgICB0aGlzLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZSh2YWx1ZSAqIHRoaXMuZnJhbWVNb2RpZmllcik7XG4gICAgfVxuXG4gICAgdGhpcy5wYXVzZSgpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmdvVG9BbmRQbGF5ID0gZnVuY3Rpb24gKHZhbHVlLCBpc0ZyYW1lLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgJiYgdGhpcy5uYW1lICE9PSBuYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG51bVZhbHVlID0gTnVtYmVyKHZhbHVlKTtcblxuICAgIGlmIChpc05hTihudW1WYWx1ZSkpIHtcbiAgICAgIHZhciBtYXJrZXIgPSB0aGlzLmdldE1hcmtlckRhdGEodmFsdWUpO1xuXG4gICAgICBpZiAobWFya2VyKSB7XG4gICAgICAgIGlmICghbWFya2VyLmR1cmF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5nb1RvQW5kU3RvcChtYXJrZXIudGltZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wbGF5U2VnbWVudHMoW21hcmtlci50aW1lLCBtYXJrZXIudGltZSArIG1hcmtlci5kdXJhdGlvbl0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ29Ub0FuZFN0b3AobnVtVmFsdWUsIGlzRnJhbWUsIG5hbWUpO1xuICAgIH1cblxuICAgIHRoaXMucGxheSgpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmFkdmFuY2VUaW1lID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaXNQYXVzZWQgPT09IHRydWUgfHwgdGhpcy5pc0xvYWRlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFZhbHVlID0gdGhpcy5jdXJyZW50UmF3RnJhbWUgKyB2YWx1ZSAqIHRoaXMuZnJhbWVNb2RpZmllcjtcbiAgICB2YXIgX2lzQ29tcGxldGUgPSBmYWxzZTsgLy8gQ2hlY2tpbmcgaWYgbmV4dFZhbHVlID4gdG90YWxGcmFtZXMgLSAxIGZvciBhZGRyZXNzaW5nIG5vbiBsb29waW5nIGFuZCBsb29waW5nIGFuaW1hdGlvbnMuXG4gICAgLy8gSWYgYW5pbWF0aW9uIHdvbid0IGxvb3AsIGl0IHNob3VsZCBzdG9wIGF0IHRvdGFsRnJhbWVzIC0gMS4gSWYgaXQgd2lsbCBsb29wIGl0IHNob3VsZCBjb21wbGV0ZSB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlbiBsb29wLlxuXG4gICAgaWYgKG5leHRWYWx1ZSA+PSB0aGlzLnRvdGFsRnJhbWVzIC0gMSAmJiB0aGlzLmZyYW1lTW9kaWZpZXIgPiAwKSB7XG4gICAgICBpZiAoIXRoaXMubG9vcCB8fCB0aGlzLnBsYXlDb3VudCA9PT0gdGhpcy5sb29wKSB7XG4gICAgICAgIGlmICghdGhpcy5jaGVja1NlZ21lbnRzKG5leHRWYWx1ZSA+IHRoaXMudG90YWxGcmFtZXMgPyBuZXh0VmFsdWUgJSB0aGlzLnRvdGFsRnJhbWVzIDogMCkpIHtcbiAgICAgICAgICBfaXNDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgbmV4dFZhbHVlID0gdGhpcy50b3RhbEZyYW1lcyAtIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobmV4dFZhbHVlID49IHRoaXMudG90YWxGcmFtZXMpIHtcbiAgICAgICAgdGhpcy5wbGF5Q291bnQgKz0gMTtcblxuICAgICAgICBpZiAoIXRoaXMuY2hlY2tTZWdtZW50cyhuZXh0VmFsdWUgJSB0aGlzLnRvdGFsRnJhbWVzKSkge1xuICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUobmV4dFZhbHVlICUgdGhpcy50b3RhbEZyYW1lcyk7XG4gICAgICAgICAgdGhpcy5fY29tcGxldGVkTG9vcCA9IHRydWU7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdsb29wQ29tcGxldGUnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZShuZXh0VmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dFZhbHVlIDwgMCkge1xuICAgICAgaWYgKCF0aGlzLmNoZWNrU2VnbWVudHMobmV4dFZhbHVlICUgdGhpcy50b3RhbEZyYW1lcykpIHtcbiAgICAgICAgaWYgKHRoaXMubG9vcCAmJiAhKHRoaXMucGxheUNvdW50LS0gPD0gMCAmJiB0aGlzLmxvb3AgIT09IHRydWUpKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wbHVzcGx1c1xuICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUodGhpcy50b3RhbEZyYW1lcyArIG5leHRWYWx1ZSAlIHRoaXMudG90YWxGcmFtZXMpO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLl9jb21wbGV0ZWRMb29wKSB7XG4gICAgICAgICAgICB0aGlzLl9jb21wbGV0ZWRMb29wID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdsb29wQ29tcGxldGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2lzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgIG5leHRWYWx1ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZShuZXh0VmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChfaXNDb21wbGV0ZSkge1xuICAgICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZShuZXh0VmFsdWUpO1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdjb21wbGV0ZScpO1xuICAgIH1cbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5hZGp1c3RTZWdtZW50ID0gZnVuY3Rpb24gKGFyciwgb2Zmc2V0KSB7XG4gICAgdGhpcy5wbGF5Q291bnQgPSAwO1xuXG4gICAgaWYgKGFyclsxXSA8IGFyclswXSkge1xuICAgICAgaWYgKHRoaXMuZnJhbWVNb2RpZmllciA+IDApIHtcbiAgICAgICAgaWYgKHRoaXMucGxheVNwZWVkIDwgMCkge1xuICAgICAgICAgIHRoaXMuc2V0U3BlZWQoLXRoaXMucGxheVNwZWVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNldERpcmVjdGlvbigtMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy50b3RhbEZyYW1lcyA9IGFyclswXSAtIGFyclsxXTtcbiAgICAgIHRoaXMudGltZUNvbXBsZXRlZCA9IHRoaXMudG90YWxGcmFtZXM7XG4gICAgICB0aGlzLmZpcnN0RnJhbWUgPSBhcnJbMV07XG4gICAgICB0aGlzLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlKHRoaXMudG90YWxGcmFtZXMgLSAwLjAwMSAtIG9mZnNldCk7XG4gICAgfSBlbHNlIGlmIChhcnJbMV0gPiBhcnJbMF0pIHtcbiAgICAgIGlmICh0aGlzLmZyYW1lTW9kaWZpZXIgPCAwKSB7XG4gICAgICAgIGlmICh0aGlzLnBsYXlTcGVlZCA8IDApIHtcbiAgICAgICAgICB0aGlzLnNldFNwZWVkKC10aGlzLnBsYXlTcGVlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZXREaXJlY3Rpb24oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy50b3RhbEZyYW1lcyA9IGFyclsxXSAtIGFyclswXTtcbiAgICAgIHRoaXMudGltZUNvbXBsZXRlZCA9IHRoaXMudG90YWxGcmFtZXM7XG4gICAgICB0aGlzLmZpcnN0RnJhbWUgPSBhcnJbMF07XG4gICAgICB0aGlzLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlKDAuMDAxICsgb2Zmc2V0KTtcbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoJ3NlZ21lbnRTdGFydCcpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnNldFNlZ21lbnQgPSBmdW5jdGlvbiAoaW5pdCwgZW5kKSB7XG4gICAgdmFyIHBlbmRpbmdGcmFtZSA9IC0xO1xuXG4gICAgaWYgKHRoaXMuaXNQYXVzZWQpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRSYXdGcmFtZSArIHRoaXMuZmlyc3RGcmFtZSA8IGluaXQpIHtcbiAgICAgICAgcGVuZGluZ0ZyYW1lID0gaW5pdDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50UmF3RnJhbWUgKyB0aGlzLmZpcnN0RnJhbWUgPiBlbmQpIHtcbiAgICAgICAgcGVuZGluZ0ZyYW1lID0gZW5kIC0gaW5pdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZpcnN0RnJhbWUgPSBpbml0O1xuICAgIHRoaXMudG90YWxGcmFtZXMgPSBlbmQgLSBpbml0O1xuICAgIHRoaXMudGltZUNvbXBsZXRlZCA9IHRoaXMudG90YWxGcmFtZXM7XG5cbiAgICBpZiAocGVuZGluZ0ZyYW1lICE9PSAtMSkge1xuICAgICAgdGhpcy5nb1RvQW5kU3RvcChwZW5kaW5nRnJhbWUsIHRydWUpO1xuICAgIH1cbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5wbGF5U2VnbWVudHMgPSBmdW5jdGlvbiAoYXJyLCBmb3JjZUZsYWcpIHtcbiAgICBpZiAoZm9yY2VGbGFnKSB7XG4gICAgICB0aGlzLnNlZ21lbnRzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKF90eXBlb2YkNChhcnJbMF0pID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHRoaXMuc2VnbWVudHMucHVzaChhcnJbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlZ21lbnRzLnB1c2goYXJyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zZWdtZW50cy5sZW5ndGggJiYgZm9yY2VGbGFnKSB7XG4gICAgICB0aGlzLmFkanVzdFNlZ21lbnQodGhpcy5zZWdtZW50cy5zaGlmdCgpLCAwKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1BhdXNlZCkge1xuICAgICAgdGhpcy5wbGF5KCk7XG4gICAgfVxuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnJlc2V0U2VnbWVudHMgPSBmdW5jdGlvbiAoZm9yY2VGbGFnKSB7XG4gICAgdGhpcy5zZWdtZW50cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuc2VnbWVudHMucHVzaChbdGhpcy5hbmltYXRpb25EYXRhLmlwLCB0aGlzLmFuaW1hdGlvbkRhdGEub3BdKTtcblxuICAgIGlmIChmb3JjZUZsYWcpIHtcbiAgICAgIHRoaXMuY2hlY2tTZWdtZW50cygwKTtcbiAgICB9XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuY2hlY2tTZWdtZW50cyA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICBpZiAodGhpcy5zZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuYWRqdXN0U2VnbWVudCh0aGlzLnNlZ21lbnRzLnNoaWZ0KCksIG9mZnNldCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUgJiYgdGhpcy5uYW1lICE9PSBuYW1lIHx8ICF0aGlzLnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJlci5kZXN0cm95KCk7XG4gICAgdGhpcy5pbWFnZVByZWxvYWRlci5kZXN0cm95KCk7XG4gICAgdGhpcy50cmlnZ2VyKCdkZXN0cm95Jyk7XG4gICAgdGhpcy5fY2JzID0gbnVsbDtcbiAgICB0aGlzLm9uRW50ZXJGcmFtZSA9IG51bGw7XG4gICAgdGhpcy5vbkxvb3BDb21wbGV0ZSA9IG51bGw7XG4gICAgdGhpcy5vbkNvbXBsZXRlID0gbnVsbDtcbiAgICB0aGlzLm9uU2VnbWVudFN0YXJ0ID0gbnVsbDtcbiAgICB0aGlzLm9uRGVzdHJveSA9IG51bGw7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5leHByZXNzaW9uc1BsdWdpbiA9IG51bGw7XG4gICAgdGhpcy5pbWFnZVByZWxvYWRlciA9IG51bGw7XG4gICAgdGhpcy5wcm9qZWN0SW50ZXJmYWNlID0gbnVsbDtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuY3VycmVudFJhd0ZyYW1lID0gdmFsdWU7XG4gICAgdGhpcy5nb3RvRnJhbWUoKTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5zZXRTcGVlZCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLnBsYXlTcGVlZCA9IHZhbDtcbiAgICB0aGlzLnVwZGFGcmFtZU1vZGlmaWVyKCk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2V0RGlyZWN0aW9uID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHRoaXMucGxheURpcmVjdGlvbiA9IHZhbCA8IDAgPyAtMSA6IDE7XG4gICAgdGhpcy51cGRhRnJhbWVNb2RpZmllcigpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnNldExvb3AgPSBmdW5jdGlvbiAoaXNMb29waW5nKSB7XG4gICAgdGhpcy5sb29wID0gaXNMb29waW5nO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnNldFZvbHVtZSA9IGZ1bmN0aW9uICh2YWwsIG5hbWUpIHtcbiAgICBpZiAobmFtZSAmJiB0aGlzLm5hbWUgIT09IG5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmF1ZGlvQ29udHJvbGxlci5zZXRWb2x1bWUodmFsKTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5nZXRWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXVkaW9Db250cm9sbGVyLmdldFZvbHVtZSgpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLm11dGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYXVkaW9Db250cm9sbGVyLm11dGUoKTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS51bm11dGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYXVkaW9Db250cm9sbGVyLnVubXV0ZSgpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnVwZGFGcmFtZU1vZGlmaWVyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnJhbWVNb2RpZmllciA9IHRoaXMuZnJhbWVNdWx0ICogdGhpcy5wbGF5U3BlZWQgKiB0aGlzLnBsYXlEaXJlY3Rpb247XG4gICAgdGhpcy5hdWRpb0NvbnRyb2xsZXIuc2V0UmF0ZSh0aGlzLnBsYXlTcGVlZCAqIHRoaXMucGxheURpcmVjdGlvbik7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXRoO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmdldEFzc2V0c1BhdGggPSBmdW5jdGlvbiAoYXNzZXREYXRhKSB7XG4gICAgdmFyIHBhdGggPSAnJztcblxuICAgIGlmIChhc3NldERhdGEuZSkge1xuICAgICAgcGF0aCA9IGFzc2V0RGF0YS5wO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hc3NldHNQYXRoKSB7XG4gICAgICB2YXIgaW1hZ2VQYXRoID0gYXNzZXREYXRhLnA7XG5cbiAgICAgIGlmIChpbWFnZVBhdGguaW5kZXhPZignaW1hZ2VzLycpICE9PSAtMSkge1xuICAgICAgICBpbWFnZVBhdGggPSBpbWFnZVBhdGguc3BsaXQoJy8nKVsxXTtcbiAgICAgIH1cblxuICAgICAgcGF0aCA9IHRoaXMuYXNzZXRzUGF0aCArIGltYWdlUGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgIHBhdGggKz0gYXNzZXREYXRhLnUgPyBhc3NldERhdGEudSA6ICcnO1xuICAgICAgcGF0aCArPSBhc3NldERhdGEucDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aDtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5nZXRBc3NldERhdGEgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IHRoaXMuYXNzZXRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAoaWQgPT09IHRoaXMuYXNzZXRzW2ldLmlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzc2V0c1tpXTtcbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZW5kZXJlci5oaWRlKCk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnNob3coKTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5nZXREdXJhdGlvbiA9IGZ1bmN0aW9uIChpc0ZyYW1lKSB7XG4gICAgcmV0dXJuIGlzRnJhbWUgPyB0aGlzLnRvdGFsRnJhbWVzIDogdGhpcy50b3RhbEZyYW1lcyAvIHRoaXMuZnJhbWVSYXRlO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnVwZGF0ZURvY3VtZW50RGF0YSA9IGZ1bmN0aW9uIChwYXRoLCBkb2N1bWVudERhdGEsIGluZGV4KSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5yZW5kZXJlci5nZXRFbGVtZW50QnlQYXRoKHBhdGgpO1xuICAgICAgZWxlbWVudC51cGRhdGVEb2N1bWVudERhdGEoZG9jdW1lbnREYXRhLCBpbmRleCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHsvLyBUT0RPOiBkZWNpZGUgaG93IHRvIGhhbmRsZSBjYXRjaCBjYXNlXG4gICAgfVxuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh0aGlzLl9jYnMgJiYgdGhpcy5fY2JzW25hbWVdKSB7XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSAnZW50ZXJGcmFtZSc6XG4gICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQobmFtZSwgbmV3IEJNRW50ZXJGcmFtZUV2ZW50KG5hbWUsIHRoaXMuY3VycmVudEZyYW1lLCB0aGlzLnRvdGFsRnJhbWVzLCB0aGlzLmZyYW1lTW9kaWZpZXIpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkcmF3bkZyYW1lJzpcbiAgICAgICAgICB0aGlzLmRyYXduRnJhbWVFdmVudC5jdXJyZW50VGltZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuICAgICAgICAgIHRoaXMuZHJhd25GcmFtZUV2ZW50LnRvdGFsVGltZSA9IHRoaXMudG90YWxGcmFtZXM7XG4gICAgICAgICAgdGhpcy5kcmF3bkZyYW1lRXZlbnQuZGlyZWN0aW9uID0gdGhpcy5mcmFtZU1vZGlmaWVyO1xuICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5hbWUsIHRoaXMuZHJhd25GcmFtZUV2ZW50KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdsb29wQ29tcGxldGUnOlxuICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5hbWUsIG5ldyBCTUNvbXBsZXRlTG9vcEV2ZW50KG5hbWUsIHRoaXMubG9vcCwgdGhpcy5wbGF5Q291bnQsIHRoaXMuZnJhbWVNdWx0KSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY29tcGxldGUnOlxuICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5hbWUsIG5ldyBCTUNvbXBsZXRlRXZlbnQobmFtZSwgdGhpcy5mcmFtZU11bHQpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzZWdtZW50U3RhcnQnOlxuICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5hbWUsIG5ldyBCTVNlZ21lbnRTdGFydEV2ZW50KG5hbWUsIHRoaXMuZmlyc3RGcmFtZSwgdGhpcy50b3RhbEZyYW1lcykpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rlc3Ryb3knOlxuICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5hbWUsIG5ldyBCTURlc3Ryb3lFdmVudChuYW1lLCB0aGlzKSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLnRyaWdnZXJFdmVudChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gJ2VudGVyRnJhbWUnICYmIHRoaXMub25FbnRlckZyYW1lKSB7XG4gICAgICB0aGlzLm9uRW50ZXJGcmFtZS5jYWxsKHRoaXMsIG5ldyBCTUVudGVyRnJhbWVFdmVudChuYW1lLCB0aGlzLmN1cnJlbnRGcmFtZSwgdGhpcy50b3RhbEZyYW1lcywgdGhpcy5mcmFtZU11bHQpKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gJ2xvb3BDb21wbGV0ZScgJiYgdGhpcy5vbkxvb3BDb21wbGV0ZSkge1xuICAgICAgdGhpcy5vbkxvb3BDb21wbGV0ZS5jYWxsKHRoaXMsIG5ldyBCTUNvbXBsZXRlTG9vcEV2ZW50KG5hbWUsIHRoaXMubG9vcCwgdGhpcy5wbGF5Q291bnQsIHRoaXMuZnJhbWVNdWx0KSk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09ICdjb21wbGV0ZScgJiYgdGhpcy5vbkNvbXBsZXRlKSB7XG4gICAgICB0aGlzLm9uQ29tcGxldGUuY2FsbCh0aGlzLCBuZXcgQk1Db21wbGV0ZUV2ZW50KG5hbWUsIHRoaXMuZnJhbWVNdWx0KSk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09ICdzZWdtZW50U3RhcnQnICYmIHRoaXMub25TZWdtZW50U3RhcnQpIHtcbiAgICAgIHRoaXMub25TZWdtZW50U3RhcnQuY2FsbCh0aGlzLCBuZXcgQk1TZWdtZW50U3RhcnRFdmVudChuYW1lLCB0aGlzLmZpcnN0RnJhbWUsIHRoaXMudG90YWxGcmFtZXMpKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gJ2Rlc3Ryb3knICYmIHRoaXMub25EZXN0cm95KSB7XG4gICAgICB0aGlzLm9uRGVzdHJveS5jYWxsKHRoaXMsIG5ldyBCTURlc3Ryb3lFdmVudChuYW1lLCB0aGlzKSk7XG4gICAgfVxuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnRyaWdnZXJSZW5kZXJGcmFtZUVycm9yID0gZnVuY3Rpb24gKG5hdGl2ZUVycm9yKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEJNUmVuZGVyRnJhbWVFcnJvckV2ZW50KG5hdGl2ZUVycm9yLCB0aGlzLmN1cnJlbnRGcmFtZSk7XG4gICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2Vycm9yJywgZXJyb3IpO1xuXG4gICAgaWYgKHRoaXMub25FcnJvcikge1xuICAgICAgdGhpcy5vbkVycm9yLmNhbGwodGhpcywgZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS50cmlnZ2VyQ29uZmlnRXJyb3IgPSBmdW5jdGlvbiAobmF0aXZlRXJyb3IpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgQk1Db25maWdFcnJvckV2ZW50KG5hdGl2ZUVycm9yLCB0aGlzLmN1cnJlbnRGcmFtZSk7XG4gICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2Vycm9yJywgZXJyb3IpO1xuXG4gICAgaWYgKHRoaXMub25FcnJvcikge1xuICAgICAgdGhpcy5vbkVycm9yLmNhbGwodGhpcywgZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgYW5pbWF0aW9uTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kdWxlT2IgPSB7fTtcbiAgICB2YXIgcmVnaXN0ZXJlZEFuaW1hdGlvbnMgPSBbXTtcbiAgICB2YXIgaW5pdFRpbWUgPSAwO1xuICAgIHZhciBsZW4gPSAwO1xuICAgIHZhciBwbGF5aW5nQW5pbWF0aW9uc051bSA9IDA7XG4gICAgdmFyIF9zdG9wcGVkID0gdHJ1ZTtcbiAgICB2YXIgX2lzRnJvemVuID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiByZW1vdmVFbGVtZW50KGV2KSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgYW5pbUl0ZW0gPSBldi50YXJnZXQ7XG5cbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIGlmIChyZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24gPT09IGFuaW1JdGVtKSB7XG4gICAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICBsZW4gLT0gMTtcblxuICAgICAgICAgIGlmICghYW5pbUl0ZW0uaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHN1YnRyYWN0UGxheWluZ0NvdW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyQW5pbWF0aW9uKGVsZW1lbnQsIGFuaW1hdGlvbkRhdGEpIHtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBpZiAocmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uZWxlbSA9PT0gZWxlbWVudCAmJiByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5lbGVtICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFuaW1JdGVtID0gbmV3IEFuaW1hdGlvbkl0ZW0oKTtcbiAgICAgIHNldHVwQW5pbWF0aW9uKGFuaW1JdGVtLCBlbGVtZW50KTtcbiAgICAgIGFuaW1JdGVtLnNldERhdGEoZWxlbWVudCwgYW5pbWF0aW9uRGF0YSk7XG4gICAgICByZXR1cm4gYW5pbUl0ZW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZEFuaW1hdGlvbnMoKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW5BbmltcyA9IHJlZ2lzdGVyZWRBbmltYXRpb25zLmxlbmd0aDtcbiAgICAgIHZhciBhbmltYXRpb25zID0gW107XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5BbmltczsgaSArPSAxKSB7XG4gICAgICAgIGFuaW1hdGlvbnMucHVzaChyZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRQbGF5aW5nQ291bnQoKSB7XG4gICAgICBwbGF5aW5nQW5pbWF0aW9uc051bSArPSAxO1xuICAgICAgYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdWJ0cmFjdFBsYXlpbmdDb3VudCgpIHtcbiAgICAgIHBsYXlpbmdBbmltYXRpb25zTnVtIC09IDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0dXBBbmltYXRpb24oYW5pbUl0ZW0sIGVsZW1lbnQpIHtcbiAgICAgIGFuaW1JdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2Rlc3Ryb3knLCByZW1vdmVFbGVtZW50KTtcbiAgICAgIGFuaW1JdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ19hY3RpdmUnLCBhZGRQbGF5aW5nQ291bnQpO1xuICAgICAgYW5pbUl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignX2lkbGUnLCBzdWJ0cmFjdFBsYXlpbmdDb3VudCk7XG4gICAgICByZWdpc3RlcmVkQW5pbWF0aW9ucy5wdXNoKHtcbiAgICAgICAgZWxlbTogZWxlbWVudCxcbiAgICAgICAgYW5pbWF0aW9uOiBhbmltSXRlbVxuICAgICAgfSk7XG4gICAgICBsZW4gKz0gMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkQW5pbWF0aW9uKHBhcmFtcykge1xuICAgICAgdmFyIGFuaW1JdGVtID0gbmV3IEFuaW1hdGlvbkl0ZW0oKTtcbiAgICAgIHNldHVwQW5pbWF0aW9uKGFuaW1JdGVtLCBudWxsKTtcbiAgICAgIGFuaW1JdGVtLnNldFBhcmFtcyhwYXJhbXMpO1xuICAgICAgcmV0dXJuIGFuaW1JdGVtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFNwZWVkKHZhbCwgYW5pbWF0aW9uKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5zZXRTcGVlZCh2YWwsIGFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0RGlyZWN0aW9uKHZhbCwgYW5pbWF0aW9uKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5zZXREaXJlY3Rpb24odmFsLCBhbmltYXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBsYXkoYW5pbWF0aW9uKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5wbGF5KGFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzdW1lKG5vd1RpbWUpIHtcbiAgICAgIHZhciBlbGFwc2VkVGltZSA9IG5vd1RpbWUgLSBpbml0VGltZTtcbiAgICAgIHZhciBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLmFkdmFuY2VUaW1lKGVsYXBzZWRUaW1lKTtcbiAgICAgIH1cblxuICAgICAgaW5pdFRpbWUgPSBub3dUaW1lO1xuXG4gICAgICBpZiAocGxheWluZ0FuaW1hdGlvbnNOdW0gJiYgIV9pc0Zyb3plbikge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlc3VtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfc3RvcHBlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlyc3Qobm93VGltZSkge1xuICAgICAgaW5pdFRpbWUgPSBub3dUaW1lO1xuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShyZXN1bWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhdXNlKGFuaW1hdGlvbikge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24ucGF1c2UoYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnb1RvQW5kU3RvcCh2YWx1ZSwgaXNGcmFtZSwgYW5pbWF0aW9uKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5nb1RvQW5kU3RvcCh2YWx1ZSwgaXNGcmFtZSwgYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdG9wKGFuaW1hdGlvbikge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24uc3RvcChhbmltYXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvZ2dsZVBhdXNlKGFuaW1hdGlvbikge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24udG9nZ2xlUGF1c2UoYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXN0cm95KGFuaW1hdGlvbikge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5kZXN0cm95KGFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VhcmNoQW5pbWF0aW9ucyhhbmltYXRpb25EYXRhLCBzdGFuZGFsb25lLCByZW5kZXJlcikge1xuICAgICAgdmFyIGFuaW1FbGVtZW50cyA9IFtdLmNvbmNhdChbXS5zbGljZS5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2xvdHRpZScpKSwgW10uc2xpY2UuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdib2R5bW92aW4nKSkpO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuQW5pbXMgPSBhbmltRWxlbWVudHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuQW5pbXM7IGkgKz0gMSkge1xuICAgICAgICBpZiAocmVuZGVyZXIpIHtcbiAgICAgICAgICBhbmltRWxlbWVudHNbaV0uc2V0QXR0cmlidXRlKCdkYXRhLWJtLXR5cGUnLCByZW5kZXJlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckFuaW1hdGlvbihhbmltRWxlbWVudHNbaV0sIGFuaW1hdGlvbkRhdGEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhbmRhbG9uZSAmJiBsZW5BbmltcyA9PT0gMCkge1xuICAgICAgICBpZiAoIXJlbmRlcmVyKSB7XG4gICAgICAgICAgcmVuZGVyZXIgPSAnc3ZnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2JvZHknKVswXTtcbiAgICAgICAgYm9keS5pbm5lclRleHQgPSAnJztcbiAgICAgICAgdmFyIGRpdiA9IGNyZWF0ZVRhZygnZGl2Jyk7XG4gICAgICAgIGRpdi5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgZGl2LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnZGF0YS1ibS10eXBlJywgcmVuZGVyZXIpO1xuICAgICAgICBib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAgIHJlZ2lzdGVyQW5pbWF0aW9uKGRpdiwgYW5pbWF0aW9uRGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzaXplKCkge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24ucmVzaXplKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWN0aXZhdGUoKSB7XG4gICAgICBpZiAoIV9pc0Zyb3plbiAmJiBwbGF5aW5nQW5pbWF0aW9uc051bSkge1xuICAgICAgICBpZiAoX3N0b3BwZWQpIHtcbiAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZpcnN0KTtcbiAgICAgICAgICBfc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJlZXplKCkge1xuICAgICAgX2lzRnJvemVuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmZyZWV6ZSgpIHtcbiAgICAgIF9pc0Zyb3plbiA9IGZhbHNlO1xuICAgICAgYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRWb2x1bWUodmFsLCBhbmltYXRpb24pIHtcbiAgICAgIHZhciBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLnNldFZvbHVtZSh2YWwsIGFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXV0ZShhbmltYXRpb24pIHtcbiAgICAgIHZhciBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLm11dGUoYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bm11dGUoYW5pbWF0aW9uKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi51bm11dGUoYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGVPYi5yZWdpc3RlckFuaW1hdGlvbiA9IHJlZ2lzdGVyQW5pbWF0aW9uO1xuICAgIG1vZHVsZU9iLmxvYWRBbmltYXRpb24gPSBsb2FkQW5pbWF0aW9uO1xuICAgIG1vZHVsZU9iLnNldFNwZWVkID0gc2V0U3BlZWQ7XG4gICAgbW9kdWxlT2Iuc2V0RGlyZWN0aW9uID0gc2V0RGlyZWN0aW9uO1xuICAgIG1vZHVsZU9iLnBsYXkgPSBwbGF5O1xuICAgIG1vZHVsZU9iLnBhdXNlID0gcGF1c2U7XG4gICAgbW9kdWxlT2Iuc3RvcCA9IHN0b3A7XG4gICAgbW9kdWxlT2IudG9nZ2xlUGF1c2UgPSB0b2dnbGVQYXVzZTtcbiAgICBtb2R1bGVPYi5zZWFyY2hBbmltYXRpb25zID0gc2VhcmNoQW5pbWF0aW9ucztcbiAgICBtb2R1bGVPYi5yZXNpemUgPSByZXNpemU7IC8vIG1vZHVsZU9iLnN0YXJ0ID0gc3RhcnQ7XG5cbiAgICBtb2R1bGVPYi5nb1RvQW5kU3RvcCA9IGdvVG9BbmRTdG9wO1xuICAgIG1vZHVsZU9iLmRlc3Ryb3kgPSBkZXN0cm95O1xuICAgIG1vZHVsZU9iLmZyZWV6ZSA9IGZyZWV6ZTtcbiAgICBtb2R1bGVPYi51bmZyZWV6ZSA9IHVuZnJlZXplO1xuICAgIG1vZHVsZU9iLnNldFZvbHVtZSA9IHNldFZvbHVtZTtcbiAgICBtb2R1bGVPYi5tdXRlID0gbXV0ZTtcbiAgICBtb2R1bGVPYi51bm11dGUgPSB1bm11dGU7XG4gICAgbW9kdWxlT2IuZ2V0UmVnaXN0ZXJlZEFuaW1hdGlvbnMgPSBnZXRSZWdpc3RlcmVkQW5pbWF0aW9ucztcbiAgICByZXR1cm4gbW9kdWxlT2I7XG4gIH0oKTtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICB2YXIgQmV6aWVyRmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcclxuICAgICAgICogQmV6aWVyRWFzaW5nIC0gdXNlIGJlemllciBjdXJ2ZSBmb3IgdHJhbnNpdGlvbiBlYXNpbmcgZnVuY3Rpb25cclxuICAgICAgICogYnkgR2HDq3RhbiBSZW5hdWRlYXUgMjAxNCAtIDIwMTUg4oCTIE1JVCBMaWNlbnNlXHJcbiAgICAgICAqXHJcbiAgICAgICAqIENyZWRpdHM6IGlzIGJhc2VkIG9uIEZpcmVmb3gncyBuc1NNSUxLZXlTcGxpbmUuY3BwXHJcbiAgICAgICAqIFVzYWdlOlxyXG4gICAgICAgKiB2YXIgc3BsaW5lID0gQmV6aWVyRWFzaW5nKFsgMC4yNSwgMC4xLCAwLjI1LCAxLjAgXSlcclxuICAgICAgICogc3BsaW5lLmdldCh4KSA9PiByZXR1cm5zIHRoZSBlYXNpbmcgdmFsdWUgfCB4IG11c3QgYmUgaW4gWzAsIDFdIHJhbmdlXHJcbiAgICAgICAqXHJcbiAgICAgICAqL1xuICAgIHZhciBvYiA9IHt9O1xuICAgIG9iLmdldEJlemllckVhc2luZyA9IGdldEJlemllckVhc2luZztcbiAgICB2YXIgYmV6aWVycyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZ2V0QmV6aWVyRWFzaW5nKGEsIGIsIGMsIGQsIG5tKSB7XG4gICAgICB2YXIgc3RyID0gbm0gfHwgKCdiZXpfJyArIGEgKyAnXycgKyBiICsgJ18nICsgYyArICdfJyArIGQpLnJlcGxhY2UoL1xcLi9nLCAncCcpO1xuXG4gICAgICBpZiAoYmV6aWVyc1tzdHJdKSB7XG4gICAgICAgIHJldHVybiBiZXppZXJzW3N0cl07XG4gICAgICB9XG5cbiAgICAgIHZhciBiZXpFYXNpbmcgPSBuZXcgQmV6aWVyRWFzaW5nKFthLCBiLCBjLCBkXSk7XG4gICAgICBiZXppZXJzW3N0cl0gPSBiZXpFYXNpbmc7XG4gICAgICByZXR1cm4gYmV6RWFzaW5nO1xuICAgIH0gLy8gVGhlc2UgdmFsdWVzIGFyZSBlc3RhYmxpc2hlZCBieSBlbXBpcmljaXNtIHdpdGggdGVzdHMgKHRyYWRlb2ZmOiBwZXJmb3JtYW5jZSBWUyBwcmVjaXNpb24pXG5cblxuICAgIHZhciBORVdUT05fSVRFUkFUSU9OUyA9IDQ7XG4gICAgdmFyIE5FV1RPTl9NSU5fU0xPUEUgPSAwLjAwMTtcbiAgICB2YXIgU1VCRElWSVNJT05fUFJFQ0lTSU9OID0gMC4wMDAwMDAxO1xuICAgIHZhciBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyA9IDEwO1xuICAgIHZhciBrU3BsaW5lVGFibGVTaXplID0gMTE7XG4gICAgdmFyIGtTYW1wbGVTdGVwU2l6ZSA9IDEuMCAvIChrU3BsaW5lVGFibGVTaXplIC0gMS4wKTtcbiAgICB2YXIgZmxvYXQzMkFycmF5U3VwcG9ydGVkID0gdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ2Z1bmN0aW9uJztcblxuICAgIGZ1bmN0aW9uIEEoYUExLCBhQTIpIHtcbiAgICAgIHJldHVybiAxLjAgLSAzLjAgKiBhQTIgKyAzLjAgKiBhQTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQihhQTEsIGFBMikge1xuICAgICAgcmV0dXJuIDMuMCAqIGFBMiAtIDYuMCAqIGFBMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDKGFBMSkge1xuICAgICAgcmV0dXJuIDMuMCAqIGFBMTtcbiAgICB9IC8vIFJldHVybnMgeCh0KSBnaXZlbiB0LCB4MSwgYW5kIHgyLCBvciB5KHQpIGdpdmVuIHQsIHkxLCBhbmQgeTIuXG5cblxuICAgIGZ1bmN0aW9uIGNhbGNCZXppZXIoYVQsIGFBMSwgYUEyKSB7XG4gICAgICByZXR1cm4gKChBKGFBMSwgYUEyKSAqIGFUICsgQihhQTEsIGFBMikpICogYVQgKyBDKGFBMSkpICogYVQ7XG4gICAgfSAvLyBSZXR1cm5zIGR4L2R0IGdpdmVuIHQsIHgxLCBhbmQgeDIsIG9yIGR5L2R0IGdpdmVuIHQsIHkxLCBhbmQgeTIuXG5cblxuICAgIGZ1bmN0aW9uIGdldFNsb3BlKGFULCBhQTEsIGFBMikge1xuICAgICAgcmV0dXJuIDMuMCAqIEEoYUExLCBhQTIpICogYVQgKiBhVCArIDIuMCAqIEIoYUExLCBhQTIpICogYVQgKyBDKGFBMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmluYXJ5U3ViZGl2aWRlKGFYLCBhQSwgYUIsIG1YMSwgbVgyKSB7XG4gICAgICB2YXIgY3VycmVudFgsXG4gICAgICAgICAgY3VycmVudFQsXG4gICAgICAgICAgaSA9IDA7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgY3VycmVudFQgPSBhQSArIChhQiAtIGFBKSAvIDIuMDtcbiAgICAgICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcblxuICAgICAgICBpZiAoY3VycmVudFggPiAwLjApIHtcbiAgICAgICAgICBhQiA9IGN1cnJlbnRUO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFBID0gY3VycmVudFQ7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKE1hdGguYWJzKGN1cnJlbnRYKSA+IFNVQkRJVklTSU9OX1BSRUNJU0lPTiAmJiArK2kgPCBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyk7XG5cbiAgICAgIHJldHVybiBjdXJyZW50VDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgYUd1ZXNzVCwgbVgxLCBtWDIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTkVXVE9OX0lURVJBVElPTlM7ICsraSkge1xuICAgICAgICB2YXIgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuICAgICAgICBpZiAoY3VycmVudFNsb3BlID09PSAwLjApIHJldHVybiBhR3Vlc3NUO1xuICAgICAgICB2YXIgY3VycmVudFggPSBjYWxjQmV6aWVyKGFHdWVzc1QsIG1YMSwgbVgyKSAtIGFYO1xuICAgICAgICBhR3Vlc3NUIC09IGN1cnJlbnRYIC8gY3VycmVudFNsb3BlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYUd1ZXNzVDtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgICAqIHBvaW50cyBpcyBhbiBhcnJheSBvZiBbIG1YMSwgbVkxLCBtWDIsIG1ZMiBdXHJcbiAgICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBCZXppZXJFYXNpbmcocG9pbnRzKSB7XG4gICAgICB0aGlzLl9wID0gcG9pbnRzO1xuICAgICAgdGhpcy5fbVNhbXBsZVZhbHVlcyA9IGZsb2F0MzJBcnJheVN1cHBvcnRlZCA/IG5ldyBGbG9hdDMyQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSkgOiBuZXcgQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSk7XG4gICAgICB0aGlzLl9wcmVjb21wdXRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5nZXQgPSB0aGlzLmdldC5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIEJlemllckVhc2luZy5wcm90b3R5cGUgPSB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCh4KSB7XG4gICAgICAgIHZhciBtWDEgPSB0aGlzLl9wWzBdLFxuICAgICAgICAgICAgbVkxID0gdGhpcy5fcFsxXSxcbiAgICAgICAgICAgIG1YMiA9IHRoaXMuX3BbMl0sXG4gICAgICAgICAgICBtWTIgPSB0aGlzLl9wWzNdO1xuICAgICAgICBpZiAoIXRoaXMuX3ByZWNvbXB1dGVkKSB0aGlzLl9wcmVjb21wdXRlKCk7XG4gICAgICAgIGlmIChtWDEgPT09IG1ZMSAmJiBtWDIgPT09IG1ZMikgcmV0dXJuIHg7IC8vIGxpbmVhclxuICAgICAgICAvLyBCZWNhdXNlIEphdmFTY3JpcHQgbnVtYmVyIGFyZSBpbXByZWNpc2UsIHdlIHNob3VsZCBndWFyYW50ZWUgdGhlIGV4dHJlbWVzIGFyZSByaWdodC5cblxuICAgICAgICBpZiAoeCA9PT0gMCkgcmV0dXJuIDA7XG4gICAgICAgIGlmICh4ID09PSAxKSByZXR1cm4gMTtcbiAgICAgICAgcmV0dXJuIGNhbGNCZXppZXIodGhpcy5fZ2V0VEZvclgoeCksIG1ZMSwgbVkyKTtcbiAgICAgIH0sXG4gICAgICAvLyBQcml2YXRlIHBhcnRcbiAgICAgIF9wcmVjb21wdXRlOiBmdW5jdGlvbiBfcHJlY29tcHV0ZSgpIHtcbiAgICAgICAgdmFyIG1YMSA9IHRoaXMuX3BbMF0sXG4gICAgICAgICAgICBtWTEgPSB0aGlzLl9wWzFdLFxuICAgICAgICAgICAgbVgyID0gdGhpcy5fcFsyXSxcbiAgICAgICAgICAgIG1ZMiA9IHRoaXMuX3BbM107XG4gICAgICAgIHRoaXMuX3ByZWNvbXB1dGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAobVgxICE9PSBtWTEgfHwgbVgyICE9PSBtWTIpIHtcbiAgICAgICAgICB0aGlzLl9jYWxjU2FtcGxlVmFsdWVzKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY2FsY1NhbXBsZVZhbHVlczogZnVuY3Rpb24gX2NhbGNTYW1wbGVWYWx1ZXMoKSB7XG4gICAgICAgIHZhciBtWDEgPSB0aGlzLl9wWzBdLFxuICAgICAgICAgICAgbVgyID0gdGhpcy5fcFsyXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtTcGxpbmVUYWJsZVNpemU7ICsraSkge1xuICAgICAgICAgIHRoaXMuX21TYW1wbGVWYWx1ZXNbaV0gPSBjYWxjQmV6aWVyKGkgKiBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBnZXRURm9yWCBjaG9zZSB0aGUgZmFzdGVzdCBoZXVyaXN0aWMgdG8gZGV0ZXJtaW5lIHRoZSBwZXJjZW50YWdlIHZhbHVlIHByZWNpc2VseSBmcm9tIGEgZ2l2ZW4gWCBwcm9qZWN0aW9uLlxyXG4gICAgICAgICAgICovXG4gICAgICBfZ2V0VEZvclg6IGZ1bmN0aW9uIF9nZXRURm9yWChhWCkge1xuICAgICAgICB2YXIgbVgxID0gdGhpcy5fcFswXSxcbiAgICAgICAgICAgIG1YMiA9IHRoaXMuX3BbMl0sXG4gICAgICAgICAgICBtU2FtcGxlVmFsdWVzID0gdGhpcy5fbVNhbXBsZVZhbHVlcztcbiAgICAgICAgdmFyIGludGVydmFsU3RhcnQgPSAwLjA7XG4gICAgICAgIHZhciBjdXJyZW50U2FtcGxlID0gMTtcbiAgICAgICAgdmFyIGxhc3RTYW1wbGUgPSBrU3BsaW5lVGFibGVTaXplIC0gMTtcblxuICAgICAgICBmb3IgKDsgY3VycmVudFNhbXBsZSAhPT0gbGFzdFNhbXBsZSAmJiBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdIDw9IGFYOyArK2N1cnJlbnRTYW1wbGUpIHtcbiAgICAgICAgICBpbnRlcnZhbFN0YXJ0ICs9IGtTYW1wbGVTdGVwU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC0tY3VycmVudFNhbXBsZTsgLy8gSW50ZXJwb2xhdGUgdG8gcHJvdmlkZSBhbiBpbml0aWFsIGd1ZXNzIGZvciB0XG5cbiAgICAgICAgdmFyIGRpc3QgPSAoYVggLSBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSAvIChtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGUgKyAxXSAtIG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pO1xuICAgICAgICB2YXIgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBrU2FtcGxlU3RlcFNpemU7XG4gICAgICAgIHZhciBpbml0aWFsU2xvcGUgPSBnZXRTbG9wZShndWVzc0ZvclQsIG1YMSwgbVgyKTtcblxuICAgICAgICBpZiAoaW5pdGlhbFNsb3BlID49IE5FV1RPTl9NSU5fU0xPUEUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluaXRpYWxTbG9wZSA9PT0gMC4wKSB7XG4gICAgICAgICAgcmV0dXJuIGd1ZXNzRm9yVDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBiaW5hcnlTdWJkaXZpZGUoYVgsIGludGVydmFsU3RhcnQsIGludGVydmFsU3RhcnQgKyBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBvYjtcbiAgfSgpO1xuXG4gIHZhciBwb29saW5nID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9kb3VibGUoYXJyKSB7XG4gICAgICByZXR1cm4gYXJyLmNvbmNhdChjcmVhdGVTaXplZEFycmF5KGFyci5sZW5ndGgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgXCJkb3VibGVcIjogX2RvdWJsZVxuICAgIH07XG4gIH0oKTtcblxuICB2YXIgcG9vbEZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbml0aWFsTGVuZ3RoLCBfY3JlYXRlLCBfcmVsZWFzZSkge1xuICAgICAgdmFyIF9sZW5ndGggPSAwO1xuICAgICAgdmFyIF9tYXhMZW5ndGggPSBpbml0aWFsTGVuZ3RoO1xuICAgICAgdmFyIHBvb2wgPSBjcmVhdGVTaXplZEFycmF5KF9tYXhMZW5ndGgpO1xuICAgICAgdmFyIG9iID0ge1xuICAgICAgICBuZXdFbGVtZW50OiBuZXdFbGVtZW50LFxuICAgICAgICByZWxlYXNlOiByZWxlYXNlXG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBuZXdFbGVtZW50KCkge1xuICAgICAgICB2YXIgZWxlbWVudDtcblxuICAgICAgICBpZiAoX2xlbmd0aCkge1xuICAgICAgICAgIF9sZW5ndGggLT0gMTtcbiAgICAgICAgICBlbGVtZW50ID0gcG9vbFtfbGVuZ3RoXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50ID0gX2NyZWF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlbGVhc2UoZWxlbWVudCkge1xuICAgICAgICBpZiAoX2xlbmd0aCA9PT0gX21heExlbmd0aCkge1xuICAgICAgICAgIHBvb2wgPSBwb29saW5nW1wiZG91YmxlXCJdKHBvb2wpO1xuICAgICAgICAgIF9tYXhMZW5ndGggKj0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfcmVsZWFzZSkge1xuICAgICAgICAgIF9yZWxlYXNlKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9vbFtfbGVuZ3RoXSA9IGVsZW1lbnQ7XG4gICAgICAgIF9sZW5ndGggKz0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iO1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgYmV6aWVyTGVuZ3RoUG9vbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRlZExlbmd0aDogMCxcbiAgICAgICAgcGVyY2VudHM6IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBnZXREZWZhdWx0Q3VydmVTZWdtZW50cygpKSxcbiAgICAgICAgbGVuZ3RoczogY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGdldERlZmF1bHRDdXJ2ZVNlZ21lbnRzKCkpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBwb29sRmFjdG9yeSg4LCBjcmVhdGUpO1xuICB9KCk7XG5cbiAgdmFyIHNlZ21lbnRzTGVuZ3RoUG9vbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZW5ndGhzOiBbXSxcbiAgICAgICAgdG90YWxMZW5ndGg6IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVsZWFzZShlbGVtZW50KSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBlbGVtZW50Lmxlbmd0aHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYmV6aWVyTGVuZ3RoUG9vbC5yZWxlYXNlKGVsZW1lbnQubGVuZ3Roc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQubGVuZ3Rocy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBwb29sRmFjdG9yeSg4LCBjcmVhdGUsIHJlbGVhc2UpO1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gYmV6RnVuY3Rpb24oKSB7XG4gICAgdmFyIG1hdGggPSBNYXRoO1xuXG4gICAgZnVuY3Rpb24gcG9pbnRPbkxpbmUyRCh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICB2YXIgZGV0MSA9IHgxICogeTIgKyB5MSAqIHgzICsgeDIgKiB5MyAtIHgzICogeTIgLSB5MyAqIHgxIC0geDIgKiB5MTtcbiAgICAgIHJldHVybiBkZXQxID4gLTAuMDAxICYmIGRldDEgPCAwLjAwMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2ludE9uTGluZTNEKHgxLCB5MSwgejEsIHgyLCB5MiwgejIsIHgzLCB5MywgejMpIHtcbiAgICAgIGlmICh6MSA9PT0gMCAmJiB6MiA9PT0gMCAmJiB6MyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcG9pbnRPbkxpbmUyRCh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpc3QxID0gbWF0aC5zcXJ0KG1hdGgucG93KHgyIC0geDEsIDIpICsgbWF0aC5wb3coeTIgLSB5MSwgMikgKyBtYXRoLnBvdyh6MiAtIHoxLCAyKSk7XG4gICAgICB2YXIgZGlzdDIgPSBtYXRoLnNxcnQobWF0aC5wb3coeDMgLSB4MSwgMikgKyBtYXRoLnBvdyh5MyAtIHkxLCAyKSArIG1hdGgucG93KHozIC0gejEsIDIpKTtcbiAgICAgIHZhciBkaXN0MyA9IG1hdGguc3FydChtYXRoLnBvdyh4MyAtIHgyLCAyKSArIG1hdGgucG93KHkzIC0geTIsIDIpICsgbWF0aC5wb3coejMgLSB6MiwgMikpO1xuICAgICAgdmFyIGRpZmZEaXN0O1xuXG4gICAgICBpZiAoZGlzdDEgPiBkaXN0Mikge1xuICAgICAgICBpZiAoZGlzdDEgPiBkaXN0Mykge1xuICAgICAgICAgIGRpZmZEaXN0ID0gZGlzdDEgLSBkaXN0MiAtIGRpc3QzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpZmZEaXN0ID0gZGlzdDMgLSBkaXN0MiAtIGRpc3QxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRpc3QzID4gZGlzdDIpIHtcbiAgICAgICAgZGlmZkRpc3QgPSBkaXN0MyAtIGRpc3QyIC0gZGlzdDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWZmRGlzdCA9IGRpc3QyIC0gZGlzdDEgLSBkaXN0MztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpZmZEaXN0ID4gLTAuMDAwMSAmJiBkaWZmRGlzdCA8IDAuMDAwMTtcbiAgICB9XG5cbiAgICB2YXIgZ2V0QmV6aWVyTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwdDEsIHB0MiwgcHQzLCBwdDQpIHtcbiAgICAgICAgdmFyIGN1cnZlU2VnbWVudHMgPSBnZXREZWZhdWx0Q3VydmVTZWdtZW50cygpO1xuICAgICAgICB2YXIgaztcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW47XG4gICAgICAgIHZhciBwdENvb3JkO1xuICAgICAgICB2YXIgcGVyYztcbiAgICAgICAgdmFyIGFkZGVkTGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIHB0RGlzdGFuY2U7XG4gICAgICAgIHZhciBwb2ludCA9IFtdO1xuICAgICAgICB2YXIgbGFzdFBvaW50ID0gW107XG4gICAgICAgIHZhciBsZW5ndGhEYXRhID0gYmV6aWVyTGVuZ3RoUG9vbC5uZXdFbGVtZW50KCk7XG4gICAgICAgIGxlbiA9IHB0My5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChrID0gMDsgayA8IGN1cnZlU2VnbWVudHM7IGsgKz0gMSkge1xuICAgICAgICAgIHBlcmMgPSBrIC8gKGN1cnZlU2VnbWVudHMgLSAxKTtcbiAgICAgICAgICBwdERpc3RhbmNlID0gMDtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgcHRDb29yZCA9IGJtUG93KDEgLSBwZXJjLCAzKSAqIHB0MVtpXSArIDMgKiBibVBvdygxIC0gcGVyYywgMikgKiBwZXJjICogcHQzW2ldICsgMyAqICgxIC0gcGVyYykgKiBibVBvdyhwZXJjLCAyKSAqIHB0NFtpXSArIGJtUG93KHBlcmMsIDMpICogcHQyW2ldO1xuICAgICAgICAgICAgcG9pbnRbaV0gPSBwdENvb3JkO1xuXG4gICAgICAgICAgICBpZiAobGFzdFBvaW50W2ldICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHB0RGlzdGFuY2UgKz0gYm1Qb3cocG9pbnRbaV0gLSBsYXN0UG9pbnRbaV0sIDIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0UG9pbnRbaV0gPSBwb2ludFtpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocHREaXN0YW5jZSkge1xuICAgICAgICAgICAgcHREaXN0YW5jZSA9IGJtU3FydChwdERpc3RhbmNlKTtcbiAgICAgICAgICAgIGFkZGVkTGVuZ3RoICs9IHB0RGlzdGFuY2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGVuZ3RoRGF0YS5wZXJjZW50c1trXSA9IHBlcmM7XG4gICAgICAgICAgbGVuZ3RoRGF0YS5sZW5ndGhzW2tdID0gYWRkZWRMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGhEYXRhLmFkZGVkTGVuZ3RoID0gYWRkZWRMZW5ndGg7XG4gICAgICAgIHJldHVybiBsZW5ndGhEYXRhO1xuICAgICAgfTtcbiAgICB9KCk7XG5cbiAgICBmdW5jdGlvbiBnZXRTZWdtZW50c0xlbmd0aChzaGFwZURhdGEpIHtcbiAgICAgIHZhciBzZWdtZW50c0xlbmd0aCA9IHNlZ21lbnRzTGVuZ3RoUG9vbC5uZXdFbGVtZW50KCk7XG4gICAgICB2YXIgY2xvc2VkID0gc2hhcGVEYXRhLmM7XG4gICAgICB2YXIgcGF0aFYgPSBzaGFwZURhdGEudjtcbiAgICAgIHZhciBwYXRoTyA9IHNoYXBlRGF0YS5vO1xuICAgICAgdmFyIHBhdGhJID0gc2hhcGVEYXRhLmk7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBzaGFwZURhdGEuX2xlbmd0aDtcbiAgICAgIHZhciBsZW5ndGhzID0gc2VnbWVudHNMZW5ndGgubGVuZ3RocztcbiAgICAgIHZhciB0b3RhbExlbmd0aCA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyBpICs9IDEpIHtcbiAgICAgICAgbGVuZ3Roc1tpXSA9IGdldEJlemllckxlbmd0aChwYXRoVltpXSwgcGF0aFZbaSArIDFdLCBwYXRoT1tpXSwgcGF0aElbaSArIDFdKTtcbiAgICAgICAgdG90YWxMZW5ndGggKz0gbGVuZ3Roc1tpXS5hZGRlZExlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNsb3NlZCAmJiBsZW4pIHtcbiAgICAgICAgbGVuZ3Roc1tpXSA9IGdldEJlemllckxlbmd0aChwYXRoVltpXSwgcGF0aFZbMF0sIHBhdGhPW2ldLCBwYXRoSVswXSk7XG4gICAgICAgIHRvdGFsTGVuZ3RoICs9IGxlbmd0aHNbaV0uYWRkZWRMZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnRzTGVuZ3RoLnRvdGFsTGVuZ3RoID0gdG90YWxMZW5ndGg7XG4gICAgICByZXR1cm4gc2VnbWVudHNMZW5ndGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQmV6aWVyRGF0YShsZW5ndGgpIHtcbiAgICAgIHRoaXMuc2VnbWVudExlbmd0aCA9IDA7XG4gICAgICB0aGlzLnBvaW50cyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFBvaW50RGF0YShwYXJ0aWFsLCBwb2ludCkge1xuICAgICAgdGhpcy5wYXJ0aWFsTGVuZ3RoID0gcGFydGlhbDtcbiAgICAgIHRoaXMucG9pbnQgPSBwb2ludDtcbiAgICB9XG5cbiAgICB2YXIgYnVpbGRCZXppZXJEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0b3JlZERhdGEgPSB7fTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAocHQxLCBwdDIsIHB0MywgcHQ0KSB7XG4gICAgICAgIHZhciBiZXppZXJOYW1lID0gKHB0MVswXSArICdfJyArIHB0MVsxXSArICdfJyArIHB0MlswXSArICdfJyArIHB0MlsxXSArICdfJyArIHB0M1swXSArICdfJyArIHB0M1sxXSArICdfJyArIHB0NFswXSArICdfJyArIHB0NFsxXSkucmVwbGFjZSgvXFwuL2csICdwJyk7XG5cbiAgICAgICAgaWYgKCFzdG9yZWREYXRhW2Jlemllck5hbWVdKSB7XG4gICAgICAgICAgdmFyIGN1cnZlU2VnbWVudHMgPSBnZXREZWZhdWx0Q3VydmVTZWdtZW50cygpO1xuICAgICAgICAgIHZhciBrO1xuICAgICAgICAgIHZhciBpO1xuICAgICAgICAgIHZhciBsZW47XG4gICAgICAgICAgdmFyIHB0Q29vcmQ7XG4gICAgICAgICAgdmFyIHBlcmM7XG4gICAgICAgICAgdmFyIGFkZGVkTGVuZ3RoID0gMDtcbiAgICAgICAgICB2YXIgcHREaXN0YW5jZTtcbiAgICAgICAgICB2YXIgcG9pbnQ7XG4gICAgICAgICAgdmFyIGxhc3RQb2ludCA9IG51bGw7XG5cbiAgICAgICAgICBpZiAocHQxLmxlbmd0aCA9PT0gMiAmJiAocHQxWzBdICE9PSBwdDJbMF0gfHwgcHQxWzFdICE9PSBwdDJbMV0pICYmIHBvaW50T25MaW5lMkQocHQxWzBdLCBwdDFbMV0sIHB0MlswXSwgcHQyWzFdLCBwdDFbMF0gKyBwdDNbMF0sIHB0MVsxXSArIHB0M1sxXSkgJiYgcG9pbnRPbkxpbmUyRChwdDFbMF0sIHB0MVsxXSwgcHQyWzBdLCBwdDJbMV0sIHB0MlswXSArIHB0NFswXSwgcHQyWzFdICsgcHQ0WzFdKSkge1xuICAgICAgICAgICAgY3VydmVTZWdtZW50cyA9IDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGJlemllckRhdGEgPSBuZXcgQmV6aWVyRGF0YShjdXJ2ZVNlZ21lbnRzKTtcbiAgICAgICAgICBsZW4gPSBwdDMubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChrID0gMDsgayA8IGN1cnZlU2VnbWVudHM7IGsgKz0gMSkge1xuICAgICAgICAgICAgcG9pbnQgPSBjcmVhdGVTaXplZEFycmF5KGxlbik7XG4gICAgICAgICAgICBwZXJjID0gayAvIChjdXJ2ZVNlZ21lbnRzIC0gMSk7XG4gICAgICAgICAgICBwdERpc3RhbmNlID0gMDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgIHB0Q29vcmQgPSBibVBvdygxIC0gcGVyYywgMykgKiBwdDFbaV0gKyAzICogYm1Qb3coMSAtIHBlcmMsIDIpICogcGVyYyAqIChwdDFbaV0gKyBwdDNbaV0pICsgMyAqICgxIC0gcGVyYykgKiBibVBvdyhwZXJjLCAyKSAqIChwdDJbaV0gKyBwdDRbaV0pICsgYm1Qb3cocGVyYywgMykgKiBwdDJbaV07XG4gICAgICAgICAgICAgIHBvaW50W2ldID0gcHRDb29yZDtcblxuICAgICAgICAgICAgICBpZiAobGFzdFBvaW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHREaXN0YW5jZSArPSBibVBvdyhwb2ludFtpXSAtIGxhc3RQb2ludFtpXSwgMik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHREaXN0YW5jZSA9IGJtU3FydChwdERpc3RhbmNlKTtcbiAgICAgICAgICAgIGFkZGVkTGVuZ3RoICs9IHB0RGlzdGFuY2U7XG4gICAgICAgICAgICBiZXppZXJEYXRhLnBvaW50c1trXSA9IG5ldyBQb2ludERhdGEocHREaXN0YW5jZSwgcG9pbnQpO1xuICAgICAgICAgICAgbGFzdFBvaW50ID0gcG9pbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYmV6aWVyRGF0YS5zZWdtZW50TGVuZ3RoID0gYWRkZWRMZW5ndGg7XG4gICAgICAgICAgc3RvcmVkRGF0YVtiZXppZXJOYW1lXSA9IGJlemllckRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RvcmVkRGF0YVtiZXppZXJOYW1lXTtcbiAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgZnVuY3Rpb24gZ2V0RGlzdGFuY2VQZXJjKHBlcmMsIGJlemllckRhdGEpIHtcbiAgICAgIHZhciBwZXJjZW50cyA9IGJlemllckRhdGEucGVyY2VudHM7XG4gICAgICB2YXIgbGVuZ3RocyA9IGJlemllckRhdGEubGVuZ3RocztcbiAgICAgIHZhciBsZW4gPSBwZXJjZW50cy5sZW5ndGg7XG4gICAgICB2YXIgaW5pdFBvcyA9IGJtRmxvb3IoKGxlbiAtIDEpICogcGVyYyk7XG4gICAgICB2YXIgbGVuZ3RoUG9zID0gcGVyYyAqIGJlemllckRhdGEuYWRkZWRMZW5ndGg7XG4gICAgICB2YXIgbFBlcmMgPSAwO1xuXG4gICAgICBpZiAoaW5pdFBvcyA9PT0gbGVuIC0gMSB8fCBpbml0UG9zID09PSAwIHx8IGxlbmd0aFBvcyA9PT0gbGVuZ3Roc1tpbml0UG9zXSkge1xuICAgICAgICByZXR1cm4gcGVyY2VudHNbaW5pdFBvc107XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXIgPSBsZW5ndGhzW2luaXRQb3NdID4gbGVuZ3RoUG9zID8gLTEgOiAxO1xuICAgICAgdmFyIGZsYWcgPSB0cnVlO1xuXG4gICAgICB3aGlsZSAoZmxhZykge1xuICAgICAgICBpZiAobGVuZ3Roc1tpbml0UG9zXSA8PSBsZW5ndGhQb3MgJiYgbGVuZ3Roc1tpbml0UG9zICsgMV0gPiBsZW5ndGhQb3MpIHtcbiAgICAgICAgICBsUGVyYyA9IChsZW5ndGhQb3MgLSBsZW5ndGhzW2luaXRQb3NdKSAvIChsZW5ndGhzW2luaXRQb3MgKyAxXSAtIGxlbmd0aHNbaW5pdFBvc10pO1xuICAgICAgICAgIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbml0UG9zICs9IGRpcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbml0UG9zIDwgMCB8fCBpbml0UG9zID49IGxlbiAtIDEpIHtcbiAgICAgICAgICAvLyBGSVggZm9yIFR5cGVkQXJyYXlzIHRoYXQgZG9uJ3Qgc3RvcmUgZmxvYXRpbmcgcG9pbnQgdmFsdWVzIHdpdGggZW5vdWdoIGFjY3VyYWN5XG4gICAgICAgICAgaWYgKGluaXRQb3MgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiBwZXJjZW50c1tpbml0UG9zXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBlcmNlbnRzW2luaXRQb3NdICsgKHBlcmNlbnRzW2luaXRQb3MgKyAxXSAtIHBlcmNlbnRzW2luaXRQb3NdKSAqIGxQZXJjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBvaW50SW5TZWdtZW50KHB0MSwgcHQyLCBwdDMsIHB0NCwgcGVyY2VudCwgYmV6aWVyRGF0YSkge1xuICAgICAgdmFyIHQxID0gZ2V0RGlzdGFuY2VQZXJjKHBlcmNlbnQsIGJlemllckRhdGEpO1xuICAgICAgdmFyIHUxID0gMSAtIHQxO1xuICAgICAgdmFyIHB0WCA9IG1hdGgucm91bmQoKHUxICogdTEgKiB1MSAqIHB0MVswXSArICh0MSAqIHUxICogdTEgKyB1MSAqIHQxICogdTEgKyB1MSAqIHUxICogdDEpICogcHQzWzBdICsgKHQxICogdDEgKiB1MSArIHUxICogdDEgKiB0MSArIHQxICogdTEgKiB0MSkgKiBwdDRbMF0gKyB0MSAqIHQxICogdDEgKiBwdDJbMF0pICogMTAwMCkgLyAxMDAwO1xuICAgICAgdmFyIHB0WSA9IG1hdGgucm91bmQoKHUxICogdTEgKiB1MSAqIHB0MVsxXSArICh0MSAqIHUxICogdTEgKyB1MSAqIHQxICogdTEgKyB1MSAqIHUxICogdDEpICogcHQzWzFdICsgKHQxICogdDEgKiB1MSArIHUxICogdDEgKiB0MSArIHQxICogdTEgKiB0MSkgKiBwdDRbMV0gKyB0MSAqIHQxICogdDEgKiBwdDJbMV0pICogMTAwMCkgLyAxMDAwO1xuICAgICAgcmV0dXJuIFtwdFgsIHB0WV07XG4gICAgfVxuXG4gICAgdmFyIGJlemllclNlZ21lbnRQb2ludHMgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgOCk7XG5cbiAgICBmdW5jdGlvbiBnZXROZXdTZWdtZW50KHB0MSwgcHQyLCBwdDMsIHB0NCwgc3RhcnRQZXJjLCBlbmRQZXJjLCBiZXppZXJEYXRhKSB7XG4gICAgICBpZiAoc3RhcnRQZXJjIDwgMCkge1xuICAgICAgICBzdGFydFBlcmMgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzdGFydFBlcmMgPiAxKSB7XG4gICAgICAgIHN0YXJ0UGVyYyA9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciB0MCA9IGdldERpc3RhbmNlUGVyYyhzdGFydFBlcmMsIGJlemllckRhdGEpO1xuICAgICAgZW5kUGVyYyA9IGVuZFBlcmMgPiAxID8gMSA6IGVuZFBlcmM7XG4gICAgICB2YXIgdDEgPSBnZXREaXN0YW5jZVBlcmMoZW5kUGVyYywgYmV6aWVyRGF0YSk7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBwdDEubGVuZ3RoO1xuICAgICAgdmFyIHUwID0gMSAtIHQwO1xuICAgICAgdmFyIHUxID0gMSAtIHQxO1xuICAgICAgdmFyIHUwdTB1MCA9IHUwICogdTAgKiB1MDtcbiAgICAgIHZhciB0MHUwdTBfMyA9IHQwICogdTAgKiB1MCAqIDM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG5cbiAgICAgIHZhciB0MHQwdTBfMyA9IHQwICogdDAgKiB1MCAqIDM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG5cbiAgICAgIHZhciB0MHQwdDAgPSB0MCAqIHQwICogdDA7IC8vXG5cbiAgICAgIHZhciB1MHUwdTEgPSB1MCAqIHUwICogdTE7XG4gICAgICB2YXIgdDB1MHUxXzMgPSB0MCAqIHUwICogdTEgKyB1MCAqIHQwICogdTEgKyB1MCAqIHUwICogdDE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG5cbiAgICAgIHZhciB0MHQwdTFfMyA9IHQwICogdDAgKiB1MSArIHUwICogdDAgKiB0MSArIHQwICogdTAgKiB0MTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcblxuICAgICAgdmFyIHQwdDB0MSA9IHQwICogdDAgKiB0MTsgLy9cblxuICAgICAgdmFyIHUwdTF1MSA9IHUwICogdTEgKiB1MTtcbiAgICAgIHZhciB0MHUxdTFfMyA9IHQwICogdTEgKiB1MSArIHUwICogdDEgKiB1MSArIHUwICogdTEgKiB0MTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcblxuICAgICAgdmFyIHQwdDF1MV8zID0gdDAgKiB0MSAqIHUxICsgdTAgKiB0MSAqIHQxICsgdDAgKiB1MSAqIHQxOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuXG4gICAgICB2YXIgdDB0MXQxID0gdDAgKiB0MSAqIHQxOyAvL1xuXG4gICAgICB2YXIgdTF1MXUxID0gdTEgKiB1MSAqIHUxO1xuICAgICAgdmFyIHQxdTF1MV8zID0gdDEgKiB1MSAqIHUxICsgdTEgKiB0MSAqIHUxICsgdTEgKiB1MSAqIHQxOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuXG4gICAgICB2YXIgdDF0MXUxXzMgPSB0MSAqIHQxICogdTEgKyB1MSAqIHQxICogdDEgKyB0MSAqIHUxICogdDE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG5cbiAgICAgIHZhciB0MXQxdDEgPSB0MSAqIHQxICogdDE7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBiZXppZXJTZWdtZW50UG9pbnRzW2kgKiA0XSA9IG1hdGgucm91bmQoKHUwdTB1MCAqIHB0MVtpXSArIHQwdTB1MF8zICogcHQzW2ldICsgdDB0MHUwXzMgKiBwdDRbaV0gKyB0MHQwdDAgKiBwdDJbaV0pICogMTAwMCkgLyAxMDAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuXG4gICAgICAgIGJlemllclNlZ21lbnRQb2ludHNbaSAqIDQgKyAxXSA9IG1hdGgucm91bmQoKHUwdTB1MSAqIHB0MVtpXSArIHQwdTB1MV8zICogcHQzW2ldICsgdDB0MHUxXzMgKiBwdDRbaV0gKyB0MHQwdDEgKiBwdDJbaV0pICogMTAwMCkgLyAxMDAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuXG4gICAgICAgIGJlemllclNlZ21lbnRQb2ludHNbaSAqIDQgKyAyXSA9IG1hdGgucm91bmQoKHUwdTF1MSAqIHB0MVtpXSArIHQwdTF1MV8zICogcHQzW2ldICsgdDB0MXUxXzMgKiBwdDRbaV0gKyB0MHQxdDEgKiBwdDJbaV0pICogMTAwMCkgLyAxMDAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuXG4gICAgICAgIGJlemllclNlZ21lbnRQb2ludHNbaSAqIDQgKyAzXSA9IG1hdGgucm91bmQoKHUxdTF1MSAqIHB0MVtpXSArIHQxdTF1MV8zICogcHQzW2ldICsgdDF0MXUxXzMgKiBwdDRbaV0gKyB0MXQxdDEgKiBwdDJbaV0pICogMTAwMCkgLyAxMDAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmV6aWVyU2VnbWVudFBvaW50cztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ2V0U2VnbWVudHNMZW5ndGg6IGdldFNlZ21lbnRzTGVuZ3RoLFxuICAgICAgZ2V0TmV3U2VnbWVudDogZ2V0TmV3U2VnbWVudCxcbiAgICAgIGdldFBvaW50SW5TZWdtZW50OiBnZXRQb2ludEluU2VnbWVudCxcbiAgICAgIGJ1aWxkQmV6aWVyRGF0YTogYnVpbGRCZXppZXJEYXRhLFxuICAgICAgcG9pbnRPbkxpbmUyRDogcG9pbnRPbkxpbmUyRCxcbiAgICAgIHBvaW50T25MaW5lM0Q6IHBvaW50T25MaW5lM0RcbiAgICB9O1xuICB9XG5cbiAgdmFyIGJleiA9IGJlekZ1bmN0aW9uKCk7XG5cbiAgdmFyIGluaXRGcmFtZSA9IGluaXRpYWxEZWZhdWx0RnJhbWU7XG4gIHZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG5cbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGVWYWx1ZShmcmFtZU51bSwgY2FjaGluZykge1xuICAgIHZhciBvZmZzZXRUaW1lID0gdGhpcy5vZmZzZXRUaW1lO1xuICAgIHZhciBuZXdWYWx1ZTtcblxuICAgIGlmICh0aGlzLnByb3BUeXBlID09PSAnbXVsdGlkaW1lbnNpb25hbCcpIHtcbiAgICAgIG5ld1ZhbHVlID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIHRoaXMucHYubGVuZ3RoKTtcbiAgICB9XG5cbiAgICB2YXIgaXRlcmF0aW9uSW5kZXggPSBjYWNoaW5nLmxhc3RJbmRleDtcbiAgICB2YXIgaSA9IGl0ZXJhdGlvbkluZGV4O1xuICAgIHZhciBsZW4gPSB0aGlzLmtleWZyYW1lcy5sZW5ndGggLSAxO1xuICAgIHZhciBmbGFnID0gdHJ1ZTtcbiAgICB2YXIga2V5RGF0YTtcbiAgICB2YXIgbmV4dEtleURhdGE7XG4gICAgdmFyIGtleWZyYW1lTWV0YWRhdGE7XG5cbiAgICB3aGlsZSAoZmxhZykge1xuICAgICAga2V5RGF0YSA9IHRoaXMua2V5ZnJhbWVzW2ldO1xuICAgICAgbmV4dEtleURhdGEgPSB0aGlzLmtleWZyYW1lc1tpICsgMV07XG5cbiAgICAgIGlmIChpID09PSBsZW4gLSAxICYmIGZyYW1lTnVtID49IG5leHRLZXlEYXRhLnQgLSBvZmZzZXRUaW1lKSB7XG4gICAgICAgIGlmIChrZXlEYXRhLmgpIHtcbiAgICAgICAgICBrZXlEYXRhID0gbmV4dEtleURhdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpdGVyYXRpb25JbmRleCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV4dEtleURhdGEudCAtIG9mZnNldFRpbWUgPiBmcmFtZU51bSkge1xuICAgICAgICBpdGVyYXRpb25JbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA8IGxlbiAtIDEpIHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0aW9uSW5kZXggPSAwO1xuICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAga2V5ZnJhbWVNZXRhZGF0YSA9IHRoaXMua2V5ZnJhbWVzTWV0YWRhdGFbaV0gfHwge307XG4gICAgdmFyIGs7XG4gICAgdmFyIGtMZW47XG4gICAgdmFyIHBlcmM7XG4gICAgdmFyIGpMZW47XG4gICAgdmFyIGo7XG4gICAgdmFyIGZuYztcbiAgICB2YXIgbmV4dEtleVRpbWUgPSBuZXh0S2V5RGF0YS50IC0gb2Zmc2V0VGltZTtcbiAgICB2YXIga2V5VGltZSA9IGtleURhdGEudCAtIG9mZnNldFRpbWU7XG4gICAgdmFyIGVuZFZhbHVlO1xuXG4gICAgaWYgKGtleURhdGEudG8pIHtcbiAgICAgIGlmICgha2V5ZnJhbWVNZXRhZGF0YS5iZXppZXJEYXRhKSB7XG4gICAgICAgIGtleWZyYW1lTWV0YWRhdGEuYmV6aWVyRGF0YSA9IGJlei5idWlsZEJlemllckRhdGEoa2V5RGF0YS5zLCBuZXh0S2V5RGF0YS5zIHx8IGtleURhdGEuZSwga2V5RGF0YS50bywga2V5RGF0YS50aSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBiZXppZXJEYXRhID0ga2V5ZnJhbWVNZXRhZGF0YS5iZXppZXJEYXRhO1xuXG4gICAgICBpZiAoZnJhbWVOdW0gPj0gbmV4dEtleVRpbWUgfHwgZnJhbWVOdW0gPCBrZXlUaW1lKSB7XG4gICAgICAgIHZhciBpbmQgPSBmcmFtZU51bSA+PSBuZXh0S2V5VGltZSA/IGJlemllckRhdGEucG9pbnRzLmxlbmd0aCAtIDEgOiAwO1xuICAgICAgICBrTGVuID0gYmV6aWVyRGF0YS5wb2ludHNbaW5kXS5wb2ludC5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChrID0gMDsgayA8IGtMZW47IGsgKz0gMSkge1xuICAgICAgICAgIG5ld1ZhbHVlW2tdID0gYmV6aWVyRGF0YS5wb2ludHNbaW5kXS5wb2ludFtrXTtcbiAgICAgICAgfSAvLyBjYWNoaW5nLl9sYXN0S2V5ZnJhbWVJbmRleCA9IC0xO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoa2V5ZnJhbWVNZXRhZGF0YS5fX2ZuY3QpIHtcbiAgICAgICAgICBmbmMgPSBrZXlmcmFtZU1ldGFkYXRhLl9fZm5jdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbmMgPSBCZXppZXJGYWN0b3J5LmdldEJlemllckVhc2luZyhrZXlEYXRhLm8ueCwga2V5RGF0YS5vLnksIGtleURhdGEuaS54LCBrZXlEYXRhLmkueSwga2V5RGF0YS5uKS5nZXQ7XG4gICAgICAgICAga2V5ZnJhbWVNZXRhZGF0YS5fX2ZuY3QgPSBmbmM7XG4gICAgICAgIH1cblxuICAgICAgICBwZXJjID0gZm5jKChmcmFtZU51bSAtIGtleVRpbWUpIC8gKG5leHRLZXlUaW1lIC0ga2V5VGltZSkpO1xuICAgICAgICB2YXIgZGlzdGFuY2VJbkxpbmUgPSBiZXppZXJEYXRhLnNlZ21lbnRMZW5ndGggKiBwZXJjO1xuICAgICAgICB2YXIgc2VnbWVudFBlcmM7XG4gICAgICAgIHZhciBhZGRlZExlbmd0aCA9IGNhY2hpbmcubGFzdEZyYW1lIDwgZnJhbWVOdW0gJiYgY2FjaGluZy5fbGFzdEtleWZyYW1lSW5kZXggPT09IGkgPyBjYWNoaW5nLl9sYXN0QWRkZWRMZW5ndGggOiAwO1xuICAgICAgICBqID0gY2FjaGluZy5sYXN0RnJhbWUgPCBmcmFtZU51bSAmJiBjYWNoaW5nLl9sYXN0S2V5ZnJhbWVJbmRleCA9PT0gaSA/IGNhY2hpbmcuX2xhc3RQb2ludCA6IDA7XG4gICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICBqTGVuID0gYmV6aWVyRGF0YS5wb2ludHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChmbGFnKSB7XG4gICAgICAgICAgYWRkZWRMZW5ndGggKz0gYmV6aWVyRGF0YS5wb2ludHNbal0ucGFydGlhbExlbmd0aDtcblxuICAgICAgICAgIGlmIChkaXN0YW5jZUluTGluZSA9PT0gMCB8fCBwZXJjID09PSAwIHx8IGogPT09IGJlemllckRhdGEucG9pbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGtMZW4gPSBiZXppZXJEYXRhLnBvaW50c1tqXS5wb2ludC5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBrTGVuOyBrICs9IDEpIHtcbiAgICAgICAgICAgICAgbmV3VmFsdWVba10gPSBiZXppZXJEYXRhLnBvaW50c1tqXS5wb2ludFtrXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmIChkaXN0YW5jZUluTGluZSA+PSBhZGRlZExlbmd0aCAmJiBkaXN0YW5jZUluTGluZSA8IGFkZGVkTGVuZ3RoICsgYmV6aWVyRGF0YS5wb2ludHNbaiArIDFdLnBhcnRpYWxMZW5ndGgpIHtcbiAgICAgICAgICAgIHNlZ21lbnRQZXJjID0gKGRpc3RhbmNlSW5MaW5lIC0gYWRkZWRMZW5ndGgpIC8gYmV6aWVyRGF0YS5wb2ludHNbaiArIDFdLnBhcnRpYWxMZW5ndGg7XG4gICAgICAgICAgICBrTGVuID0gYmV6aWVyRGF0YS5wb2ludHNbal0ucG9pbnQubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwga0xlbjsgayArPSAxKSB7XG4gICAgICAgICAgICAgIG5ld1ZhbHVlW2tdID0gYmV6aWVyRGF0YS5wb2ludHNbal0ucG9pbnRba10gKyAoYmV6aWVyRGF0YS5wb2ludHNbaiArIDFdLnBvaW50W2tdIC0gYmV6aWVyRGF0YS5wb2ludHNbal0ucG9pbnRba10pICogc2VnbWVudFBlcmM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChqIDwgakxlbiAtIDEpIHtcbiAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNhY2hpbmcuX2xhc3RQb2ludCA9IGo7XG4gICAgICAgIGNhY2hpbmcuX2xhc3RBZGRlZExlbmd0aCA9IGFkZGVkTGVuZ3RoIC0gYmV6aWVyRGF0YS5wb2ludHNbal0ucGFydGlhbExlbmd0aDtcbiAgICAgICAgY2FjaGluZy5fbGFzdEtleWZyYW1lSW5kZXggPSBpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb3V0WDtcbiAgICAgIHZhciBvdXRZO1xuICAgICAgdmFyIGluWDtcbiAgICAgIHZhciBpblk7XG4gICAgICB2YXIga2V5VmFsdWU7XG4gICAgICBsZW4gPSBrZXlEYXRhLnMubGVuZ3RoO1xuICAgICAgZW5kVmFsdWUgPSBuZXh0S2V5RGF0YS5zIHx8IGtleURhdGEuZTtcblxuICAgICAgaWYgKHRoaXMuc2ggJiYga2V5RGF0YS5oICE9PSAxKSB7XG4gICAgICAgIGlmIChmcmFtZU51bSA+PSBuZXh0S2V5VGltZSkge1xuICAgICAgICAgIG5ld1ZhbHVlWzBdID0gZW5kVmFsdWVbMF07XG4gICAgICAgICAgbmV3VmFsdWVbMV0gPSBlbmRWYWx1ZVsxXTtcbiAgICAgICAgICBuZXdWYWx1ZVsyXSA9IGVuZFZhbHVlWzJdO1xuICAgICAgICB9IGVsc2UgaWYgKGZyYW1lTnVtIDw9IGtleVRpbWUpIHtcbiAgICAgICAgICBuZXdWYWx1ZVswXSA9IGtleURhdGEuc1swXTtcbiAgICAgICAgICBuZXdWYWx1ZVsxXSA9IGtleURhdGEuc1sxXTtcbiAgICAgICAgICBuZXdWYWx1ZVsyXSA9IGtleURhdGEuc1syXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcXVhdFN0YXJ0ID0gY3JlYXRlUXVhdGVybmlvbihrZXlEYXRhLnMpO1xuICAgICAgICAgIHZhciBxdWF0RW5kID0gY3JlYXRlUXVhdGVybmlvbihlbmRWYWx1ZSk7XG4gICAgICAgICAgdmFyIHRpbWUgPSAoZnJhbWVOdW0gLSBrZXlUaW1lKSAvIChuZXh0S2V5VGltZSAtIGtleVRpbWUpO1xuICAgICAgICAgIHF1YXRlcm5pb25Ub0V1bGVyKG5ld1ZhbHVlLCBzbGVycChxdWF0U3RhcnQsIHF1YXRFbmQsIHRpbWUpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKGtleURhdGEuaCAhPT0gMSkge1xuICAgICAgICAgICAgaWYgKGZyYW1lTnVtID49IG5leHRLZXlUaW1lKSB7XG4gICAgICAgICAgICAgIHBlcmMgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmcmFtZU51bSA8IGtleVRpbWUpIHtcbiAgICAgICAgICAgICAgcGVyYyA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoa2V5RGF0YS5vLnguY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZXlmcmFtZU1ldGFkYXRhLl9fZm5jdCkge1xuICAgICAgICAgICAgICAgICAga2V5ZnJhbWVNZXRhZGF0YS5fX2ZuY3QgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWtleWZyYW1lTWV0YWRhdGEuX19mbmN0W2ldKSB7XG4gICAgICAgICAgICAgICAgICBvdXRYID0ga2V5RGF0YS5vLnhbaV0gPT09IHVuZGVmaW5lZCA/IGtleURhdGEuby54WzBdIDoga2V5RGF0YS5vLnhbaV07XG4gICAgICAgICAgICAgICAgICBvdXRZID0ga2V5RGF0YS5vLnlbaV0gPT09IHVuZGVmaW5lZCA/IGtleURhdGEuby55WzBdIDoga2V5RGF0YS5vLnlbaV07XG4gICAgICAgICAgICAgICAgICBpblggPSBrZXlEYXRhLmkueFtpXSA9PT0gdW5kZWZpbmVkID8ga2V5RGF0YS5pLnhbMF0gOiBrZXlEYXRhLmkueFtpXTtcbiAgICAgICAgICAgICAgICAgIGluWSA9IGtleURhdGEuaS55W2ldID09PSB1bmRlZmluZWQgPyBrZXlEYXRhLmkueVswXSA6IGtleURhdGEuaS55W2ldO1xuICAgICAgICAgICAgICAgICAgZm5jID0gQmV6aWVyRmFjdG9yeS5nZXRCZXppZXJFYXNpbmcob3V0WCwgb3V0WSwgaW5YLCBpblkpLmdldDtcbiAgICAgICAgICAgICAgICAgIGtleWZyYW1lTWV0YWRhdGEuX19mbmN0W2ldID0gZm5jO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBmbmMgPSBrZXlmcmFtZU1ldGFkYXRhLl9fZm5jdFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWtleWZyYW1lTWV0YWRhdGEuX19mbmN0KSB7XG4gICAgICAgICAgICAgICAgb3V0WCA9IGtleURhdGEuby54O1xuICAgICAgICAgICAgICAgIG91dFkgPSBrZXlEYXRhLm8ueTtcbiAgICAgICAgICAgICAgICBpblggPSBrZXlEYXRhLmkueDtcbiAgICAgICAgICAgICAgICBpblkgPSBrZXlEYXRhLmkueTtcbiAgICAgICAgICAgICAgICBmbmMgPSBCZXppZXJGYWN0b3J5LmdldEJlemllckVhc2luZyhvdXRYLCBvdXRZLCBpblgsIGluWSkuZ2V0O1xuICAgICAgICAgICAgICAgIGtleURhdGEua2V5ZnJhbWVNZXRhZGF0YSA9IGZuYztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbmMgPSBrZXlmcmFtZU1ldGFkYXRhLl9fZm5jdDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHBlcmMgPSBmbmMoKGZyYW1lTnVtIC0ga2V5VGltZSkgLyAobmV4dEtleVRpbWUgLSBrZXlUaW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZW5kVmFsdWUgPSBuZXh0S2V5RGF0YS5zIHx8IGtleURhdGEuZTtcbiAgICAgICAgICBrZXlWYWx1ZSA9IGtleURhdGEuaCA9PT0gMSA/IGtleURhdGEuc1tpXSA6IGtleURhdGEuc1tpXSArIChlbmRWYWx1ZVtpXSAtIGtleURhdGEuc1tpXSkgKiBwZXJjO1xuXG4gICAgICAgICAgaWYgKHRoaXMucHJvcFR5cGUgPT09ICdtdWx0aWRpbWVuc2lvbmFsJykge1xuICAgICAgICAgICAgbmV3VmFsdWVbaV0gPSBrZXlWYWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBrZXlWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjYWNoaW5nLmxhc3RJbmRleCA9IGl0ZXJhdGlvbkluZGV4O1xuICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgfSAvLyBiYXNlZCBvbiBAVG9qaSdzIGh0dHBzOi8vZ2l0aHViLmNvbS90b2ppL2dsLW1hdHJpeC9cblxuXG4gIGZ1bmN0aW9uIHNsZXJwKGEsIGIsIHQpIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgdmFyIGF4ID0gYVswXTtcbiAgICB2YXIgYXkgPSBhWzFdO1xuICAgIHZhciBheiA9IGFbMl07XG4gICAgdmFyIGF3ID0gYVszXTtcbiAgICB2YXIgYnggPSBiWzBdO1xuICAgIHZhciBieSA9IGJbMV07XG4gICAgdmFyIGJ6ID0gYlsyXTtcbiAgICB2YXIgYncgPSBiWzNdO1xuICAgIHZhciBvbWVnYTtcbiAgICB2YXIgY29zb207XG4gICAgdmFyIHNpbm9tO1xuICAgIHZhciBzY2FsZTA7XG4gICAgdmFyIHNjYWxlMTtcbiAgICBjb3NvbSA9IGF4ICogYnggKyBheSAqIGJ5ICsgYXogKiBieiArIGF3ICogYnc7XG5cbiAgICBpZiAoY29zb20gPCAwLjApIHtcbiAgICAgIGNvc29tID0gLWNvc29tO1xuICAgICAgYnggPSAtYng7XG4gICAgICBieSA9IC1ieTtcbiAgICAgIGJ6ID0gLWJ6O1xuICAgICAgYncgPSAtYnc7XG4gICAgfVxuXG4gICAgaWYgKDEuMCAtIGNvc29tID4gMC4wMDAwMDEpIHtcbiAgICAgIG9tZWdhID0gTWF0aC5hY29zKGNvc29tKTtcbiAgICAgIHNpbm9tID0gTWF0aC5zaW4ob21lZ2EpO1xuICAgICAgc2NhbGUwID0gTWF0aC5zaW4oKDEuMCAtIHQpICogb21lZ2EpIC8gc2lub207XG4gICAgICBzY2FsZTEgPSBNYXRoLnNpbih0ICogb21lZ2EpIC8gc2lub207XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlMCA9IDEuMCAtIHQ7XG4gICAgICBzY2FsZTEgPSB0O1xuICAgIH1cblxuICAgIG91dFswXSA9IHNjYWxlMCAqIGF4ICsgc2NhbGUxICogYng7XG4gICAgb3V0WzFdID0gc2NhbGUwICogYXkgKyBzY2FsZTEgKiBieTtcbiAgICBvdXRbMl0gPSBzY2FsZTAgKiBheiArIHNjYWxlMSAqIGJ6O1xuICAgIG91dFszXSA9IHNjYWxlMCAqIGF3ICsgc2NhbGUxICogYnc7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHF1YXRlcm5pb25Ub0V1bGVyKG91dCwgcXVhdCkge1xuICAgIHZhciBxeCA9IHF1YXRbMF07XG4gICAgdmFyIHF5ID0gcXVhdFsxXTtcbiAgICB2YXIgcXogPSBxdWF0WzJdO1xuICAgIHZhciBxdyA9IHF1YXRbM107XG4gICAgdmFyIGhlYWRpbmcgPSBNYXRoLmF0YW4yKDIgKiBxeSAqIHF3IC0gMiAqIHF4ICogcXosIDEgLSAyICogcXkgKiBxeSAtIDIgKiBxeiAqIHF6KTtcbiAgICB2YXIgYXR0aXR1ZGUgPSBNYXRoLmFzaW4oMiAqIHF4ICogcXkgKyAyICogcXogKiBxdyk7XG4gICAgdmFyIGJhbmsgPSBNYXRoLmF0YW4yKDIgKiBxeCAqIHF3IC0gMiAqIHF5ICogcXosIDEgLSAyICogcXggKiBxeCAtIDIgKiBxeiAqIHF6KTtcbiAgICBvdXRbMF0gPSBoZWFkaW5nIC8gZGVnVG9SYWRzO1xuICAgIG91dFsxXSA9IGF0dGl0dWRlIC8gZGVnVG9SYWRzO1xuICAgIG91dFsyXSA9IGJhbmsgLyBkZWdUb1JhZHM7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVRdWF0ZXJuaW9uKHZhbHVlcykge1xuICAgIHZhciBoZWFkaW5nID0gdmFsdWVzWzBdICogZGVnVG9SYWRzO1xuICAgIHZhciBhdHRpdHVkZSA9IHZhbHVlc1sxXSAqIGRlZ1RvUmFkcztcbiAgICB2YXIgYmFuayA9IHZhbHVlc1syXSAqIGRlZ1RvUmFkcztcbiAgICB2YXIgYzEgPSBNYXRoLmNvcyhoZWFkaW5nIC8gMik7XG4gICAgdmFyIGMyID0gTWF0aC5jb3MoYXR0aXR1ZGUgLyAyKTtcbiAgICB2YXIgYzMgPSBNYXRoLmNvcyhiYW5rIC8gMik7XG4gICAgdmFyIHMxID0gTWF0aC5zaW4oaGVhZGluZyAvIDIpO1xuICAgIHZhciBzMiA9IE1hdGguc2luKGF0dGl0dWRlIC8gMik7XG4gICAgdmFyIHMzID0gTWF0aC5zaW4oYmFuayAvIDIpO1xuICAgIHZhciB3ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuICAgIHZhciB4ID0gczEgKiBzMiAqIGMzICsgYzEgKiBjMiAqIHMzO1xuICAgIHZhciB5ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgIHZhciB6ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuICAgIHJldHVybiBbeCwgeSwgeiwgd107XG4gIH1cblxuICBmdW5jdGlvbiBnZXRWYWx1ZUF0Q3VycmVudFRpbWUoKSB7XG4gICAgdmFyIGZyYW1lTnVtID0gdGhpcy5jb21wLnJlbmRlcmVkRnJhbWUgLSB0aGlzLm9mZnNldFRpbWU7XG4gICAgdmFyIGluaXRUaW1lID0gdGhpcy5rZXlmcmFtZXNbMF0udCAtIHRoaXMub2Zmc2V0VGltZTtcbiAgICB2YXIgZW5kVGltZSA9IHRoaXMua2V5ZnJhbWVzW3RoaXMua2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnQgLSB0aGlzLm9mZnNldFRpbWU7XG5cbiAgICBpZiAoIShmcmFtZU51bSA9PT0gdGhpcy5fY2FjaGluZy5sYXN0RnJhbWUgfHwgdGhpcy5fY2FjaGluZy5sYXN0RnJhbWUgIT09IGluaXRGcmFtZSAmJiAodGhpcy5fY2FjaGluZy5sYXN0RnJhbWUgPj0gZW5kVGltZSAmJiBmcmFtZU51bSA+PSBlbmRUaW1lIHx8IHRoaXMuX2NhY2hpbmcubGFzdEZyYW1lIDwgaW5pdFRpbWUgJiYgZnJhbWVOdW0gPCBpbml0VGltZSkpKSB7XG4gICAgICBpZiAodGhpcy5fY2FjaGluZy5sYXN0RnJhbWUgPj0gZnJhbWVOdW0pIHtcbiAgICAgICAgdGhpcy5fY2FjaGluZy5fbGFzdEtleWZyYW1lSW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5fY2FjaGluZy5sYXN0SW5kZXggPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVuZGVyUmVzdWx0ID0gdGhpcy5pbnRlcnBvbGF0ZVZhbHVlKGZyYW1lTnVtLCB0aGlzLl9jYWNoaW5nKTtcbiAgICAgIHRoaXMucHYgPSByZW5kZXJSZXN1bHQ7XG4gICAgfVxuXG4gICAgdGhpcy5fY2FjaGluZy5sYXN0RnJhbWUgPSBmcmFtZU51bTtcbiAgICByZXR1cm4gdGhpcy5wdjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFZWYWx1ZSh2YWwpIHtcbiAgICB2YXIgbXVsdGlwbGllZFZhbHVlO1xuXG4gICAgaWYgKHRoaXMucHJvcFR5cGUgPT09ICd1bmlkaW1lbnNpb25hbCcpIHtcbiAgICAgIG11bHRpcGxpZWRWYWx1ZSA9IHZhbCAqIHRoaXMubXVsdDtcblxuICAgICAgaWYgKG1hdGhBYnModGhpcy52IC0gbXVsdGlwbGllZFZhbHVlKSA+IDAuMDAwMDEpIHtcbiAgICAgICAgdGhpcy52ID0gbXVsdGlwbGllZFZhbHVlO1xuICAgICAgICB0aGlzLl9tZGYgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgbGVuID0gdGhpcy52Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgbXVsdGlwbGllZFZhbHVlID0gdmFsW2ldICogdGhpcy5tdWx0O1xuXG4gICAgICAgIGlmIChtYXRoQWJzKHRoaXMudltpXSAtIG11bHRpcGxpZWRWYWx1ZSkgPiAwLjAwMDAxKSB7XG4gICAgICAgICAgdGhpcy52W2ldID0gbXVsdGlwbGllZFZhbHVlO1xuICAgICAgICAgIHRoaXMuX21kZiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpICs9IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0VmZmVjdHNTZXF1ZW5jZSgpIHtcbiAgICBpZiAodGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5mcmFtZUlkIHx8ICF0aGlzLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sb2NrKSB7XG4gICAgICB0aGlzLnNldFZWYWx1ZSh0aGlzLnB2KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmxvY2sgPSB0cnVlO1xuICAgIHRoaXMuX21kZiA9IHRoaXMuX2lzRmlyc3RGcmFtZTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoO1xuICAgIHZhciBmaW5hbFZhbHVlID0gdGhpcy5rZiA/IHRoaXMucHYgOiB0aGlzLmRhdGEuaztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgZmluYWxWYWx1ZSA9IHRoaXMuZWZmZWN0c1NlcXVlbmNlW2ldKGZpbmFsVmFsdWUpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0VlZhbHVlKGZpbmFsVmFsdWUpO1xuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IGZhbHNlO1xuICAgIHRoaXMubG9jayA9IGZhbHNlO1xuICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRFZmZlY3QoZWZmZWN0RnVuY3Rpb24pIHtcbiAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZS5wdXNoKGVmZmVjdEZ1bmN0aW9uKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hZGREeW5hbWljUHJvcGVydHkodGhpcyk7XG4gIH1cblxuICBmdW5jdGlvbiBWYWx1ZVByb3BlcnR5KGVsZW0sIGRhdGEsIG11bHQsIGNvbnRhaW5lcikge1xuICAgIHRoaXMucHJvcFR5cGUgPSAndW5pZGltZW5zaW9uYWwnO1xuICAgIHRoaXMubXVsdCA9IG11bHQgfHwgMTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMudiA9IG11bHQgPyBkYXRhLmsgKiBtdWx0IDogZGF0YS5rO1xuICAgIHRoaXMucHYgPSBkYXRhLms7XG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLmNvbXAgPSBlbGVtLmNvbXA7XG4gICAgdGhpcy5rID0gZmFsc2U7XG4gICAgdGhpcy5rZiA9IGZhbHNlO1xuICAgIHRoaXMudmVsID0gMDtcbiAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZSA9IFtdO1xuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHByb2Nlc3NFZmZlY3RzU2VxdWVuY2U7XG4gICAgdGhpcy5zZXRWVmFsdWUgPSBzZXRWVmFsdWU7XG4gICAgdGhpcy5hZGRFZmZlY3QgPSBhZGRFZmZlY3Q7XG4gIH1cblxuICBmdW5jdGlvbiBNdWx0aURpbWVuc2lvbmFsUHJvcGVydHkoZWxlbSwgZGF0YSwgbXVsdCwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wcm9wVHlwZSA9ICdtdWx0aWRpbWVuc2lvbmFsJztcbiAgICB0aGlzLm11bHQgPSBtdWx0IHx8IDE7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcbiAgICB0aGlzLmsgPSBmYWxzZTtcbiAgICB0aGlzLmtmID0gZmFsc2U7XG4gICAgdGhpcy5mcmFtZUlkID0gLTE7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IGRhdGEuay5sZW5ndGg7XG4gICAgdGhpcy52ID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XG4gICAgdGhpcy5wdiA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuICAgIHRoaXMudmVsID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMudltpXSA9IGRhdGEua1tpXSAqIHRoaXMubXVsdDtcbiAgICAgIHRoaXMucHZbaV0gPSBkYXRhLmtbaV07XG4gICAgfVxuXG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcbiAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZSA9IFtdO1xuICAgIHRoaXMuZ2V0VmFsdWUgPSBwcm9jZXNzRWZmZWN0c1NlcXVlbmNlO1xuICAgIHRoaXMuc2V0VlZhbHVlID0gc2V0VlZhbHVlO1xuICAgIHRoaXMuYWRkRWZmZWN0ID0gYWRkRWZmZWN0O1xuICB9XG5cbiAgZnVuY3Rpb24gS2V5ZnJhbWVkVmFsdWVQcm9wZXJ0eShlbGVtLCBkYXRhLCBtdWx0LCBjb250YWluZXIpIHtcbiAgICB0aGlzLnByb3BUeXBlID0gJ3VuaWRpbWVuc2lvbmFsJztcbiAgICB0aGlzLmtleWZyYW1lcyA9IGRhdGEuaztcbiAgICB0aGlzLmtleWZyYW1lc01ldGFkYXRhID0gW107XG4gICAgdGhpcy5vZmZzZXRUaW1lID0gZWxlbS5kYXRhLnN0O1xuICAgIHRoaXMuZnJhbWVJZCA9IC0xO1xuICAgIHRoaXMuX2NhY2hpbmcgPSB7XG4gICAgICBsYXN0RnJhbWU6IGluaXRGcmFtZSxcbiAgICAgIGxhc3RJbmRleDogMCxcbiAgICAgIHZhbHVlOiAwLFxuICAgICAgX2xhc3RLZXlmcmFtZUluZGV4OiAtMVxuICAgIH07XG4gICAgdGhpcy5rID0gdHJ1ZTtcbiAgICB0aGlzLmtmID0gdHJ1ZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMubXVsdCA9IG11bHQgfHwgMTtcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcbiAgICB0aGlzLnYgPSBpbml0RnJhbWU7XG4gICAgdGhpcy5wdiA9IGluaXRGcmFtZTtcbiAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xuICAgIHRoaXMuZ2V0VmFsdWUgPSBwcm9jZXNzRWZmZWN0c1NlcXVlbmNlO1xuICAgIHRoaXMuc2V0VlZhbHVlID0gc2V0VlZhbHVlO1xuICAgIHRoaXMuaW50ZXJwb2xhdGVWYWx1ZSA9IGludGVycG9sYXRlVmFsdWU7XG4gICAgdGhpcy5lZmZlY3RzU2VxdWVuY2UgPSBbZ2V0VmFsdWVBdEN1cnJlbnRUaW1lLmJpbmQodGhpcyldO1xuICAgIHRoaXMuYWRkRWZmZWN0ID0gYWRkRWZmZWN0O1xuICB9XG5cbiAgZnVuY3Rpb24gS2V5ZnJhbWVkTXVsdGlkaW1lbnNpb25hbFByb3BlcnR5KGVsZW0sIGRhdGEsIG11bHQsIGNvbnRhaW5lcikge1xuICAgIHRoaXMucHJvcFR5cGUgPSAnbXVsdGlkaW1lbnNpb25hbCc7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IGRhdGEuay5sZW5ndGg7XG4gICAgdmFyIHM7XG4gICAgdmFyIGU7XG4gICAgdmFyIHRvO1xuICAgIHZhciB0aTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyBpICs9IDEpIHtcbiAgICAgIGlmIChkYXRhLmtbaV0udG8gJiYgZGF0YS5rW2ldLnMgJiYgZGF0YS5rW2kgKyAxXSAmJiBkYXRhLmtbaSArIDFdLnMpIHtcbiAgICAgICAgcyA9IGRhdGEua1tpXS5zO1xuICAgICAgICBlID0gZGF0YS5rW2kgKyAxXS5zO1xuICAgICAgICB0byA9IGRhdGEua1tpXS50bztcbiAgICAgICAgdGkgPSBkYXRhLmtbaV0udGk7XG5cbiAgICAgICAgaWYgKHMubGVuZ3RoID09PSAyICYmICEoc1swXSA9PT0gZVswXSAmJiBzWzFdID09PSBlWzFdKSAmJiBiZXoucG9pbnRPbkxpbmUyRChzWzBdLCBzWzFdLCBlWzBdLCBlWzFdLCBzWzBdICsgdG9bMF0sIHNbMV0gKyB0b1sxXSkgJiYgYmV6LnBvaW50T25MaW5lMkQoc1swXSwgc1sxXSwgZVswXSwgZVsxXSwgZVswXSArIHRpWzBdLCBlWzFdICsgdGlbMV0pIHx8IHMubGVuZ3RoID09PSAzICYmICEoc1swXSA9PT0gZVswXSAmJiBzWzFdID09PSBlWzFdICYmIHNbMl0gPT09IGVbMl0pICYmIGJlei5wb2ludE9uTGluZTNEKHNbMF0sIHNbMV0sIHNbMl0sIGVbMF0sIGVbMV0sIGVbMl0sIHNbMF0gKyB0b1swXSwgc1sxXSArIHRvWzFdLCBzWzJdICsgdG9bMl0pICYmIGJlei5wb2ludE9uTGluZTNEKHNbMF0sIHNbMV0sIHNbMl0sIGVbMF0sIGVbMV0sIGVbMl0sIGVbMF0gKyB0aVswXSwgZVsxXSArIHRpWzFdLCBlWzJdICsgdGlbMl0pKSB7XG4gICAgICAgICAgZGF0YS5rW2ldLnRvID0gbnVsbDtcbiAgICAgICAgICBkYXRhLmtbaV0udGkgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNbMF0gPT09IGVbMF0gJiYgc1sxXSA9PT0gZVsxXSAmJiB0b1swXSA9PT0gMCAmJiB0b1sxXSA9PT0gMCAmJiB0aVswXSA9PT0gMCAmJiB0aVsxXSA9PT0gMCkge1xuICAgICAgICAgIGlmIChzLmxlbmd0aCA9PT0gMiB8fCBzWzJdID09PSBlWzJdICYmIHRvWzJdID09PSAwICYmIHRpWzJdID09PSAwKSB7XG4gICAgICAgICAgICBkYXRhLmtbaV0udG8gPSBudWxsO1xuICAgICAgICAgICAgZGF0YS5rW2ldLnRpID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZSA9IFtnZXRWYWx1ZUF0Q3VycmVudFRpbWUuYmluZCh0aGlzKV07XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmtleWZyYW1lcyA9IGRhdGEuaztcbiAgICB0aGlzLmtleWZyYW1lc01ldGFkYXRhID0gW107XG4gICAgdGhpcy5vZmZzZXRUaW1lID0gZWxlbS5kYXRhLnN0O1xuICAgIHRoaXMuayA9IHRydWU7XG4gICAgdGhpcy5rZiA9IHRydWU7XG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcbiAgICB0aGlzLm11bHQgPSBtdWx0IHx8IDE7XG4gICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLmNvbXAgPSBlbGVtLmNvbXA7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHByb2Nlc3NFZmZlY3RzU2VxdWVuY2U7XG4gICAgdGhpcy5zZXRWVmFsdWUgPSBzZXRWVmFsdWU7XG4gICAgdGhpcy5pbnRlcnBvbGF0ZVZhbHVlID0gaW50ZXJwb2xhdGVWYWx1ZTtcbiAgICB0aGlzLmZyYW1lSWQgPSAtMTtcbiAgICB2YXIgYXJyTGVuID0gZGF0YS5rWzBdLnMubGVuZ3RoO1xuICAgIHRoaXMudiA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBhcnJMZW4pO1xuICAgIHRoaXMucHYgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgYXJyTGVuKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBhcnJMZW47IGkgKz0gMSkge1xuICAgICAgdGhpcy52W2ldID0gaW5pdEZyYW1lO1xuICAgICAgdGhpcy5wdltpXSA9IGluaXRGcmFtZTtcbiAgICB9XG5cbiAgICB0aGlzLl9jYWNoaW5nID0ge1xuICAgICAgbGFzdEZyYW1lOiBpbml0RnJhbWUsXG4gICAgICBsYXN0SW5kZXg6IDAsXG4gICAgICB2YWx1ZTogY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGFyckxlbilcbiAgICB9O1xuICAgIHRoaXMuYWRkRWZmZWN0ID0gYWRkRWZmZWN0O1xuICB9XG5cbiAgdmFyIFByb3BlcnR5RmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBnZXRQcm9wKGVsZW0sIGRhdGEsIHR5cGUsIG11bHQsIGNvbnRhaW5lcikge1xuICAgICAgaWYgKGRhdGEuc2lkKSB7XG4gICAgICAgIGRhdGEgPSBlbGVtLmdsb2JhbERhdGEuc2xvdE1hbmFnZXIuZ2V0UHJvcChkYXRhKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHA7XG5cbiAgICAgIGlmICghZGF0YS5rLmxlbmd0aCkge1xuICAgICAgICBwID0gbmV3IFZhbHVlUHJvcGVydHkoZWxlbSwgZGF0YSwgbXVsdCwgY29udGFpbmVyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEua1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcCA9IG5ldyBNdWx0aURpbWVuc2lvbmFsUHJvcGVydHkoZWxlbSwgZGF0YSwgbXVsdCwgY29udGFpbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHAgPSBuZXcgS2V5ZnJhbWVkVmFsdWVQcm9wZXJ0eShlbGVtLCBkYXRhLCBtdWx0LCBjb250YWluZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBwID0gbmV3IEtleWZyYW1lZE11bHRpZGltZW5zaW9uYWxQcm9wZXJ0eShlbGVtLCBkYXRhLCBtdWx0LCBjb250YWluZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHAuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICBjb250YWluZXIuYWRkRHluYW1pY1Byb3BlcnR5KHApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICB2YXIgb2IgPSB7XG4gICAgICBnZXRQcm9wOiBnZXRQcm9wXG4gICAgfTtcbiAgICByZXR1cm4gb2I7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBEeW5hbWljUHJvcGVydHlDb250YWluZXIoKSB7fVxuXG4gIER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lci5wcm90b3R5cGUgPSB7XG4gICAgYWRkRHluYW1pY1Byb3BlcnR5OiBmdW5jdGlvbiBhZGREeW5hbWljUHJvcGVydHkocHJvcCkge1xuICAgICAgaWYgKHRoaXMuZHluYW1pY1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllcy5wdXNoKHByb3ApO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGREeW5hbWljUHJvcGVydHkodGhpcyk7XG4gICAgICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzOiBmdW5jdGlvbiBpdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKSB7XG4gICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllc1tpXS5nZXRWYWx1ZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldLl9tZGYpIHtcbiAgICAgICAgICB0aGlzLl9tZGYgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBpbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyOiBmdW5jdGlvbiBpbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzID0gW107XG4gICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHBvaW50UG9vbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIDIpO1xuICAgIH1cblxuICAgIHJldHVybiBwb29sRmFjdG9yeSg4LCBjcmVhdGUpO1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gU2hhcGVQYXRoKCkge1xuICAgIHRoaXMuYyA9IGZhbHNlO1xuICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWF4TGVuZ3RoID0gODtcbiAgICB0aGlzLnYgPSBjcmVhdGVTaXplZEFycmF5KHRoaXMuX21heExlbmd0aCk7XG4gICAgdGhpcy5vID0gY3JlYXRlU2l6ZWRBcnJheSh0aGlzLl9tYXhMZW5ndGgpO1xuICAgIHRoaXMuaSA9IGNyZWF0ZVNpemVkQXJyYXkodGhpcy5fbWF4TGVuZ3RoKTtcbiAgfVxuXG4gIFNoYXBlUGF0aC5wcm90b3R5cGUuc2V0UGF0aERhdGEgPSBmdW5jdGlvbiAoY2xvc2VkLCBsZW4pIHtcbiAgICB0aGlzLmMgPSBjbG9zZWQ7XG4gICAgdGhpcy5zZXRMZW5ndGgobGVuKTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgdGhpcy52W2ldID0gcG9pbnRQb29sLm5ld0VsZW1lbnQoKTtcbiAgICAgIHRoaXMub1tpXSA9IHBvaW50UG9vbC5uZXdFbGVtZW50KCk7XG4gICAgICB0aGlzLmlbaV0gPSBwb2ludFBvb2wubmV3RWxlbWVudCgpO1xuICAgICAgaSArPSAxO1xuICAgIH1cbiAgfTtcblxuICBTaGFwZVBhdGgucHJvdG90eXBlLnNldExlbmd0aCA9IGZ1bmN0aW9uIChsZW4pIHtcbiAgICB3aGlsZSAodGhpcy5fbWF4TGVuZ3RoIDwgbGVuKSB7XG4gICAgICB0aGlzLmRvdWJsZUFycmF5TGVuZ3RoKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fbGVuZ3RoID0gbGVuO1xuICB9O1xuXG4gIFNoYXBlUGF0aC5wcm90b3R5cGUuZG91YmxlQXJyYXlMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy52ID0gdGhpcy52LmNvbmNhdChjcmVhdGVTaXplZEFycmF5KHRoaXMuX21heExlbmd0aCkpO1xuICAgIHRoaXMuaSA9IHRoaXMuaS5jb25jYXQoY3JlYXRlU2l6ZWRBcnJheSh0aGlzLl9tYXhMZW5ndGgpKTtcbiAgICB0aGlzLm8gPSB0aGlzLm8uY29uY2F0KGNyZWF0ZVNpemVkQXJyYXkodGhpcy5fbWF4TGVuZ3RoKSk7XG4gICAgdGhpcy5fbWF4TGVuZ3RoICo9IDI7XG4gIH07XG5cbiAgU2hhcGVQYXRoLnByb3RvdHlwZS5zZXRYWUF0ID0gZnVuY3Rpb24gKHgsIHksIHR5cGUsIHBvcywgcmVwbGFjZSkge1xuICAgIHZhciBhcnI7XG4gICAgdGhpcy5fbGVuZ3RoID0gTWF0aC5tYXgodGhpcy5fbGVuZ3RoLCBwb3MgKyAxKTtcblxuICAgIGlmICh0aGlzLl9sZW5ndGggPj0gdGhpcy5fbWF4TGVuZ3RoKSB7XG4gICAgICB0aGlzLmRvdWJsZUFycmF5TGVuZ3RoKCk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICd2JzpcbiAgICAgICAgYXJyID0gdGhpcy52O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnaSc6XG4gICAgICAgIGFyciA9IHRoaXMuaTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ28nOlxuICAgICAgICBhcnIgPSB0aGlzLm87XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcnIgPSBbXTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKCFhcnJbcG9zXSB8fCBhcnJbcG9zXSAmJiAhcmVwbGFjZSkge1xuICAgICAgYXJyW3Bvc10gPSBwb2ludFBvb2wubmV3RWxlbWVudCgpO1xuICAgIH1cblxuICAgIGFycltwb3NdWzBdID0geDtcbiAgICBhcnJbcG9zXVsxXSA9IHk7XG4gIH07XG5cbiAgU2hhcGVQYXRoLnByb3RvdHlwZS5zZXRUcmlwbGVBdCA9IGZ1bmN0aW9uICh2WCwgdlksIG9YLCBvWSwgaVgsIGlZLCBwb3MsIHJlcGxhY2UpIHtcbiAgICB0aGlzLnNldFhZQXQodlgsIHZZLCAndicsIHBvcywgcmVwbGFjZSk7XG4gICAgdGhpcy5zZXRYWUF0KG9YLCBvWSwgJ28nLCBwb3MsIHJlcGxhY2UpO1xuICAgIHRoaXMuc2V0WFlBdChpWCwgaVksICdpJywgcG9zLCByZXBsYWNlKTtcbiAgfTtcblxuICBTaGFwZVBhdGgucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5ld1BhdGggPSBuZXcgU2hhcGVQYXRoKCk7XG4gICAgbmV3UGF0aC5zZXRQYXRoRGF0YSh0aGlzLmMsIHRoaXMuX2xlbmd0aCk7XG4gICAgdmFyIHZlcnRpY2VzID0gdGhpcy52O1xuICAgIHZhciBvdXRQb2ludHMgPSB0aGlzLm87XG4gICAgdmFyIGluUG9pbnRzID0gdGhpcy5pO1xuICAgIHZhciBpbml0ID0gMDtcblxuICAgIGlmICh0aGlzLmMpIHtcbiAgICAgIG5ld1BhdGguc2V0VHJpcGxlQXQodmVydGljZXNbMF1bMF0sIHZlcnRpY2VzWzBdWzFdLCBpblBvaW50c1swXVswXSwgaW5Qb2ludHNbMF1bMV0sIG91dFBvaW50c1swXVswXSwgb3V0UG9pbnRzWzBdWzFdLCAwLCBmYWxzZSk7XG4gICAgICBpbml0ID0gMTtcbiAgICB9XG5cbiAgICB2YXIgY250ID0gdGhpcy5fbGVuZ3RoIC0gMTtcbiAgICB2YXIgbGVuID0gdGhpcy5fbGVuZ3RoO1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gaW5pdDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBuZXdQYXRoLnNldFRyaXBsZUF0KHZlcnRpY2VzW2NudF1bMF0sIHZlcnRpY2VzW2NudF1bMV0sIGluUG9pbnRzW2NudF1bMF0sIGluUG9pbnRzW2NudF1bMV0sIG91dFBvaW50c1tjbnRdWzBdLCBvdXRQb2ludHNbY250XVsxXSwgaSwgZmFsc2UpO1xuICAgICAgY250IC09IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1BhdGg7XG4gIH07XG5cbiAgU2hhcGVQYXRoLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgfTtcblxuICB2YXIgc2hhcGVQb29sID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIHJldHVybiBuZXcgU2hhcGVQYXRoKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVsZWFzZShzaGFwZVBhdGgpIHtcbiAgICAgIHZhciBsZW4gPSBzaGFwZVBhdGguX2xlbmd0aDtcbiAgICAgIHZhciBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcG9pbnRQb29sLnJlbGVhc2Uoc2hhcGVQYXRoLnZbaV0pO1xuICAgICAgICBwb2ludFBvb2wucmVsZWFzZShzaGFwZVBhdGguaVtpXSk7XG4gICAgICAgIHBvaW50UG9vbC5yZWxlYXNlKHNoYXBlUGF0aC5vW2ldKTtcbiAgICAgICAgc2hhcGVQYXRoLnZbaV0gPSBudWxsO1xuICAgICAgICBzaGFwZVBhdGguaVtpXSA9IG51bGw7XG4gICAgICAgIHNoYXBlUGF0aC5vW2ldID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgc2hhcGVQYXRoLl9sZW5ndGggPSAwO1xuICAgICAgc2hhcGVQYXRoLmMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZShzaGFwZSkge1xuICAgICAgdmFyIGNsb25lZCA9IGZhY3RvcnkubmV3RWxlbWVudCgpO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gc2hhcGUuX2xlbmd0aCA9PT0gdW5kZWZpbmVkID8gc2hhcGUudi5sZW5ndGggOiBzaGFwZS5fbGVuZ3RoO1xuICAgICAgY2xvbmVkLnNldExlbmd0aChsZW4pO1xuICAgICAgY2xvbmVkLmMgPSBzaGFwZS5jO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgY2xvbmVkLnNldFRyaXBsZUF0KHNoYXBlLnZbaV1bMF0sIHNoYXBlLnZbaV1bMV0sIHNoYXBlLm9baV1bMF0sIHNoYXBlLm9baV1bMV0sIHNoYXBlLmlbaV1bMF0sIHNoYXBlLmlbaV1bMV0sIGkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvbmVkO1xuICAgIH1cblxuICAgIHZhciBmYWN0b3J5ID0gcG9vbEZhY3RvcnkoNCwgY3JlYXRlLCByZWxlYXNlKTtcbiAgICBmYWN0b3J5LmNsb25lID0gY2xvbmU7XG4gICAgcmV0dXJuIGZhY3Rvcnk7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBTaGFwZUNvbGxlY3Rpb24oKSB7XG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYXhMZW5ndGggPSA0O1xuICAgIHRoaXMuc2hhcGVzID0gY3JlYXRlU2l6ZWRBcnJheSh0aGlzLl9tYXhMZW5ndGgpO1xuICB9XG5cbiAgU2hhcGVDb2xsZWN0aW9uLnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uIChzaGFwZURhdGEpIHtcbiAgICBpZiAodGhpcy5fbGVuZ3RoID09PSB0aGlzLl9tYXhMZW5ndGgpIHtcbiAgICAgIHRoaXMuc2hhcGVzID0gdGhpcy5zaGFwZXMuY29uY2F0KGNyZWF0ZVNpemVkQXJyYXkodGhpcy5fbWF4TGVuZ3RoKSk7XG4gICAgICB0aGlzLl9tYXhMZW5ndGggKj0gMjtcbiAgICB9XG5cbiAgICB0aGlzLnNoYXBlc1t0aGlzLl9sZW5ndGhdID0gc2hhcGVEYXRhO1xuICAgIHRoaXMuX2xlbmd0aCArPSAxO1xuICB9O1xuXG4gIFNoYXBlQ29sbGVjdGlvbi5wcm90b3R5cGUucmVsZWFzZVNoYXBlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgc2hhcGVQb29sLnJlbGVhc2UodGhpcy5zaGFwZXNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gIH07XG5cbiAgdmFyIHNoYXBlQ29sbGVjdGlvblBvb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iID0ge1xuICAgICAgbmV3U2hhcGVDb2xsZWN0aW9uOiBuZXdTaGFwZUNvbGxlY3Rpb24sXG4gICAgICByZWxlYXNlOiByZWxlYXNlXG4gICAgfTtcbiAgICB2YXIgX2xlbmd0aCA9IDA7XG4gICAgdmFyIF9tYXhMZW5ndGggPSA0O1xuICAgIHZhciBwb29sID0gY3JlYXRlU2l6ZWRBcnJheShfbWF4TGVuZ3RoKTtcblxuICAgIGZ1bmN0aW9uIG5ld1NoYXBlQ29sbGVjdGlvbigpIHtcbiAgICAgIHZhciBzaGFwZUNvbGxlY3Rpb247XG5cbiAgICAgIGlmIChfbGVuZ3RoKSB7XG4gICAgICAgIF9sZW5ndGggLT0gMTtcbiAgICAgICAgc2hhcGVDb2xsZWN0aW9uID0gcG9vbFtfbGVuZ3RoXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNoYXBlQ29sbGVjdGlvbiA9IG5ldyBTaGFwZUNvbGxlY3Rpb24oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNoYXBlQ29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWxlYXNlKHNoYXBlQ29sbGVjdGlvbikge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gc2hhcGVDb2xsZWN0aW9uLl9sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBzaGFwZVBvb2wucmVsZWFzZShzaGFwZUNvbGxlY3Rpb24uc2hhcGVzW2ldKTtcbiAgICAgIH1cblxuICAgICAgc2hhcGVDb2xsZWN0aW9uLl9sZW5ndGggPSAwO1xuXG4gICAgICBpZiAoX2xlbmd0aCA9PT0gX21heExlbmd0aCkge1xuICAgICAgICBwb29sID0gcG9vbGluZ1tcImRvdWJsZVwiXShwb29sKTtcbiAgICAgICAgX21heExlbmd0aCAqPSAyO1xuICAgICAgfVxuXG4gICAgICBwb29sW19sZW5ndGhdID0gc2hhcGVDb2xsZWN0aW9uO1xuICAgICAgX2xlbmd0aCArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBvYjtcbiAgfSgpO1xuXG4gIHZhciBTaGFwZVByb3BlcnR5RmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5pdEZyYW1lID0gLTk5OTk5OTtcblxuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlU2hhcGUoZnJhbWVOdW0sIHByZXZpb3VzVmFsdWUsIGNhY2hpbmcpIHtcbiAgICAgIHZhciBpdGVyYXRpb25JbmRleCA9IGNhY2hpbmcubGFzdEluZGV4O1xuICAgICAgdmFyIGtleVByb3BTO1xuICAgICAgdmFyIGtleVByb3BFO1xuICAgICAgdmFyIGlzSG9sZDtcbiAgICAgIHZhciBqO1xuICAgICAgdmFyIGs7XG4gICAgICB2YXIgakxlbjtcbiAgICAgIHZhciBrTGVuO1xuICAgICAgdmFyIHBlcmM7XG4gICAgICB2YXIgdmVydGV4VmFsdWU7XG4gICAgICB2YXIga2YgPSB0aGlzLmtleWZyYW1lcztcblxuICAgICAgaWYgKGZyYW1lTnVtIDwga2ZbMF0udCAtIHRoaXMub2Zmc2V0VGltZSkge1xuICAgICAgICBrZXlQcm9wUyA9IGtmWzBdLnNbMF07XG4gICAgICAgIGlzSG9sZCA9IHRydWU7XG4gICAgICAgIGl0ZXJhdGlvbkluZGV4ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoZnJhbWVOdW0gPj0ga2Zba2YubGVuZ3RoIC0gMV0udCAtIHRoaXMub2Zmc2V0VGltZSkge1xuICAgICAgICBrZXlQcm9wUyA9IGtmW2tmLmxlbmd0aCAtIDFdLnMgPyBrZltrZi5sZW5ndGggLSAxXS5zWzBdIDoga2Zba2YubGVuZ3RoIC0gMl0uZVswXTtcbiAgICAgICAgLyogaWYoa2Zba2YubGVuZ3RoIC0gMV0ucyl7XHJcbiAgICAgICAgICAgICAgICAgIGtleVByb3BTID0ga2Zba2YubGVuZ3RoIC0gMV0uc1swXTtcclxuICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAga2V5UHJvcFMgPSBrZltrZi5sZW5ndGggLSAyXS5lWzBdO1xyXG4gICAgICAgICAgICAgIH0gKi9cblxuICAgICAgICBpc0hvbGQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSBpdGVyYXRpb25JbmRleDtcbiAgICAgICAgdmFyIGxlbiA9IGtmLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBmbGFnID0gdHJ1ZTtcbiAgICAgICAgdmFyIGtleURhdGE7XG4gICAgICAgIHZhciBuZXh0S2V5RGF0YTtcbiAgICAgICAgdmFyIGtleWZyYW1lTWV0YWRhdGE7XG5cbiAgICAgICAgd2hpbGUgKGZsYWcpIHtcbiAgICAgICAgICBrZXlEYXRhID0ga2ZbaV07XG4gICAgICAgICAgbmV4dEtleURhdGEgPSBrZltpICsgMV07XG5cbiAgICAgICAgICBpZiAobmV4dEtleURhdGEudCAtIHRoaXMub2Zmc2V0VGltZSA+IGZyYW1lTnVtKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaSA8IGxlbiAtIDEpIHtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGtleWZyYW1lTWV0YWRhdGEgPSB0aGlzLmtleWZyYW1lc01ldGFkYXRhW2ldIHx8IHt9O1xuICAgICAgICBpc0hvbGQgPSBrZXlEYXRhLmggPT09IDE7XG4gICAgICAgIGl0ZXJhdGlvbkluZGV4ID0gaTtcblxuICAgICAgICBpZiAoIWlzSG9sZCkge1xuICAgICAgICAgIGlmIChmcmFtZU51bSA+PSBuZXh0S2V5RGF0YS50IC0gdGhpcy5vZmZzZXRUaW1lKSB7XG4gICAgICAgICAgICBwZXJjID0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZyYW1lTnVtIDwga2V5RGF0YS50IC0gdGhpcy5vZmZzZXRUaW1lKSB7XG4gICAgICAgICAgICBwZXJjID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZuYztcblxuICAgICAgICAgICAgaWYgKGtleWZyYW1lTWV0YWRhdGEuX19mbmN0KSB7XG4gICAgICAgICAgICAgIGZuYyA9IGtleWZyYW1lTWV0YWRhdGEuX19mbmN0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm5jID0gQmV6aWVyRmFjdG9yeS5nZXRCZXppZXJFYXNpbmcoa2V5RGF0YS5vLngsIGtleURhdGEuby55LCBrZXlEYXRhLmkueCwga2V5RGF0YS5pLnkpLmdldDtcbiAgICAgICAgICAgICAga2V5ZnJhbWVNZXRhZGF0YS5fX2ZuY3QgPSBmbmM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBlcmMgPSBmbmMoKGZyYW1lTnVtIC0gKGtleURhdGEudCAtIHRoaXMub2Zmc2V0VGltZSkpIC8gKG5leHRLZXlEYXRhLnQgLSB0aGlzLm9mZnNldFRpbWUgLSAoa2V5RGF0YS50IC0gdGhpcy5vZmZzZXRUaW1lKSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGtleVByb3BFID0gbmV4dEtleURhdGEucyA/IG5leHRLZXlEYXRhLnNbMF0gOiBrZXlEYXRhLmVbMF07XG4gICAgICAgIH1cblxuICAgICAgICBrZXlQcm9wUyA9IGtleURhdGEuc1swXTtcbiAgICAgIH1cblxuICAgICAgakxlbiA9IHByZXZpb3VzVmFsdWUuX2xlbmd0aDtcbiAgICAgIGtMZW4gPSBrZXlQcm9wUy5pWzBdLmxlbmd0aDtcbiAgICAgIGNhY2hpbmcubGFzdEluZGV4ID0gaXRlcmF0aW9uSW5kZXg7XG5cbiAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGtMZW47IGsgKz0gMSkge1xuICAgICAgICAgIHZlcnRleFZhbHVlID0gaXNIb2xkID8ga2V5UHJvcFMuaVtqXVtrXSA6IGtleVByb3BTLmlbal1ba10gKyAoa2V5UHJvcEUuaVtqXVtrXSAtIGtleVByb3BTLmlbal1ba10pICogcGVyYztcbiAgICAgICAgICBwcmV2aW91c1ZhbHVlLmlbal1ba10gPSB2ZXJ0ZXhWYWx1ZTtcbiAgICAgICAgICB2ZXJ0ZXhWYWx1ZSA9IGlzSG9sZCA/IGtleVByb3BTLm9bal1ba10gOiBrZXlQcm9wUy5vW2pdW2tdICsgKGtleVByb3BFLm9bal1ba10gLSBrZXlQcm9wUy5vW2pdW2tdKSAqIHBlcmM7XG4gICAgICAgICAgcHJldmlvdXNWYWx1ZS5vW2pdW2tdID0gdmVydGV4VmFsdWU7XG4gICAgICAgICAgdmVydGV4VmFsdWUgPSBpc0hvbGQgPyBrZXlQcm9wUy52W2pdW2tdIDoga2V5UHJvcFMudltqXVtrXSArIChrZXlQcm9wRS52W2pdW2tdIC0ga2V5UHJvcFMudltqXVtrXSkgKiBwZXJjO1xuICAgICAgICAgIHByZXZpb3VzVmFsdWUudltqXVtrXSA9IHZlcnRleFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGVTaGFwZUN1cnJlbnRUaW1lKCkge1xuICAgICAgdmFyIGZyYW1lTnVtID0gdGhpcy5jb21wLnJlbmRlcmVkRnJhbWUgLSB0aGlzLm9mZnNldFRpbWU7XG4gICAgICB2YXIgaW5pdFRpbWUgPSB0aGlzLmtleWZyYW1lc1swXS50IC0gdGhpcy5vZmZzZXRUaW1lO1xuICAgICAgdmFyIGVuZFRpbWUgPSB0aGlzLmtleWZyYW1lc1t0aGlzLmtleWZyYW1lcy5sZW5ndGggLSAxXS50IC0gdGhpcy5vZmZzZXRUaW1lO1xuICAgICAgdmFyIGxhc3RGcmFtZSA9IHRoaXMuX2NhY2hpbmcubGFzdEZyYW1lO1xuXG4gICAgICBpZiAoIShsYXN0RnJhbWUgIT09IGluaXRGcmFtZSAmJiAobGFzdEZyYW1lIDwgaW5pdFRpbWUgJiYgZnJhbWVOdW0gPCBpbml0VGltZSB8fCBsYXN0RnJhbWUgPiBlbmRUaW1lICYmIGZyYW1lTnVtID4gZW5kVGltZSkpKSB7XG4gICAgICAgIC8vLyAvXG4gICAgICAgIHRoaXMuX2NhY2hpbmcubGFzdEluZGV4ID0gbGFzdEZyYW1lIDwgZnJhbWVOdW0gPyB0aGlzLl9jYWNoaW5nLmxhc3RJbmRleCA6IDA7XG4gICAgICAgIHRoaXMuaW50ZXJwb2xhdGVTaGFwZShmcmFtZU51bSwgdGhpcy5wdiwgdGhpcy5fY2FjaGluZyk7IC8vLyAvXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NhY2hpbmcubGFzdEZyYW1lID0gZnJhbWVOdW07XG4gICAgICByZXR1cm4gdGhpcy5wdjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNldFNoYXBlKCkge1xuICAgICAgdGhpcy5wYXRocyA9IHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hhcGVzRXF1YWwoc2hhcGUxLCBzaGFwZTIpIHtcbiAgICAgIGlmIChzaGFwZTEuX2xlbmd0aCAhPT0gc2hhcGUyLl9sZW5ndGggfHwgc2hhcGUxLmMgIT09IHNoYXBlMi5jKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gc2hhcGUxLl9sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoc2hhcGUxLnZbaV1bMF0gIT09IHNoYXBlMi52W2ldWzBdIHx8IHNoYXBlMS52W2ldWzFdICE9PSBzaGFwZTIudltpXVsxXSB8fCBzaGFwZTEub1tpXVswXSAhPT0gc2hhcGUyLm9baV1bMF0gfHwgc2hhcGUxLm9baV1bMV0gIT09IHNoYXBlMi5vW2ldWzFdIHx8IHNoYXBlMS5pW2ldWzBdICE9PSBzaGFwZTIuaVtpXVswXSB8fCBzaGFwZTEuaVtpXVsxXSAhPT0gc2hhcGUyLmlbaV1bMV0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0VlZhbHVlKG5ld1BhdGgpIHtcbiAgICAgIGlmICghc2hhcGVzRXF1YWwodGhpcy52LCBuZXdQYXRoKSkge1xuICAgICAgICB0aGlzLnYgPSBzaGFwZVBvb2wuY2xvbmUobmV3UGF0aCk7XG4gICAgICAgIHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb24ucmVsZWFzZVNoYXBlcygpO1xuICAgICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uLmFkZFNoYXBlKHRoaXMudik7XG4gICAgICAgIHRoaXMuX21kZiA9IHRydWU7XG4gICAgICAgIHRoaXMucGF0aHMgPSB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NFZmZlY3RzU2VxdWVuY2UoKSB7XG4gICAgICBpZiAodGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5mcmFtZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubG9jaykge1xuICAgICAgICB0aGlzLnNldFZWYWx1ZSh0aGlzLnB2KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxvY2sgPSB0cnVlO1xuICAgICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgICB2YXIgZmluYWxWYWx1ZTtcblxuICAgICAgaWYgKHRoaXMua2YpIHtcbiAgICAgICAgZmluYWxWYWx1ZSA9IHRoaXMucHY7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS5rcykge1xuICAgICAgICBmaW5hbFZhbHVlID0gdGhpcy5kYXRhLmtzLms7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaW5hbFZhbHVlID0gdGhpcy5kYXRhLnB0Lms7XG4gICAgICB9XG5cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGZpbmFsVmFsdWUgPSB0aGlzLmVmZmVjdHNTZXF1ZW5jZVtpXShmaW5hbFZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRWVmFsdWUoZmluYWxWYWx1ZSk7XG4gICAgICB0aGlzLmxvY2sgPSBmYWxzZTtcbiAgICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gU2hhcGVQcm9wZXJ0eShlbGVtLCBkYXRhLCB0eXBlKSB7XG4gICAgICB0aGlzLnByb3BUeXBlID0gJ3NoYXBlJztcbiAgICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gZWxlbTtcbiAgICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgdGhpcy5rID0gZmFsc2U7XG4gICAgICB0aGlzLmtmID0gZmFsc2U7XG4gICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICAgIHZhciBwYXRoRGF0YSA9IHR5cGUgPT09IDMgPyBkYXRhLnB0LmsgOiBkYXRhLmtzLms7XG4gICAgICB0aGlzLnYgPSBzaGFwZVBvb2wuY2xvbmUocGF0aERhdGEpO1xuICAgICAgdGhpcy5wdiA9IHNoYXBlUG9vbC5jbG9uZSh0aGlzLnYpO1xuICAgICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbiA9IHNoYXBlQ29sbGVjdGlvblBvb2wubmV3U2hhcGVDb2xsZWN0aW9uKCk7XG4gICAgICB0aGlzLnBhdGhzID0gdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcbiAgICAgIHRoaXMucGF0aHMuYWRkU2hhcGUodGhpcy52KTtcbiAgICAgIHRoaXMucmVzZXQgPSByZXNldFNoYXBlO1xuICAgICAgdGhpcy5lZmZlY3RzU2VxdWVuY2UgPSBbXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRFZmZlY3QoZWZmZWN0RnVuY3Rpb24pIHtcbiAgICAgIHRoaXMuZWZmZWN0c1NlcXVlbmNlLnB1c2goZWZmZWN0RnVuY3Rpb24pO1xuICAgICAgdGhpcy5jb250YWluZXIuYWRkRHluYW1pY1Byb3BlcnR5KHRoaXMpO1xuICAgIH1cblxuICAgIFNoYXBlUHJvcGVydHkucHJvdG90eXBlLmludGVycG9sYXRlU2hhcGUgPSBpbnRlcnBvbGF0ZVNoYXBlO1xuICAgIFNoYXBlUHJvcGVydHkucHJvdG90eXBlLmdldFZhbHVlID0gcHJvY2Vzc0VmZmVjdHNTZXF1ZW5jZTtcbiAgICBTaGFwZVByb3BlcnR5LnByb3RvdHlwZS5zZXRWVmFsdWUgPSBzZXRWVmFsdWU7XG4gICAgU2hhcGVQcm9wZXJ0eS5wcm90b3R5cGUuYWRkRWZmZWN0ID0gYWRkRWZmZWN0O1xuXG4gICAgZnVuY3Rpb24gS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eShlbGVtLCBkYXRhLCB0eXBlKSB7XG4gICAgICB0aGlzLnByb3BUeXBlID0gJ3NoYXBlJztcbiAgICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcbiAgICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgICB0aGlzLmNvbnRhaW5lciA9IGVsZW07XG4gICAgICB0aGlzLm9mZnNldFRpbWUgPSBlbGVtLmRhdGEuc3Q7XG4gICAgICB0aGlzLmtleWZyYW1lcyA9IHR5cGUgPT09IDMgPyBkYXRhLnB0LmsgOiBkYXRhLmtzLms7XG4gICAgICB0aGlzLmtleWZyYW1lc01ldGFkYXRhID0gW107XG4gICAgICB0aGlzLmsgPSB0cnVlO1xuICAgICAgdGhpcy5rZiA9IHRydWU7XG4gICAgICB2YXIgbGVuID0gdGhpcy5rZXlmcmFtZXNbMF0uc1swXS5pLmxlbmd0aDtcbiAgICAgIHRoaXMudiA9IHNoYXBlUG9vbC5uZXdFbGVtZW50KCk7XG4gICAgICB0aGlzLnYuc2V0UGF0aERhdGEodGhpcy5rZXlmcmFtZXNbMF0uc1swXS5jLCBsZW4pO1xuICAgICAgdGhpcy5wdiA9IHNoYXBlUG9vbC5jbG9uZSh0aGlzLnYpO1xuICAgICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbiA9IHNoYXBlQ29sbGVjdGlvblBvb2wubmV3U2hhcGVDb2xsZWN0aW9uKCk7XG4gICAgICB0aGlzLnBhdGhzID0gdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcbiAgICAgIHRoaXMucGF0aHMuYWRkU2hhcGUodGhpcy52KTtcbiAgICAgIHRoaXMubGFzdEZyYW1lID0gaW5pdEZyYW1lO1xuICAgICAgdGhpcy5yZXNldCA9IHJlc2V0U2hhcGU7XG4gICAgICB0aGlzLl9jYWNoaW5nID0ge1xuICAgICAgICBsYXN0RnJhbWU6IGluaXRGcmFtZSxcbiAgICAgICAgbGFzdEluZGV4OiAwXG4gICAgICB9O1xuICAgICAgdGhpcy5lZmZlY3RzU2VxdWVuY2UgPSBbaW50ZXJwb2xhdGVTaGFwZUN1cnJlbnRUaW1lLmJpbmQodGhpcyldO1xuICAgIH1cblxuICAgIEtleWZyYW1lZFNoYXBlUHJvcGVydHkucHJvdG90eXBlLmdldFZhbHVlID0gcHJvY2Vzc0VmZmVjdHNTZXF1ZW5jZTtcbiAgICBLZXlmcmFtZWRTaGFwZVByb3BlcnR5LnByb3RvdHlwZS5pbnRlcnBvbGF0ZVNoYXBlID0gaW50ZXJwb2xhdGVTaGFwZTtcbiAgICBLZXlmcmFtZWRTaGFwZVByb3BlcnR5LnByb3RvdHlwZS5zZXRWVmFsdWUgPSBzZXRWVmFsdWU7XG4gICAgS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eS5wcm90b3R5cGUuYWRkRWZmZWN0ID0gYWRkRWZmZWN0O1xuXG4gICAgdmFyIEVsbFNoYXBlUHJvcGVydHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY1BvaW50ID0gcm91bmRDb3JuZXI7XG5cbiAgICAgIGZ1bmN0aW9uIEVsbFNoYXBlUHJvcGVydHlGYWN0b3J5KGVsZW0sIGRhdGEpIHtcbiAgICAgICAgdGhpcy52ID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcbiAgICAgICAgdGhpcy52LnNldFBhdGhEYXRhKHRydWUsIDQpO1xuICAgICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVDb2xsZWN0aW9uUG9vbC5uZXdTaGFwZUNvbGxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5wYXRocyA9IHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb247XG4gICAgICAgIHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb24uYWRkU2hhcGUodGhpcy52KTtcbiAgICAgICAgdGhpcy5kID0gZGF0YS5kO1xuICAgICAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgICAgICB0aGlzLmNvbXAgPSBlbGVtLmNvbXA7XG4gICAgICAgIHRoaXMuZnJhbWVJZCA9IC0xO1xuICAgICAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XG4gICAgICAgIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucCwgMSwgMCwgdGhpcyk7XG4gICAgICAgIHRoaXMucyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucywgMSwgMCwgdGhpcyk7XG5cbiAgICAgICAgaWYgKHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5rID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmsgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNvbnZlcnRFbGxUb1BhdGgoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBFbGxTaGFwZVByb3BlcnR5RmFjdG9yeS5wcm90b3R5cGUgPSB7XG4gICAgICAgIHJlc2V0OiByZXNldFNoYXBlLFxuICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQgPT09IHRoaXMuZnJhbWVJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XG4gICAgICAgICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9tZGYpIHtcbiAgICAgICAgICAgIHRoaXMuY29udmVydEVsbFRvUGF0aCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29udmVydEVsbFRvUGF0aDogZnVuY3Rpb24gY29udmVydEVsbFRvUGF0aCgpIHtcbiAgICAgICAgICB2YXIgcDAgPSB0aGlzLnAudlswXTtcbiAgICAgICAgICB2YXIgcDEgPSB0aGlzLnAudlsxXTtcbiAgICAgICAgICB2YXIgczAgPSB0aGlzLnMudlswXSAvIDI7XG4gICAgICAgICAgdmFyIHMxID0gdGhpcy5zLnZbMV0gLyAyO1xuXG4gICAgICAgICAgdmFyIF9jdyA9IHRoaXMuZCAhPT0gMztcblxuICAgICAgICAgIHZhciBfdiA9IHRoaXMudjtcbiAgICAgICAgICBfdi52WzBdWzBdID0gcDA7XG4gICAgICAgICAgX3YudlswXVsxXSA9IHAxIC0gczE7XG4gICAgICAgICAgX3YudlsxXVswXSA9IF9jdyA/IHAwICsgczAgOiBwMCAtIHMwO1xuICAgICAgICAgIF92LnZbMV1bMV0gPSBwMTtcbiAgICAgICAgICBfdi52WzJdWzBdID0gcDA7XG4gICAgICAgICAgX3YudlsyXVsxXSA9IHAxICsgczE7XG4gICAgICAgICAgX3YudlszXVswXSA9IF9jdyA/IHAwIC0gczAgOiBwMCArIHMwO1xuICAgICAgICAgIF92LnZbM11bMV0gPSBwMTtcbiAgICAgICAgICBfdi5pWzBdWzBdID0gX2N3ID8gcDAgLSBzMCAqIGNQb2ludCA6IHAwICsgczAgKiBjUG9pbnQ7XG4gICAgICAgICAgX3YuaVswXVsxXSA9IHAxIC0gczE7XG4gICAgICAgICAgX3YuaVsxXVswXSA9IF9jdyA/IHAwICsgczAgOiBwMCAtIHMwO1xuICAgICAgICAgIF92LmlbMV1bMV0gPSBwMSAtIHMxICogY1BvaW50O1xuICAgICAgICAgIF92LmlbMl1bMF0gPSBfY3cgPyBwMCArIHMwICogY1BvaW50IDogcDAgLSBzMCAqIGNQb2ludDtcbiAgICAgICAgICBfdi5pWzJdWzFdID0gcDEgKyBzMTtcbiAgICAgICAgICBfdi5pWzNdWzBdID0gX2N3ID8gcDAgLSBzMCA6IHAwICsgczA7XG4gICAgICAgICAgX3YuaVszXVsxXSA9IHAxICsgczEgKiBjUG9pbnQ7XG4gICAgICAgICAgX3Yub1swXVswXSA9IF9jdyA/IHAwICsgczAgKiBjUG9pbnQgOiBwMCAtIHMwICogY1BvaW50O1xuICAgICAgICAgIF92Lm9bMF1bMV0gPSBwMSAtIHMxO1xuICAgICAgICAgIF92Lm9bMV1bMF0gPSBfY3cgPyBwMCArIHMwIDogcDAgLSBzMDtcbiAgICAgICAgICBfdi5vWzFdWzFdID0gcDEgKyBzMSAqIGNQb2ludDtcbiAgICAgICAgICBfdi5vWzJdWzBdID0gX2N3ID8gcDAgLSBzMCAqIGNQb2ludCA6IHAwICsgczAgKiBjUG9pbnQ7XG4gICAgICAgICAgX3Yub1syXVsxXSA9IHAxICsgczE7XG4gICAgICAgICAgX3Yub1szXVswXSA9IF9jdyA/IHAwIC0gczAgOiBwMCArIHMwO1xuICAgICAgICAgIF92Lm9bM11bMV0gPSBwMSAtIHMxICogY1BvaW50O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBFbGxTaGFwZVByb3BlcnR5RmFjdG9yeSk7XG4gICAgICByZXR1cm4gRWxsU2hhcGVQcm9wZXJ0eUZhY3Rvcnk7XG4gICAgfSgpO1xuXG4gICAgdmFyIFN0YXJTaGFwZVByb3BlcnR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU3RhclNoYXBlUHJvcGVydHlGYWN0b3J5KGVsZW0sIGRhdGEpIHtcbiAgICAgICAgdGhpcy52ID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcbiAgICAgICAgdGhpcy52LnNldFBhdGhEYXRhKHRydWUsIDApO1xuICAgICAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgICAgICB0aGlzLmNvbXAgPSBlbGVtLmNvbXA7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuZnJhbWVJZCA9IC0xO1xuICAgICAgICB0aGlzLmQgPSBkYXRhLmQ7XG4gICAgICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtKTtcblxuICAgICAgICBpZiAoZGF0YS5zeSA9PT0gMSkge1xuICAgICAgICAgIHRoaXMuaXIgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmlyLCAwLCAwLCB0aGlzKTtcbiAgICAgICAgICB0aGlzLmlzID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5pcywgMCwgMC4wMSwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5jb252ZXJ0VG9QYXRoID0gdGhpcy5jb252ZXJ0U3RhclRvUGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNvbnZlcnRUb1BhdGggPSB0aGlzLmNvbnZlcnRQb2x5Z29uVG9QYXRoO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wdCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucHQsIDAsIDAsIHRoaXMpO1xuICAgICAgICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnAsIDEsIDAsIHRoaXMpO1xuICAgICAgICB0aGlzLnIgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnIsIDAsIGRlZ1RvUmFkcywgdGhpcyk7XG4gICAgICAgIHRoaXMub3IgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm9yLCAwLCAwLCB0aGlzKTtcbiAgICAgICAgdGhpcy5vcyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEub3MsIDAsIDAuMDEsIHRoaXMpO1xuICAgICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVDb2xsZWN0aW9uUG9vbC5uZXdTaGFwZUNvbGxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZSh0aGlzLnYpO1xuICAgICAgICB0aGlzLnBhdGhzID0gdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcblxuICAgICAgICBpZiAodGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmsgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuayA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuY29udmVydFRvUGF0aCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIFN0YXJTaGFwZVByb3BlcnR5RmFjdG9yeS5wcm90b3R5cGUgPSB7XG4gICAgICAgIHJlc2V0OiByZXNldFNoYXBlLFxuICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQgPT09IHRoaXMuZnJhbWVJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XG4gICAgICAgICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9tZGYpIHtcbiAgICAgICAgICAgIHRoaXMuY29udmVydFRvUGF0aCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29udmVydFN0YXJUb1BhdGg6IGZ1bmN0aW9uIGNvbnZlcnRTdGFyVG9QYXRoKCkge1xuICAgICAgICAgIHZhciBudW1QdHMgPSBNYXRoLmZsb29yKHRoaXMucHQudikgKiAyO1xuICAgICAgICAgIHZhciBhbmdsZSA9IE1hdGguUEkgKiAyIC8gbnVtUHRzO1xuICAgICAgICAgIC8qIHRoaXMudi52Lmxlbmd0aCA9IG51bVB0cztcclxuICAgICAgICAgICAgICAgICAgdGhpcy52LmkubGVuZ3RoID0gbnVtUHRzO1xyXG4gICAgICAgICAgICAgICAgICB0aGlzLnYuby5sZW5ndGggPSBudW1QdHM7ICovXG5cbiAgICAgICAgICB2YXIgbG9uZ0ZsYWcgPSB0cnVlO1xuICAgICAgICAgIHZhciBsb25nUmFkID0gdGhpcy5vci52O1xuICAgICAgICAgIHZhciBzaG9ydFJhZCA9IHRoaXMuaXIudjtcbiAgICAgICAgICB2YXIgbG9uZ1JvdW5kID0gdGhpcy5vcy52O1xuICAgICAgICAgIHZhciBzaG9ydFJvdW5kID0gdGhpcy5pcy52O1xuICAgICAgICAgIHZhciBsb25nUGVyaW1TZWdtZW50ID0gMiAqIE1hdGguUEkgKiBsb25nUmFkIC8gKG51bVB0cyAqIDIpO1xuICAgICAgICAgIHZhciBzaG9ydFBlcmltU2VnbWVudCA9IDIgKiBNYXRoLlBJICogc2hvcnRSYWQgLyAobnVtUHRzICogMik7XG4gICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgdmFyIHJhZDtcbiAgICAgICAgICB2YXIgcm91bmRuZXNzO1xuICAgICAgICAgIHZhciBwZXJpbVNlZ21lbnQ7XG4gICAgICAgICAgdmFyIGN1cnJlbnRBbmcgPSAtTWF0aC5QSSAvIDI7XG4gICAgICAgICAgY3VycmVudEFuZyArPSB0aGlzLnIudjtcbiAgICAgICAgICB2YXIgZGlyID0gdGhpcy5kYXRhLmQgPT09IDMgPyAtMSA6IDE7XG4gICAgICAgICAgdGhpcy52Ll9sZW5ndGggPSAwO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVB0czsgaSArPSAxKSB7XG4gICAgICAgICAgICByYWQgPSBsb25nRmxhZyA/IGxvbmdSYWQgOiBzaG9ydFJhZDtcbiAgICAgICAgICAgIHJvdW5kbmVzcyA9IGxvbmdGbGFnID8gbG9uZ1JvdW5kIDogc2hvcnRSb3VuZDtcbiAgICAgICAgICAgIHBlcmltU2VnbWVudCA9IGxvbmdGbGFnID8gbG9uZ1BlcmltU2VnbWVudCA6IHNob3J0UGVyaW1TZWdtZW50O1xuICAgICAgICAgICAgdmFyIHggPSByYWQgKiBNYXRoLmNvcyhjdXJyZW50QW5nKTtcbiAgICAgICAgICAgIHZhciB5ID0gcmFkICogTWF0aC5zaW4oY3VycmVudEFuZyk7XG4gICAgICAgICAgICB2YXIgb3ggPSB4ID09PSAwICYmIHkgPT09IDAgPyAwIDogeSAvIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICAgICAgICAgIHZhciBveSA9IHggPT09IDAgJiYgeSA9PT0gMCA/IDAgOiAteCAvIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICAgICAgICAgIHggKz0gK3RoaXMucC52WzBdO1xuICAgICAgICAgICAgeSArPSArdGhpcy5wLnZbMV07XG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQoeCwgeSwgeCAtIG94ICogcGVyaW1TZWdtZW50ICogcm91bmRuZXNzICogZGlyLCB5IC0gb3kgKiBwZXJpbVNlZ21lbnQgKiByb3VuZG5lc3MgKiBkaXIsIHggKyBveCAqIHBlcmltU2VnbWVudCAqIHJvdW5kbmVzcyAqIGRpciwgeSArIG95ICogcGVyaW1TZWdtZW50ICogcm91bmRuZXNzICogZGlyLCBpLCB0cnVlKTtcbiAgICAgICAgICAgIC8qIHRoaXMudi52W2ldID0gW3gseV07XHJcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnYuaVtpXSA9IFt4K294KnBlcmltU2VnbWVudCpyb3VuZG5lc3MqZGlyLHkrb3kqcGVyaW1TZWdtZW50KnJvdW5kbmVzcypkaXJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy52Lm9baV0gPSBbeC1veCpwZXJpbVNlZ21lbnQqcm91bmRuZXNzKmRpcix5LW95KnBlcmltU2VnbWVudCpyb3VuZG5lc3MqZGlyXTtcclxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMudi5fbGVuZ3RoID0gbnVtUHRzOyAqL1xuXG4gICAgICAgICAgICBsb25nRmxhZyA9ICFsb25nRmxhZztcbiAgICAgICAgICAgIGN1cnJlbnRBbmcgKz0gYW5nbGUgKiBkaXI7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb252ZXJ0UG9seWdvblRvUGF0aDogZnVuY3Rpb24gY29udmVydFBvbHlnb25Ub1BhdGgoKSB7XG4gICAgICAgICAgdmFyIG51bVB0cyA9IE1hdGguZmxvb3IodGhpcy5wdC52KTtcbiAgICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLlBJICogMiAvIG51bVB0cztcbiAgICAgICAgICB2YXIgcmFkID0gdGhpcy5vci52O1xuICAgICAgICAgIHZhciByb3VuZG5lc3MgPSB0aGlzLm9zLnY7XG4gICAgICAgICAgdmFyIHBlcmltU2VnbWVudCA9IDIgKiBNYXRoLlBJICogcmFkIC8gKG51bVB0cyAqIDQpO1xuICAgICAgICAgIHZhciBpO1xuICAgICAgICAgIHZhciBjdXJyZW50QW5nID0gLU1hdGguUEkgKiAwLjU7XG4gICAgICAgICAgdmFyIGRpciA9IHRoaXMuZGF0YS5kID09PSAzID8gLTEgOiAxO1xuICAgICAgICAgIGN1cnJlbnRBbmcgKz0gdGhpcy5yLnY7XG4gICAgICAgICAgdGhpcy52Ll9sZW5ndGggPSAwO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVB0czsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHJhZCAqIE1hdGguY29zKGN1cnJlbnRBbmcpO1xuICAgICAgICAgICAgdmFyIHkgPSByYWQgKiBNYXRoLnNpbihjdXJyZW50QW5nKTtcbiAgICAgICAgICAgIHZhciBveCA9IHggPT09IDAgJiYgeSA9PT0gMCA/IDAgOiB5IC8gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgICAgICAgICAgdmFyIG95ID0geCA9PT0gMCAmJiB5ID09PSAwID8gMCA6IC14IC8gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgICAgICAgICAgeCArPSArdGhpcy5wLnZbMF07XG4gICAgICAgICAgICB5ICs9ICt0aGlzLnAudlsxXTtcbiAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdCh4LCB5LCB4IC0gb3ggKiBwZXJpbVNlZ21lbnQgKiByb3VuZG5lc3MgKiBkaXIsIHkgLSBveSAqIHBlcmltU2VnbWVudCAqIHJvdW5kbmVzcyAqIGRpciwgeCArIG94ICogcGVyaW1TZWdtZW50ICogcm91bmRuZXNzICogZGlyLCB5ICsgb3kgKiBwZXJpbVNlZ21lbnQgKiByb3VuZG5lc3MgKiBkaXIsIGksIHRydWUpO1xuICAgICAgICAgICAgY3VycmVudEFuZyArPSBhbmdsZSAqIGRpcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnBhdGhzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgdGhpcy5wYXRoc1swXSA9IHRoaXMudjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgU3RhclNoYXBlUHJvcGVydHlGYWN0b3J5KTtcbiAgICAgIHJldHVybiBTdGFyU2hhcGVQcm9wZXJ0eUZhY3Rvcnk7XG4gICAgfSgpO1xuXG4gICAgdmFyIFJlY3RTaGFwZVByb3BlcnR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUmVjdFNoYXBlUHJvcGVydHlGYWN0b3J5KGVsZW0sIGRhdGEpIHtcbiAgICAgICAgdGhpcy52ID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcbiAgICAgICAgdGhpcy52LmMgPSB0cnVlO1xuICAgICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVDb2xsZWN0aW9uUG9vbC5uZXdTaGFwZUNvbGxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZSh0aGlzLnYpO1xuICAgICAgICB0aGlzLnBhdGhzID0gdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcbiAgICAgICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICAgICAgdGhpcy5jb21wID0gZWxlbS5jb21wO1xuICAgICAgICB0aGlzLmZyYW1lSWQgPSAtMTtcbiAgICAgICAgdGhpcy5kID0gZGF0YS5kO1xuICAgICAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XG4gICAgICAgIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucCwgMSwgMCwgdGhpcyk7XG4gICAgICAgIHRoaXMucyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucywgMSwgMCwgdGhpcyk7XG4gICAgICAgIHRoaXMuciA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuciwgMCwgMCwgdGhpcyk7XG5cbiAgICAgICAgaWYgKHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5rID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmsgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNvbnZlcnRSZWN0VG9QYXRoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgUmVjdFNoYXBlUHJvcGVydHlGYWN0b3J5LnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29udmVydFJlY3RUb1BhdGg6IGZ1bmN0aW9uIGNvbnZlcnRSZWN0VG9QYXRoKCkge1xuICAgICAgICAgIHZhciBwMCA9IHRoaXMucC52WzBdO1xuICAgICAgICAgIHZhciBwMSA9IHRoaXMucC52WzFdO1xuICAgICAgICAgIHZhciB2MCA9IHRoaXMucy52WzBdIC8gMjtcbiAgICAgICAgICB2YXIgdjEgPSB0aGlzLnMudlsxXSAvIDI7XG4gICAgICAgICAgdmFyIHJvdW5kID0gYm1NaW4odjAsIHYxLCB0aGlzLnIudik7XG4gICAgICAgICAgdmFyIGNQb2ludCA9IHJvdW5kICogKDEgLSByb3VuZENvcm5lcik7XG4gICAgICAgICAgdGhpcy52Ll9sZW5ndGggPSAwO1xuXG4gICAgICAgICAgaWYgKHRoaXMuZCA9PT0gMiB8fCB0aGlzLmQgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCArIHYwLCBwMSAtIHYxICsgcm91bmQsIHAwICsgdjAsIHAxIC0gdjEgKyByb3VuZCwgcDAgKyB2MCwgcDEgLSB2MSArIGNQb2ludCwgMCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgKyB2MCwgcDEgKyB2MSAtIHJvdW5kLCBwMCArIHYwLCBwMSArIHYxIC0gY1BvaW50LCBwMCArIHYwLCBwMSArIHYxIC0gcm91bmQsIDEsIHRydWUpO1xuXG4gICAgICAgICAgICBpZiAocm91bmQgIT09IDApIHtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwICsgdjAgLSByb3VuZCwgcDEgKyB2MSwgcDAgKyB2MCAtIHJvdW5kLCBwMSArIHYxLCBwMCArIHYwIC0gY1BvaW50LCBwMSArIHYxLCAyLCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAgKyByb3VuZCwgcDEgKyB2MSwgcDAgLSB2MCArIGNQb2ludCwgcDEgKyB2MSwgcDAgLSB2MCArIHJvdW5kLCBwMSArIHYxLCAzLCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxICsgdjEgLSByb3VuZCwgcDAgLSB2MCwgcDEgKyB2MSAtIHJvdW5kLCBwMCAtIHYwLCBwMSArIHYxIC0gY1BvaW50LCA0LCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxIC0gdjEgKyByb3VuZCwgcDAgLSB2MCwgcDEgLSB2MSArIGNQb2ludCwgcDAgLSB2MCwgcDEgLSB2MSArIHJvdW5kLCA1LCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAgKyByb3VuZCwgcDEgLSB2MSwgcDAgLSB2MCArIHJvdW5kLCBwMSAtIHYxLCBwMCAtIHYwICsgY1BvaW50LCBwMSAtIHYxLCA2LCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwICsgdjAgLSByb3VuZCwgcDEgLSB2MSwgcDAgKyB2MCAtIGNQb2ludCwgcDEgLSB2MSwgcDAgKyB2MCAtIHJvdW5kLCBwMSAtIHYxLCA3LCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCAtIHYwLCBwMSArIHYxLCBwMCAtIHYwICsgY1BvaW50LCBwMSArIHYxLCBwMCAtIHYwLCBwMSArIHYxLCAyKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxIC0gdjEsIHAwIC0gdjAsIHAxIC0gdjEgKyBjUG9pbnQsIHAwIC0gdjAsIHAxIC0gdjEsIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgKyB2MCwgcDEgLSB2MSArIHJvdW5kLCBwMCArIHYwLCBwMSAtIHYxICsgY1BvaW50LCBwMCArIHYwLCBwMSAtIHYxICsgcm91bmQsIDAsIHRydWUpO1xuXG4gICAgICAgICAgICBpZiAocm91bmQgIT09IDApIHtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwICsgdjAgLSByb3VuZCwgcDEgLSB2MSwgcDAgKyB2MCAtIHJvdW5kLCBwMSAtIHYxLCBwMCArIHYwIC0gY1BvaW50LCBwMSAtIHYxLCAxLCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAgKyByb3VuZCwgcDEgLSB2MSwgcDAgLSB2MCArIGNQb2ludCwgcDEgLSB2MSwgcDAgLSB2MCArIHJvdW5kLCBwMSAtIHYxLCAyLCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxIC0gdjEgKyByb3VuZCwgcDAgLSB2MCwgcDEgLSB2MSArIHJvdW5kLCBwMCAtIHYwLCBwMSAtIHYxICsgY1BvaW50LCAzLCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxICsgdjEgLSByb3VuZCwgcDAgLSB2MCwgcDEgKyB2MSAtIGNQb2ludCwgcDAgLSB2MCwgcDEgKyB2MSAtIHJvdW5kLCA0LCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAgKyByb3VuZCwgcDEgKyB2MSwgcDAgLSB2MCArIHJvdW5kLCBwMSArIHYxLCBwMCAtIHYwICsgY1BvaW50LCBwMSArIHYxLCA1LCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwICsgdjAgLSByb3VuZCwgcDEgKyB2MSwgcDAgKyB2MCAtIGNQb2ludCwgcDEgKyB2MSwgcDAgKyB2MCAtIHJvdW5kLCBwMSArIHYxLCA2LCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwICsgdjAsIHAxICsgdjEgLSByb3VuZCwgcDAgKyB2MCwgcDEgKyB2MSAtIHJvdW5kLCBwMCArIHYwLCBwMSArIHYxIC0gY1BvaW50LCA3LCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCAtIHYwLCBwMSAtIHYxLCBwMCAtIHYwICsgY1BvaW50LCBwMSAtIHYxLCBwMCAtIHYwLCBwMSAtIHYxLCAxLCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxICsgdjEsIHAwIC0gdjAsIHAxICsgdjEgLSBjUG9pbnQsIHAwIC0gdjAsIHAxICsgdjEsIDIsIHRydWUpO1xuICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgKyB2MCwgcDEgKyB2MSwgcDAgKyB2MCAtIGNQb2ludCwgcDEgKyB2MSwgcDAgKyB2MCwgcDEgKyB2MSwgMywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQgPT09IHRoaXMuZnJhbWVJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XG4gICAgICAgICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9tZGYpIHtcbiAgICAgICAgICAgIHRoaXMuY29udmVydFJlY3RUb1BhdGgoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0OiByZXNldFNoYXBlXG4gICAgICB9O1xuICAgICAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBSZWN0U2hhcGVQcm9wZXJ0eUZhY3RvcnkpO1xuICAgICAgcmV0dXJuIFJlY3RTaGFwZVByb3BlcnR5RmFjdG9yeTtcbiAgICB9KCk7XG5cbiAgICBmdW5jdGlvbiBnZXRTaGFwZVByb3AoZWxlbSwgZGF0YSwgdHlwZSkge1xuICAgICAgdmFyIHByb3A7XG5cbiAgICAgIGlmICh0eXBlID09PSAzIHx8IHR5cGUgPT09IDQpIHtcbiAgICAgICAgdmFyIGRhdGFQcm9wID0gdHlwZSA9PT0gMyA/IGRhdGEucHQgOiBkYXRhLmtzO1xuICAgICAgICB2YXIga2V5cyA9IGRhdGFQcm9wLms7XG5cbiAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgcHJvcCA9IG5ldyBLZXlmcmFtZWRTaGFwZVByb3BlcnR5KGVsZW0sIGRhdGEsIHR5cGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3AgPSBuZXcgU2hhcGVQcm9wZXJ0eShlbGVtLCBkYXRhLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA1KSB7XG4gICAgICAgIHByb3AgPSBuZXcgUmVjdFNoYXBlUHJvcGVydHkoZWxlbSwgZGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDYpIHtcbiAgICAgICAgcHJvcCA9IG5ldyBFbGxTaGFwZVByb3BlcnR5KGVsZW0sIGRhdGEpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA3KSB7XG4gICAgICAgIHByb3AgPSBuZXcgU3RhclNoYXBlUHJvcGVydHkoZWxlbSwgZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wLmspIHtcbiAgICAgICAgZWxlbS5hZGREeW5hbWljUHJvcGVydHkocHJvcCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9wO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENvbnN0cnVjdG9yRnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gU2hhcGVQcm9wZXJ0eTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRLZXlmcmFtZWRDb25zdHJ1Y3RvckZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEtleWZyYW1lZFNoYXBlUHJvcGVydHk7XG4gICAgfVxuXG4gICAgdmFyIG9iID0ge307XG4gICAgb2IuZ2V0U2hhcGVQcm9wID0gZ2V0U2hhcGVQcm9wO1xuICAgIG9iLmdldENvbnN0cnVjdG9yRnVuY3Rpb24gPSBnZXRDb25zdHJ1Y3RvckZ1bmN0aW9uO1xuICAgIG9iLmdldEtleWZyYW1lZENvbnN0cnVjdG9yRnVuY3Rpb24gPSBnZXRLZXlmcmFtZWRDb25zdHJ1Y3RvckZ1bmN0aW9uO1xuICAgIHJldHVybiBvYjtcbiAgfSgpO1xuXG4gIC8qIVxyXG4gICBUcmFuc2Zvcm1hdGlvbiBNYXRyaXggdjIuMFxyXG4gICAoYykgRXBpc3RlbWV4IDIwMTQtMjAxNVxyXG4gICB3d3cuZXBpc3RlbWV4LmNvbVxyXG4gICBCeSBLZW4gRnlyc3RlbmJlcmdcclxuICAgQ29udHJpYnV0aW9ucyBieSBsZWVvbml5YS5cclxuICAgTGljZW5zZTogTUlULCBoZWFkZXIgcmVxdWlyZWQuXHJcbiAgICovXG5cbiAgLyoqXHJcbiAgICogMkQgdHJhbnNmb3JtYXRpb24gbWF0cml4IG9iamVjdCBpbml0aWFsaXplZCB3aXRoIGlkZW50aXR5IG1hdHJpeC5cclxuICAgKlxyXG4gICAqIFRoZSBtYXRyaXggY2FuIHN5bmNocm9uaXplIGEgY2FudmFzIGNvbnRleHQgYnkgc3VwcGx5aW5nIHRoZSBjb250ZXh0XHJcbiAgICogYXMgYW4gYXJndW1lbnQsIG9yIGxhdGVyIGFwcGx5IGN1cnJlbnQgYWJzb2x1dGUgdHJhbnNmb3JtIHRvIGFuXHJcbiAgICogZXhpc3RpbmcgY29udGV4dC5cclxuICAgKlxyXG4gICAqIEFsbCB2YWx1ZXMgYXJlIGhhbmRsZWQgYXMgZmxvYXRpbmcgcG9pbnQgdmFsdWVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFtjb250ZXh0XSAtIE9wdGlvbmFsIGNvbnRleHQgdG8gc3luYyB3aXRoIE1hdHJpeFxyXG4gICAqIEBwcm9wIHtudW1iZXJ9IGEgLSBzY2FsZSB4XHJcbiAgICogQHByb3Age251bWJlcn0gYiAtIHNoZWFyIHlcclxuICAgKiBAcHJvcCB7bnVtYmVyfSBjIC0gc2hlYXIgeFxyXG4gICAqIEBwcm9wIHtudW1iZXJ9IGQgLSBzY2FsZSB5XHJcbiAgICogQHByb3Age251bWJlcn0gZSAtIHRyYW5zbGF0ZSB4XHJcbiAgICogQHByb3Age251bWJlcn0gZiAtIHRyYW5zbGF0ZSB5XHJcbiAgICogQHByb3Age0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxudWxsfSBbY29udGV4dD1udWxsXSAtIHNldCBvciBnZXQgY3VycmVudCBjYW52YXMgY29udGV4dFxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqL1xuXG4gIHZhciBNYXRyaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9jb3MgPSBNYXRoLmNvcztcbiAgICB2YXIgX3NpbiA9IE1hdGguc2luO1xuICAgIHZhciBfdGFuID0gTWF0aC50YW47XG4gICAgdmFyIF9ybmQgPSBNYXRoLnJvdW5kO1xuXG4gICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLnByb3BzWzBdID0gMTtcbiAgICAgIHRoaXMucHJvcHNbMV0gPSAwO1xuICAgICAgdGhpcy5wcm9wc1syXSA9IDA7XG4gICAgICB0aGlzLnByb3BzWzNdID0gMDtcbiAgICAgIHRoaXMucHJvcHNbNF0gPSAwO1xuICAgICAgdGhpcy5wcm9wc1s1XSA9IDE7XG4gICAgICB0aGlzLnByb3BzWzZdID0gMDtcbiAgICAgIHRoaXMucHJvcHNbN10gPSAwO1xuICAgICAgdGhpcy5wcm9wc1s4XSA9IDA7XG4gICAgICB0aGlzLnByb3BzWzldID0gMDtcbiAgICAgIHRoaXMucHJvcHNbMTBdID0gMTtcbiAgICAgIHRoaXMucHJvcHNbMTFdID0gMDtcbiAgICAgIHRoaXMucHJvcHNbMTJdID0gMDtcbiAgICAgIHRoaXMucHJvcHNbMTNdID0gMDtcbiAgICAgIHRoaXMucHJvcHNbMTRdID0gMDtcbiAgICAgIHRoaXMucHJvcHNbMTVdID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJvdGF0ZShhbmdsZSkge1xuICAgICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgbUNvcyA9IF9jb3MoYW5nbGUpO1xuXG4gICAgICB2YXIgbVNpbiA9IF9zaW4oYW5nbGUpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fdChtQ29zLCAtbVNpbiwgMCwgMCwgbVNpbiwgbUNvcywgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcm90YXRlWChhbmdsZSkge1xuICAgICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgbUNvcyA9IF9jb3MoYW5nbGUpO1xuXG4gICAgICB2YXIgbVNpbiA9IF9zaW4oYW5nbGUpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fdCgxLCAwLCAwLCAwLCAwLCBtQ29zLCAtbVNpbiwgMCwgMCwgbVNpbiwgbUNvcywgMCwgMCwgMCwgMCwgMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcm90YXRlWShhbmdsZSkge1xuICAgICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgbUNvcyA9IF9jb3MoYW5nbGUpO1xuXG4gICAgICB2YXIgbVNpbiA9IF9zaW4oYW5nbGUpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fdChtQ29zLCAwLCBtU2luLCAwLCAwLCAxLCAwLCAwLCAtbVNpbiwgMCwgbUNvcywgMCwgMCwgMCwgMCwgMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcm90YXRlWihhbmdsZSkge1xuICAgICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgbUNvcyA9IF9jb3MoYW5nbGUpO1xuXG4gICAgICB2YXIgbVNpbiA9IF9zaW4oYW5nbGUpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fdChtQ29zLCAtbVNpbiwgMCwgMCwgbVNpbiwgbUNvcywgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hlYXIoc3gsIHN5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fdCgxLCBzeSwgc3gsIDEsIDAsIDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNrZXcoYXgsIGF5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zaGVhcihfdGFuKGF4KSwgX3RhbihheSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNrZXdGcm9tQXhpcyhheCwgYW5nbGUpIHtcbiAgICAgIHZhciBtQ29zID0gX2NvcyhhbmdsZSk7XG5cbiAgICAgIHZhciBtU2luID0gX3NpbihhbmdsZSk7XG5cbiAgICAgIHJldHVybiB0aGlzLl90KG1Db3MsIG1TaW4sIDAsIDAsIC1tU2luLCBtQ29zLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKS5fdCgxLCAwLCAwLCAwLCBfdGFuKGF4KSwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSkuX3QobUNvcywgLW1TaW4sIDAsIDAsIG1TaW4sIG1Db3MsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpOyAvLyByZXR1cm4gdGhpcy5fdChtQ29zLCBtU2luLCAtbVNpbiwgbUNvcywgMCwgMCkuX3QoMSwgMCwgX3RhbihheCksIDEsIDAsIDApLl90KG1Db3MsIC1tU2luLCBtU2luLCBtQ29zLCAwLCAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FsZShzeCwgc3ksIHN6KSB7XG4gICAgICBpZiAoIXN6ICYmIHN6ICE9PSAwKSB7XG4gICAgICAgIHN6ID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN4ID09PSAxICYmIHN5ID09PSAxICYmIHN6ID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fdChzeCwgMCwgMCwgMCwgMCwgc3ksIDAsIDAsIDAsIDAsIHN6LCAwLCAwLCAwLCAwLCAxKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbCwgbSwgbiwgbywgcCkge1xuICAgICAgdGhpcy5wcm9wc1swXSA9IGE7XG4gICAgICB0aGlzLnByb3BzWzFdID0gYjtcbiAgICAgIHRoaXMucHJvcHNbMl0gPSBjO1xuICAgICAgdGhpcy5wcm9wc1szXSA9IGQ7XG4gICAgICB0aGlzLnByb3BzWzRdID0gZTtcbiAgICAgIHRoaXMucHJvcHNbNV0gPSBmO1xuICAgICAgdGhpcy5wcm9wc1s2XSA9IGc7XG4gICAgICB0aGlzLnByb3BzWzddID0gaDtcbiAgICAgIHRoaXMucHJvcHNbOF0gPSBpO1xuICAgICAgdGhpcy5wcm9wc1s5XSA9IGo7XG4gICAgICB0aGlzLnByb3BzWzEwXSA9IGs7XG4gICAgICB0aGlzLnByb3BzWzExXSA9IGw7XG4gICAgICB0aGlzLnByb3BzWzEyXSA9IG07XG4gICAgICB0aGlzLnByb3BzWzEzXSA9IG47XG4gICAgICB0aGlzLnByb3BzWzE0XSA9IG87XG4gICAgICB0aGlzLnByb3BzWzE1XSA9IHA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGUodHgsIHR5LCB0eikge1xuICAgICAgdHogPSB0eiB8fCAwO1xuXG4gICAgICBpZiAodHggIT09IDAgfHwgdHkgIT09IDAgfHwgdHogIT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3QoMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgdHgsIHR5LCB0eiwgMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybShhMiwgYjIsIGMyLCBkMiwgZTIsIGYyLCBnMiwgaDIsIGkyLCBqMiwgazIsIGwyLCBtMiwgbjIsIG8yLCBwMikge1xuICAgICAgdmFyIF9wID0gdGhpcy5wcm9wcztcblxuICAgICAgaWYgKGEyID09PSAxICYmIGIyID09PSAwICYmIGMyID09PSAwICYmIGQyID09PSAwICYmIGUyID09PSAwICYmIGYyID09PSAxICYmIGcyID09PSAwICYmIGgyID09PSAwICYmIGkyID09PSAwICYmIGoyID09PSAwICYmIGsyID09PSAxICYmIGwyID09PSAwKSB7XG4gICAgICAgIC8vIE5PVEU6IGNvbW1lbnRpbmcgdGhpcyBjb25kaXRpb24gYmVjYXVzZSBUdXJib0ZhbiBkZW9wdGltaXplcyBjb2RlIHdoZW4gcHJlc2VudFxuICAgICAgICAvLyBpZihtMiAhPT0gMCB8fCBuMiAhPT0gMCB8fCBvMiAhPT0gMCl7XG4gICAgICAgIF9wWzEyXSA9IF9wWzEyXSAqIGEyICsgX3BbMTVdICogbTI7XG4gICAgICAgIF9wWzEzXSA9IF9wWzEzXSAqIGYyICsgX3BbMTVdICogbjI7XG4gICAgICAgIF9wWzE0XSA9IF9wWzE0XSAqIGsyICsgX3BbMTVdICogbzI7XG4gICAgICAgIF9wWzE1XSAqPSBwMjsgLy8gfVxuXG4gICAgICAgIHRoaXMuX2lkZW50aXR5Q2FsY3VsYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIGExID0gX3BbMF07XG4gICAgICB2YXIgYjEgPSBfcFsxXTtcbiAgICAgIHZhciBjMSA9IF9wWzJdO1xuICAgICAgdmFyIGQxID0gX3BbM107XG4gICAgICB2YXIgZTEgPSBfcFs0XTtcbiAgICAgIHZhciBmMSA9IF9wWzVdO1xuICAgICAgdmFyIGcxID0gX3BbNl07XG4gICAgICB2YXIgaDEgPSBfcFs3XTtcbiAgICAgIHZhciBpMSA9IF9wWzhdO1xuICAgICAgdmFyIGoxID0gX3BbOV07XG4gICAgICB2YXIgazEgPSBfcFsxMF07XG4gICAgICB2YXIgbDEgPSBfcFsxMV07XG4gICAgICB2YXIgbTEgPSBfcFsxMl07XG4gICAgICB2YXIgbjEgPSBfcFsxM107XG4gICAgICB2YXIgbzEgPSBfcFsxNF07XG4gICAgICB2YXIgcDEgPSBfcFsxNV07XG4gICAgICAvKiBtYXRyaXggb3JkZXIgKGNhbnZhcyBjb21wYXRpYmxlKTpcclxuICAgICAgICAgICAqIGFjZVxyXG4gICAgICAgICAgICogYmRmXHJcbiAgICAgICAgICAgKiAwMDFcclxuICAgICAgICAgICAqL1xuXG4gICAgICBfcFswXSA9IGExICogYTIgKyBiMSAqIGUyICsgYzEgKiBpMiArIGQxICogbTI7XG4gICAgICBfcFsxXSA9IGExICogYjIgKyBiMSAqIGYyICsgYzEgKiBqMiArIGQxICogbjI7XG4gICAgICBfcFsyXSA9IGExICogYzIgKyBiMSAqIGcyICsgYzEgKiBrMiArIGQxICogbzI7XG4gICAgICBfcFszXSA9IGExICogZDIgKyBiMSAqIGgyICsgYzEgKiBsMiArIGQxICogcDI7XG4gICAgICBfcFs0XSA9IGUxICogYTIgKyBmMSAqIGUyICsgZzEgKiBpMiArIGgxICogbTI7XG4gICAgICBfcFs1XSA9IGUxICogYjIgKyBmMSAqIGYyICsgZzEgKiBqMiArIGgxICogbjI7XG4gICAgICBfcFs2XSA9IGUxICogYzIgKyBmMSAqIGcyICsgZzEgKiBrMiArIGgxICogbzI7XG4gICAgICBfcFs3XSA9IGUxICogZDIgKyBmMSAqIGgyICsgZzEgKiBsMiArIGgxICogcDI7XG4gICAgICBfcFs4XSA9IGkxICogYTIgKyBqMSAqIGUyICsgazEgKiBpMiArIGwxICogbTI7XG4gICAgICBfcFs5XSA9IGkxICogYjIgKyBqMSAqIGYyICsgazEgKiBqMiArIGwxICogbjI7XG4gICAgICBfcFsxMF0gPSBpMSAqIGMyICsgajEgKiBnMiArIGsxICogazIgKyBsMSAqIG8yO1xuICAgICAgX3BbMTFdID0gaTEgKiBkMiArIGoxICogaDIgKyBrMSAqIGwyICsgbDEgKiBwMjtcbiAgICAgIF9wWzEyXSA9IG0xICogYTIgKyBuMSAqIGUyICsgbzEgKiBpMiArIHAxICogbTI7XG4gICAgICBfcFsxM10gPSBtMSAqIGIyICsgbjEgKiBmMiArIG8xICogajIgKyBwMSAqIG4yO1xuICAgICAgX3BbMTRdID0gbTEgKiBjMiArIG4xICogZzIgKyBvMSAqIGsyICsgcDEgKiBvMjtcbiAgICAgIF9wWzE1XSA9IG0xICogZDIgKyBuMSAqIGgyICsgbzEgKiBsMiArIHAxICogcDI7XG4gICAgICB0aGlzLl9pZGVudGl0eUNhbGN1bGF0ZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG11bHRpcGx5KG1hdHJpeCkge1xuICAgICAgdmFyIG1hdHJpeFByb3BzID0gbWF0cml4LnByb3BzO1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKG1hdHJpeFByb3BzWzBdLCBtYXRyaXhQcm9wc1sxXSwgbWF0cml4UHJvcHNbMl0sIG1hdHJpeFByb3BzWzNdLCBtYXRyaXhQcm9wc1s0XSwgbWF0cml4UHJvcHNbNV0sIG1hdHJpeFByb3BzWzZdLCBtYXRyaXhQcm9wc1s3XSwgbWF0cml4UHJvcHNbOF0sIG1hdHJpeFByb3BzWzldLCBtYXRyaXhQcm9wc1sxMF0sIG1hdHJpeFByb3BzWzExXSwgbWF0cml4UHJvcHNbMTJdLCBtYXRyaXhQcm9wc1sxM10sIG1hdHJpeFByb3BzWzE0XSwgbWF0cml4UHJvcHNbMTVdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aXR5KCkge1xuICAgICAgaWYgKCF0aGlzLl9pZGVudGl0eUNhbGN1bGF0ZWQpIHtcbiAgICAgICAgdGhpcy5faWRlbnRpdHkgPSAhKHRoaXMucHJvcHNbMF0gIT09IDEgfHwgdGhpcy5wcm9wc1sxXSAhPT0gMCB8fCB0aGlzLnByb3BzWzJdICE9PSAwIHx8IHRoaXMucHJvcHNbM10gIT09IDAgfHwgdGhpcy5wcm9wc1s0XSAhPT0gMCB8fCB0aGlzLnByb3BzWzVdICE9PSAxIHx8IHRoaXMucHJvcHNbNl0gIT09IDAgfHwgdGhpcy5wcm9wc1s3XSAhPT0gMCB8fCB0aGlzLnByb3BzWzhdICE9PSAwIHx8IHRoaXMucHJvcHNbOV0gIT09IDAgfHwgdGhpcy5wcm9wc1sxMF0gIT09IDEgfHwgdGhpcy5wcm9wc1sxMV0gIT09IDAgfHwgdGhpcy5wcm9wc1sxMl0gIT09IDAgfHwgdGhpcy5wcm9wc1sxM10gIT09IDAgfHwgdGhpcy5wcm9wc1sxNF0gIT09IDAgfHwgdGhpcy5wcm9wc1sxNV0gIT09IDEpO1xuICAgICAgICB0aGlzLl9pZGVudGl0eUNhbGN1bGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5faWRlbnRpdHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXF1YWxzKG1hdHIpIHtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgd2hpbGUgKGkgPCAxNikge1xuICAgICAgICBpZiAobWF0ci5wcm9wc1tpXSAhPT0gdGhpcy5wcm9wc1tpXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUobWF0cikge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSArPSAxKSB7XG4gICAgICAgIG1hdHIucHJvcHNbaV0gPSB0aGlzLnByb3BzW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF0cjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZUZyb21Qcm9wcyhwcm9wcykge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSArPSAxKSB7XG4gICAgICAgIHRoaXMucHJvcHNbaV0gPSBwcm9wc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseVRvUG9pbnQoeCwgeSwgeikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAqIHRoaXMucHJvcHNbMF0gKyB5ICogdGhpcy5wcm9wc1s0XSArIHogKiB0aGlzLnByb3BzWzhdICsgdGhpcy5wcm9wc1sxMl0sXG4gICAgICAgIHk6IHggKiB0aGlzLnByb3BzWzFdICsgeSAqIHRoaXMucHJvcHNbNV0gKyB6ICogdGhpcy5wcm9wc1s5XSArIHRoaXMucHJvcHNbMTNdLFxuICAgICAgICB6OiB4ICogdGhpcy5wcm9wc1syXSArIHkgKiB0aGlzLnByb3BzWzZdICsgeiAqIHRoaXMucHJvcHNbMTBdICsgdGhpcy5wcm9wc1sxNF1cbiAgICAgIH07XG4gICAgICAvKiByZXR1cm4ge1xyXG4gICAgICAgICAgIHg6IHggKiBtZS5hICsgeSAqIG1lLmMgKyBtZS5lLFxyXG4gICAgICAgICAgIHk6IHggKiBtZS5iICsgeSAqIG1lLmQgKyBtZS5mXHJcbiAgICAgICAgICAgfTsgKi9cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseVRvWCh4LCB5LCB6KSB7XG4gICAgICByZXR1cm4geCAqIHRoaXMucHJvcHNbMF0gKyB5ICogdGhpcy5wcm9wc1s0XSArIHogKiB0aGlzLnByb3BzWzhdICsgdGhpcy5wcm9wc1sxMl07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlUb1koeCwgeSwgeikge1xuICAgICAgcmV0dXJuIHggKiB0aGlzLnByb3BzWzFdICsgeSAqIHRoaXMucHJvcHNbNV0gKyB6ICogdGhpcy5wcm9wc1s5XSArIHRoaXMucHJvcHNbMTNdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5VG9aKHgsIHksIHopIHtcbiAgICAgIHJldHVybiB4ICogdGhpcy5wcm9wc1syXSArIHkgKiB0aGlzLnByb3BzWzZdICsgeiAqIHRoaXMucHJvcHNbMTBdICsgdGhpcy5wcm9wc1sxNF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SW52ZXJzZU1hdHJpeCgpIHtcbiAgICAgIHZhciBkZXRlcm1pbmFudCA9IHRoaXMucHJvcHNbMF0gKiB0aGlzLnByb3BzWzVdIC0gdGhpcy5wcm9wc1sxXSAqIHRoaXMucHJvcHNbNF07XG4gICAgICB2YXIgYSA9IHRoaXMucHJvcHNbNV0gLyBkZXRlcm1pbmFudDtcbiAgICAgIHZhciBiID0gLXRoaXMucHJvcHNbMV0gLyBkZXRlcm1pbmFudDtcbiAgICAgIHZhciBjID0gLXRoaXMucHJvcHNbNF0gLyBkZXRlcm1pbmFudDtcbiAgICAgIHZhciBkID0gdGhpcy5wcm9wc1swXSAvIGRldGVybWluYW50O1xuICAgICAgdmFyIGUgPSAodGhpcy5wcm9wc1s0XSAqIHRoaXMucHJvcHNbMTNdIC0gdGhpcy5wcm9wc1s1XSAqIHRoaXMucHJvcHNbMTJdKSAvIGRldGVybWluYW50O1xuICAgICAgdmFyIGYgPSAtKHRoaXMucHJvcHNbMF0gKiB0aGlzLnByb3BzWzEzXSAtIHRoaXMucHJvcHNbMV0gKiB0aGlzLnByb3BzWzEyXSkgLyBkZXRlcm1pbmFudDtcbiAgICAgIHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgICAgaW52ZXJzZU1hdHJpeC5wcm9wc1swXSA9IGE7XG4gICAgICBpbnZlcnNlTWF0cml4LnByb3BzWzFdID0gYjtcbiAgICAgIGludmVyc2VNYXRyaXgucHJvcHNbNF0gPSBjO1xuICAgICAgaW52ZXJzZU1hdHJpeC5wcm9wc1s1XSA9IGQ7XG4gICAgICBpbnZlcnNlTWF0cml4LnByb3BzWzEyXSA9IGU7XG4gICAgICBpbnZlcnNlTWF0cml4LnByb3BzWzEzXSA9IGY7XG4gICAgICByZXR1cm4gaW52ZXJzZU1hdHJpeDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZlcnNlUG9pbnQocHQpIHtcbiAgICAgIHZhciBpbnZlcnNlTWF0cml4ID0gdGhpcy5nZXRJbnZlcnNlTWF0cml4KCk7XG4gICAgICByZXR1cm4gaW52ZXJzZU1hdHJpeC5hcHBseVRvUG9pbnRBcnJheShwdFswXSwgcHRbMV0sIHB0WzJdIHx8IDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmVyc2VQb2ludHMocHRzKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBwdHMubGVuZ3RoO1xuICAgICAgdmFyIHJldFB0cyA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcmV0UHRzW2ldID0gaW52ZXJzZVBvaW50KHB0c1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXRQdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlUb1RyaXBsZVBvaW50cyhwdDEsIHB0MiwgcHQzKSB7XG4gICAgICB2YXIgYXJyID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIDYpO1xuXG4gICAgICBpZiAodGhpcy5pc0lkZW50aXR5KCkpIHtcbiAgICAgICAgYXJyWzBdID0gcHQxWzBdO1xuICAgICAgICBhcnJbMV0gPSBwdDFbMV07XG4gICAgICAgIGFyclsyXSA9IHB0MlswXTtcbiAgICAgICAgYXJyWzNdID0gcHQyWzFdO1xuICAgICAgICBhcnJbNF0gPSBwdDNbMF07XG4gICAgICAgIGFycls1XSA9IHB0M1sxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwMCA9IHRoaXMucHJvcHNbMF07XG4gICAgICAgIHZhciBwMSA9IHRoaXMucHJvcHNbMV07XG4gICAgICAgIHZhciBwNCA9IHRoaXMucHJvcHNbNF07XG4gICAgICAgIHZhciBwNSA9IHRoaXMucHJvcHNbNV07XG4gICAgICAgIHZhciBwMTIgPSB0aGlzLnByb3BzWzEyXTtcbiAgICAgICAgdmFyIHAxMyA9IHRoaXMucHJvcHNbMTNdO1xuICAgICAgICBhcnJbMF0gPSBwdDFbMF0gKiBwMCArIHB0MVsxXSAqIHA0ICsgcDEyO1xuICAgICAgICBhcnJbMV0gPSBwdDFbMF0gKiBwMSArIHB0MVsxXSAqIHA1ICsgcDEzO1xuICAgICAgICBhcnJbMl0gPSBwdDJbMF0gKiBwMCArIHB0MlsxXSAqIHA0ICsgcDEyO1xuICAgICAgICBhcnJbM10gPSBwdDJbMF0gKiBwMSArIHB0MlsxXSAqIHA1ICsgcDEzO1xuICAgICAgICBhcnJbNF0gPSBwdDNbMF0gKiBwMCArIHB0M1sxXSAqIHA0ICsgcDEyO1xuICAgICAgICBhcnJbNV0gPSBwdDNbMF0gKiBwMSArIHB0M1sxXSAqIHA1ICsgcDEzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5VG9Qb2ludEFycmF5KHgsIHksIHopIHtcbiAgICAgIHZhciBhcnI7XG5cbiAgICAgIGlmICh0aGlzLmlzSWRlbnRpdHkoKSkge1xuICAgICAgICBhcnIgPSBbeCwgeSwgel07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnIgPSBbeCAqIHRoaXMucHJvcHNbMF0gKyB5ICogdGhpcy5wcm9wc1s0XSArIHogKiB0aGlzLnByb3BzWzhdICsgdGhpcy5wcm9wc1sxMl0sIHggKiB0aGlzLnByb3BzWzFdICsgeSAqIHRoaXMucHJvcHNbNV0gKyB6ICogdGhpcy5wcm9wc1s5XSArIHRoaXMucHJvcHNbMTNdLCB4ICogdGhpcy5wcm9wc1syXSArIHkgKiB0aGlzLnByb3BzWzZdICsgeiAqIHRoaXMucHJvcHNbMTBdICsgdGhpcy5wcm9wc1sxNF1dO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5VG9Qb2ludFN0cmluZ2lmaWVkKHgsIHkpIHtcbiAgICAgIGlmICh0aGlzLmlzSWRlbnRpdHkoKSkge1xuICAgICAgICByZXR1cm4geCArICcsJyArIHk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfcCA9IHRoaXMucHJvcHM7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCgoeCAqIF9wWzBdICsgeSAqIF9wWzRdICsgX3BbMTJdKSAqIDEwMCkgLyAxMDAgKyAnLCcgKyBNYXRoLnJvdW5kKCh4ICogX3BbMV0gKyB5ICogX3BbNV0gKyBfcFsxM10pICogMTAwKSAvIDEwMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0NTUygpIHtcbiAgICAgIC8vIERvZXNuJ3QgbWFrZSBtdWNoIHNlbnNlIHRvIGFkZCB0aGlzIG9wdGltaXphdGlvbi4gSWYgaXQgaXMgYW4gaWRlbnRpdHkgbWF0cml4LCBpdCdzIHZlcnkgbGlrZWx5IHRoaXMgd2lsbCBnZXQgY2FsbGVkIG9ubHkgb25jZSBzaW5jZSBpdCB3b24ndCBiZSBrZXlmcmFtZWQuXG5cbiAgICAgIC8qIGlmKHRoaXMuaXNJZGVudGl0eSgpKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgfSAqL1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBjc3NWYWx1ZSA9ICdtYXRyaXgzZCgnO1xuICAgICAgdmFyIHYgPSAxMDAwMDtcblxuICAgICAgd2hpbGUgKGkgPCAxNikge1xuICAgICAgICBjc3NWYWx1ZSArPSBfcm5kKHByb3BzW2ldICogdikgLyB2O1xuICAgICAgICBjc3NWYWx1ZSArPSBpID09PSAxNSA/ICcpJyA6ICcsJztcbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3NzVmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcm91bmRNYXRyaXhQcm9wZXJ0eSh2YWwpIHtcbiAgICAgIHZhciB2ID0gMTAwMDA7XG5cbiAgICAgIGlmICh2YWwgPCAwLjAwMDAwMSAmJiB2YWwgPiAwIHx8IHZhbCA+IC0wLjAwMDAwMSAmJiB2YWwgPCAwKSB7XG4gICAgICAgIHJldHVybiBfcm5kKHZhbCAqIHYpIC8gdjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0bzJkQ1NTKCkge1xuICAgICAgLy8gRG9lc24ndCBtYWtlIG11Y2ggc2Vuc2UgdG8gYWRkIHRoaXMgb3B0aW1pemF0aW9uLiBJZiBpdCBpcyBhbiBpZGVudGl0eSBtYXRyaXgsIGl0J3MgdmVyeSBsaWtlbHkgdGhpcyB3aWxsIGdldCBjYWxsZWQgb25seSBvbmNlIHNpbmNlIGl0IHdvbid0IGJlIGtleWZyYW1lZC5cblxuICAgICAgLyogaWYodGhpcy5pc0lkZW50aXR5KCkpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICB9ICovXG4gICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuXG4gICAgICB2YXIgX2EgPSByb3VuZE1hdHJpeFByb3BlcnR5KHByb3BzWzBdKTtcblxuICAgICAgdmFyIF9iID0gcm91bmRNYXRyaXhQcm9wZXJ0eShwcm9wc1sxXSk7XG5cbiAgICAgIHZhciBfYyA9IHJvdW5kTWF0cml4UHJvcGVydHkocHJvcHNbNF0pO1xuXG4gICAgICB2YXIgX2QgPSByb3VuZE1hdHJpeFByb3BlcnR5KHByb3BzWzVdKTtcblxuICAgICAgdmFyIF9lID0gcm91bmRNYXRyaXhQcm9wZXJ0eShwcm9wc1sxMl0pO1xuXG4gICAgICB2YXIgX2YgPSByb3VuZE1hdHJpeFByb3BlcnR5KHByb3BzWzEzXSk7XG5cbiAgICAgIHJldHVybiAnbWF0cml4KCcgKyBfYSArICcsJyArIF9iICsgJywnICsgX2MgKyAnLCcgKyBfZCArICcsJyArIF9lICsgJywnICsgX2YgKyAnKSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucmVzZXQgPSByZXNldDtcbiAgICAgIHRoaXMucm90YXRlID0gcm90YXRlO1xuICAgICAgdGhpcy5yb3RhdGVYID0gcm90YXRlWDtcbiAgICAgIHRoaXMucm90YXRlWSA9IHJvdGF0ZVk7XG4gICAgICB0aGlzLnJvdGF0ZVogPSByb3RhdGVaO1xuICAgICAgdGhpcy5za2V3ID0gc2tldztcbiAgICAgIHRoaXMuc2tld0Zyb21BeGlzID0gc2tld0Zyb21BeGlzO1xuICAgICAgdGhpcy5zaGVhciA9IHNoZWFyO1xuICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0gPSBzZXRUcmFuc2Zvcm07XG4gICAgICB0aGlzLnRyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcbiAgICAgIHRoaXMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgdGhpcy5tdWx0aXBseSA9IG11bHRpcGx5O1xuICAgICAgdGhpcy5hcHBseVRvUG9pbnQgPSBhcHBseVRvUG9pbnQ7XG4gICAgICB0aGlzLmFwcGx5VG9YID0gYXBwbHlUb1g7XG4gICAgICB0aGlzLmFwcGx5VG9ZID0gYXBwbHlUb1k7XG4gICAgICB0aGlzLmFwcGx5VG9aID0gYXBwbHlUb1o7XG4gICAgICB0aGlzLmFwcGx5VG9Qb2ludEFycmF5ID0gYXBwbHlUb1BvaW50QXJyYXk7XG4gICAgICB0aGlzLmFwcGx5VG9UcmlwbGVQb2ludHMgPSBhcHBseVRvVHJpcGxlUG9pbnRzO1xuICAgICAgdGhpcy5hcHBseVRvUG9pbnRTdHJpbmdpZmllZCA9IGFwcGx5VG9Qb2ludFN0cmluZ2lmaWVkO1xuICAgICAgdGhpcy50b0NTUyA9IHRvQ1NTO1xuICAgICAgdGhpcy50bzJkQ1NTID0gdG8yZENTUztcbiAgICAgIHRoaXMuY2xvbmUgPSBjbG9uZTtcbiAgICAgIHRoaXMuY2xvbmVGcm9tUHJvcHMgPSBjbG9uZUZyb21Qcm9wcztcbiAgICAgIHRoaXMuZXF1YWxzID0gZXF1YWxzO1xuICAgICAgdGhpcy5pbnZlcnNlUG9pbnRzID0gaW52ZXJzZVBvaW50cztcbiAgICAgIHRoaXMuaW52ZXJzZVBvaW50ID0gaW52ZXJzZVBvaW50O1xuICAgICAgdGhpcy5nZXRJbnZlcnNlTWF0cml4ID0gZ2V0SW52ZXJzZU1hdHJpeDtcbiAgICAgIHRoaXMuX3QgPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgIHRoaXMuaXNJZGVudGl0eSA9IGlzSWRlbnRpdHk7XG4gICAgICB0aGlzLl9pZGVudGl0eSA9IHRydWU7XG4gICAgICB0aGlzLl9pZGVudGl0eUNhbGN1bGF0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMucHJvcHMgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgMTYpO1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH07XG4gIH0oKTtcblxuICBmdW5jdGlvbiBfdHlwZW9mJDMob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YkMyA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mJDMgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZiQzKG9iaik7IH1cbiAgdmFyIGxvdHRpZSA9IHt9O1xuICB2YXIgc3RhbmRhbG9uZSA9ICdfX1tTVEFOREFMT05FXV9fJztcbiAgdmFyIGFuaW1hdGlvbkRhdGEgPSAnX19bQU5JTUFUSU9OREFUQV1fXyc7XG4gIHZhciByZW5kZXJlciA9ICcnO1xuXG4gIGZ1bmN0aW9uIHNldExvY2F0aW9uKGhyZWYpIHtcbiAgICBzZXRMb2NhdGlvbkhyZWYoaHJlZik7XG4gIH1cblxuICBmdW5jdGlvbiBzZWFyY2hBbmltYXRpb25zKCkge1xuICAgIGlmIChzdGFuZGFsb25lID09PSB0cnVlKSB7XG4gICAgICBhbmltYXRpb25NYW5hZ2VyLnNlYXJjaEFuaW1hdGlvbnMoYW5pbWF0aW9uRGF0YSwgc3RhbmRhbG9uZSwgcmVuZGVyZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmltYXRpb25NYW5hZ2VyLnNlYXJjaEFuaW1hdGlvbnMoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRTdWJmcmFtZVJlbmRlcmluZyhmbGFnKSB7XG4gICAgc2V0U3ViZnJhbWVFbmFibGVkKGZsYWcpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0UHJlZml4KHByZWZpeCkge1xuICAgIHNldElkUHJlZml4KHByZWZpeCk7XG4gIH1cblxuICBmdW5jdGlvbiBsb2FkQW5pbWF0aW9uKHBhcmFtcykge1xuICAgIGlmIChzdGFuZGFsb25lID09PSB0cnVlKSB7XG4gICAgICBwYXJhbXMuYW5pbWF0aW9uRGF0YSA9IEpTT04ucGFyc2UoYW5pbWF0aW9uRGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuaW1hdGlvbk1hbmFnZXIubG9hZEFuaW1hdGlvbihwYXJhbXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0UXVhbGl0eSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ2hpZ2gnOlxuICAgICAgICAgIHNldERlZmF1bHRDdXJ2ZVNlZ21lbnRzKDIwMCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2FzZSAnbWVkaXVtJzpcbiAgICAgICAgICBzZXREZWZhdWx0Q3VydmVTZWdtZW50cyg1MCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbG93JzpcbiAgICAgICAgICBzZXREZWZhdWx0Q3VydmVTZWdtZW50cygxMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNOYU4odmFsdWUpICYmIHZhbHVlID4gMSkge1xuICAgICAgc2V0RGVmYXVsdEN1cnZlU2VnbWVudHModmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChnZXREZWZhdWx0Q3VydmVTZWdtZW50cygpID49IDUwKSB7XG4gICAgICByb3VuZFZhbHVlcyhmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvdW5kVmFsdWVzKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluQnJvd3NlcigpIHtcbiAgICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnN0YWxsUGx1Z2luKHR5cGUsIHBsdWdpbikge1xuICAgIGlmICh0eXBlID09PSAnZXhwcmVzc2lvbnMnKSB7XG4gICAgICBzZXRFeHByZXNzaW9uc1BsdWdpbihwbHVnaW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZhY3RvcnkobmFtZSkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAncHJvcGVydHlGYWN0b3J5JzpcbiAgICAgICAgcmV0dXJuIFByb3BlcnR5RmFjdG9yeTtcblxuICAgICAgY2FzZSAnc2hhcGVQcm9wZXJ0eUZhY3RvcnknOlxuICAgICAgICByZXR1cm4gU2hhcGVQcm9wZXJ0eUZhY3Rvcnk7XG5cbiAgICAgIGNhc2UgJ21hdHJpeCc6XG4gICAgICAgIHJldHVybiBNYXRyaXg7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGxvdHRpZS5wbGF5ID0gYW5pbWF0aW9uTWFuYWdlci5wbGF5O1xuICBsb3R0aWUucGF1c2UgPSBhbmltYXRpb25NYW5hZ2VyLnBhdXNlO1xuICBsb3R0aWUuc2V0TG9jYXRpb25IcmVmID0gc2V0TG9jYXRpb247XG4gIGxvdHRpZS50b2dnbGVQYXVzZSA9IGFuaW1hdGlvbk1hbmFnZXIudG9nZ2xlUGF1c2U7XG4gIGxvdHRpZS5zZXRTcGVlZCA9IGFuaW1hdGlvbk1hbmFnZXIuc2V0U3BlZWQ7XG4gIGxvdHRpZS5zZXREaXJlY3Rpb24gPSBhbmltYXRpb25NYW5hZ2VyLnNldERpcmVjdGlvbjtcbiAgbG90dGllLnN0b3AgPSBhbmltYXRpb25NYW5hZ2VyLnN0b3A7XG4gIGxvdHRpZS5zZWFyY2hBbmltYXRpb25zID0gc2VhcmNoQW5pbWF0aW9ucztcbiAgbG90dGllLnJlZ2lzdGVyQW5pbWF0aW9uID0gYW5pbWF0aW9uTWFuYWdlci5yZWdpc3RlckFuaW1hdGlvbjtcbiAgbG90dGllLmxvYWRBbmltYXRpb24gPSBsb2FkQW5pbWF0aW9uO1xuICBsb3R0aWUuc2V0U3ViZnJhbWVSZW5kZXJpbmcgPSBzZXRTdWJmcmFtZVJlbmRlcmluZztcbiAgbG90dGllLnJlc2l6ZSA9IGFuaW1hdGlvbk1hbmFnZXIucmVzaXplOyAvLyBsb3R0aWUuc3RhcnQgPSBzdGFydDtcblxuICBsb3R0aWUuZ29Ub0FuZFN0b3AgPSBhbmltYXRpb25NYW5hZ2VyLmdvVG9BbmRTdG9wO1xuICBsb3R0aWUuZGVzdHJveSA9IGFuaW1hdGlvbk1hbmFnZXIuZGVzdHJveTtcbiAgbG90dGllLnNldFF1YWxpdHkgPSBzZXRRdWFsaXR5O1xuICBsb3R0aWUuaW5Ccm93c2VyID0gaW5Ccm93c2VyO1xuICBsb3R0aWUuaW5zdGFsbFBsdWdpbiA9IGluc3RhbGxQbHVnaW47XG4gIGxvdHRpZS5mcmVlemUgPSBhbmltYXRpb25NYW5hZ2VyLmZyZWV6ZTtcbiAgbG90dGllLnVuZnJlZXplID0gYW5pbWF0aW9uTWFuYWdlci51bmZyZWV6ZTtcbiAgbG90dGllLnNldFZvbHVtZSA9IGFuaW1hdGlvbk1hbmFnZXIuc2V0Vm9sdW1lO1xuICBsb3R0aWUubXV0ZSA9IGFuaW1hdGlvbk1hbmFnZXIubXV0ZTtcbiAgbG90dGllLnVubXV0ZSA9IGFuaW1hdGlvbk1hbmFnZXIudW5tdXRlO1xuICBsb3R0aWUuZ2V0UmVnaXN0ZXJlZEFuaW1hdGlvbnMgPSBhbmltYXRpb25NYW5hZ2VyLmdldFJlZ2lzdGVyZWRBbmltYXRpb25zO1xuICBsb3R0aWUudXNlV2ViV29ya2VyID0gc2V0V2ViV29ya2VyO1xuICBsb3R0aWUuc2V0SURQcmVmaXggPSBzZXRQcmVmaXg7XG4gIGxvdHRpZS5fX2dldEZhY3RvcnkgPSBnZXRGYWN0b3J5O1xuICBsb3R0aWUudmVyc2lvbiA9ICc1LjEyLjInO1xuXG4gIGZ1bmN0aW9uIGNoZWNrUmVhZHkoKSB7XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwocmVhZHlTdGF0ZUNoZWNrSW50ZXJ2YWwpO1xuICAgICAgc2VhcmNoQW5pbWF0aW9ucygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFF1ZXJ5VmFyaWFibGUodmFyaWFibGUpIHtcbiAgICB2YXIgdmFycyA9IHF1ZXJ5U3RyaW5nLnNwbGl0KCcmJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciBwYWlyID0gdmFyc1tpXS5zcGxpdCgnPScpO1xuXG4gICAgICBpZiAoZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMF0pID09IHZhcmlhYmxlKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcXVlcnlTdHJpbmcgPSAnJztcblxuICBpZiAoc3RhbmRhbG9uZSkge1xuICAgIHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICAgIHZhciBpbmRleCA9IHNjcmlwdHMubGVuZ3RoIC0gMTtcbiAgICB2YXIgbXlTY3JpcHQgPSBzY3JpcHRzW2luZGV4XSB8fCB7XG4gICAgICBzcmM6ICcnXG4gICAgfTtcbiAgICBxdWVyeVN0cmluZyA9IG15U2NyaXB0LnNyYyA/IG15U2NyaXB0LnNyYy5yZXBsYWNlKC9eW15cXD9dK1xcPz8vLCAnJykgOiAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuXG4gICAgcmVuZGVyZXIgPSBnZXRRdWVyeVZhcmlhYmxlKCdyZW5kZXJlcicpO1xuICB9XG5cbiAgdmFyIHJlYWR5U3RhdGVDaGVja0ludGVydmFsID0gc2V0SW50ZXJ2YWwoY2hlY2tSZWFkeSwgMTAwKTsgLy8gdGhpcyBhZGRzIGJvZHltb3ZpbiB0byB0aGUgd2luZG93IG9iamVjdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuICB0cnkge1xuICAgIGlmICghKCh0eXBlb2YgZXhwb3J0cyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mJDMoZXhwb3J0cykpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgJiYgISh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICApIHtcbiAgICAgIHdpbmRvdy5ib2R5bW92aW4gPSBsb3R0aWU7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHsvL1xuICB9XG5cbiAgdmFyIFNoYXBlTW9kaWZpZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYiA9IHt9O1xuICAgIHZhciBtb2RpZmllcnMgPSB7fTtcbiAgICBvYi5yZWdpc3Rlck1vZGlmaWVyID0gcmVnaXN0ZXJNb2RpZmllcjtcbiAgICBvYi5nZXRNb2RpZmllciA9IGdldE1vZGlmaWVyO1xuXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJNb2RpZmllcihubSwgZmFjdG9yeSkge1xuICAgICAgaWYgKCFtb2RpZmllcnNbbm1dKSB7XG4gICAgICAgIG1vZGlmaWVyc1tubV0gPSBmYWN0b3J5O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE1vZGlmaWVyKG5tLCBlbGVtLCBkYXRhKSB7XG4gICAgICByZXR1cm4gbmV3IG1vZGlmaWVyc1tubV0oZWxlbSwgZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iO1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gU2hhcGVNb2RpZmllcigpIHt9XG5cbiAgU2hhcGVNb2RpZmllci5wcm90b3R5cGUuaW5pdE1vZGlmaWVyUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIFNoYXBlTW9kaWZpZXIucHJvdG90eXBlLmFkZFNoYXBlVG9Nb2RpZmllciA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIFNoYXBlTW9kaWZpZXIucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuY2xvc2VkKSB7XG4gICAgICAvLyBBZGRpbmcgc2hhcGUgdG8gZHluYW1pYyBwcm9wZXJ0aWVzLiBJdCBjb3ZlcnMgdGhlIGNhc2Ugd2hlcmUgYSBzaGFwZSBoYXMgbm8gZWZmZWN0cyBhcHBsaWVkLCB0byByZXNldCBpdCdzIF9tZGYgc3RhdGUgb24gZXZlcnkgdGljay5cbiAgICAgIGRhdGEuc2guY29udGFpbmVyLmFkZER5bmFtaWNQcm9wZXJ0eShkYXRhLnNoKTtcbiAgICAgIHZhciBzaGFwZURhdGEgPSB7XG4gICAgICAgIHNoYXBlOiBkYXRhLnNoLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbjogc2hhcGVDb2xsZWN0aW9uUG9vbC5uZXdTaGFwZUNvbGxlY3Rpb24oKVxuICAgICAgfTtcbiAgICAgIHRoaXMuc2hhcGVzLnB1c2goc2hhcGVEYXRhKTtcbiAgICAgIHRoaXMuYWRkU2hhcGVUb01vZGlmaWVyKHNoYXBlRGF0YSk7XG5cbiAgICAgIGlmICh0aGlzLl9pc0FuaW1hdGVkKSB7XG4gICAgICAgIGRhdGEuc2V0QXNBbmltYXRlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBTaGFwZU1vZGlmaWVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEpIHtcbiAgICB0aGlzLnNoYXBlcyA9IFtdO1xuICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xuICAgIHRoaXMuaW5pdE1vZGlmaWVyUHJvcGVydGllcyhlbGVtLCBkYXRhKTtcbiAgICB0aGlzLmZyYW1lSWQgPSBpbml0aWFsRGVmYXVsdEZyYW1lO1xuICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgdGhpcy5rID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuayA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2V0VmFsdWUodHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIFNoYXBlTW9kaWZpZXIucHJvdG90eXBlLnByb2Nlc3NLZXlzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLmZyYW1lSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmZyYW1lSWQgPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkO1xuICAgIHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzKCk7XG4gIH07XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBTaGFwZU1vZGlmaWVyKTtcblxuICBmdW5jdGlvbiBUcmltTW9kaWZpZXIoKSB7fVxuXG4gIGV4dGVuZFByb3RvdHlwZShbU2hhcGVNb2RpZmllcl0sIFRyaW1Nb2RpZmllcik7XG5cbiAgVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEpIHtcbiAgICB0aGlzLnMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnMsIDAsIDAuMDEsIHRoaXMpO1xuICAgIHRoaXMuZSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuZSwgMCwgMC4wMSwgdGhpcyk7XG4gICAgdGhpcy5vID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5vLCAwLCAwLCB0aGlzKTtcbiAgICB0aGlzLnNWYWx1ZSA9IDA7XG4gICAgdGhpcy5lVmFsdWUgPSAwO1xuICAgIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLnByb2Nlc3NLZXlzO1xuICAgIHRoaXMubSA9IGRhdGEubTtcbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gISF0aGlzLnMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCB8fCAhIXRoaXMuZS5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoIHx8ICEhdGhpcy5vLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGg7XG4gIH07XG5cbiAgVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5hZGRTaGFwZVRvTW9kaWZpZXIgPSBmdW5jdGlvbiAoc2hhcGVEYXRhKSB7XG4gICAgc2hhcGVEYXRhLnBhdGhzRGF0YSA9IFtdO1xuICB9O1xuXG4gIFRyaW1Nb2RpZmllci5wcm90b3R5cGUuY2FsY3VsYXRlU2hhcGVFZGdlcyA9IGZ1bmN0aW9uIChzLCBlLCBzaGFwZUxlbmd0aCwgYWRkZWRMZW5ndGgsIHRvdGFsTW9kaWZpZXJMZW5ndGgpIHtcbiAgICB2YXIgc2VnbWVudHMgPSBbXTtcblxuICAgIGlmIChlIDw9IDEpIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICBzOiBzLFxuICAgICAgICBlOiBlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHMgPj0gMSkge1xuICAgICAgc2VnbWVudHMucHVzaCh7XG4gICAgICAgIHM6IHMgLSAxLFxuICAgICAgICBlOiBlIC0gMVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICBzOiBzLFxuICAgICAgICBlOiAxXG4gICAgICB9KTtcbiAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICBzOiAwLFxuICAgICAgICBlOiBlIC0gMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHNoYXBlU2VnbWVudHMgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gc2VnbWVudHMubGVuZ3RoO1xuICAgIHZhciBzZWdtZW50T2I7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHNlZ21lbnRPYiA9IHNlZ21lbnRzW2ldO1xuXG4gICAgICBpZiAoIShzZWdtZW50T2IuZSAqIHRvdGFsTW9kaWZpZXJMZW5ndGggPCBhZGRlZExlbmd0aCB8fCBzZWdtZW50T2IucyAqIHRvdGFsTW9kaWZpZXJMZW5ndGggPiBhZGRlZExlbmd0aCArIHNoYXBlTGVuZ3RoKSkge1xuICAgICAgICB2YXIgc2hhcGVTO1xuICAgICAgICB2YXIgc2hhcGVFO1xuXG4gICAgICAgIGlmIChzZWdtZW50T2IucyAqIHRvdGFsTW9kaWZpZXJMZW5ndGggPD0gYWRkZWRMZW5ndGgpIHtcbiAgICAgICAgICBzaGFwZVMgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNoYXBlUyA9IChzZWdtZW50T2IucyAqIHRvdGFsTW9kaWZpZXJMZW5ndGggLSBhZGRlZExlbmd0aCkgLyBzaGFwZUxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWdtZW50T2IuZSAqIHRvdGFsTW9kaWZpZXJMZW5ndGggPj0gYWRkZWRMZW5ndGggKyBzaGFwZUxlbmd0aCkge1xuICAgICAgICAgIHNoYXBlRSA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hhcGVFID0gKHNlZ21lbnRPYi5lICogdG90YWxNb2RpZmllckxlbmd0aCAtIGFkZGVkTGVuZ3RoKSAvIHNoYXBlTGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgc2hhcGVTZWdtZW50cy5wdXNoKFtzaGFwZVMsIHNoYXBlRV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc2hhcGVTZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHNoYXBlU2VnbWVudHMucHVzaChbMCwgMF0pO1xuICAgIH1cblxuICAgIHJldHVybiBzaGFwZVNlZ21lbnRzO1xuICB9O1xuXG4gIFRyaW1Nb2RpZmllci5wcm90b3R5cGUucmVsZWFzZVBhdGhzRGF0YSA9IGZ1bmN0aW9uIChwYXRoc0RhdGEpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gcGF0aHNEYXRhLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgc2VnbWVudHNMZW5ndGhQb29sLnJlbGVhc2UocGF0aHNEYXRhW2ldKTtcbiAgICB9XG5cbiAgICBwYXRoc0RhdGEubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gcGF0aHNEYXRhO1xuICB9O1xuXG4gIFRyaW1Nb2RpZmllci5wcm90b3R5cGUucHJvY2Vzc1NoYXBlcyA9IGZ1bmN0aW9uIChfaXNGaXJzdEZyYW1lKSB7XG4gICAgdmFyIHM7XG4gICAgdmFyIGU7XG5cbiAgICBpZiAodGhpcy5fbWRmIHx8IF9pc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHZhciBvID0gdGhpcy5vLnYgJSAzNjAgLyAzNjA7XG5cbiAgICAgIGlmIChvIDwgMCkge1xuICAgICAgICBvICs9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnMudiA+IDEpIHtcbiAgICAgICAgcyA9IDEgKyBvO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnMudiA8IDApIHtcbiAgICAgICAgcyA9IDAgKyBvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcyA9IHRoaXMucy52ICsgbztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZS52ID4gMSkge1xuICAgICAgICBlID0gMSArIG87XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZS52IDwgMCkge1xuICAgICAgICBlID0gMCArIG87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlID0gdGhpcy5lLnYgKyBvO1xuICAgICAgfVxuXG4gICAgICBpZiAocyA+IGUpIHtcbiAgICAgICAgdmFyIF9zID0gcztcbiAgICAgICAgcyA9IGU7XG4gICAgICAgIGUgPSBfcztcbiAgICAgIH1cblxuICAgICAgcyA9IE1hdGgucm91bmQocyAqIDEwMDAwKSAqIDAuMDAwMTtcbiAgICAgIGUgPSBNYXRoLnJvdW5kKGUgKiAxMDAwMCkgKiAwLjAwMDE7XG4gICAgICB0aGlzLnNWYWx1ZSA9IHM7XG4gICAgICB0aGlzLmVWYWx1ZSA9IGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgPSB0aGlzLnNWYWx1ZTtcbiAgICAgIGUgPSB0aGlzLmVWYWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgc2hhcGVQYXRocztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5zaGFwZXMubGVuZ3RoO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuO1xuICAgIHZhciBwYXRoc0RhdGE7XG4gICAgdmFyIHBhdGhEYXRhO1xuICAgIHZhciB0b3RhbFNoYXBlTGVuZ3RoO1xuICAgIHZhciB0b3RhbE1vZGlmaWVyTGVuZ3RoID0gMDtcblxuICAgIGlmIChlID09PSBzKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5zaGFwZXNbaV0ubG9jYWxTaGFwZUNvbGxlY3Rpb24ucmVsZWFzZVNoYXBlcygpO1xuICAgICAgICB0aGlzLnNoYXBlc1tpXS5zaGFwZS5fbWRmID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zaGFwZXNbaV0uc2hhcGUucGF0aHMgPSB0aGlzLnNoYXBlc1tpXS5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcblxuICAgICAgICBpZiAodGhpcy5fbWRmKSB7XG4gICAgICAgICAgdGhpcy5zaGFwZXNbaV0ucGF0aHNEYXRhLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoZSA9PT0gMSAmJiBzID09PSAwIHx8IGUgPT09IDAgJiYgcyA9PT0gMSkpIHtcbiAgICAgIHZhciBzZWdtZW50cyA9IFtdO1xuICAgICAgdmFyIHNoYXBlRGF0YTtcbiAgICAgIHZhciBsb2NhbFNoYXBlQ29sbGVjdGlvbjtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHNoYXBlRGF0YSA9IHRoaXMuc2hhcGVzW2ldOyAvLyBpZiBzaGFwZSBoYXNuJ3QgY2hhbmdlZCBhbmQgdHJpbSBwcm9wZXJ0aWVzIGhhdmVuJ3QgY2hhbmdlZCwgY2FjaGVkIHByZXZpb3VzIHBhdGggY2FuIGJlIHVzZWRcblxuICAgICAgICBpZiAoIXNoYXBlRGF0YS5zaGFwZS5fbWRmICYmICF0aGlzLl9tZGYgJiYgIV9pc0ZpcnN0RnJhbWUgJiYgdGhpcy5tICE9PSAyKSB7XG4gICAgICAgICAgc2hhcGVEYXRhLnNoYXBlLnBhdGhzID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNoYXBlUGF0aHMgPSBzaGFwZURhdGEuc2hhcGUucGF0aHM7XG4gICAgICAgICAgakxlbiA9IHNoYXBlUGF0aHMuX2xlbmd0aDtcbiAgICAgICAgICB0b3RhbFNoYXBlTGVuZ3RoID0gMDtcblxuICAgICAgICAgIGlmICghc2hhcGVEYXRhLnNoYXBlLl9tZGYgJiYgc2hhcGVEYXRhLnBhdGhzRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRvdGFsU2hhcGVMZW5ndGggPSBzaGFwZURhdGEudG90YWxTaGFwZUxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0aHNEYXRhID0gdGhpcy5yZWxlYXNlUGF0aHNEYXRhKHNoYXBlRGF0YS5wYXRoc0RhdGEpO1xuXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICAgIHBhdGhEYXRhID0gYmV6LmdldFNlZ21lbnRzTGVuZ3RoKHNoYXBlUGF0aHMuc2hhcGVzW2pdKTtcbiAgICAgICAgICAgICAgcGF0aHNEYXRhLnB1c2gocGF0aERhdGEpO1xuICAgICAgICAgICAgICB0b3RhbFNoYXBlTGVuZ3RoICs9IHBhdGhEYXRhLnRvdGFsTGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzaGFwZURhdGEudG90YWxTaGFwZUxlbmd0aCA9IHRvdGFsU2hhcGVMZW5ndGg7XG4gICAgICAgICAgICBzaGFwZURhdGEucGF0aHNEYXRhID0gcGF0aHNEYXRhO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvdGFsTW9kaWZpZXJMZW5ndGggKz0gdG90YWxTaGFwZUxlbmd0aDtcbiAgICAgICAgICBzaGFwZURhdGEuc2hhcGUuX21kZiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNoYXBlUyA9IHM7XG4gICAgICB2YXIgc2hhcGVFID0gZTtcbiAgICAgIHZhciBhZGRlZExlbmd0aCA9IDA7XG4gICAgICB2YXIgZWRnZXM7XG5cbiAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIHNoYXBlRGF0YSA9IHRoaXMuc2hhcGVzW2ldO1xuXG4gICAgICAgIGlmIChzaGFwZURhdGEuc2hhcGUuX21kZikge1xuICAgICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uLnJlbGVhc2VTaGFwZXMoKTsgLy8gaWYgbSA9PT0gMiBtZWFucyBwYXRocyBhcmUgdHJpbW1lZCBpbmRpdmlkdWFsbHkgc28gZWRnZXMgbmVlZCB0byBiZSBmb3VuZCBmb3IgdGhpcyBzcGVjaWZpYyBzaGFwZSByZWxhdGl2ZSB0byB3aG9lbCBncm91cFxuXG4gICAgICAgICAgaWYgKHRoaXMubSA9PT0gMiAmJiBsZW4gPiAxKSB7XG4gICAgICAgICAgICBlZGdlcyA9IHRoaXMuY2FsY3VsYXRlU2hhcGVFZGdlcyhzLCBlLCBzaGFwZURhdGEudG90YWxTaGFwZUxlbmd0aCwgYWRkZWRMZW5ndGgsIHRvdGFsTW9kaWZpZXJMZW5ndGgpO1xuICAgICAgICAgICAgYWRkZWRMZW5ndGggKz0gc2hhcGVEYXRhLnRvdGFsU2hhcGVMZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVkZ2VzID0gW1tzaGFwZVMsIHNoYXBlRV1dO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGpMZW4gPSBlZGdlcy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICBzaGFwZVMgPSBlZGdlc1tqXVswXTtcbiAgICAgICAgICAgIHNoYXBlRSA9IGVkZ2VzW2pdWzFdO1xuICAgICAgICAgICAgc2VnbWVudHMubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgaWYgKHNoYXBlRSA8PSAxKSB7XG4gICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHM6IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoICogc2hhcGVTLFxuICAgICAgICAgICAgICAgIGU6IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoICogc2hhcGVFXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZVMgPj0gMSkge1xuICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzOiBzaGFwZURhdGEudG90YWxTaGFwZUxlbmd0aCAqIChzaGFwZVMgLSAxKSxcbiAgICAgICAgICAgICAgICBlOiBzaGFwZURhdGEudG90YWxTaGFwZUxlbmd0aCAqIChzaGFwZUUgLSAxKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHM6IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoICogc2hhcGVTLFxuICAgICAgICAgICAgICAgIGU6IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzOiAwLFxuICAgICAgICAgICAgICAgIGU6IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoICogKHNoYXBlRSAtIDEpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmV3U2hhcGVzRGF0YSA9IHRoaXMuYWRkU2hhcGVzKHNoYXBlRGF0YSwgc2VnbWVudHNbMF0pO1xuXG4gICAgICAgICAgICBpZiAoc2VnbWVudHNbMF0ucyAhPT0gc2VnbWVudHNbMF0uZSkge1xuICAgICAgICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciBsYXN0U2hhcGVJbkNvbGxlY3Rpb24gPSBzaGFwZURhdGEuc2hhcGUucGF0aHMuc2hhcGVzW3NoYXBlRGF0YS5zaGFwZS5wYXRocy5fbGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgICAgICBpZiAobGFzdFNoYXBlSW5Db2xsZWN0aW9uLmMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBsYXN0U2hhcGUgPSBuZXdTaGFwZXNEYXRhLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5hZGRQYXRocyhuZXdTaGFwZXNEYXRhLCBsb2NhbFNoYXBlQ29sbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgICBuZXdTaGFwZXNEYXRhID0gdGhpcy5hZGRTaGFwZXMoc2hhcGVEYXRhLCBzZWdtZW50c1sxXSwgbGFzdFNoYXBlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5hZGRQYXRocyhuZXdTaGFwZXNEYXRhLCBsb2NhbFNoYXBlQ29sbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgICBuZXdTaGFwZXNEYXRhID0gdGhpcy5hZGRTaGFwZXMoc2hhcGVEYXRhLCBzZWdtZW50c1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5hZGRQYXRocyhuZXdTaGFwZXNEYXRhLCBsb2NhbFNoYXBlQ29sbGVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2hhcGVEYXRhLnNoYXBlLnBhdGhzID0gbG9jYWxTaGFwZUNvbGxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX21kZikge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIC8vIFJlbGVhc2lnbiBUcmltIENhY2hlZCBwYXRocyBkYXRhIHdoZW4gbm8gdHJpbSBhcHBsaWVkIGluIGNhc2Ugc2hhcGVzIGFyZSBtb2RpZmllZCBpbmJldHdlZW4uXG4gICAgICAgIC8vIERvbid0IHJlbW92ZSB0aGlzIGV2ZW4gaWYgaXQncyBsb3NpbmcgY2FjaGVkIGluZm8uXG4gICAgICAgIHRoaXMuc2hhcGVzW2ldLnBhdGhzRGF0YS5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnNoYXBlc1tpXS5zaGFwZS5fbWRmID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5hZGRQYXRocyA9IGZ1bmN0aW9uIChuZXdQYXRocywgbG9jYWxTaGFwZUNvbGxlY3Rpb24pIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gbmV3UGF0aHMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZShuZXdQYXRoc1tpXSk7XG4gICAgfVxuICB9O1xuXG4gIFRyaW1Nb2RpZmllci5wcm90b3R5cGUuYWRkU2VnbWVudCA9IGZ1bmN0aW9uIChwdDEsIHB0MiwgcHQzLCBwdDQsIHNoYXBlUGF0aCwgcG9zLCBuZXdTaGFwZSkge1xuICAgIHNoYXBlUGF0aC5zZXRYWUF0KHB0MlswXSwgcHQyWzFdLCAnbycsIHBvcyk7XG4gICAgc2hhcGVQYXRoLnNldFhZQXQocHQzWzBdLCBwdDNbMV0sICdpJywgcG9zICsgMSk7XG5cbiAgICBpZiAobmV3U2hhcGUpIHtcbiAgICAgIHNoYXBlUGF0aC5zZXRYWUF0KHB0MVswXSwgcHQxWzFdLCAndicsIHBvcyk7XG4gICAgfVxuXG4gICAgc2hhcGVQYXRoLnNldFhZQXQocHQ0WzBdLCBwdDRbMV0sICd2JywgcG9zICsgMSk7XG4gIH07XG5cbiAgVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5hZGRTZWdtZW50RnJvbUFycmF5ID0gZnVuY3Rpb24gKHBvaW50cywgc2hhcGVQYXRoLCBwb3MsIG5ld1NoYXBlKSB7XG4gICAgc2hhcGVQYXRoLnNldFhZQXQocG9pbnRzWzFdLCBwb2ludHNbNV0sICdvJywgcG9zKTtcbiAgICBzaGFwZVBhdGguc2V0WFlBdChwb2ludHNbMl0sIHBvaW50c1s2XSwgJ2knLCBwb3MgKyAxKTtcblxuICAgIGlmIChuZXdTaGFwZSkge1xuICAgICAgc2hhcGVQYXRoLnNldFhZQXQocG9pbnRzWzBdLCBwb2ludHNbNF0sICd2JywgcG9zKTtcbiAgICB9XG5cbiAgICBzaGFwZVBhdGguc2V0WFlBdChwb2ludHNbM10sIHBvaW50c1s3XSwgJ3YnLCBwb3MgKyAxKTtcbiAgfTtcblxuICBUcmltTW9kaWZpZXIucHJvdG90eXBlLmFkZFNoYXBlcyA9IGZ1bmN0aW9uIChzaGFwZURhdGEsIHNoYXBlU2VnbWVudCwgc2hhcGVQYXRoKSB7XG4gICAgdmFyIHBhdGhzRGF0YSA9IHNoYXBlRGF0YS5wYXRoc0RhdGE7XG4gICAgdmFyIHNoYXBlUGF0aHMgPSBzaGFwZURhdGEuc2hhcGUucGF0aHMuc2hhcGVzO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBzaGFwZURhdGEuc2hhcGUucGF0aHMuX2xlbmd0aDtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgYWRkZWRMZW5ndGggPSAwO1xuICAgIHZhciBjdXJyZW50TGVuZ3RoRGF0YTtcbiAgICB2YXIgc2VnbWVudENvdW50O1xuICAgIHZhciBsZW5ndGhzO1xuICAgIHZhciBzZWdtZW50O1xuICAgIHZhciBzaGFwZXMgPSBbXTtcbiAgICB2YXIgaW5pdFBvcztcbiAgICB2YXIgbmV3U2hhcGUgPSB0cnVlO1xuXG4gICAgaWYgKCFzaGFwZVBhdGgpIHtcbiAgICAgIHNoYXBlUGF0aCA9IHNoYXBlUG9vbC5uZXdFbGVtZW50KCk7XG4gICAgICBzZWdtZW50Q291bnQgPSAwO1xuICAgICAgaW5pdFBvcyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlZ21lbnRDb3VudCA9IHNoYXBlUGF0aC5fbGVuZ3RoO1xuICAgICAgaW5pdFBvcyA9IHNoYXBlUGF0aC5fbGVuZ3RoO1xuICAgIH1cblxuICAgIHNoYXBlcy5wdXNoKHNoYXBlUGF0aCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGxlbmd0aHMgPSBwYXRoc0RhdGFbaV0ubGVuZ3RocztcbiAgICAgIHNoYXBlUGF0aC5jID0gc2hhcGVQYXRoc1tpXS5jO1xuICAgICAgakxlbiA9IHNoYXBlUGF0aHNbaV0uYyA/IGxlbmd0aHMubGVuZ3RoIDogbGVuZ3Rocy5sZW5ndGggKyAxO1xuXG4gICAgICBmb3IgKGogPSAxOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgIGN1cnJlbnRMZW5ndGhEYXRhID0gbGVuZ3Roc1tqIC0gMV07XG5cbiAgICAgICAgaWYgKGFkZGVkTGVuZ3RoICsgY3VycmVudExlbmd0aERhdGEuYWRkZWRMZW5ndGggPCBzaGFwZVNlZ21lbnQucykge1xuICAgICAgICAgIGFkZGVkTGVuZ3RoICs9IGN1cnJlbnRMZW5ndGhEYXRhLmFkZGVkTGVuZ3RoO1xuICAgICAgICAgIHNoYXBlUGF0aC5jID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoYWRkZWRMZW5ndGggPiBzaGFwZVNlZ21lbnQuZSkge1xuICAgICAgICAgIHNoYXBlUGF0aC5jID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNoYXBlU2VnbWVudC5zIDw9IGFkZGVkTGVuZ3RoICYmIHNoYXBlU2VnbWVudC5lID49IGFkZGVkTGVuZ3RoICsgY3VycmVudExlbmd0aERhdGEuYWRkZWRMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkU2VnbWVudChzaGFwZVBhdGhzW2ldLnZbaiAtIDFdLCBzaGFwZVBhdGhzW2ldLm9baiAtIDFdLCBzaGFwZVBhdGhzW2ldLmlbal0sIHNoYXBlUGF0aHNbaV0udltqXSwgc2hhcGVQYXRoLCBzZWdtZW50Q291bnQsIG5ld1NoYXBlKTtcbiAgICAgICAgICAgIG5ld1NoYXBlID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBiZXouZ2V0TmV3U2VnbWVudChzaGFwZVBhdGhzW2ldLnZbaiAtIDFdLCBzaGFwZVBhdGhzW2ldLnZbal0sIHNoYXBlUGF0aHNbaV0ub1tqIC0gMV0sIHNoYXBlUGF0aHNbaV0uaVtqXSwgKHNoYXBlU2VnbWVudC5zIC0gYWRkZWRMZW5ndGgpIC8gY3VycmVudExlbmd0aERhdGEuYWRkZWRMZW5ndGgsIChzaGFwZVNlZ21lbnQuZSAtIGFkZGVkTGVuZ3RoKSAvIGN1cnJlbnRMZW5ndGhEYXRhLmFkZGVkTGVuZ3RoLCBsZW5ndGhzW2ogLSAxXSk7XG4gICAgICAgICAgICB0aGlzLmFkZFNlZ21lbnRGcm9tQXJyYXkoc2VnbWVudCwgc2hhcGVQYXRoLCBzZWdtZW50Q291bnQsIG5ld1NoYXBlKTsgLy8gdGhpcy5hZGRTZWdtZW50KHNlZ21lbnQucHQxLCBzZWdtZW50LnB0Mywgc2VnbWVudC5wdDQsIHNlZ21lbnQucHQyLCBzaGFwZVBhdGgsIHNlZ21lbnRDb3VudCwgbmV3U2hhcGUpO1xuXG4gICAgICAgICAgICBuZXdTaGFwZSA9IGZhbHNlO1xuICAgICAgICAgICAgc2hhcGVQYXRoLmMgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhZGRlZExlbmd0aCArPSBjdXJyZW50TGVuZ3RoRGF0YS5hZGRlZExlbmd0aDtcbiAgICAgICAgICBzZWdtZW50Q291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2hhcGVQYXRoc1tpXS5jICYmIGxlbmd0aHMubGVuZ3RoKSB7XG4gICAgICAgIGN1cnJlbnRMZW5ndGhEYXRhID0gbGVuZ3Roc1tqIC0gMV07XG5cbiAgICAgICAgaWYgKGFkZGVkTGVuZ3RoIDw9IHNoYXBlU2VnbWVudC5lKSB7XG4gICAgICAgICAgdmFyIHNlZ21lbnRMZW5ndGggPSBsZW5ndGhzW2ogLSAxXS5hZGRlZExlbmd0aDtcblxuICAgICAgICAgIGlmIChzaGFwZVNlZ21lbnQucyA8PSBhZGRlZExlbmd0aCAmJiBzaGFwZVNlZ21lbnQuZSA+PSBhZGRlZExlbmd0aCArIHNlZ21lbnRMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkU2VnbWVudChzaGFwZVBhdGhzW2ldLnZbaiAtIDFdLCBzaGFwZVBhdGhzW2ldLm9baiAtIDFdLCBzaGFwZVBhdGhzW2ldLmlbMF0sIHNoYXBlUGF0aHNbaV0udlswXSwgc2hhcGVQYXRoLCBzZWdtZW50Q291bnQsIG5ld1NoYXBlKTtcbiAgICAgICAgICAgIG5ld1NoYXBlID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBiZXouZ2V0TmV3U2VnbWVudChzaGFwZVBhdGhzW2ldLnZbaiAtIDFdLCBzaGFwZVBhdGhzW2ldLnZbMF0sIHNoYXBlUGF0aHNbaV0ub1tqIC0gMV0sIHNoYXBlUGF0aHNbaV0uaVswXSwgKHNoYXBlU2VnbWVudC5zIC0gYWRkZWRMZW5ndGgpIC8gc2VnbWVudExlbmd0aCwgKHNoYXBlU2VnbWVudC5lIC0gYWRkZWRMZW5ndGgpIC8gc2VnbWVudExlbmd0aCwgbGVuZ3Roc1tqIC0gMV0pO1xuICAgICAgICAgICAgdGhpcy5hZGRTZWdtZW50RnJvbUFycmF5KHNlZ21lbnQsIHNoYXBlUGF0aCwgc2VnbWVudENvdW50LCBuZXdTaGFwZSk7IC8vIHRoaXMuYWRkU2VnbWVudChzZWdtZW50LnB0MSwgc2VnbWVudC5wdDMsIHNlZ21lbnQucHQ0LCBzZWdtZW50LnB0Miwgc2hhcGVQYXRoLCBzZWdtZW50Q291bnQsIG5ld1NoYXBlKTtcblxuICAgICAgICAgICAgbmV3U2hhcGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHNoYXBlUGF0aC5jID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNoYXBlUGF0aC5jID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBhZGRlZExlbmd0aCArPSBjdXJyZW50TGVuZ3RoRGF0YS5hZGRlZExlbmd0aDtcbiAgICAgICAgc2VnbWVudENvdW50ICs9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaGFwZVBhdGguX2xlbmd0aCkge1xuICAgICAgICBzaGFwZVBhdGguc2V0WFlBdChzaGFwZVBhdGgudltpbml0UG9zXVswXSwgc2hhcGVQYXRoLnZbaW5pdFBvc11bMV0sICdpJywgaW5pdFBvcyk7XG4gICAgICAgIHNoYXBlUGF0aC5zZXRYWUF0KHNoYXBlUGF0aC52W3NoYXBlUGF0aC5fbGVuZ3RoIC0gMV1bMF0sIHNoYXBlUGF0aC52W3NoYXBlUGF0aC5fbGVuZ3RoIC0gMV1bMV0sICdvJywgc2hhcGVQYXRoLl9sZW5ndGggLSAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZGVkTGVuZ3RoID4gc2hhcGVTZWdtZW50LmUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChpIDwgbGVuIC0gMSkge1xuICAgICAgICBzaGFwZVBhdGggPSBzaGFwZVBvb2wubmV3RWxlbWVudCgpO1xuICAgICAgICBuZXdTaGFwZSA9IHRydWU7XG4gICAgICAgIHNoYXBlcy5wdXNoKHNoYXBlUGF0aCk7XG4gICAgICAgIHNlZ21lbnRDb3VudCA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYXBlcztcbiAgfTtcblxuICBmdW5jdGlvbiBQdWNrZXJBbmRCbG9hdE1vZGlmaWVyKCkge31cblxuICBleHRlbmRQcm90b3R5cGUoW1NoYXBlTW9kaWZpZXJdLCBQdWNrZXJBbmRCbG9hdE1vZGlmaWVyKTtcblxuICBQdWNrZXJBbmRCbG9hdE1vZGlmaWVyLnByb3RvdHlwZS5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEpIHtcbiAgICB0aGlzLmdldFZhbHVlID0gdGhpcy5wcm9jZXNzS2V5cztcbiAgICB0aGlzLmFtb3VudCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuYSwgMCwgbnVsbCwgdGhpcyk7XG4gICAgdGhpcy5faXNBbmltYXRlZCA9ICEhdGhpcy5hbW91bnQuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcbiAgfTtcblxuICBQdWNrZXJBbmRCbG9hdE1vZGlmaWVyLnByb3RvdHlwZS5wcm9jZXNzUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCBhbW91bnQpIHtcbiAgICB2YXIgcGVyY2VudCA9IGFtb3VudCAvIDEwMDtcbiAgICB2YXIgY2VudGVyUG9pbnQgPSBbMCwgMF07XG4gICAgdmFyIHBhdGhMZW5ndGggPSBwYXRoLl9sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGhMZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY2VudGVyUG9pbnRbMF0gKz0gcGF0aC52W2ldWzBdO1xuICAgICAgY2VudGVyUG9pbnRbMV0gKz0gcGF0aC52W2ldWzFdO1xuICAgIH1cblxuICAgIGNlbnRlclBvaW50WzBdIC89IHBhdGhMZW5ndGg7XG4gICAgY2VudGVyUG9pbnRbMV0gLz0gcGF0aExlbmd0aDtcbiAgICB2YXIgY2xvbmVkUGF0aCA9IHNoYXBlUG9vbC5uZXdFbGVtZW50KCk7XG4gICAgY2xvbmVkUGF0aC5jID0gcGF0aC5jO1xuICAgIHZhciB2WDtcbiAgICB2YXIgdlk7XG4gICAgdmFyIG9YO1xuICAgIHZhciBvWTtcbiAgICB2YXIgaVg7XG4gICAgdmFyIGlZO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGhMZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdlggPSBwYXRoLnZbaV1bMF0gKyAoY2VudGVyUG9pbnRbMF0gLSBwYXRoLnZbaV1bMF0pICogcGVyY2VudDtcbiAgICAgIHZZID0gcGF0aC52W2ldWzFdICsgKGNlbnRlclBvaW50WzFdIC0gcGF0aC52W2ldWzFdKSAqIHBlcmNlbnQ7XG4gICAgICBvWCA9IHBhdGgub1tpXVswXSArIChjZW50ZXJQb2ludFswXSAtIHBhdGgub1tpXVswXSkgKiAtcGVyY2VudDtcbiAgICAgIG9ZID0gcGF0aC5vW2ldWzFdICsgKGNlbnRlclBvaW50WzFdIC0gcGF0aC5vW2ldWzFdKSAqIC1wZXJjZW50O1xuICAgICAgaVggPSBwYXRoLmlbaV1bMF0gKyAoY2VudGVyUG9pbnRbMF0gLSBwYXRoLmlbaV1bMF0pICogLXBlcmNlbnQ7XG4gICAgICBpWSA9IHBhdGguaVtpXVsxXSArIChjZW50ZXJQb2ludFsxXSAtIHBhdGguaVtpXVsxXSkgKiAtcGVyY2VudDtcbiAgICAgIGNsb25lZFBhdGguc2V0VHJpcGxlQXQodlgsIHZZLCBvWCwgb1ksIGlYLCBpWSwgaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lZFBhdGg7XG4gIH07XG5cbiAgUHVja2VyQW5kQmxvYXRNb2RpZmllci5wcm90b3R5cGUucHJvY2Vzc1NoYXBlcyA9IGZ1bmN0aW9uIChfaXNGaXJzdEZyYW1lKSB7XG4gICAgdmFyIHNoYXBlUGF0aHM7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuc2hhcGVzLmxlbmd0aDtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgYW1vdW50ID0gdGhpcy5hbW91bnQudjtcblxuICAgIGlmIChhbW91bnQgIT09IDApIHtcbiAgICAgIHZhciBzaGFwZURhdGE7XG4gICAgICB2YXIgbG9jYWxTaGFwZUNvbGxlY3Rpb247XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBzaGFwZURhdGEgPSB0aGlzLnNoYXBlc1tpXTtcbiAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24gPSBzaGFwZURhdGEubG9jYWxTaGFwZUNvbGxlY3Rpb247XG5cbiAgICAgICAgaWYgKCEoIXNoYXBlRGF0YS5zaGFwZS5fbWRmICYmICF0aGlzLl9tZGYgJiYgIV9pc0ZpcnN0RnJhbWUpKSB7XG4gICAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24ucmVsZWFzZVNoYXBlcygpO1xuICAgICAgICAgIHNoYXBlRGF0YS5zaGFwZS5fbWRmID0gdHJ1ZTtcbiAgICAgICAgICBzaGFwZVBhdGhzID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzLnNoYXBlcztcbiAgICAgICAgICBqTGVuID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzLl9sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZSh0aGlzLnByb2Nlc3NQYXRoKHNoYXBlUGF0aHNbal0sIGFtb3VudCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNoYXBlRGF0YS5zaGFwZS5wYXRocyA9IHNoYXBlRGF0YS5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIFRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGVmYXVsdFZlY3RvciA9IFswLCAwXTtcblxuICAgIGZ1bmN0aW9uIGFwcGx5VG9NYXRyaXgobWF0KSB7XG4gICAgICB2YXIgX21kZiA9IHRoaXMuX21kZjtcbiAgICAgIHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzKCk7XG4gICAgICB0aGlzLl9tZGYgPSB0aGlzLl9tZGYgfHwgX21kZjtcblxuICAgICAgaWYgKHRoaXMuYSkge1xuICAgICAgICBtYXQudHJhbnNsYXRlKC10aGlzLmEudlswXSwgLXRoaXMuYS52WzFdLCB0aGlzLmEudlsyXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnMpIHtcbiAgICAgICAgbWF0LnNjYWxlKHRoaXMucy52WzBdLCB0aGlzLnMudlsxXSwgdGhpcy5zLnZbMl0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zaykge1xuICAgICAgICBtYXQuc2tld0Zyb21BeGlzKC10aGlzLnNrLnYsIHRoaXMuc2Eudik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnIpIHtcbiAgICAgICAgbWF0LnJvdGF0ZSgtdGhpcy5yLnYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0LnJvdGF0ZVooLXRoaXMucnoudikucm90YXRlWSh0aGlzLnJ5LnYpLnJvdGF0ZVgodGhpcy5yeC52KS5yb3RhdGVaKC10aGlzLm9yLnZbMl0pLnJvdGF0ZVkodGhpcy5vci52WzFdKS5yb3RhdGVYKHRoaXMub3IudlswXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRhdGEucC5zKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEucC56KSB7XG4gICAgICAgICAgbWF0LnRyYW5zbGF0ZSh0aGlzLnB4LnYsIHRoaXMucHkudiwgLXRoaXMucHoudik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0LnRyYW5zbGF0ZSh0aGlzLnB4LnYsIHRoaXMucHkudiwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdC50cmFuc2xhdGUodGhpcy5wLnZbMF0sIHRoaXMucC52WzFdLCAtdGhpcy5wLnZbMl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NLZXlzKGZvcmNlUmVuZGVyKSB7XG4gICAgICBpZiAodGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5mcmFtZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2lzRGlydHkpIHtcbiAgICAgICAgdGhpcy5wcmVjYWxjdWxhdGVNYXRyaXgoKTtcbiAgICAgICAgdGhpcy5faXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcygpO1xuXG4gICAgICBpZiAodGhpcy5fbWRmIHx8IGZvcmNlUmVuZGVyKSB7XG4gICAgICAgIHZhciBmcmFtZVJhdGU7XG4gICAgICAgIHRoaXMudi5jbG9uZUZyb21Qcm9wcyh0aGlzLnByZS5wcm9wcyk7XG5cbiAgICAgICAgaWYgKHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDEpIHtcbiAgICAgICAgICB0aGlzLnYudHJhbnNsYXRlKC10aGlzLmEudlswXSwgLXRoaXMuYS52WzFdLCB0aGlzLmEudlsyXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zIDwgMikge1xuICAgICAgICAgIHRoaXMudi5zY2FsZSh0aGlzLnMudlswXSwgdGhpcy5zLnZbMV0sIHRoaXMucy52WzJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNrICYmIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDMpIHtcbiAgICAgICAgICB0aGlzLnYuc2tld0Zyb21BeGlzKC10aGlzLnNrLnYsIHRoaXMuc2Eudik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5yICYmIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDQpIHtcbiAgICAgICAgICB0aGlzLnYucm90YXRlKC10aGlzLnIudik7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuciAmJiB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPCA0KSB7XG4gICAgICAgICAgdGhpcy52LnJvdGF0ZVooLXRoaXMucnoudikucm90YXRlWSh0aGlzLnJ5LnYpLnJvdGF0ZVgodGhpcy5yeC52KS5yb3RhdGVaKC10aGlzLm9yLnZbMl0pLnJvdGF0ZVkodGhpcy5vci52WzFdKS5yb3RhdGVYKHRoaXMub3IudlswXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hdXRvT3JpZW50ZWQpIHtcbiAgICAgICAgICB2YXIgdjE7XG4gICAgICAgICAgdmFyIHYyO1xuICAgICAgICAgIGZyYW1lUmF0ZSA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcblxuICAgICAgICAgIGlmICh0aGlzLnAgJiYgdGhpcy5wLmtleWZyYW1lcyAmJiB0aGlzLnAuZ2V0VmFsdWVBdFRpbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnAuX2NhY2hpbmcubGFzdEZyYW1lICsgdGhpcy5wLm9mZnNldFRpbWUgPD0gdGhpcy5wLmtleWZyYW1lc1swXS50KSB7XG4gICAgICAgICAgICAgIHYxID0gdGhpcy5wLmdldFZhbHVlQXRUaW1lKCh0aGlzLnAua2V5ZnJhbWVzWzBdLnQgKyAwLjAxKSAvIGZyYW1lUmF0ZSwgMCk7XG4gICAgICAgICAgICAgIHYyID0gdGhpcy5wLmdldFZhbHVlQXRUaW1lKHRoaXMucC5rZXlmcmFtZXNbMF0udCAvIGZyYW1lUmF0ZSwgMCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucC5fY2FjaGluZy5sYXN0RnJhbWUgKyB0aGlzLnAub2Zmc2V0VGltZSA+PSB0aGlzLnAua2V5ZnJhbWVzW3RoaXMucC5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCkge1xuICAgICAgICAgICAgICB2MSA9IHRoaXMucC5nZXRWYWx1ZUF0VGltZSh0aGlzLnAua2V5ZnJhbWVzW3RoaXMucC5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCAvIGZyYW1lUmF0ZSwgMCk7XG4gICAgICAgICAgICAgIHYyID0gdGhpcy5wLmdldFZhbHVlQXRUaW1lKCh0aGlzLnAua2V5ZnJhbWVzW3RoaXMucC5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCAtIDAuMDUpIC8gZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHYxID0gdGhpcy5wLnB2O1xuICAgICAgICAgICAgICB2MiA9IHRoaXMucC5nZXRWYWx1ZUF0VGltZSgodGhpcy5wLl9jYWNoaW5nLmxhc3RGcmFtZSArIHRoaXMucC5vZmZzZXRUaW1lIC0gMC4wMSkgLyBmcmFtZVJhdGUsIHRoaXMucC5vZmZzZXRUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHggJiYgdGhpcy5weC5rZXlmcmFtZXMgJiYgdGhpcy5weS5rZXlmcmFtZXMgJiYgdGhpcy5weC5nZXRWYWx1ZUF0VGltZSAmJiB0aGlzLnB5LmdldFZhbHVlQXRUaW1lKSB7XG4gICAgICAgICAgICB2MSA9IFtdO1xuICAgICAgICAgICAgdjIgPSBbXTtcbiAgICAgICAgICAgIHZhciBweCA9IHRoaXMucHg7XG4gICAgICAgICAgICB2YXIgcHkgPSB0aGlzLnB5O1xuXG4gICAgICAgICAgICBpZiAocHguX2NhY2hpbmcubGFzdEZyYW1lICsgcHgub2Zmc2V0VGltZSA8PSBweC5rZXlmcmFtZXNbMF0udCkge1xuICAgICAgICAgICAgICB2MVswXSA9IHB4LmdldFZhbHVlQXRUaW1lKChweC5rZXlmcmFtZXNbMF0udCArIDAuMDEpIC8gZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgICAgICAgdjFbMV0gPSBweS5nZXRWYWx1ZUF0VGltZSgocHkua2V5ZnJhbWVzWzBdLnQgKyAwLjAxKSAvIGZyYW1lUmF0ZSwgMCk7XG4gICAgICAgICAgICAgIHYyWzBdID0gcHguZ2V0VmFsdWVBdFRpbWUocHgua2V5ZnJhbWVzWzBdLnQgLyBmcmFtZVJhdGUsIDApO1xuICAgICAgICAgICAgICB2MlsxXSA9IHB5LmdldFZhbHVlQXRUaW1lKHB5LmtleWZyYW1lc1swXS50IC8gZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHguX2NhY2hpbmcubGFzdEZyYW1lICsgcHgub2Zmc2V0VGltZSA+PSBweC5rZXlmcmFtZXNbcHgua2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnQpIHtcbiAgICAgICAgICAgICAgdjFbMF0gPSBweC5nZXRWYWx1ZUF0VGltZShweC5rZXlmcmFtZXNbcHgua2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnQgLyBmcmFtZVJhdGUsIDApO1xuICAgICAgICAgICAgICB2MVsxXSA9IHB5LmdldFZhbHVlQXRUaW1lKHB5LmtleWZyYW1lc1tweS5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCAvIGZyYW1lUmF0ZSwgMCk7XG4gICAgICAgICAgICAgIHYyWzBdID0gcHguZ2V0VmFsdWVBdFRpbWUoKHB4LmtleWZyYW1lc1tweC5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCAtIDAuMDEpIC8gZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgICAgICAgdjJbMV0gPSBweS5nZXRWYWx1ZUF0VGltZSgocHkua2V5ZnJhbWVzW3B5LmtleWZyYW1lcy5sZW5ndGggLSAxXS50IC0gMC4wMSkgLyBmcmFtZVJhdGUsIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdjEgPSBbcHgucHYsIHB5LnB2XTtcbiAgICAgICAgICAgICAgdjJbMF0gPSBweC5nZXRWYWx1ZUF0VGltZSgocHguX2NhY2hpbmcubGFzdEZyYW1lICsgcHgub2Zmc2V0VGltZSAtIDAuMDEpIC8gZnJhbWVSYXRlLCBweC5vZmZzZXRUaW1lKTtcbiAgICAgICAgICAgICAgdjJbMV0gPSBweS5nZXRWYWx1ZUF0VGltZSgocHkuX2NhY2hpbmcubGFzdEZyYW1lICsgcHkub2Zmc2V0VGltZSAtIDAuMDEpIC8gZnJhbWVSYXRlLCBweS5vZmZzZXRUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdjIgPSBkZWZhdWx0VmVjdG9yO1xuICAgICAgICAgICAgdjEgPSB2MjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnYucm90YXRlKC1NYXRoLmF0YW4yKHYxWzFdIC0gdjJbMV0sIHYxWzBdIC0gdjJbMF0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmRhdGEucCAmJiB0aGlzLmRhdGEucC5zKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZGF0YS5wLnopIHtcbiAgICAgICAgICAgIHRoaXMudi50cmFuc2xhdGUodGhpcy5weC52LCB0aGlzLnB5LnYsIC10aGlzLnB6LnYpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnYudHJhbnNsYXRlKHRoaXMucHgudiwgdGhpcy5weS52LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy52LnRyYW5zbGF0ZSh0aGlzLnAudlswXSwgdGhpcy5wLnZbMV0sIC10aGlzLnAudlsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5mcmFtZUlkID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVjYWxjdWxhdGVNYXRyaXgoKSB7XG4gICAgICB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPSAwO1xuICAgICAgdGhpcy5wcmUucmVzZXQoKTtcblxuICAgICAgaWYgKCF0aGlzLmEuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnByZS50cmFuc2xhdGUoLXRoaXMuYS52WzBdLCAtdGhpcy5hLnZbMV0sIHRoaXMuYS52WzJdKTtcbiAgICAgICAgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnByZS5zY2FsZSh0aGlzLnMudlswXSwgdGhpcy5zLnZbMV0sIHRoaXMucy52WzJdKTtcbiAgICAgICAgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2spIHtcbiAgICAgICAgaWYgKCF0aGlzLnNrLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGggJiYgIXRoaXMuc2EuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMucHJlLnNrZXdGcm9tQXhpcygtdGhpcy5zay52LCB0aGlzLnNhLnYpO1xuICAgICAgICAgIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA9IDM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnIpIHtcbiAgICAgICAgaWYgKCF0aGlzLnIuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMucHJlLnJvdGF0ZSgtdGhpcy5yLnYpO1xuICAgICAgICAgIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA9IDQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMucnouZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCAmJiAhdGhpcy5yeS5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoICYmICF0aGlzLnJ4LmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGggJiYgIXRoaXMub3IuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnByZS5yb3RhdGVaKC10aGlzLnJ6LnYpLnJvdGF0ZVkodGhpcy5yeS52KS5yb3RhdGVYKHRoaXMucngudikucm90YXRlWigtdGhpcy5vci52WzJdKS5yb3RhdGVZKHRoaXMub3IudlsxXSkucm90YXRlWCh0aGlzLm9yLnZbMF0pO1xuICAgICAgICB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPSA0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGF1dG9PcmllbnQoKSB7Ly9cbiAgICAgIC8vIHZhciBwcmV2UCA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGREeW5hbWljUHJvcGVydHkocHJvcCkge1xuICAgICAgdGhpcy5fYWRkRHluYW1pY1Byb3BlcnR5KHByb3ApO1xuXG4gICAgICB0aGlzLmVsZW0uYWRkRHluYW1pY1Byb3BlcnR5KHByb3ApO1xuICAgICAgdGhpcy5faXNEaXJ0eSA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtUHJvcGVydHkoZWxlbSwgZGF0YSwgY29udGFpbmVyKSB7XG4gICAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgICAgdGhpcy5mcmFtZUlkID0gLTE7XG4gICAgICB0aGlzLnByb3BUeXBlID0gJ3RyYW5zZm9ybSc7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgdGhpcy52ID0gbmV3IE1hdHJpeCgpOyAvLyBQcmVjYWxjdWxhdGVkIG1hdHJpeCB3aXRoIG5vbiBhbmltYXRlZCBwcm9wZXJ0aWVzXG5cbiAgICAgIHRoaXMucHJlID0gbmV3IE1hdHJpeCgpO1xuICAgICAgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zID0gMDtcbiAgICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihjb250YWluZXIgfHwgZWxlbSk7XG5cbiAgICAgIGlmIChkYXRhLnAgJiYgZGF0YS5wLnMpIHtcbiAgICAgICAgdGhpcy5weCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucC54LCAwLCAwLCB0aGlzKTtcbiAgICAgICAgdGhpcy5weSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucC55LCAwLCAwLCB0aGlzKTtcblxuICAgICAgICBpZiAoZGF0YS5wLnopIHtcbiAgICAgICAgICB0aGlzLnB6ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5wLnosIDAsIDAsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnAgfHwge1xuICAgICAgICAgIGs6IFswLCAwLCAwXVxuICAgICAgICB9LCAxLCAwLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEucngpIHtcbiAgICAgICAgdGhpcy5yeCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucngsIDAsIGRlZ1RvUmFkcywgdGhpcyk7XG4gICAgICAgIHRoaXMucnkgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnJ5LCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xuICAgICAgICB0aGlzLnJ6ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5yeiwgMCwgZGVnVG9SYWRzLCB0aGlzKTtcblxuICAgICAgICBpZiAoZGF0YS5vci5rWzBdLnRpKSB7XG4gICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgdmFyIGxlbiA9IGRhdGEub3Iuay5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGRhdGEub3Iua1tpXS50byA9IG51bGw7XG4gICAgICAgICAgICBkYXRhLm9yLmtbaV0udGkgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3IgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm9yLCAxLCBkZWdUb1JhZHMsIHRoaXMpOyAvLyBzaCBJbmRpY2F0ZXMgaXQgbmVlZHMgdG8gYmUgY2FwcGVkIGJldHdlZW4gLTE4MCBhbmQgMTgwXG5cbiAgICAgICAgdGhpcy5vci5zaCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnIgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnIgfHwge1xuICAgICAgICAgIGs6IDBcbiAgICAgICAgfSwgMCwgZGVnVG9SYWRzLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuc2spIHtcbiAgICAgICAgdGhpcy5zayA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuc2ssIDAsIGRlZ1RvUmFkcywgdGhpcyk7XG4gICAgICAgIHRoaXMuc2EgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnNhLCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmEgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmEgfHwge1xuICAgICAgICBrOiBbMCwgMCwgMF1cbiAgICAgIH0sIDEsIDAsIHRoaXMpO1xuICAgICAgdGhpcy5zID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5zIHx8IHtcbiAgICAgICAgazogWzEwMCwgMTAwLCAxMDBdXG4gICAgICB9LCAxLCAwLjAxLCB0aGlzKTsgLy8gT3BhY2l0eSBpcyBub3QgcGFydCBvZiB0aGUgdHJhbnNmb3JtIHByb3BlcnRpZXMsIHRoYXQncyB3aHkgaXQgd29uJ3QgdXNlIHRoaXMuZHluYW1pY1Byb3BlcnRpZXMuIFRoYXQgd2F5IHRyYW5zZm9ybXMgd29uJ3QgZ2V0IHVwZGF0ZWQgaWYgb3BhY2l0eSBjaGFuZ2VzLlxuXG4gICAgICBpZiAoZGF0YS5vKSB7XG4gICAgICAgIHRoaXMubyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEubywgMCwgMC4wMSwgZWxlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm8gPSB7XG4gICAgICAgICAgX21kZjogZmFsc2UsXG4gICAgICAgICAgdjogMVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pc0RpcnR5ID0gdHJ1ZTtcblxuICAgICAgaWYgKCF0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmdldFZhbHVlKHRydWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIFRyYW5zZm9ybVByb3BlcnR5LnByb3RvdHlwZSA9IHtcbiAgICAgIGFwcGx5VG9NYXRyaXg6IGFwcGx5VG9NYXRyaXgsXG4gICAgICBnZXRWYWx1ZTogcHJvY2Vzc0tleXMsXG4gICAgICBwcmVjYWxjdWxhdGVNYXRyaXg6IHByZWNhbGN1bGF0ZU1hdHJpeCxcbiAgICAgIGF1dG9PcmllbnQ6IGF1dG9PcmllbnRcbiAgICB9O1xuICAgIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgVHJhbnNmb3JtUHJvcGVydHkpO1xuICAgIFRyYW5zZm9ybVByb3BlcnR5LnByb3RvdHlwZS5hZGREeW5hbWljUHJvcGVydHkgPSBhZGREeW5hbWljUHJvcGVydHk7XG4gICAgVHJhbnNmb3JtUHJvcGVydHkucHJvdG90eXBlLl9hZGREeW5hbWljUHJvcGVydHkgPSBEeW5hbWljUHJvcGVydHlDb250YWluZXIucHJvdG90eXBlLmFkZER5bmFtaWNQcm9wZXJ0eTtcblxuICAgIGZ1bmN0aW9uIGdldFRyYW5zZm9ybVByb3BlcnR5KGVsZW0sIGRhdGEsIGNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1Qcm9wZXJ0eShlbGVtLCBkYXRhLCBjb250YWluZXIpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBnZXRUcmFuc2Zvcm1Qcm9wZXJ0eTogZ2V0VHJhbnNmb3JtUHJvcGVydHlcbiAgICB9O1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gUmVwZWF0ZXJNb2RpZmllcigpIHt9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtTaGFwZU1vZGlmaWVyXSwgUmVwZWF0ZXJNb2RpZmllcik7XG5cbiAgUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUuaW5pdE1vZGlmaWVyUHJvcGVydGllcyA9IGZ1bmN0aW9uIChlbGVtLCBkYXRhKSB7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMucHJvY2Vzc0tleXM7XG4gICAgdGhpcy5jID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5jLCAwLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLm8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm8sIDAsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMudHIgPSBUcmFuc2Zvcm1Qcm9wZXJ0eUZhY3RvcnkuZ2V0VHJhbnNmb3JtUHJvcGVydHkoZWxlbSwgZGF0YS50ciwgdGhpcyk7XG4gICAgdGhpcy5zbyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEudHIuc28sIDAsIDAuMDEsIHRoaXMpO1xuICAgIHRoaXMuZW8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnRyLmVvLCAwLCAwLjAxLCB0aGlzKTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuXG4gICAgaWYgKCF0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5nZXRWYWx1ZSh0cnVlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gISF0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICB0aGlzLnBNYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy5yTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgIHRoaXMuc01hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLnRNYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy5tYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gIH07XG5cbiAgUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUuYXBwbHlUcmFuc2Zvcm1zID0gZnVuY3Rpb24gKHBNYXRyaXgsIHJNYXRyaXgsIHNNYXRyaXgsIHRyYW5zZm9ybSwgcGVyYywgaW52KSB7XG4gICAgdmFyIGRpciA9IGludiA/IC0xIDogMTtcbiAgICB2YXIgc2NhbGVYID0gdHJhbnNmb3JtLnMudlswXSArICgxIC0gdHJhbnNmb3JtLnMudlswXSkgKiAoMSAtIHBlcmMpO1xuICAgIHZhciBzY2FsZVkgPSB0cmFuc2Zvcm0ucy52WzFdICsgKDEgLSB0cmFuc2Zvcm0ucy52WzFdKSAqICgxIC0gcGVyYyk7XG4gICAgcE1hdHJpeC50cmFuc2xhdGUodHJhbnNmb3JtLnAudlswXSAqIGRpciAqIHBlcmMsIHRyYW5zZm9ybS5wLnZbMV0gKiBkaXIgKiBwZXJjLCB0cmFuc2Zvcm0ucC52WzJdKTtcbiAgICByTWF0cml4LnRyYW5zbGF0ZSgtdHJhbnNmb3JtLmEudlswXSwgLXRyYW5zZm9ybS5hLnZbMV0sIHRyYW5zZm9ybS5hLnZbMl0pO1xuICAgIHJNYXRyaXgucm90YXRlKC10cmFuc2Zvcm0uci52ICogZGlyICogcGVyYyk7XG4gICAgck1hdHJpeC50cmFuc2xhdGUodHJhbnNmb3JtLmEudlswXSwgdHJhbnNmb3JtLmEudlsxXSwgdHJhbnNmb3JtLmEudlsyXSk7XG4gICAgc01hdHJpeC50cmFuc2xhdGUoLXRyYW5zZm9ybS5hLnZbMF0sIC10cmFuc2Zvcm0uYS52WzFdLCB0cmFuc2Zvcm0uYS52WzJdKTtcbiAgICBzTWF0cml4LnNjYWxlKGludiA/IDEgLyBzY2FsZVggOiBzY2FsZVgsIGludiA/IDEgLyBzY2FsZVkgOiBzY2FsZVkpO1xuICAgIHNNYXRyaXgudHJhbnNsYXRlKHRyYW5zZm9ybS5hLnZbMF0sIHRyYW5zZm9ybS5hLnZbMV0sIHRyYW5zZm9ybS5hLnZbMl0pO1xuICB9O1xuXG4gIFJlcGVhdGVyTW9kaWZpZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZWxlbSwgYXJyLCBwb3MsIGVsZW1zRGF0YSkge1xuICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgdGhpcy5hcnIgPSBhcnI7XG4gICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgdGhpcy5lbGVtc0RhdGEgPSBlbGVtc0RhdGE7XG4gICAgdGhpcy5fY3VycmVudENvcGllcyA9IDA7XG4gICAgdGhpcy5fZWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLl9ncm91cHMgPSBbXTtcbiAgICB0aGlzLmZyYW1lSWQgPSAtMTtcbiAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XG4gICAgdGhpcy5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzKGVsZW0sIGFycltwb3NdKTtcblxuICAgIHdoaWxlIChwb3MgPiAwKSB7XG4gICAgICBwb3MgLT0gMTsgLy8gdGhpcy5fZWxlbWVudHMudW5zaGlmdChhcnIuc3BsaWNlKHBvcywxKVswXSk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnRzLnVuc2hpZnQoYXJyW3Bvc10pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5rID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5nZXRWYWx1ZSh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUucmVzZXRFbGVtZW50cyA9IGZ1bmN0aW9uIChlbGVtZW50cykge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBlbGVtZW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGVsZW1lbnRzW2ldLl9wcm9jZXNzZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKGVsZW1lbnRzW2ldLnR5ID09PSAnZ3InKSB7XG4gICAgICAgIHRoaXMucmVzZXRFbGVtZW50cyhlbGVtZW50c1tpXS5pdCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFJlcGVhdGVyTW9kaWZpZXIucHJvdG90eXBlLmNsb25lRWxlbWVudHMgPSBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICB2YXIgbmV3RWxlbWVudHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVsZW1lbnRzKSk7XG4gICAgdGhpcy5yZXNldEVsZW1lbnRzKG5ld0VsZW1lbnRzKTtcbiAgICByZXR1cm4gbmV3RWxlbWVudHM7XG4gIH07XG5cbiAgUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUuY2hhbmdlR3JvdXBSZW5kZXIgPSBmdW5jdGlvbiAoZWxlbWVudHMsIHJlbmRlckZsYWcpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gZWxlbWVudHMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBlbGVtZW50c1tpXS5fcmVuZGVyID0gcmVuZGVyRmxhZztcblxuICAgICAgaWYgKGVsZW1lbnRzW2ldLnR5ID09PSAnZ3InKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlR3JvdXBSZW5kZXIoZWxlbWVudHNbaV0uaXQsIHJlbmRlckZsYWcpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBSZXBlYXRlck1vZGlmaWVyLnByb3RvdHlwZS5wcm9jZXNzU2hhcGVzID0gZnVuY3Rpb24gKF9pc0ZpcnN0RnJhbWUpIHtcbiAgICB2YXIgaXRlbXM7XG4gICAgdmFyIGl0ZW1zVHJhbnNmb3JtO1xuICAgIHZhciBpO1xuICAgIHZhciBkaXI7XG4gICAgdmFyIGNvbnQ7XG4gICAgdmFyIGhhc1JlbG9hZGVkID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5fbWRmIHx8IF9pc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHZhciBjb3BpZXMgPSBNYXRoLmNlaWwodGhpcy5jLnYpO1xuXG4gICAgICBpZiAodGhpcy5fZ3JvdXBzLmxlbmd0aCA8IGNvcGllcykge1xuICAgICAgICB3aGlsZSAodGhpcy5fZ3JvdXBzLmxlbmd0aCA8IGNvcGllcykge1xuICAgICAgICAgIHZhciBncm91cCA9IHtcbiAgICAgICAgICAgIGl0OiB0aGlzLmNsb25lRWxlbWVudHModGhpcy5fZWxlbWVudHMpLFxuICAgICAgICAgICAgdHk6ICdncidcbiAgICAgICAgICB9O1xuICAgICAgICAgIGdyb3VwLml0LnB1c2goe1xuICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICBhOiAwLFxuICAgICAgICAgICAgICBpeDogMSxcbiAgICAgICAgICAgICAgazogWzAsIDBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm06ICdUcmFuc2Zvcm0nLFxuICAgICAgICAgICAgbzoge1xuICAgICAgICAgICAgICBhOiAwLFxuICAgICAgICAgICAgICBpeDogNyxcbiAgICAgICAgICAgICAgazogMTAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcDoge1xuICAgICAgICAgICAgICBhOiAwLFxuICAgICAgICAgICAgICBpeDogMixcbiAgICAgICAgICAgICAgazogWzAsIDBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcjoge1xuICAgICAgICAgICAgICBhOiAxLFxuICAgICAgICAgICAgICBpeDogNixcbiAgICAgICAgICAgICAgazogW3tcbiAgICAgICAgICAgICAgICBzOiAwLFxuICAgICAgICAgICAgICAgIGU6IDAsXG4gICAgICAgICAgICAgICAgdDogMFxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgczogMCxcbiAgICAgICAgICAgICAgICBlOiAwLFxuICAgICAgICAgICAgICAgIHQ6IDFcbiAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzOiB7XG4gICAgICAgICAgICAgIGE6IDAsXG4gICAgICAgICAgICAgIGl4OiAzLFxuICAgICAgICAgICAgICBrOiBbMTAwLCAxMDBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2E6IHtcbiAgICAgICAgICAgICAgYTogMCxcbiAgICAgICAgICAgICAgaXg6IDUsXG4gICAgICAgICAgICAgIGs6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzazoge1xuICAgICAgICAgICAgICBhOiAwLFxuICAgICAgICAgICAgICBpeDogNCxcbiAgICAgICAgICAgICAgazogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHR5OiAndHInXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5hcnIuc3BsaWNlKDAsIDAsIGdyb3VwKTtcblxuICAgICAgICAgIHRoaXMuX2dyb3Vwcy5zcGxpY2UoMCwgMCwgZ3JvdXApO1xuXG4gICAgICAgICAgdGhpcy5fY3VycmVudENvcGllcyArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbGVtLnJlbG9hZFNoYXBlcygpO1xuICAgICAgICBoYXNSZWxvYWRlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnQgPSAwO1xuICAgICAgdmFyIHJlbmRlckZsYWc7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPD0gdGhpcy5fZ3JvdXBzLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgICAgICByZW5kZXJGbGFnID0gY29udCA8IGNvcGllcztcbiAgICAgICAgdGhpcy5fZ3JvdXBzW2ldLl9yZW5kZXIgPSByZW5kZXJGbGFnO1xuICAgICAgICB0aGlzLmNoYW5nZUdyb3VwUmVuZGVyKHRoaXMuX2dyb3Vwc1tpXS5pdCwgcmVuZGVyRmxhZyk7XG5cbiAgICAgICAgaWYgKCFyZW5kZXJGbGFnKSB7XG4gICAgICAgICAgdmFyIGVsZW1zID0gdGhpcy5lbGVtc0RhdGFbaV0uaXQ7XG4gICAgICAgICAgdmFyIHRyYW5zZm9ybURhdGEgPSBlbGVtc1tlbGVtcy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgIGlmICh0cmFuc2Zvcm1EYXRhLnRyYW5zZm9ybS5vcC52ICE9PSAwKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnRyYW5zZm9ybS5vcC5fbWRmID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyYW5zZm9ybURhdGEudHJhbnNmb3JtLm9wLnYgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnRyYW5zZm9ybS5vcC5fbWRmID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udCArPSAxO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jdXJyZW50Q29waWVzID0gY29waWVzOyAvLy8gL1xuXG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vLnY7XG4gICAgICB2YXIgb2Zmc2V0TW9kdWxvID0gb2Zmc2V0ICUgMTtcbiAgICAgIHZhciByb3VuZE9mZnNldCA9IG9mZnNldCA+IDAgPyBNYXRoLmZsb29yKG9mZnNldCkgOiBNYXRoLmNlaWwob2Zmc2V0KTtcbiAgICAgIHZhciBwUHJvcHMgPSB0aGlzLnBNYXRyaXgucHJvcHM7XG4gICAgICB2YXIgclByb3BzID0gdGhpcy5yTWF0cml4LnByb3BzO1xuICAgICAgdmFyIHNQcm9wcyA9IHRoaXMuc01hdHJpeC5wcm9wcztcbiAgICAgIHRoaXMucE1hdHJpeC5yZXNldCgpO1xuICAgICAgdGhpcy5yTWF0cml4LnJlc2V0KCk7XG4gICAgICB0aGlzLnNNYXRyaXgucmVzZXQoKTtcbiAgICAgIHRoaXMudE1hdHJpeC5yZXNldCgpO1xuICAgICAgdGhpcy5tYXRyaXgucmVzZXQoKTtcbiAgICAgIHZhciBpdGVyYXRpb24gPSAwO1xuXG4gICAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgICB3aGlsZSAoaXRlcmF0aW9uIDwgcm91bmRPZmZzZXQpIHtcbiAgICAgICAgICB0aGlzLmFwcGx5VHJhbnNmb3Jtcyh0aGlzLnBNYXRyaXgsIHRoaXMuck1hdHJpeCwgdGhpcy5zTWF0cml4LCB0aGlzLnRyLCAxLCBmYWxzZSk7XG4gICAgICAgICAgaXRlcmF0aW9uICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2Zmc2V0TW9kdWxvKSB7XG4gICAgICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybXModGhpcy5wTWF0cml4LCB0aGlzLnJNYXRyaXgsIHRoaXMuc01hdHJpeCwgdGhpcy50ciwgb2Zmc2V0TW9kdWxvLCBmYWxzZSk7XG4gICAgICAgICAgaXRlcmF0aW9uICs9IG9mZnNldE1vZHVsbztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgIHdoaWxlIChpdGVyYXRpb24gPiByb3VuZE9mZnNldCkge1xuICAgICAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1zKHRoaXMucE1hdHJpeCwgdGhpcy5yTWF0cml4LCB0aGlzLnNNYXRyaXgsIHRoaXMudHIsIDEsIHRydWUpO1xuICAgICAgICAgIGl0ZXJhdGlvbiAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9mZnNldE1vZHVsbykge1xuICAgICAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1zKHRoaXMucE1hdHJpeCwgdGhpcy5yTWF0cml4LCB0aGlzLnNNYXRyaXgsIHRoaXMudHIsIC1vZmZzZXRNb2R1bG8sIHRydWUpO1xuICAgICAgICAgIGl0ZXJhdGlvbiAtPSBvZmZzZXRNb2R1bG87XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaSA9IHRoaXMuZGF0YS5tID09PSAxID8gMCA6IHRoaXMuX2N1cnJlbnRDb3BpZXMgLSAxO1xuICAgICAgZGlyID0gdGhpcy5kYXRhLm0gPT09IDEgPyAxIDogLTE7XG4gICAgICBjb250ID0gdGhpcy5fY3VycmVudENvcGllcztcbiAgICAgIHZhciBqO1xuICAgICAgdmFyIGpMZW47XG5cbiAgICAgIHdoaWxlIChjb250KSB7XG4gICAgICAgIGl0ZW1zID0gdGhpcy5lbGVtc0RhdGFbaV0uaXQ7XG4gICAgICAgIGl0ZW1zVHJhbnNmb3JtID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0udHJhbnNmb3JtLm1Qcm9wcy52LnByb3BzO1xuICAgICAgICBqTGVuID0gaXRlbXNUcmFuc2Zvcm0ubGVuZ3RoO1xuICAgICAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS50cmFuc2Zvcm0ubVByb3BzLl9tZGYgPSB0cnVlO1xuICAgICAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS50cmFuc2Zvcm0ub3AuX21kZiA9IHRydWU7XG4gICAgICAgIGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLnRyYW5zZm9ybS5vcC52ID0gdGhpcy5fY3VycmVudENvcGllcyA9PT0gMSA/IHRoaXMuc28udiA6IHRoaXMuc28udiArICh0aGlzLmVvLnYgLSB0aGlzLnNvLnYpICogKGkgLyAodGhpcy5fY3VycmVudENvcGllcyAtIDEpKTtcblxuICAgICAgICBpZiAoaXRlcmF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgaWYgKGkgIT09IDAgJiYgZGlyID09PSAxIHx8IGkgIT09IHRoaXMuX2N1cnJlbnRDb3BpZXMgLSAxICYmIGRpciA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1zKHRoaXMucE1hdHJpeCwgdGhpcy5yTWF0cml4LCB0aGlzLnNNYXRyaXgsIHRoaXMudHIsIDEsIGZhbHNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm1hdHJpeC50cmFuc2Zvcm0oclByb3BzWzBdLCByUHJvcHNbMV0sIHJQcm9wc1syXSwgclByb3BzWzNdLCByUHJvcHNbNF0sIHJQcm9wc1s1XSwgclByb3BzWzZdLCByUHJvcHNbN10sIHJQcm9wc1s4XSwgclByb3BzWzldLCByUHJvcHNbMTBdLCByUHJvcHNbMTFdLCByUHJvcHNbMTJdLCByUHJvcHNbMTNdLCByUHJvcHNbMTRdLCByUHJvcHNbMTVdKTtcbiAgICAgICAgICB0aGlzLm1hdHJpeC50cmFuc2Zvcm0oc1Byb3BzWzBdLCBzUHJvcHNbMV0sIHNQcm9wc1syXSwgc1Byb3BzWzNdLCBzUHJvcHNbNF0sIHNQcm9wc1s1XSwgc1Byb3BzWzZdLCBzUHJvcHNbN10sIHNQcm9wc1s4XSwgc1Byb3BzWzldLCBzUHJvcHNbMTBdLCBzUHJvcHNbMTFdLCBzUHJvcHNbMTJdLCBzUHJvcHNbMTNdLCBzUHJvcHNbMTRdLCBzUHJvcHNbMTVdKTtcbiAgICAgICAgICB0aGlzLm1hdHJpeC50cmFuc2Zvcm0ocFByb3BzWzBdLCBwUHJvcHNbMV0sIHBQcm9wc1syXSwgcFByb3BzWzNdLCBwUHJvcHNbNF0sIHBQcm9wc1s1XSwgcFByb3BzWzZdLCBwUHJvcHNbN10sIHBQcm9wc1s4XSwgcFByb3BzWzldLCBwUHJvcHNbMTBdLCBwUHJvcHNbMTFdLCBwUHJvcHNbMTJdLCBwUHJvcHNbMTNdLCBwUHJvcHNbMTRdLCBwUHJvcHNbMTVdKTtcblxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGl0ZW1zVHJhbnNmb3JtW2pdID0gdGhpcy5tYXRyaXgucHJvcHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5tYXRyaXgucmVzZXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm1hdHJpeC5yZXNldCgpO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgaXRlbXNUcmFuc2Zvcm1bal0gPSB0aGlzLm1hdHJpeC5wcm9wc1tqXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpdGVyYXRpb24gKz0gMTtcbiAgICAgICAgY29udCAtPSAxO1xuICAgICAgICBpICs9IGRpcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udCA9IHRoaXMuX2N1cnJlbnRDb3BpZXM7XG4gICAgICBpID0gMDtcbiAgICAgIGRpciA9IDE7XG5cbiAgICAgIHdoaWxlIChjb250KSB7XG4gICAgICAgIGl0ZW1zID0gdGhpcy5lbGVtc0RhdGFbaV0uaXQ7XG4gICAgICAgIGl0ZW1zVHJhbnNmb3JtID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0udHJhbnNmb3JtLm1Qcm9wcy52LnByb3BzO1xuICAgICAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS50cmFuc2Zvcm0ubVByb3BzLl9tZGYgPSBmYWxzZTtcbiAgICAgICAgaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0udHJhbnNmb3JtLm9wLl9tZGYgPSBmYWxzZTtcbiAgICAgICAgY29udCAtPSAxO1xuICAgICAgICBpICs9IGRpcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGFzUmVsb2FkZWQ7XG4gIH07XG5cbiAgUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBmdW5jdGlvbiBSb3VuZENvcm5lcnNNb2RpZmllcigpIHt9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtTaGFwZU1vZGlmaWVyXSwgUm91bmRDb3JuZXJzTW9kaWZpZXIpO1xuXG4gIFJvdW5kQ29ybmVyc01vZGlmaWVyLnByb3RvdHlwZS5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEpIHtcbiAgICB0aGlzLmdldFZhbHVlID0gdGhpcy5wcm9jZXNzS2V5cztcbiAgICB0aGlzLnJkID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5yLCAwLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gISF0aGlzLnJkLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGg7XG4gIH07XG5cbiAgUm91bmRDb3JuZXJzTW9kaWZpZXIucHJvdG90eXBlLnByb2Nlc3NQYXRoID0gZnVuY3Rpb24gKHBhdGgsIHJvdW5kKSB7XG4gICAgdmFyIGNsb25lZFBhdGggPSBzaGFwZVBvb2wubmV3RWxlbWVudCgpO1xuICAgIGNsb25lZFBhdGguYyA9IHBhdGguYztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gcGF0aC5fbGVuZ3RoO1xuICAgIHZhciBjdXJyZW50VjtcbiAgICB2YXIgY3VycmVudEk7XG4gICAgdmFyIGN1cnJlbnRPO1xuICAgIHZhciBjbG9zZXJWO1xuICAgIHZhciBkaXN0YW5jZTtcbiAgICB2YXIgbmV3UG9zUGVyYztcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciB2WDtcbiAgICB2YXIgdlk7XG4gICAgdmFyIG9YO1xuICAgIHZhciBvWTtcbiAgICB2YXIgaVg7XG4gICAgdmFyIGlZO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBjdXJyZW50ViA9IHBhdGgudltpXTtcbiAgICAgIGN1cnJlbnRPID0gcGF0aC5vW2ldO1xuICAgICAgY3VycmVudEkgPSBwYXRoLmlbaV07XG5cbiAgICAgIGlmIChjdXJyZW50VlswXSA9PT0gY3VycmVudE9bMF0gJiYgY3VycmVudFZbMV0gPT09IGN1cnJlbnRPWzFdICYmIGN1cnJlbnRWWzBdID09PSBjdXJyZW50SVswXSAmJiBjdXJyZW50VlsxXSA9PT0gY3VycmVudElbMV0pIHtcbiAgICAgICAgaWYgKChpID09PSAwIHx8IGkgPT09IGxlbiAtIDEpICYmICFwYXRoLmMpIHtcbiAgICAgICAgICBjbG9uZWRQYXRoLnNldFRyaXBsZUF0KGN1cnJlbnRWWzBdLCBjdXJyZW50VlsxXSwgY3VycmVudE9bMF0sIGN1cnJlbnRPWzFdLCBjdXJyZW50SVswXSwgY3VycmVudElbMV0sIGluZGV4KTtcbiAgICAgICAgICAvKiBjbG9uZWRQYXRoLnZbaW5kZXhdID0gY3VycmVudFY7XHJcbiAgICAgICAgICAgICAgICAgIGNsb25lZFBhdGgub1tpbmRleF0gPSBjdXJyZW50TztcclxuICAgICAgICAgICAgICAgICAgY2xvbmVkUGF0aC5pW2luZGV4XSA9IGN1cnJlbnRJOyAqL1xuXG4gICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgY2xvc2VyViA9IHBhdGgudltsZW4gLSAxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xvc2VyViA9IHBhdGgudltpIC0gMV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3coY3VycmVudFZbMF0gLSBjbG9zZXJWWzBdLCAyKSArIE1hdGgucG93KGN1cnJlbnRWWzFdIC0gY2xvc2VyVlsxXSwgMikpO1xuICAgICAgICAgIG5ld1Bvc1BlcmMgPSBkaXN0YW5jZSA/IE1hdGgubWluKGRpc3RhbmNlIC8gMiwgcm91bmQpIC8gZGlzdGFuY2UgOiAwO1xuICAgICAgICAgIGlYID0gY3VycmVudFZbMF0gKyAoY2xvc2VyVlswXSAtIGN1cnJlbnRWWzBdKSAqIG5ld1Bvc1BlcmM7XG4gICAgICAgICAgdlggPSBpWDtcbiAgICAgICAgICBpWSA9IGN1cnJlbnRWWzFdIC0gKGN1cnJlbnRWWzFdIC0gY2xvc2VyVlsxXSkgKiBuZXdQb3NQZXJjO1xuICAgICAgICAgIHZZID0gaVk7XG4gICAgICAgICAgb1ggPSB2WCAtICh2WCAtIGN1cnJlbnRWWzBdKSAqIHJvdW5kQ29ybmVyO1xuICAgICAgICAgIG9ZID0gdlkgLSAodlkgLSBjdXJyZW50VlsxXSkgKiByb3VuZENvcm5lcjtcbiAgICAgICAgICBjbG9uZWRQYXRoLnNldFRyaXBsZUF0KHZYLCB2WSwgb1gsIG9ZLCBpWCwgaVksIGluZGV4KTtcbiAgICAgICAgICBpbmRleCArPSAxO1xuXG4gICAgICAgICAgaWYgKGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgIGNsb3NlclYgPSBwYXRoLnZbMF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsb3NlclYgPSBwYXRoLnZbaSArIDFdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KE1hdGgucG93KGN1cnJlbnRWWzBdIC0gY2xvc2VyVlswXSwgMikgKyBNYXRoLnBvdyhjdXJyZW50VlsxXSAtIGNsb3NlclZbMV0sIDIpKTtcbiAgICAgICAgICBuZXdQb3NQZXJjID0gZGlzdGFuY2UgPyBNYXRoLm1pbihkaXN0YW5jZSAvIDIsIHJvdW5kKSAvIGRpc3RhbmNlIDogMDtcbiAgICAgICAgICBvWCA9IGN1cnJlbnRWWzBdICsgKGNsb3NlclZbMF0gLSBjdXJyZW50VlswXSkgKiBuZXdQb3NQZXJjO1xuICAgICAgICAgIHZYID0gb1g7XG4gICAgICAgICAgb1kgPSBjdXJyZW50VlsxXSArIChjbG9zZXJWWzFdIC0gY3VycmVudFZbMV0pICogbmV3UG9zUGVyYztcbiAgICAgICAgICB2WSA9IG9ZO1xuICAgICAgICAgIGlYID0gdlggLSAodlggLSBjdXJyZW50VlswXSkgKiByb3VuZENvcm5lcjtcbiAgICAgICAgICBpWSA9IHZZIC0gKHZZIC0gY3VycmVudFZbMV0pICogcm91bmRDb3JuZXI7XG4gICAgICAgICAgY2xvbmVkUGF0aC5zZXRUcmlwbGVBdCh2WCwgdlksIG9YLCBvWSwgaVgsIGlZLCBpbmRleCk7XG4gICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvbmVkUGF0aC5zZXRUcmlwbGVBdChwYXRoLnZbaV1bMF0sIHBhdGgudltpXVsxXSwgcGF0aC5vW2ldWzBdLCBwYXRoLm9baV1bMV0sIHBhdGguaVtpXVswXSwgcGF0aC5pW2ldWzFdLCBpbmRleCk7XG4gICAgICAgIGluZGV4ICs9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lZFBhdGg7XG4gIH07XG5cbiAgUm91bmRDb3JuZXJzTW9kaWZpZXIucHJvdG90eXBlLnByb2Nlc3NTaGFwZXMgPSBmdW5jdGlvbiAoX2lzRmlyc3RGcmFtZSkge1xuICAgIHZhciBzaGFwZVBhdGhzO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLnNoYXBlcy5sZW5ndGg7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW47XG4gICAgdmFyIHJkID0gdGhpcy5yZC52O1xuXG4gICAgaWYgKHJkICE9PSAwKSB7XG4gICAgICB2YXIgc2hhcGVEYXRhO1xuICAgICAgdmFyIGxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgc2hhcGVEYXRhID0gdGhpcy5zaGFwZXNbaV07XG4gICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuXG4gICAgICAgIGlmICghKCFzaGFwZURhdGEuc2hhcGUuX21kZiAmJiAhdGhpcy5fbWRmICYmICFfaXNGaXJzdEZyYW1lKSkge1xuICAgICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uLnJlbGVhc2VTaGFwZXMoKTtcbiAgICAgICAgICBzaGFwZURhdGEuc2hhcGUuX21kZiA9IHRydWU7XG4gICAgICAgICAgc2hhcGVQYXRocyA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5zaGFwZXM7XG4gICAgICAgICAgakxlbiA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5fbGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24uYWRkU2hhcGUodGhpcy5wcm9jZXNzUGF0aChzaGFwZVBhdGhzW2pdLCByZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNoYXBlRGF0YS5zaGFwZS5wYXRocyA9IHNoYXBlRGF0YS5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZmxvYXRFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSAqIDEwMDAwMCA8PSBNYXRoLm1pbihNYXRoLmFicyhhKSwgTWF0aC5hYnMoYikpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmxvYXRaZXJvKGYpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoZikgPD0gMC4wMDAwMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlcnAocDAsIHAxLCBhbW91bnQpIHtcbiAgICByZXR1cm4gcDAgKiAoMSAtIGFtb3VudCkgKyBwMSAqIGFtb3VudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlcnBQb2ludChwMCwgcDEsIGFtb3VudCkge1xuICAgIHJldHVybiBbbGVycChwMFswXSwgcDFbMF0sIGFtb3VudCksIGxlcnAocDBbMV0sIHAxWzFdLCBhbW91bnQpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHF1YWRSb290cyhhLCBiLCBjKSB7XG4gICAgLy8gbm8gcm9vdFxuICAgIGlmIChhID09PSAwKSByZXR1cm4gW107XG4gICAgdmFyIHMgPSBiICogYiAtIDQgKiBhICogYzsgLy8gQ29tcGxleCByb290c1xuXG4gICAgaWYgKHMgPCAwKSByZXR1cm4gW107XG4gICAgdmFyIHNpbmdsZVJvb3QgPSAtYiAvICgyICogYSk7IC8vIDEgcm9vdFxuXG4gICAgaWYgKHMgPT09IDApIHJldHVybiBbc2luZ2xlUm9vdF07XG4gICAgdmFyIGRlbHRhID0gTWF0aC5zcXJ0KHMpIC8gKDIgKiBhKTsgLy8gMiByb290c1xuXG4gICAgcmV0dXJuIFtzaW5nbGVSb290IC0gZGVsdGEsIHNpbmdsZVJvb3QgKyBkZWx0YV07XG4gIH1cblxuICBmdW5jdGlvbiBwb2x5bm9taWFsQ29lZmZpY2llbnRzKHAwLCBwMSwgcDIsIHAzKSB7XG4gICAgcmV0dXJuIFstcDAgKyAzICogcDEgLSAzICogcDIgKyBwMywgMyAqIHAwIC0gNiAqIHAxICsgMyAqIHAyLCAtMyAqIHAwICsgMyAqIHAxLCBwMF07XG4gIH1cblxuICBmdW5jdGlvbiBzaW5nbGVQb2ludChwKSB7XG4gICAgcmV0dXJuIG5ldyBQb2x5bm9taWFsQmV6aWVyKHAsIHAsIHAsIHAsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFBvbHlub21pYWxCZXppZXIocDAsIHAxLCBwMiwgcDMsIGxpbmVhcml6ZSkge1xuICAgIGlmIChsaW5lYXJpemUgJiYgcG9pbnRFcXVhbChwMCwgcDEpKSB7XG4gICAgICBwMSA9IGxlcnBQb2ludChwMCwgcDMsIDEgLyAzKTtcbiAgICB9XG5cbiAgICBpZiAobGluZWFyaXplICYmIHBvaW50RXF1YWwocDIsIHAzKSkge1xuICAgICAgcDIgPSBsZXJwUG9pbnQocDAsIHAzLCAyIC8gMyk7XG4gICAgfVxuXG4gICAgdmFyIGNvZWZmeCA9IHBvbHlub21pYWxDb2VmZmljaWVudHMocDBbMF0sIHAxWzBdLCBwMlswXSwgcDNbMF0pO1xuICAgIHZhciBjb2VmZnkgPSBwb2x5bm9taWFsQ29lZmZpY2llbnRzKHAwWzFdLCBwMVsxXSwgcDJbMV0sIHAzWzFdKTtcbiAgICB0aGlzLmEgPSBbY29lZmZ4WzBdLCBjb2VmZnlbMF1dO1xuICAgIHRoaXMuYiA9IFtjb2VmZnhbMV0sIGNvZWZmeVsxXV07XG4gICAgdGhpcy5jID0gW2NvZWZmeFsyXSwgY29lZmZ5WzJdXTtcbiAgICB0aGlzLmQgPSBbY29lZmZ4WzNdLCBjb2VmZnlbM11dO1xuICAgIHRoaXMucG9pbnRzID0gW3AwLCBwMSwgcDIsIHAzXTtcbiAgfVxuXG4gIFBvbHlub21pYWxCZXppZXIucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gWygodGhpcy5hWzBdICogdCArIHRoaXMuYlswXSkgKiB0ICsgdGhpcy5jWzBdKSAqIHQgKyB0aGlzLmRbMF0sICgodGhpcy5hWzFdICogdCArIHRoaXMuYlsxXSkgKiB0ICsgdGhpcy5jWzFdKSAqIHQgKyB0aGlzLmRbMV1dO1xuICB9O1xuXG4gIFBvbHlub21pYWxCZXppZXIucHJvdG90eXBlLmRlcml2YXRpdmUgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBbKDMgKiB0ICogdGhpcy5hWzBdICsgMiAqIHRoaXMuYlswXSkgKiB0ICsgdGhpcy5jWzBdLCAoMyAqIHQgKiB0aGlzLmFbMV0gKyAyICogdGhpcy5iWzFdKSAqIHQgKyB0aGlzLmNbMV1dO1xuICB9O1xuXG4gIFBvbHlub21pYWxCZXppZXIucHJvdG90eXBlLnRhbmdlbnRBbmdsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgdmFyIHAgPSB0aGlzLmRlcml2YXRpdmUodCk7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIocFsxXSwgcFswXSk7XG4gIH07XG5cbiAgUG9seW5vbWlhbEJlemllci5wcm90b3R5cGUubm9ybWFsQW5nbGUgPSBmdW5jdGlvbiAodCkge1xuICAgIHZhciBwID0gdGhpcy5kZXJpdmF0aXZlKHQpO1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHBbMF0sIHBbMV0pO1xuICB9O1xuXG4gIFBvbHlub21pYWxCZXppZXIucHJvdG90eXBlLmluZmxlY3Rpb25Qb2ludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlbm9tID0gdGhpcy5hWzFdICogdGhpcy5iWzBdIC0gdGhpcy5hWzBdICogdGhpcy5iWzFdO1xuICAgIGlmIChmbG9hdFplcm8oZGVub20pKSByZXR1cm4gW107XG4gICAgdmFyIHRjdXNwID0gLTAuNSAqICh0aGlzLmFbMV0gKiB0aGlzLmNbMF0gLSB0aGlzLmFbMF0gKiB0aGlzLmNbMV0pIC8gZGVub207XG4gICAgdmFyIHNxdWFyZSA9IHRjdXNwICogdGN1c3AgLSAxIC8gMyAqICh0aGlzLmJbMV0gKiB0aGlzLmNbMF0gLSB0aGlzLmJbMF0gKiB0aGlzLmNbMV0pIC8gZGVub207XG4gICAgaWYgKHNxdWFyZSA8IDApIHJldHVybiBbXTtcbiAgICB2YXIgcm9vdCA9IE1hdGguc3FydChzcXVhcmUpO1xuXG4gICAgaWYgKGZsb2F0WmVybyhyb290KSkge1xuICAgICAgaWYgKHJvb3QgPiAwICYmIHJvb3QgPCAxKSByZXR1cm4gW3RjdXNwXTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3RjdXNwIC0gcm9vdCwgdGN1c3AgKyByb290XS5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgIHJldHVybiByID4gMCAmJiByIDwgMTtcbiAgICB9KTtcbiAgfTtcblxuICBQb2x5bm9taWFsQmV6aWVyLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgaWYgKHQgPD0gMCkgcmV0dXJuIFtzaW5nbGVQb2ludCh0aGlzLnBvaW50c1swXSksIHRoaXNdO1xuICAgIGlmICh0ID49IDEpIHJldHVybiBbdGhpcywgc2luZ2xlUG9pbnQodGhpcy5wb2ludHNbdGhpcy5wb2ludHMubGVuZ3RoIC0gMV0pXTtcbiAgICB2YXIgcDEwID0gbGVycFBvaW50KHRoaXMucG9pbnRzWzBdLCB0aGlzLnBvaW50c1sxXSwgdCk7XG4gICAgdmFyIHAxMSA9IGxlcnBQb2ludCh0aGlzLnBvaW50c1sxXSwgdGhpcy5wb2ludHNbMl0sIHQpO1xuICAgIHZhciBwMTIgPSBsZXJwUG9pbnQodGhpcy5wb2ludHNbMl0sIHRoaXMucG9pbnRzWzNdLCB0KTtcbiAgICB2YXIgcDIwID0gbGVycFBvaW50KHAxMCwgcDExLCB0KTtcbiAgICB2YXIgcDIxID0gbGVycFBvaW50KHAxMSwgcDEyLCB0KTtcbiAgICB2YXIgcDMgPSBsZXJwUG9pbnQocDIwLCBwMjEsIHQpO1xuICAgIHJldHVybiBbbmV3IFBvbHlub21pYWxCZXppZXIodGhpcy5wb2ludHNbMF0sIHAxMCwgcDIwLCBwMywgdHJ1ZSksIG5ldyBQb2x5bm9taWFsQmV6aWVyKHAzLCBwMjEsIHAxMiwgdGhpcy5wb2ludHNbM10sIHRydWUpXTtcbiAgfTtcblxuICBmdW5jdGlvbiBleHRyZW1hKGJleiwgY29tcCkge1xuICAgIHZhciBtaW4gPSBiZXoucG9pbnRzWzBdW2NvbXBdO1xuICAgIHZhciBtYXggPSBiZXoucG9pbnRzW2Jlei5wb2ludHMubGVuZ3RoIC0gMV1bY29tcF07XG5cbiAgICBpZiAobWluID4gbWF4KSB7XG4gICAgICB2YXIgZSA9IG1heDtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IGU7XG4gICAgfSAvLyBEZXJpdmF0aXZlIHJvb3RzIHRvIGZpbmQgbWluL21heFxuXG5cbiAgICB2YXIgZiA9IHF1YWRSb290cygzICogYmV6LmFbY29tcF0sIDIgKiBiZXouYltjb21wXSwgYmV6LmNbY29tcF0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoZltpXSA+IDAgJiYgZltpXSA8IDEpIHtcbiAgICAgICAgdmFyIHZhbCA9IGJlei5wb2ludChmW2ldKVtjb21wXTtcbiAgICAgICAgaWYgKHZhbCA8IG1pbikgbWluID0gdmFsO2Vsc2UgaWYgKHZhbCA+IG1heCkgbWF4ID0gdmFsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBtaW46IG1pbixcbiAgICAgIG1heDogbWF4XG4gICAgfTtcbiAgfVxuXG4gIFBvbHlub21pYWxCZXppZXIucHJvdG90eXBlLmJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogZXh0cmVtYSh0aGlzLCAwKSxcbiAgICAgIHk6IGV4dHJlbWEodGhpcywgMSlcbiAgICB9O1xuICB9O1xuXG4gIFBvbHlub21pYWxCZXppZXIucHJvdG90eXBlLmJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBib3VuZHMgPSB0aGlzLmJvdW5kcygpO1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBib3VuZHMueC5taW4sXG4gICAgICByaWdodDogYm91bmRzLngubWF4LFxuICAgICAgdG9wOiBib3VuZHMueS5taW4sXG4gICAgICBib3R0b206IGJvdW5kcy55Lm1heCxcbiAgICAgIHdpZHRoOiBib3VuZHMueC5tYXggLSBib3VuZHMueC5taW4sXG4gICAgICBoZWlnaHQ6IGJvdW5kcy55Lm1heCAtIGJvdW5kcy55Lm1pbixcbiAgICAgIGN4OiAoYm91bmRzLngubWF4ICsgYm91bmRzLngubWluKSAvIDIsXG4gICAgICBjeTogKGJvdW5kcy55Lm1heCArIGJvdW5kcy55Lm1pbikgLyAyXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBpbnRlcnNlY3REYXRhKGJleiwgdDEsIHQyKSB7XG4gICAgdmFyIGJveCA9IGJlei5ib3VuZGluZ0JveCgpO1xuICAgIHJldHVybiB7XG4gICAgICBjeDogYm94LmN4LFxuICAgICAgY3k6IGJveC5jeSxcbiAgICAgIHdpZHRoOiBib3gud2lkdGgsXG4gICAgICBoZWlnaHQ6IGJveC5oZWlnaHQsXG4gICAgICBiZXo6IGJleixcbiAgICAgIHQ6ICh0MSArIHQyKSAvIDIsXG4gICAgICB0MTogdDEsXG4gICAgICB0MjogdDJcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc3BsaXREYXRhKGRhdGEpIHtcbiAgICB2YXIgc3BsaXQgPSBkYXRhLmJlei5zcGxpdCgwLjUpO1xuICAgIHJldHVybiBbaW50ZXJzZWN0RGF0YShzcGxpdFswXSwgZGF0YS50MSwgZGF0YS50KSwgaW50ZXJzZWN0RGF0YShzcGxpdFsxXSwgZGF0YS50LCBkYXRhLnQyKV07XG4gIH1cblxuICBmdW5jdGlvbiBib3hJbnRlcnNlY3QoYjEsIGIyKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGIxLmN4IC0gYjIuY3gpICogMiA8IGIxLndpZHRoICsgYjIud2lkdGggJiYgTWF0aC5hYnMoYjEuY3kgLSBiMi5jeSkgKiAyIDwgYjEuaGVpZ2h0ICsgYjIuaGVpZ2h0O1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJzZWN0c0ltcGwoZDEsIGQyLCBkZXB0aCwgdG9sZXJhbmNlLCBpbnRlcnNlY3Rpb25zLCBtYXhSZWN1cnNpb24pIHtcbiAgICBpZiAoIWJveEludGVyc2VjdChkMSwgZDIpKSByZXR1cm47XG5cbiAgICBpZiAoZGVwdGggPj0gbWF4UmVjdXJzaW9uIHx8IGQxLndpZHRoIDw9IHRvbGVyYW5jZSAmJiBkMS5oZWlnaHQgPD0gdG9sZXJhbmNlICYmIGQyLndpZHRoIDw9IHRvbGVyYW5jZSAmJiBkMi5oZWlnaHQgPD0gdG9sZXJhbmNlKSB7XG4gICAgICBpbnRlcnNlY3Rpb25zLnB1c2goW2QxLnQsIGQyLnRdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZDFzID0gc3BsaXREYXRhKGQxKTtcbiAgICB2YXIgZDJzID0gc3BsaXREYXRhKGQyKTtcbiAgICBpbnRlcnNlY3RzSW1wbChkMXNbMF0sIGQyc1swXSwgZGVwdGggKyAxLCB0b2xlcmFuY2UsIGludGVyc2VjdGlvbnMsIG1heFJlY3Vyc2lvbik7XG4gICAgaW50ZXJzZWN0c0ltcGwoZDFzWzBdLCBkMnNbMV0sIGRlcHRoICsgMSwgdG9sZXJhbmNlLCBpbnRlcnNlY3Rpb25zLCBtYXhSZWN1cnNpb24pO1xuICAgIGludGVyc2VjdHNJbXBsKGQxc1sxXSwgZDJzWzBdLCBkZXB0aCArIDEsIHRvbGVyYW5jZSwgaW50ZXJzZWN0aW9ucywgbWF4UmVjdXJzaW9uKTtcbiAgICBpbnRlcnNlY3RzSW1wbChkMXNbMV0sIGQyc1sxXSwgZGVwdGggKyAxLCB0b2xlcmFuY2UsIGludGVyc2VjdGlvbnMsIG1heFJlY3Vyc2lvbik7XG4gIH1cblxuICBQb2x5bm9taWFsQmV6aWVyLnByb3RvdHlwZS5pbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gKG90aGVyLCB0b2xlcmFuY2UsIG1heFJlY3Vyc2lvbikge1xuICAgIGlmICh0b2xlcmFuY2UgPT09IHVuZGVmaW5lZCkgdG9sZXJhbmNlID0gMjtcbiAgICBpZiAobWF4UmVjdXJzaW9uID09PSB1bmRlZmluZWQpIG1heFJlY3Vyc2lvbiA9IDc7XG4gICAgdmFyIGludGVyc2VjdGlvbnMgPSBbXTtcbiAgICBpbnRlcnNlY3RzSW1wbChpbnRlcnNlY3REYXRhKHRoaXMsIDAsIDEpLCBpbnRlcnNlY3REYXRhKG90aGVyLCAwLCAxKSwgMCwgdG9sZXJhbmNlLCBpbnRlcnNlY3Rpb25zLCBtYXhSZWN1cnNpb24pO1xuICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICB9O1xuXG4gIFBvbHlub21pYWxCZXppZXIuc2hhcGVTZWdtZW50ID0gZnVuY3Rpb24gKHNoYXBlUGF0aCwgaW5kZXgpIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gKGluZGV4ICsgMSkgJSBzaGFwZVBhdGgubGVuZ3RoKCk7XG4gICAgcmV0dXJuIG5ldyBQb2x5bm9taWFsQmV6aWVyKHNoYXBlUGF0aC52W2luZGV4XSwgc2hhcGVQYXRoLm9baW5kZXhdLCBzaGFwZVBhdGguaVtuZXh0SW5kZXhdLCBzaGFwZVBhdGgudltuZXh0SW5kZXhdLCB0cnVlKTtcbiAgfTtcblxuICBQb2x5bm9taWFsQmV6aWVyLnNoYXBlU2VnbWVudEludmVydGVkID0gZnVuY3Rpb24gKHNoYXBlUGF0aCwgaW5kZXgpIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gKGluZGV4ICsgMSkgJSBzaGFwZVBhdGgubGVuZ3RoKCk7XG4gICAgcmV0dXJuIG5ldyBQb2x5bm9taWFsQmV6aWVyKHNoYXBlUGF0aC52W25leHRJbmRleF0sIHNoYXBlUGF0aC5pW25leHRJbmRleF0sIHNoYXBlUGF0aC5vW2luZGV4XSwgc2hhcGVQYXRoLnZbaW5kZXhdLCB0cnVlKTtcbiAgfTtcblxuICBmdW5jdGlvbiBjcm9zc1Byb2R1Y3QoYSwgYikge1xuICAgIHJldHVybiBbYVsxXSAqIGJbMl0gLSBhWzJdICogYlsxXSwgYVsyXSAqIGJbMF0gLSBhWzBdICogYlsyXSwgYVswXSAqIGJbMV0gLSBhWzFdICogYlswXV07XG4gIH1cblxuICBmdW5jdGlvbiBsaW5lSW50ZXJzZWN0aW9uKHN0YXJ0MSwgZW5kMSwgc3RhcnQyLCBlbmQyKSB7XG4gICAgdmFyIHYxID0gW3N0YXJ0MVswXSwgc3RhcnQxWzFdLCAxXTtcbiAgICB2YXIgdjIgPSBbZW5kMVswXSwgZW5kMVsxXSwgMV07XG4gICAgdmFyIHYzID0gW3N0YXJ0MlswXSwgc3RhcnQyWzFdLCAxXTtcbiAgICB2YXIgdjQgPSBbZW5kMlswXSwgZW5kMlsxXSwgMV07XG4gICAgdmFyIHIgPSBjcm9zc1Byb2R1Y3QoY3Jvc3NQcm9kdWN0KHYxLCB2MiksIGNyb3NzUHJvZHVjdCh2MywgdjQpKTtcbiAgICBpZiAoZmxvYXRaZXJvKHJbMl0pKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gW3JbMF0gLyByWzJdLCByWzFdIC8gclsyXV07XG4gIH1cblxuICBmdW5jdGlvbiBwb2xhck9mZnNldChwLCBhbmdsZSwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIFtwWzBdICsgTWF0aC5jb3MoYW5nbGUpICogbGVuZ3RoLCBwWzFdIC0gTWF0aC5zaW4oYW5nbGUpICogbGVuZ3RoXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvaW50RGlzdGFuY2UocDEsIHAyKSB7XG4gICAgcmV0dXJuIE1hdGguaHlwb3QocDFbMF0gLSBwMlswXSwgcDFbMV0gLSBwMlsxXSk7XG4gIH1cblxuICBmdW5jdGlvbiBwb2ludEVxdWFsKHAxLCBwMikge1xuICAgIHJldHVybiBmbG9hdEVxdWFsKHAxWzBdLCBwMlswXSkgJiYgZmxvYXRFcXVhbChwMVsxXSwgcDJbMV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gWmlnWmFnTW9kaWZpZXIoKSB7fVxuXG4gIGV4dGVuZFByb3RvdHlwZShbU2hhcGVNb2RpZmllcl0sIFppZ1phZ01vZGlmaWVyKTtcblxuICBaaWdaYWdNb2RpZmllci5wcm90b3R5cGUuaW5pdE1vZGlmaWVyUHJvcGVydGllcyA9IGZ1bmN0aW9uIChlbGVtLCBkYXRhKSB7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMucHJvY2Vzc0tleXM7XG4gICAgdGhpcy5hbXBsaXR1ZGUgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnMsIDAsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMuZnJlcXVlbmN5ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5yLCAwLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLnBvaW50c1R5cGUgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnB0LCAwLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gdGhpcy5hbXBsaXR1ZGUuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCAhPT0gMCB8fCB0aGlzLmZyZXF1ZW5jeS5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoICE9PSAwIHx8IHRoaXMucG9pbnRzVHlwZS5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoICE9PSAwO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNldFBvaW50KG91dHB1dEJlemllciwgcG9pbnQsIGFuZ2xlLCBkaXJlY3Rpb24sIGFtcGxpdHVkZSwgb3V0QW1wbGl0dWRlLCBpbkFtcGxpdHVkZSkge1xuICAgIHZhciBhbmdPID0gYW5nbGUgLSBNYXRoLlBJIC8gMjtcbiAgICB2YXIgYW5nSSA9IGFuZ2xlICsgTWF0aC5QSSAvIDI7XG4gICAgdmFyIHB4ID0gcG9pbnRbMF0gKyBNYXRoLmNvcyhhbmdsZSkgKiBkaXJlY3Rpb24gKiBhbXBsaXR1ZGU7XG4gICAgdmFyIHB5ID0gcG9pbnRbMV0gLSBNYXRoLnNpbihhbmdsZSkgKiBkaXJlY3Rpb24gKiBhbXBsaXR1ZGU7XG4gICAgb3V0cHV0QmV6aWVyLnNldFRyaXBsZUF0KHB4LCBweSwgcHggKyBNYXRoLmNvcyhhbmdPKSAqIG91dEFtcGxpdHVkZSwgcHkgLSBNYXRoLnNpbihhbmdPKSAqIG91dEFtcGxpdHVkZSwgcHggKyBNYXRoLmNvcyhhbmdJKSAqIGluQW1wbGl0dWRlLCBweSAtIE1hdGguc2luKGFuZ0kpICogaW5BbXBsaXR1ZGUsIG91dHB1dEJlemllci5sZW5ndGgoKSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQZXJwZW5kaWN1bGFyVmVjdG9yKHB0MSwgcHQyKSB7XG4gICAgdmFyIHZlY3RvciA9IFtwdDJbMF0gLSBwdDFbMF0sIHB0MlsxXSAtIHB0MVsxXV07XG4gICAgdmFyIHJvdCA9IC1NYXRoLlBJICogMC41O1xuICAgIHZhciByb3RhdGVkVmVjdG9yID0gW01hdGguY29zKHJvdCkgKiB2ZWN0b3JbMF0gLSBNYXRoLnNpbihyb3QpICogdmVjdG9yWzFdLCBNYXRoLnNpbihyb3QpICogdmVjdG9yWzBdICsgTWF0aC5jb3Mocm90KSAqIHZlY3RvclsxXV07XG4gICAgcmV0dXJuIHJvdGF0ZWRWZWN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQcm9qZWN0aW5nQW5nbGUocGF0aCwgY3VyKSB7XG4gICAgdmFyIHByZXZJbmRleCA9IGN1ciA9PT0gMCA/IHBhdGgubGVuZ3RoKCkgLSAxIDogY3VyIC0gMTtcbiAgICB2YXIgbmV4dEluZGV4ID0gKGN1ciArIDEpICUgcGF0aC5sZW5ndGgoKTtcbiAgICB2YXIgcHJldlBvaW50ID0gcGF0aC52W3ByZXZJbmRleF07XG4gICAgdmFyIG5leHRQb2ludCA9IHBhdGgudltuZXh0SW5kZXhdO1xuICAgIHZhciBwVmVjdG9yID0gZ2V0UGVycGVuZGljdWxhclZlY3RvcihwcmV2UG9pbnQsIG5leHRQb2ludCk7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoMCwgMSkgLSBNYXRoLmF0YW4yKHBWZWN0b3JbMV0sIHBWZWN0b3JbMF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gemlnWmFnQ29ybmVyKG91dHB1dEJlemllciwgcGF0aCwgY3VyLCBhbXBsaXR1ZGUsIGZyZXF1ZW5jeSwgcG9pbnRUeXBlLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgYW5nbGUgPSBnZXRQcm9qZWN0aW5nQW5nbGUocGF0aCwgY3VyKTtcbiAgICB2YXIgcG9pbnQgPSBwYXRoLnZbY3VyICUgcGF0aC5fbGVuZ3RoXTtcbiAgICB2YXIgcHJldlBvaW50ID0gcGF0aC52W2N1ciA9PT0gMCA/IHBhdGguX2xlbmd0aCAtIDEgOiBjdXIgLSAxXTtcbiAgICB2YXIgbmV4dFBvaW50ID0gcGF0aC52WyhjdXIgKyAxKSAlIHBhdGguX2xlbmd0aF07XG4gICAgdmFyIHByZXZEaXN0ID0gcG9pbnRUeXBlID09PSAyID8gTWF0aC5zcXJ0KE1hdGgucG93KHBvaW50WzBdIC0gcHJldlBvaW50WzBdLCAyKSArIE1hdGgucG93KHBvaW50WzFdIC0gcHJldlBvaW50WzFdLCAyKSkgOiAwO1xuICAgIHZhciBuZXh0RGlzdCA9IHBvaW50VHlwZSA9PT0gMiA/IE1hdGguc3FydChNYXRoLnBvdyhwb2ludFswXSAtIG5leHRQb2ludFswXSwgMikgKyBNYXRoLnBvdyhwb2ludFsxXSAtIG5leHRQb2ludFsxXSwgMikpIDogMDtcbiAgICBzZXRQb2ludChvdXRwdXRCZXppZXIsIHBhdGgudltjdXIgJSBwYXRoLl9sZW5ndGhdLCBhbmdsZSwgZGlyZWN0aW9uLCBhbXBsaXR1ZGUsIG5leHREaXN0IC8gKChmcmVxdWVuY3kgKyAxKSAqIDIpLCBwcmV2RGlzdCAvICgoZnJlcXVlbmN5ICsgMSkgKiAyKSwgcG9pbnRUeXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHppZ1phZ1NlZ21lbnQob3V0cHV0QmV6aWVyLCBzZWdtZW50LCBhbXBsaXR1ZGUsIGZyZXF1ZW5jeSwgcG9pbnRUeXBlLCBkaXJlY3Rpb24pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyZXF1ZW5jeTsgaSArPSAxKSB7XG4gICAgICB2YXIgdCA9IChpICsgMSkgLyAoZnJlcXVlbmN5ICsgMSk7XG4gICAgICB2YXIgZGlzdCA9IHBvaW50VHlwZSA9PT0gMiA/IE1hdGguc3FydChNYXRoLnBvdyhzZWdtZW50LnBvaW50c1szXVswXSAtIHNlZ21lbnQucG9pbnRzWzBdWzBdLCAyKSArIE1hdGgucG93KHNlZ21lbnQucG9pbnRzWzNdWzFdIC0gc2VnbWVudC5wb2ludHNbMF1bMV0sIDIpKSA6IDA7XG4gICAgICB2YXIgYW5nbGUgPSBzZWdtZW50Lm5vcm1hbEFuZ2xlKHQpO1xuICAgICAgdmFyIHBvaW50ID0gc2VnbWVudC5wb2ludCh0KTtcbiAgICAgIHNldFBvaW50KG91dHB1dEJlemllciwgcG9pbnQsIGFuZ2xlLCBkaXJlY3Rpb24sIGFtcGxpdHVkZSwgZGlzdCAvICgoZnJlcXVlbmN5ICsgMSkgKiAyKSwgZGlzdCAvICgoZnJlcXVlbmN5ICsgMSkgKiAyKSwgcG9pbnRUeXBlKTtcbiAgICAgIGRpcmVjdGlvbiA9IC1kaXJlY3Rpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgfVxuXG4gIFppZ1phZ01vZGlmaWVyLnByb3RvdHlwZS5wcm9jZXNzUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCBhbXBsaXR1ZGUsIGZyZXF1ZW5jeSwgcG9pbnRUeXBlKSB7XG4gICAgdmFyIGNvdW50ID0gcGF0aC5fbGVuZ3RoO1xuICAgIHZhciBjbG9uZWRQYXRoID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcbiAgICBjbG9uZWRQYXRoLmMgPSBwYXRoLmM7XG5cbiAgICBpZiAoIXBhdGguYykge1xuICAgICAgY291bnQgLT0gMTtcbiAgICB9XG5cbiAgICBpZiAoY291bnQgPT09IDApIHJldHVybiBjbG9uZWRQYXRoO1xuICAgIHZhciBkaXJlY3Rpb24gPSAtMTtcbiAgICB2YXIgc2VnbWVudCA9IFBvbHlub21pYWxCZXppZXIuc2hhcGVTZWdtZW50KHBhdGgsIDApO1xuICAgIHppZ1phZ0Nvcm5lcihjbG9uZWRQYXRoLCBwYXRoLCAwLCBhbXBsaXR1ZGUsIGZyZXF1ZW5jeSwgcG9pbnRUeXBlLCBkaXJlY3Rpb24pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICBkaXJlY3Rpb24gPSB6aWdaYWdTZWdtZW50KGNsb25lZFBhdGgsIHNlZ21lbnQsIGFtcGxpdHVkZSwgZnJlcXVlbmN5LCBwb2ludFR5cGUsIC1kaXJlY3Rpb24pO1xuXG4gICAgICBpZiAoaSA9PT0gY291bnQgLSAxICYmICFwYXRoLmMpIHtcbiAgICAgICAgc2VnbWVudCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWdtZW50ID0gUG9seW5vbWlhbEJlemllci5zaGFwZVNlZ21lbnQocGF0aCwgKGkgKyAxKSAlIGNvdW50KTtcbiAgICAgIH1cblxuICAgICAgemlnWmFnQ29ybmVyKGNsb25lZFBhdGgsIHBhdGgsIGkgKyAxLCBhbXBsaXR1ZGUsIGZyZXF1ZW5jeSwgcG9pbnRUeXBlLCBkaXJlY3Rpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBjbG9uZWRQYXRoO1xuICB9O1xuXG4gIFppZ1phZ01vZGlmaWVyLnByb3RvdHlwZS5wcm9jZXNzU2hhcGVzID0gZnVuY3Rpb24gKF9pc0ZpcnN0RnJhbWUpIHtcbiAgICB2YXIgc2hhcGVQYXRocztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5zaGFwZXMubGVuZ3RoO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuO1xuICAgIHZhciBhbXBsaXR1ZGUgPSB0aGlzLmFtcGxpdHVkZS52O1xuICAgIHZhciBmcmVxdWVuY3kgPSBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKHRoaXMuZnJlcXVlbmN5LnYpKTtcbiAgICB2YXIgcG9pbnRUeXBlID0gdGhpcy5wb2ludHNUeXBlLnY7XG5cbiAgICBpZiAoYW1wbGl0dWRlICE9PSAwKSB7XG4gICAgICB2YXIgc2hhcGVEYXRhO1xuICAgICAgdmFyIGxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgc2hhcGVEYXRhID0gdGhpcy5zaGFwZXNbaV07XG4gICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuXG4gICAgICAgIGlmICghKCFzaGFwZURhdGEuc2hhcGUuX21kZiAmJiAhdGhpcy5fbWRmICYmICFfaXNGaXJzdEZyYW1lKSkge1xuICAgICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uLnJlbGVhc2VTaGFwZXMoKTtcbiAgICAgICAgICBzaGFwZURhdGEuc2hhcGUuX21kZiA9IHRydWU7XG4gICAgICAgICAgc2hhcGVQYXRocyA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5zaGFwZXM7XG4gICAgICAgICAgakxlbiA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5fbGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24uYWRkU2hhcGUodGhpcy5wcm9jZXNzUGF0aChzaGFwZVBhdGhzW2pdLCBhbXBsaXR1ZGUsIGZyZXF1ZW5jeSwgcG9pbnRUeXBlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2hhcGVEYXRhLnNoYXBlLnBhdGhzID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBsaW5lYXJPZmZzZXQocDEsIHAyLCBhbW91bnQpIHtcbiAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHAyWzBdIC0gcDFbMF0sIHAyWzFdIC0gcDFbMV0pO1xuICAgIHJldHVybiBbcG9sYXJPZmZzZXQocDEsIGFuZ2xlLCBhbW91bnQpLCBwb2xhck9mZnNldChwMiwgYW5nbGUsIGFtb3VudCldO1xuICB9XG5cbiAgZnVuY3Rpb24gb2Zmc2V0U2VnbWVudChzZWdtZW50LCBhbW91bnQpIHtcbiAgICB2YXIgcDA7XG4gICAgdmFyIHAxYTtcbiAgICB2YXIgcDFiO1xuICAgIHZhciBwMmI7XG4gICAgdmFyIHAyYTtcbiAgICB2YXIgcDM7XG4gICAgdmFyIGU7XG4gICAgZSA9IGxpbmVhck9mZnNldChzZWdtZW50LnBvaW50c1swXSwgc2VnbWVudC5wb2ludHNbMV0sIGFtb3VudCk7XG4gICAgcDAgPSBlWzBdO1xuICAgIHAxYSA9IGVbMV07XG4gICAgZSA9IGxpbmVhck9mZnNldChzZWdtZW50LnBvaW50c1sxXSwgc2VnbWVudC5wb2ludHNbMl0sIGFtb3VudCk7XG4gICAgcDFiID0gZVswXTtcbiAgICBwMmIgPSBlWzFdO1xuICAgIGUgPSBsaW5lYXJPZmZzZXQoc2VnbWVudC5wb2ludHNbMl0sIHNlZ21lbnQucG9pbnRzWzNdLCBhbW91bnQpO1xuICAgIHAyYSA9IGVbMF07XG4gICAgcDMgPSBlWzFdO1xuICAgIHZhciBwMSA9IGxpbmVJbnRlcnNlY3Rpb24ocDAsIHAxYSwgcDFiLCBwMmIpO1xuICAgIGlmIChwMSA9PT0gbnVsbCkgcDEgPSBwMWE7XG4gICAgdmFyIHAyID0gbGluZUludGVyc2VjdGlvbihwMmEsIHAzLCBwMWIsIHAyYik7XG4gICAgaWYgKHAyID09PSBudWxsKSBwMiA9IHAyYTtcbiAgICByZXR1cm4gbmV3IFBvbHlub21pYWxCZXppZXIocDAsIHAxLCBwMiwgcDMpO1xuICB9XG5cbiAgZnVuY3Rpb24gam9pbkxpbmVzKG91dHB1dEJlemllciwgc2VnMSwgc2VnMiwgbGluZUpvaW4sIG1pdGVyTGltaXQpIHtcbiAgICB2YXIgcDAgPSBzZWcxLnBvaW50c1szXTtcbiAgICB2YXIgcDEgPSBzZWcyLnBvaW50c1swXTsgLy8gQmV2ZWxcblxuICAgIGlmIChsaW5lSm9pbiA9PT0gMykgcmV0dXJuIHAwOyAvLyBDb25uZWN0ZWQsIHRoZXkgZG9uJ3QgbmVlZCBhIGpvaW50XG5cbiAgICBpZiAocG9pbnRFcXVhbChwMCwgcDEpKSByZXR1cm4gcDA7IC8vIFJvdW5kXG5cbiAgICBpZiAobGluZUpvaW4gPT09IDIpIHtcbiAgICAgIHZhciBhbmdsZU91dCA9IC1zZWcxLnRhbmdlbnRBbmdsZSgxKTtcbiAgICAgIHZhciBhbmdsZUluID0gLXNlZzIudGFuZ2VudEFuZ2xlKDApICsgTWF0aC5QSTtcbiAgICAgIHZhciBjZW50ZXIgPSBsaW5lSW50ZXJzZWN0aW9uKHAwLCBwb2xhck9mZnNldChwMCwgYW5nbGVPdXQgKyBNYXRoLlBJIC8gMiwgMTAwKSwgcDEsIHBvbGFyT2Zmc2V0KHAxLCBhbmdsZU91dCArIE1hdGguUEkgLyAyLCAxMDApKTtcbiAgICAgIHZhciByYWRpdXMgPSBjZW50ZXIgPyBwb2ludERpc3RhbmNlKGNlbnRlciwgcDApIDogcG9pbnREaXN0YW5jZShwMCwgcDEpIC8gMjtcbiAgICAgIHZhciB0YW4gPSBwb2xhck9mZnNldChwMCwgYW5nbGVPdXQsIDIgKiByYWRpdXMgKiByb3VuZENvcm5lcik7XG4gICAgICBvdXRwdXRCZXppZXIuc2V0WFlBdCh0YW5bMF0sIHRhblsxXSwgJ28nLCBvdXRwdXRCZXppZXIubGVuZ3RoKCkgLSAxKTtcbiAgICAgIHRhbiA9IHBvbGFyT2Zmc2V0KHAxLCBhbmdsZUluLCAyICogcmFkaXVzICogcm91bmRDb3JuZXIpO1xuICAgICAgb3V0cHV0QmV6aWVyLnNldFRyaXBsZUF0KHAxWzBdLCBwMVsxXSwgcDFbMF0sIHAxWzFdLCB0YW5bMF0sIHRhblsxXSwgb3V0cHV0QmV6aWVyLmxlbmd0aCgpKTtcbiAgICAgIHJldHVybiBwMTtcbiAgICB9IC8vIE1pdGVyXG5cblxuICAgIHZhciB0MCA9IHBvaW50RXF1YWwocDAsIHNlZzEucG9pbnRzWzJdKSA/IHNlZzEucG9pbnRzWzBdIDogc2VnMS5wb2ludHNbMl07XG4gICAgdmFyIHQxID0gcG9pbnRFcXVhbChwMSwgc2VnMi5wb2ludHNbMV0pID8gc2VnMi5wb2ludHNbM10gOiBzZWcyLnBvaW50c1sxXTtcbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gbGluZUludGVyc2VjdGlvbih0MCwgcDAsIHAxLCB0MSk7XG5cbiAgICBpZiAoaW50ZXJzZWN0aW9uICYmIHBvaW50RGlzdGFuY2UoaW50ZXJzZWN0aW9uLCBwMCkgPCBtaXRlckxpbWl0KSB7XG4gICAgICBvdXRwdXRCZXppZXIuc2V0VHJpcGxlQXQoaW50ZXJzZWN0aW9uWzBdLCBpbnRlcnNlY3Rpb25bMV0sIGludGVyc2VjdGlvblswXSwgaW50ZXJzZWN0aW9uWzFdLCBpbnRlcnNlY3Rpb25bMF0sIGludGVyc2VjdGlvblsxXSwgb3V0cHV0QmV6aWVyLmxlbmd0aCgpKTtcbiAgICAgIHJldHVybiBpbnRlcnNlY3Rpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIHAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uKGEsIGIpIHtcbiAgICB2YXIgaW50ZXJzZWN0ID0gYS5pbnRlcnNlY3Rpb25zKGIpO1xuICAgIGlmIChpbnRlcnNlY3QubGVuZ3RoICYmIGZsb2F0RXF1YWwoaW50ZXJzZWN0WzBdWzBdLCAxKSkgaW50ZXJzZWN0LnNoaWZ0KCk7XG4gICAgaWYgKGludGVyc2VjdC5sZW5ndGgpIHJldHVybiBpbnRlcnNlY3RbMF07XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBwcnVuZVNlZ21lbnRJbnRlcnNlY3Rpb24oYSwgYikge1xuICAgIHZhciBvdXRhID0gYS5zbGljZSgpO1xuICAgIHZhciBvdXRiID0gYi5zbGljZSgpO1xuICAgIHZhciBpbnRlcnNlY3QgPSBnZXRJbnRlcnNlY3Rpb24oYVthLmxlbmd0aCAtIDFdLCBiWzBdKTtcblxuICAgIGlmIChpbnRlcnNlY3QpIHtcbiAgICAgIG91dGFbYS5sZW5ndGggLSAxXSA9IGFbYS5sZW5ndGggLSAxXS5zcGxpdChpbnRlcnNlY3RbMF0pWzBdO1xuICAgICAgb3V0YlswXSA9IGJbMF0uc3BsaXQoaW50ZXJzZWN0WzFdKVsxXTtcbiAgICB9XG5cbiAgICBpZiAoYS5sZW5ndGggPiAxICYmIGIubGVuZ3RoID4gMSkge1xuICAgICAgaW50ZXJzZWN0ID0gZ2V0SW50ZXJzZWN0aW9uKGFbMF0sIGJbYi5sZW5ndGggLSAxXSk7XG5cbiAgICAgIGlmIChpbnRlcnNlY3QpIHtcbiAgICAgICAgcmV0dXJuIFtbYVswXS5zcGxpdChpbnRlcnNlY3RbMF0pWzBdXSwgW2JbYi5sZW5ndGggLSAxXS5zcGxpdChpbnRlcnNlY3RbMV0pWzFdXV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtvdXRhLCBvdXRiXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBydW5lSW50ZXJzZWN0aW9ucyhzZWdtZW50cykge1xuICAgIHZhciBlO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgZSA9IHBydW5lU2VnbWVudEludGVyc2VjdGlvbihzZWdtZW50c1tpIC0gMV0sIHNlZ21lbnRzW2ldKTtcbiAgICAgIHNlZ21lbnRzW2kgLSAxXSA9IGVbMF07XG4gICAgICBzZWdtZW50c1tpXSA9IGVbMV07XG4gICAgfVxuXG4gICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGUgPSBwcnVuZVNlZ21lbnRJbnRlcnNlY3Rpb24oc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0sIHNlZ21lbnRzWzBdKTtcbiAgICAgIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdID0gZVswXTtcbiAgICAgIHNlZ21lbnRzWzBdID0gZVsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VnbWVudHM7XG4gIH1cblxuICBmdW5jdGlvbiBvZmZzZXRTZWdtZW50U3BsaXQoc2VnbWVudCwgYW1vdW50KSB7XG4gICAgLypcclxuICAgICAgV2Ugc3BsaXQgZWFjaCBiZXppZXIgc2VnbWVudCBpbnRvIHNtYWxsZXIgcGllY2VzIGJhc2VkXHJcbiAgICAgIG9uIGluZmxlY3Rpb24gcG9pbnRzLCB0aGlzIGVuc3VyZXMgdGhlIGNvbnRyb2wgcG9pbnRcclxuICAgICAgcG9seWdvbiBpcyBjb252ZXguXHJcbiAgICAgICAgKEEgY3ViaWMgYmV6aWVyIGNhbiBoYXZlIG5vbmUsIG9uZSwgb3IgdHdvIGluZmxlY3Rpb24gcG9pbnRzKVxyXG4gICAgKi9cbiAgICB2YXIgZmxleCA9IHNlZ21lbnQuaW5mbGVjdGlvblBvaW50cygpO1xuICAgIHZhciBsZWZ0O1xuICAgIHZhciByaWdodDtcbiAgICB2YXIgc3BsaXQ7XG4gICAgdmFyIG1pZDtcblxuICAgIGlmIChmbGV4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtvZmZzZXRTZWdtZW50KHNlZ21lbnQsIGFtb3VudCldO1xuICAgIH1cblxuICAgIGlmIChmbGV4Lmxlbmd0aCA9PT0gMSB8fCBmbG9hdEVxdWFsKGZsZXhbMV0sIDEpKSB7XG4gICAgICBzcGxpdCA9IHNlZ21lbnQuc3BsaXQoZmxleFswXSk7XG4gICAgICBsZWZ0ID0gc3BsaXRbMF07XG4gICAgICByaWdodCA9IHNwbGl0WzFdO1xuICAgICAgcmV0dXJuIFtvZmZzZXRTZWdtZW50KGxlZnQsIGFtb3VudCksIG9mZnNldFNlZ21lbnQocmlnaHQsIGFtb3VudCldO1xuICAgIH1cblxuICAgIHNwbGl0ID0gc2VnbWVudC5zcGxpdChmbGV4WzBdKTtcbiAgICBsZWZ0ID0gc3BsaXRbMF07XG4gICAgdmFyIHQgPSAoZmxleFsxXSAtIGZsZXhbMF0pIC8gKDEgLSBmbGV4WzBdKTtcbiAgICBzcGxpdCA9IHNwbGl0WzFdLnNwbGl0KHQpO1xuICAgIG1pZCA9IHNwbGl0WzBdO1xuICAgIHJpZ2h0ID0gc3BsaXRbMV07XG4gICAgcmV0dXJuIFtvZmZzZXRTZWdtZW50KGxlZnQsIGFtb3VudCksIG9mZnNldFNlZ21lbnQobWlkLCBhbW91bnQpLCBvZmZzZXRTZWdtZW50KHJpZ2h0LCBhbW91bnQpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIE9mZnNldFBhdGhNb2RpZmllcigpIHt9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtTaGFwZU1vZGlmaWVyXSwgT2Zmc2V0UGF0aE1vZGlmaWVyKTtcblxuICBPZmZzZXRQYXRoTW9kaWZpZXIucHJvdG90eXBlLmluaXRNb2RpZmllclByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZWxlbSwgZGF0YSkge1xuICAgIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLnByb2Nlc3NLZXlzO1xuICAgIHRoaXMuYW1vdW50ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5hLCAwLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLm1pdGVyTGltaXQgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm1sLCAwLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLmxpbmVKb2luID0gZGF0YS5sajtcbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gdGhpcy5hbW91bnQuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCAhPT0gMDtcbiAgfTtcblxuICBPZmZzZXRQYXRoTW9kaWZpZXIucHJvdG90eXBlLnByb2Nlc3NQYXRoID0gZnVuY3Rpb24gKGlucHV0QmV6aWVyLCBhbW91bnQsIGxpbmVKb2luLCBtaXRlckxpbWl0KSB7XG4gICAgdmFyIG91dHB1dEJlemllciA9IHNoYXBlUG9vbC5uZXdFbGVtZW50KCk7XG4gICAgb3V0cHV0QmV6aWVyLmMgPSBpbnB1dEJlemllci5jO1xuICAgIHZhciBjb3VudCA9IGlucHV0QmV6aWVyLmxlbmd0aCgpO1xuXG4gICAgaWYgKCFpbnB1dEJlemllci5jKSB7XG4gICAgICBjb3VudCAtPSAxO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBqO1xuICAgIHZhciBzZWdtZW50O1xuICAgIHZhciBtdWx0aVNlZ21lbnRzID0gW107XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgc2VnbWVudCA9IFBvbHlub21pYWxCZXppZXIuc2hhcGVTZWdtZW50KGlucHV0QmV6aWVyLCBpKTtcbiAgICAgIG11bHRpU2VnbWVudHMucHVzaChvZmZzZXRTZWdtZW50U3BsaXQoc2VnbWVudCwgYW1vdW50KSk7XG4gICAgfVxuXG4gICAgaWYgKCFpbnB1dEJlemllci5jKSB7XG4gICAgICBmb3IgKGkgPSBjb3VudCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIHNlZ21lbnQgPSBQb2x5bm9taWFsQmV6aWVyLnNoYXBlU2VnbWVudEludmVydGVkKGlucHV0QmV6aWVyLCBpKTtcbiAgICAgICAgbXVsdGlTZWdtZW50cy5wdXNoKG9mZnNldFNlZ21lbnRTcGxpdChzZWdtZW50LCBhbW91bnQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtdWx0aVNlZ21lbnRzID0gcHJ1bmVJbnRlcnNlY3Rpb25zKG11bHRpU2VnbWVudHMpOyAvLyBBZGQgYmV6aWVyIHNlZ21lbnRzIHRvIHRoZSBvdXRwdXQgYW5kIGFwcGx5IGxpbmUgam9pbnRzXG5cbiAgICB2YXIgbGFzdFBvaW50ID0gbnVsbDtcbiAgICB2YXIgbGFzdFNlZyA9IG51bGw7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbXVsdGlTZWdtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIG11bHRpU2VnbWVudCA9IG11bHRpU2VnbWVudHNbaV07XG4gICAgICBpZiAobGFzdFNlZykgbGFzdFBvaW50ID0gam9pbkxpbmVzKG91dHB1dEJlemllciwgbGFzdFNlZywgbXVsdGlTZWdtZW50WzBdLCBsaW5lSm9pbiwgbWl0ZXJMaW1pdCk7XG4gICAgICBsYXN0U2VnID0gbXVsdGlTZWdtZW50W211bHRpU2VnbWVudC5sZW5ndGggLSAxXTtcblxuICAgICAgZm9yIChqID0gMDsgaiA8IG11bHRpU2VnbWVudC5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICBzZWdtZW50ID0gbXVsdGlTZWdtZW50W2pdO1xuXG4gICAgICAgIGlmIChsYXN0UG9pbnQgJiYgcG9pbnRFcXVhbChzZWdtZW50LnBvaW50c1swXSwgbGFzdFBvaW50KSkge1xuICAgICAgICAgIG91dHB1dEJlemllci5zZXRYWUF0KHNlZ21lbnQucG9pbnRzWzFdWzBdLCBzZWdtZW50LnBvaW50c1sxXVsxXSwgJ28nLCBvdXRwdXRCZXppZXIubGVuZ3RoKCkgLSAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXRCZXppZXIuc2V0VHJpcGxlQXQoc2VnbWVudC5wb2ludHNbMF1bMF0sIHNlZ21lbnQucG9pbnRzWzBdWzFdLCBzZWdtZW50LnBvaW50c1sxXVswXSwgc2VnbWVudC5wb2ludHNbMV1bMV0sIHNlZ21lbnQucG9pbnRzWzBdWzBdLCBzZWdtZW50LnBvaW50c1swXVsxXSwgb3V0cHV0QmV6aWVyLmxlbmd0aCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dEJlemllci5zZXRUcmlwbGVBdChzZWdtZW50LnBvaW50c1szXVswXSwgc2VnbWVudC5wb2ludHNbM11bMV0sIHNlZ21lbnQucG9pbnRzWzNdWzBdLCBzZWdtZW50LnBvaW50c1szXVsxXSwgc2VnbWVudC5wb2ludHNbMl1bMF0sIHNlZ21lbnQucG9pbnRzWzJdWzFdLCBvdXRwdXRCZXppZXIubGVuZ3RoKCkpO1xuICAgICAgICBsYXN0UG9pbnQgPSBzZWdtZW50LnBvaW50c1szXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobXVsdGlTZWdtZW50cy5sZW5ndGgpIGpvaW5MaW5lcyhvdXRwdXRCZXppZXIsIGxhc3RTZWcsIG11bHRpU2VnbWVudHNbMF1bMF0sIGxpbmVKb2luLCBtaXRlckxpbWl0KTtcbiAgICByZXR1cm4gb3V0cHV0QmV6aWVyO1xuICB9O1xuXG4gIE9mZnNldFBhdGhNb2RpZmllci5wcm90b3R5cGUucHJvY2Vzc1NoYXBlcyA9IGZ1bmN0aW9uIChfaXNGaXJzdEZyYW1lKSB7XG4gICAgdmFyIHNoYXBlUGF0aHM7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuc2hhcGVzLmxlbmd0aDtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgYW1vdW50ID0gdGhpcy5hbW91bnQudjtcbiAgICB2YXIgbWl0ZXJMaW1pdCA9IHRoaXMubWl0ZXJMaW1pdC52O1xuICAgIHZhciBsaW5lSm9pbiA9IHRoaXMubGluZUpvaW47XG5cbiAgICBpZiAoYW1vdW50ICE9PSAwKSB7XG4gICAgICB2YXIgc2hhcGVEYXRhO1xuICAgICAgdmFyIGxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgc2hhcGVEYXRhID0gdGhpcy5zaGFwZXNbaV07XG4gICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuXG4gICAgICAgIGlmICghKCFzaGFwZURhdGEuc2hhcGUuX21kZiAmJiAhdGhpcy5fbWRmICYmICFfaXNGaXJzdEZyYW1lKSkge1xuICAgICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uLnJlbGVhc2VTaGFwZXMoKTtcbiAgICAgICAgICBzaGFwZURhdGEuc2hhcGUuX21kZiA9IHRydWU7XG4gICAgICAgICAgc2hhcGVQYXRocyA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5zaGFwZXM7XG4gICAgICAgICAgakxlbiA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5fbGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24uYWRkU2hhcGUodGhpcy5wcm9jZXNzUGF0aChzaGFwZVBhdGhzW2pdLCBhbW91bnQsIGxpbmVKb2luLCBtaXRlckxpbWl0KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2hhcGVEYXRhLnNoYXBlLnBhdGhzID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBnZXRGb250UHJvcGVydGllcyhmb250RGF0YSkge1xuICAgIHZhciBzdHlsZXMgPSBmb250RGF0YS5mU3R5bGUgPyBmb250RGF0YS5mU3R5bGUuc3BsaXQoJyAnKSA6IFtdO1xuICAgIHZhciBmV2VpZ2h0ID0gJ25vcm1hbCc7XG4gICAgdmFyIGZTdHlsZSA9ICdub3JtYWwnO1xuICAgIHZhciBsZW4gPSBzdHlsZXMubGVuZ3RoO1xuICAgIHZhciBzdHlsZU5hbWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBzdHlsZU5hbWUgPSBzdHlsZXNbaV0udG9Mb3dlckNhc2UoKTtcblxuICAgICAgc3dpdGNoIChzdHlsZU5hbWUpIHtcbiAgICAgICAgY2FzZSAnaXRhbGljJzpcbiAgICAgICAgICBmU3R5bGUgPSAnaXRhbGljJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdib2xkJzpcbiAgICAgICAgICBmV2VpZ2h0ID0gJzcwMCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnYmxhY2snOlxuICAgICAgICAgIGZXZWlnaHQgPSAnOTAwJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtZWRpdW0nOlxuICAgICAgICAgIGZXZWlnaHQgPSAnNTAwJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyZWd1bGFyJzpcbiAgICAgICAgY2FzZSAnbm9ybWFsJzpcbiAgICAgICAgICBmV2VpZ2h0ID0gJzQwMCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbGlnaHQnOlxuICAgICAgICBjYXNlICd0aGluJzpcbiAgICAgICAgICBmV2VpZ2h0ID0gJzIwMCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3R5bGU6IGZTdHlsZSxcbiAgICAgIHdlaWdodDogZm9udERhdGEuZldlaWdodCB8fCBmV2VpZ2h0XG4gICAgfTtcbiAgfVxuXG4gIHZhciBGb250TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWF4V2FpdGluZ1RpbWUgPSA1MDAwO1xuICAgIHZhciBlbXB0eUNoYXIgPSB7XG4gICAgICB3OiAwLFxuICAgICAgc2l6ZTogMCxcbiAgICAgIHNoYXBlczogW10sXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHNoYXBlczogW11cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBjb21iaW5lZENoYXJhY3RlcnMgPSBbXTsgLy8gSGluZGkgY2hhcmFjdGVyc1xuXG4gICAgY29tYmluZWRDaGFyYWN0ZXJzID0gY29tYmluZWRDaGFyYWN0ZXJzLmNvbmNhdChbMjMwNCwgMjMwNSwgMjMwNiwgMjMwNywgMjM2MiwgMjM2MywgMjM2NCwgMjM2NCwgMjM2NiwgMjM2NywgMjM2OCwgMjM2OSwgMjM3MCwgMjM3MSwgMjM3MiwgMjM3MywgMjM3NCwgMjM3NSwgMjM3NiwgMjM3NywgMjM3OCwgMjM3OSwgMjM4MCwgMjM4MSwgMjM4MiwgMjM4MywgMjM4NywgMjM4OCwgMjM4OSwgMjM5MCwgMjM5MSwgMjQwMiwgMjQwM10pO1xuICAgIHZhciBCTEFDS19GTEFHX0NPREVfUE9JTlQgPSAxMjc5ODg7XG4gICAgdmFyIENBTkNFTF9UQUdfQ09ERV9QT0lOVCA9IDkxNzYzMTtcbiAgICB2YXIgQV9UQUdfQ09ERV9QT0lOVCA9IDkxNzYwMTtcbiAgICB2YXIgWl9UQUdfQ09ERV9QT0lOVCA9IDkxNzYyNjtcbiAgICB2YXIgVkFSSUFUSU9OX1NFTEVDVE9SXzE2X0NPREVfUE9JTlQgPSA2NTAzOTtcbiAgICB2YXIgWkVST19XSURUSF9KT0lORVJfQ09ERV9QT0lOVCA9IDgyMDU7XG4gICAgdmFyIFJFR0lPTkFMX0NIQVJBQ1RFUl9BX0NPREVfUE9JTlQgPSAxMjc0NjI7XG4gICAgdmFyIFJFR0lPTkFMX0NIQVJBQ1RFUl9aX0NPREVfUE9JTlQgPSAxMjc0ODc7XG4gICAgdmFyIHN1cnJvZ2F0ZU1vZGlmaWVycyA9IFsnZDgzY2RmZmInLCAnZDgzY2RmZmMnLCAnZDgzY2RmZmQnLCAnZDgzY2RmZmUnLCAnZDgzY2RmZmYnXTtcblxuICAgIGZ1bmN0aW9uIHRyaW1Gb250T3B0aW9ucyhmb250KSB7XG4gICAgICB2YXIgZmFtaWx5QXJyYXkgPSBmb250LnNwbGl0KCcsJyk7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBmYW1pbHlBcnJheS5sZW5ndGg7XG4gICAgICB2YXIgZW5hYmxlZEZhbWlsaWVzID0gW107XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoZmFtaWx5QXJyYXlbaV0gIT09ICdzYW5zLXNlcmlmJyAmJiBmYW1pbHlBcnJheVtpXSAhPT0gJ21vbm9zcGFjZScpIHtcbiAgICAgICAgICBlbmFibGVkRmFtaWxpZXMucHVzaChmYW1pbHlBcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVuYWJsZWRGYW1pbGllcy5qb2luKCcsJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0VXBOb2RlKGZvbnQsIGZhbWlseSkge1xuICAgICAgdmFyIHBhcmVudE5vZGUgPSBjcmVhdGVUYWcoJ3NwYW4nKTsgLy8gTm9kZSBpcyBpbnZpc2libGUgdG8gc2NyZWVuIHJlYWRlcnMuXG5cbiAgICAgIHBhcmVudE5vZGUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuICAgICAgcGFyZW50Tm9kZS5zdHlsZS5mb250RmFtaWx5ID0gZmFtaWx5O1xuICAgICAgdmFyIG5vZGUgPSBjcmVhdGVUYWcoJ3NwYW4nKTsgLy8gQ2hhcmFjdGVycyB0aGF0IHZhcnkgc2lnbmlmaWNhbnRseSBhbW9uZyBkaWZmZXJlbnQgZm9udHNcblxuICAgICAgbm9kZS5pbm5lclRleHQgPSAnZ2lJdFQxV1F5QCEtLyMnOyAvLyBWaXNpYmxlIC0gc28gd2UgY2FuIG1lYXN1cmUgaXQgLSBidXQgbm90IG9uIHRoZSBzY3JlZW5cblxuICAgICAgcGFyZW50Tm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBwYXJlbnROb2RlLnN0eWxlLmxlZnQgPSAnLTEwMDAwcHgnO1xuICAgICAgcGFyZW50Tm9kZS5zdHlsZS50b3AgPSAnLTEwMDAwcHgnOyAvLyBMYXJnZSBmb250IHNpemUgbWFrZXMgZXZlbiBzdWJ0bGUgY2hhbmdlcyBvYnZpb3VzXG5cbiAgICAgIHBhcmVudE5vZGUuc3R5bGUuZm9udFNpemUgPSAnMzAwcHgnOyAvLyBSZXNldCBhbnkgZm9udCBwcm9wZXJ0aWVzXG5cbiAgICAgIHBhcmVudE5vZGUuc3R5bGUuZm9udFZhcmlhbnQgPSAnbm9ybWFsJztcbiAgICAgIHBhcmVudE5vZGUuc3R5bGUuZm9udFN0eWxlID0gJ25vcm1hbCc7XG4gICAgICBwYXJlbnROb2RlLnN0eWxlLmZvbnRXZWlnaHQgPSAnbm9ybWFsJztcbiAgICAgIHBhcmVudE5vZGUuc3R5bGUubGV0dGVyU3BhY2luZyA9ICcwJztcbiAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHBhcmVudE5vZGUpOyAvLyBSZW1lbWJlciB3aWR0aCB3aXRoIG5vIGFwcGxpZWQgd2ViIGZvbnRcblxuICAgICAgdmFyIHdpZHRoID0gbm9kZS5vZmZzZXRXaWR0aDtcbiAgICAgIG5vZGUuc3R5bGUuZm9udEZhbWlseSA9IHRyaW1Gb250T3B0aW9ucyhmb250KSArICcsICcgKyBmYW1pbHk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICB3OiB3aWR0aCxcbiAgICAgICAgcGFyZW50OiBwYXJlbnROb2RlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrTG9hZGVkRm9udHMoKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmZvbnRzLmxlbmd0aDtcbiAgICAgIHZhciBub2RlO1xuICAgICAgdmFyIHc7XG4gICAgICB2YXIgbG9hZGVkQ291bnQgPSBsZW47XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAodGhpcy5mb250c1tpXS5sb2FkZWQpIHtcbiAgICAgICAgICBsb2FkZWRDb3VudCAtPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZm9udHNbaV0uZk9yaWdpbiA9PT0gJ24nIHx8IHRoaXMuZm9udHNbaV0ub3JpZ2luID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5mb250c1tpXS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLmZvbnRzW2ldLm1vbm9DYXNlLm5vZGU7XG4gICAgICAgICAgdyA9IHRoaXMuZm9udHNbaV0ubW9ub0Nhc2UudztcblxuICAgICAgICAgIGlmIChub2RlLm9mZnNldFdpZHRoICE9PSB3KSB7XG4gICAgICAgICAgICBsb2FkZWRDb3VudCAtPSAxO1xuICAgICAgICAgICAgdGhpcy5mb250c1tpXS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5mb250c1tpXS5zYW5zQ2FzZS5ub2RlO1xuICAgICAgICAgICAgdyA9IHRoaXMuZm9udHNbaV0uc2Fuc0Nhc2UudztcblxuICAgICAgICAgICAgaWYgKG5vZGUub2Zmc2V0V2lkdGggIT09IHcpIHtcbiAgICAgICAgICAgICAgbG9hZGVkQ291bnQgLT0gMTtcbiAgICAgICAgICAgICAgdGhpcy5mb250c1tpXS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLmZvbnRzW2ldLmxvYWRlZCkge1xuICAgICAgICAgICAgdGhpcy5mb250c1tpXS5zYW5zQ2FzZS5wYXJlbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZvbnRzW2ldLnNhbnNDYXNlLnBhcmVudCk7XG4gICAgICAgICAgICB0aGlzLmZvbnRzW2ldLm1vbm9DYXNlLnBhcmVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9udHNbaV0ubW9ub0Nhc2UucGFyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGxvYWRlZENvdW50ICE9PSAwICYmIERhdGUubm93KCkgLSB0aGlzLmluaXRUaW1lIDwgbWF4V2FpdGluZ1RpbWUpIHtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLmNoZWNrTG9hZGVkRm9udHNCaW5kZWQsIDIwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5zZXRJc0xvYWRlZEJpbmRlZCwgMTApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUhlbHBlcihmb250RGF0YSwgZGVmKSB7XG4gICAgICB2YXIgZW5naW5lID0gZG9jdW1lbnQuYm9keSAmJiBkZWYgPyAnc3ZnJyA6ICdjYW52YXMnO1xuICAgICAgdmFyIGhlbHBlcjtcbiAgICAgIHZhciBmb250UHJvcHMgPSBnZXRGb250UHJvcGVydGllcyhmb250RGF0YSk7XG5cbiAgICAgIGlmIChlbmdpbmUgPT09ICdzdmcnKSB7XG4gICAgICAgIHZhciB0SGVscGVyID0gY3JlYXRlTlMoJ3RleHQnKTtcbiAgICAgICAgdEhlbHBlci5zdHlsZS5mb250U2l6ZSA9ICcxMDBweCc7IC8vIHRIZWxwZXIuc3R5bGUuZm9udEZhbWlseSA9IGZvbnREYXRhLmZGYW1pbHk7XG5cbiAgICAgICAgdEhlbHBlci5zZXRBdHRyaWJ1dGUoJ2ZvbnQtZmFtaWx5JywgZm9udERhdGEuZkZhbWlseSk7XG4gICAgICAgIHRIZWxwZXIuc2V0QXR0cmlidXRlKCdmb250LXN0eWxlJywgZm9udFByb3BzLnN0eWxlKTtcbiAgICAgICAgdEhlbHBlci5zZXRBdHRyaWJ1dGUoJ2ZvbnQtd2VpZ2h0JywgZm9udFByb3BzLndlaWdodCk7XG4gICAgICAgIHRIZWxwZXIudGV4dENvbnRlbnQgPSAnMSc7XG5cbiAgICAgICAgaWYgKGZvbnREYXRhLmZDbGFzcykge1xuICAgICAgICAgIHRIZWxwZXIuc3R5bGUuZm9udEZhbWlseSA9ICdpbmhlcml0JztcbiAgICAgICAgICB0SGVscGVyLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBmb250RGF0YS5mQ2xhc3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRIZWxwZXIuc3R5bGUuZm9udEZhbWlseSA9IGZvbnREYXRhLmZGYW1pbHk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWYuYXBwZW5kQ2hpbGQodEhlbHBlcik7XG4gICAgICAgIGhlbHBlciA9IHRIZWxwZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdENhbnZhc0hlbHBlciA9IG5ldyBPZmZzY3JlZW5DYW52YXMoNTAwLCA1MDApLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHRDYW52YXNIZWxwZXIuZm9udCA9IGZvbnRQcm9wcy5zdHlsZSArICcgJyArIGZvbnRQcm9wcy53ZWlnaHQgKyAnIDEwMHB4ICcgKyBmb250RGF0YS5mRmFtaWx5O1xuICAgICAgICBoZWxwZXIgPSB0Q2FudmFzSGVscGVyO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtZWFzdXJlKHRleHQpIHtcbiAgICAgICAgaWYgKGVuZ2luZSA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICBoZWxwZXIudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICAgIHJldHVybiBoZWxwZXIuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGVscGVyLm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZWFzdXJlVGV4dDogbWVhc3VyZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRGb250cyhmb250RGF0YSwgZGVmcykge1xuICAgICAgaWYgKCFmb250RGF0YSkge1xuICAgICAgICB0aGlzLmlzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jaGFycykge1xuICAgICAgICB0aGlzLmlzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5mb250cyA9IGZvbnREYXRhLmxpc3Q7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIHRoaXMuaXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICBmb250RGF0YS5saXN0LmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICBkYXRhLmhlbHBlciA9IGNyZWF0ZUhlbHBlcihkYXRhKTtcbiAgICAgICAgICBkYXRhLmNhY2hlID0ge307XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZvbnRzID0gZm9udERhdGEubGlzdDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZm9udEFyciA9IGZvbnREYXRhLmxpc3Q7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBmb250QXJyLmxlbmd0aDtcbiAgICAgIHZhciBfcGVuZGluZ0ZvbnRzID0gbGVuO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHNob3VsZExvYWRGb250ID0gdHJ1ZTtcbiAgICAgICAgdmFyIGxvYWRlZFNlbGVjdG9yO1xuICAgICAgICB2YXIgajtcbiAgICAgICAgZm9udEFycltpXS5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgZm9udEFycltpXS5tb25vQ2FzZSA9IHNldFVwTm9kZShmb250QXJyW2ldLmZGYW1pbHksICdtb25vc3BhY2UnKTtcbiAgICAgICAgZm9udEFycltpXS5zYW5zQ2FzZSA9IHNldFVwTm9kZShmb250QXJyW2ldLmZGYW1pbHksICdzYW5zLXNlcmlmJyk7XG5cbiAgICAgICAgaWYgKCFmb250QXJyW2ldLmZQYXRoKSB7XG4gICAgICAgICAgZm9udEFycltpXS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgIF9wZW5kaW5nRm9udHMgLT0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChmb250QXJyW2ldLmZPcmlnaW4gPT09ICdwJyB8fCBmb250QXJyW2ldLm9yaWdpbiA9PT0gMykge1xuICAgICAgICAgIGxvYWRlZFNlbGVjdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGVbZi1mb3JpZ2luPVwicFwiXVtmLWZhbWlseT1cIicgKyBmb250QXJyW2ldLmZGYW1pbHkgKyAnXCJdLCBzdHlsZVtmLW9yaWdpbj1cIjNcIl1bZi1mYW1pbHk9XCInICsgZm9udEFycltpXS5mRmFtaWx5ICsgJ1wiXScpO1xuXG4gICAgICAgICAgaWYgKGxvYWRlZFNlbGVjdG9yLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNob3VsZExvYWRGb250ID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNob3VsZExvYWRGb250KSB7XG4gICAgICAgICAgICB2YXIgcyA9IGNyZWF0ZVRhZygnc3R5bGUnKTtcbiAgICAgICAgICAgIHMuc2V0QXR0cmlidXRlKCdmLWZvcmlnaW4nLCBmb250QXJyW2ldLmZPcmlnaW4pO1xuICAgICAgICAgICAgcy5zZXRBdHRyaWJ1dGUoJ2Ytb3JpZ2luJywgZm9udEFycltpXS5vcmlnaW4pO1xuICAgICAgICAgICAgcy5zZXRBdHRyaWJ1dGUoJ2YtZmFtaWx5JywgZm9udEFycltpXS5mRmFtaWx5KTtcbiAgICAgICAgICAgIHMudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgICAgICAgICBzLmlubmVyVGV4dCA9ICdAZm9udC1mYWNlIHtmb250LWZhbWlseTogJyArIGZvbnRBcnJbaV0uZkZhbWlseSArIFwiOyBmb250LXN0eWxlOiBub3JtYWw7IHNyYzogdXJsKCdcIiArIGZvbnRBcnJbaV0uZlBhdGggKyBcIicpO31cIjtcbiAgICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQocyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZvbnRBcnJbaV0uZk9yaWdpbiA9PT0gJ2cnIHx8IGZvbnRBcnJbaV0ub3JpZ2luID09PSAxKSB7XG4gICAgICAgICAgbG9hZGVkU2VsZWN0b3IgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdsaW5rW2YtZm9yaWdpbj1cImdcIl0sIGxpbmtbZi1vcmlnaW49XCIxXCJdJyk7XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbG9hZGVkU2VsZWN0b3IubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChsb2FkZWRTZWxlY3RvcltqXS5ocmVmLmluZGV4T2YoZm9udEFycltpXS5mUGF0aCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgIC8vIEZvbnQgaXMgYWxyZWFkeSBsb2FkZWRcbiAgICAgICAgICAgICAgc2hvdWxkTG9hZEZvbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2hvdWxkTG9hZEZvbnQpIHtcbiAgICAgICAgICAgIHZhciBsID0gY3JlYXRlVGFnKCdsaW5rJyk7XG4gICAgICAgICAgICBsLnNldEF0dHJpYnV0ZSgnZi1mb3JpZ2luJywgZm9udEFycltpXS5mT3JpZ2luKTtcbiAgICAgICAgICAgIGwuc2V0QXR0cmlidXRlKCdmLW9yaWdpbicsIGZvbnRBcnJbaV0ub3JpZ2luKTtcbiAgICAgICAgICAgIGwudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgICAgICAgICBsLnJlbCA9ICdzdHlsZXNoZWV0JztcbiAgICAgICAgICAgIGwuaHJlZiA9IGZvbnRBcnJbaV0uZlBhdGg7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmb250QXJyW2ldLmZPcmlnaW4gPT09ICd0JyB8fCBmb250QXJyW2ldLm9yaWdpbiA9PT0gMikge1xuICAgICAgICAgIGxvYWRlZFNlbGVjdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc2NyaXB0W2YtZm9yaWdpbj1cInRcIl0sIHNjcmlwdFtmLW9yaWdpbj1cIjJcIl0nKTtcblxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsb2FkZWRTZWxlY3Rvci5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgaWYgKGZvbnRBcnJbaV0uZlBhdGggPT09IGxvYWRlZFNlbGVjdG9yW2pdLnNyYykge1xuICAgICAgICAgICAgICAvLyBGb250IGlzIGFscmVhZHkgbG9hZGVkXG4gICAgICAgICAgICAgIHNob3VsZExvYWRGb250ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNob3VsZExvYWRGb250KSB7XG4gICAgICAgICAgICB2YXIgc2MgPSBjcmVhdGVUYWcoJ2xpbmsnKTtcbiAgICAgICAgICAgIHNjLnNldEF0dHJpYnV0ZSgnZi1mb3JpZ2luJywgZm9udEFycltpXS5mT3JpZ2luKTtcbiAgICAgICAgICAgIHNjLnNldEF0dHJpYnV0ZSgnZi1vcmlnaW4nLCBmb250QXJyW2ldLm9yaWdpbik7XG4gICAgICAgICAgICBzYy5zZXRBdHRyaWJ1dGUoJ3JlbCcsICdzdHlsZXNoZWV0Jyk7XG4gICAgICAgICAgICBzYy5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBmb250QXJyW2ldLmZQYXRoKTtcbiAgICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoc2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvbnRBcnJbaV0uaGVscGVyID0gY3JlYXRlSGVscGVyKGZvbnRBcnJbaV0sIGRlZnMpO1xuICAgICAgICBmb250QXJyW2ldLmNhY2hlID0ge307XG4gICAgICAgIHRoaXMuZm9udHMucHVzaChmb250QXJyW2ldKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9wZW5kaW5nRm9udHMgPT09IDApIHtcbiAgICAgICAgdGhpcy5pc0xvYWRlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPbiBzb21lIGNhc2VzIGV2ZW4gaWYgdGhlIGZvbnQgaXMgbG9hZGVkLCBpdCB3b24ndCBsb2FkIGNvcnJlY3RseSB3aGVuIG1lYXN1cmluZyB0ZXh0IG9uIGNhbnZhcy5cbiAgICAgICAgLy8gQWRkaW5nIHRoaXMgdGltZW91dCBzZWVtcyB0byBmaXggaXRcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLmNoZWNrTG9hZGVkRm9udHMuYmluZCh0aGlzKSwgMTAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRDaGFycyhjaGFycykge1xuICAgICAgaWYgKCFjaGFycykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5jaGFycykge1xuICAgICAgICB0aGlzLmNoYXJzID0gW107XG4gICAgICB9XG5cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IGNoYXJzLmxlbmd0aDtcbiAgICAgIHZhciBqO1xuICAgICAgdmFyIGpMZW4gPSB0aGlzLmNoYXJzLmxlbmd0aDtcbiAgICAgIHZhciBmb3VuZDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGogPSAwO1xuICAgICAgICBmb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgIHdoaWxlIChqIDwgakxlbikge1xuICAgICAgICAgIGlmICh0aGlzLmNoYXJzW2pdLnN0eWxlID09PSBjaGFyc1tpXS5zdHlsZSAmJiB0aGlzLmNoYXJzW2pdLmZGYW1pbHkgPT09IGNoYXJzW2ldLmZGYW1pbHkgJiYgdGhpcy5jaGFyc1tqXS5jaCA9PT0gY2hhcnNbaV0uY2gpIHtcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBqICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgdGhpcy5jaGFycy5wdXNoKGNoYXJzW2ldKTtcbiAgICAgICAgICBqTGVuICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDaGFyRGF0YShfY2hhciwgc3R5bGUsIGZvbnQpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmNoYXJzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuY2hhcnNbaV0uY2ggPT09IF9jaGFyICYmIHRoaXMuY2hhcnNbaV0uc3R5bGUgPT09IHN0eWxlICYmIHRoaXMuY2hhcnNbaV0uZkZhbWlseSA9PT0gZm9udCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNoYXJzW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoKHR5cGVvZiBfY2hhciA9PT0gJ3N0cmluZycgJiYgX2NoYXIuY2hhckNvZGVBdCgwKSAhPT0gMTMgfHwgIV9jaGFyKSAmJiBjb25zb2xlICYmIGNvbnNvbGUud2FybiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgICYmICF0aGlzLl93YXJuZWQpIHtcbiAgICAgICAgdGhpcy5fd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS53YXJuKCdNaXNzaW5nIGNoYXJhY3RlciBmcm9tIGV4cG9ydGVkIGNoYXJhY3RlcnMgbGlzdDogJywgX2NoYXIsIHN0eWxlLCBmb250KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbXB0eUNoYXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVhc3VyZVRleHQoX2NoYXIyLCBmb250TmFtZSwgc2l6ZSkge1xuICAgICAgdmFyIGZvbnREYXRhID0gdGhpcy5nZXRGb250QnlOYW1lKGZvbnROYW1lKTsgLy8gVXNpbmcgdGhlIGNoYXIgaW5zdGVhZCBvZiBjaGFyLmNoYXJDb2RlQXQoMClcbiAgICAgIC8vIHRvIGF2b2lkIGNvbGxpc2lvbnMgYmV0d2VlbiBlcXVhbCBjaGFyc1xuXG4gICAgICB2YXIgaW5kZXggPSBfY2hhcjI7XG5cbiAgICAgIGlmICghZm9udERhdGEuY2FjaGVbaW5kZXhdKSB7XG4gICAgICAgIHZhciB0SGVscGVyID0gZm9udERhdGEuaGVscGVyO1xuXG4gICAgICAgIGlmIChfY2hhcjIgPT09ICcgJykge1xuICAgICAgICAgIHZhciBkb3VibGVTaXplID0gdEhlbHBlci5tZWFzdXJlVGV4dCgnfCcgKyBfY2hhcjIgKyAnfCcpO1xuICAgICAgICAgIHZhciBzaW5nbGVTaXplID0gdEhlbHBlci5tZWFzdXJlVGV4dCgnfHwnKTtcbiAgICAgICAgICBmb250RGF0YS5jYWNoZVtpbmRleF0gPSAoZG91YmxlU2l6ZSAtIHNpbmdsZVNpemUpIC8gMTAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvbnREYXRhLmNhY2hlW2luZGV4XSA9IHRIZWxwZXIubWVhc3VyZVRleHQoX2NoYXIyKSAvIDEwMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm9udERhdGEuY2FjaGVbaW5kZXhdICogc2l6ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRGb250QnlOYW1lKG5hbWUpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmZvbnRzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuZm9udHNbaV0uZk5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mb250c1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZm9udHNbMF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q29kZVBvaW50KHN0cmluZykge1xuICAgICAgdmFyIGNvZGVQb2ludCA9IDA7XG4gICAgICB2YXIgZmlyc3QgPSBzdHJpbmcuY2hhckNvZGVBdCgwKTtcblxuICAgICAgaWYgKGZpcnN0ID49IDB4RDgwMCAmJiBmaXJzdCA8PSAweERCRkYpIHtcbiAgICAgICAgdmFyIHNlY29uZCA9IHN0cmluZy5jaGFyQ29kZUF0KDEpO1xuXG4gICAgICAgIGlmIChzZWNvbmQgPj0gMHhEQzAwICYmIHNlY29uZCA8PSAweERGRkYpIHtcbiAgICAgICAgICBjb2RlUG9pbnQgPSAoZmlyc3QgLSAweEQ4MDApICogMHg0MDAgKyBzZWNvbmQgLSAweERDMDAgKyAweDEwMDAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2RlUG9pbnQ7XG4gICAgfSAvLyBTa2luIHRvbmUgbW9kaWZpZXJzXG5cblxuICAgIGZ1bmN0aW9uIGlzTW9kaWZpZXIoZmlyc3RDaGFyQ29kZSwgc2Vjb25kQ2hhckNvZGUpIHtcbiAgICAgIHZhciBzdW0gPSBmaXJzdENoYXJDb2RlLnRvU3RyaW5nKDE2KSArIHNlY29uZENoYXJDb2RlLnRvU3RyaW5nKDE2KTtcbiAgICAgIHJldHVybiBzdXJyb2dhdGVNb2RpZmllcnMuaW5kZXhPZihzdW0pICE9PSAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1plcm9XaWR0aEpvaW5lcihjaGFyQ29kZSkge1xuICAgICAgcmV0dXJuIGNoYXJDb2RlID09PSBaRVJPX1dJRFRIX0pPSU5FUl9DT0RFX1BPSU5UO1xuICAgIH0gLy8gVGhpcyBjb2RlcG9pbnQgbWF5IGNoYW5nZSB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgcHJlY2VkaW5nIGNoYXJhY3Rlci5cbiAgICAvLyBJZiB0aGF0IGlzIGEgc3ltYm9sLCBkaW5nYmF0IG9yIGVtb2ppLCBVK0ZFMEYgZm9yY2VzIGl0IHRvIGJlIHJlbmRlcmVkXG4gICAgLy8gYXMgYSBjb2xvcmZ1bCBpbWFnZSBhcyBjb21wYXJlZCB0byBhIG1vbm9jaHJvbWUgdGV4dCB2YXJpYW50LlxuXG5cbiAgICBmdW5jdGlvbiBpc1ZhcmlhdGlvblNlbGVjdG9yKGNoYXJDb2RlKSB7XG4gICAgICByZXR1cm4gY2hhckNvZGUgPT09IFZBUklBVElPTl9TRUxFQ1RPUl8xNl9DT0RFX1BPSU5UO1xuICAgIH0gLy8gVGhlIHJlZ2lvbmFsIGluZGljYXRvciBzeW1ib2xzIGFyZSBhIHNldCBvZiAyNiBhbHBoYWJldGljIFVuaWNvZGVcbiAgICAvLy8gY2hhcmFjdGVycyAoQeKAk1opIGludGVuZGVkIHRvIGJlIHVzZWQgdG8gZW5jb2RlIElTTyAzMTY2LTEgYWxwaGEtMlxuICAgIC8vIHR3by1sZXR0ZXIgY291bnRyeSBjb2RlcyBpbiBhIHdheSB0aGF0IGFsbG93cyBvcHRpb25hbCBzcGVjaWFsIHRyZWF0bWVudC5cblxuXG4gICAgZnVuY3Rpb24gaXNSZWdpb25hbENvZGUoc3RyaW5nKSB7XG4gICAgICB2YXIgY29kZVBvaW50ID0gZ2V0Q29kZVBvaW50KHN0cmluZyk7XG5cbiAgICAgIGlmIChjb2RlUG9pbnQgPj0gUkVHSU9OQUxfQ0hBUkFDVEVSX0FfQ09ERV9QT0lOVCAmJiBjb2RlUG9pbnQgPD0gUkVHSU9OQUxfQ0hBUkFDVEVSX1pfQ09ERV9QT0lOVCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gU29tZSBFbW9qaSBpbXBsZW1lbnRhdGlvbnMgcmVwcmVzZW50IGNvbWJpbmF0aW9ucyBvZlxuICAgIC8vIHR3byDigJxyZWdpb25hbCBpbmRpY2F0b3LigJ0gbGV0dGVycyBhcyBhIHNpbmdsZSBmbGFnIHN5bWJvbC5cblxuXG4gICAgZnVuY3Rpb24gaXNGbGFnRW1vamkoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gaXNSZWdpb25hbENvZGUoc3RyaW5nLnN1YnN0cigwLCAyKSkgJiYgaXNSZWdpb25hbENvZGUoc3RyaW5nLnN1YnN0cigyLCAyKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNDb21iaW5lZENoYXJhY3RlcihfY2hhcjMpIHtcbiAgICAgIHJldHVybiBjb21iaW5lZENoYXJhY3RlcnMuaW5kZXhPZihfY2hhcjMpICE9PSAtMTtcbiAgICB9IC8vIFJlZ2lvbmFsIGZsYWdzIHN0YXJ0IHdpdGggYSBCTEFDS19GTEFHX0NPREVfUE9JTlRcbiAgICAvLyBmb2xvd2VkIGJ5IDUgY2hhcnMgaW4gdGhlIFRBRyByYW5nZVxuICAgIC8vIGFuZCBlbmQgd2l0aCBhIENBTkNFTF9UQUdfQ09ERV9QT0lOVFxuXG5cbiAgICBmdW5jdGlvbiBpc1JlZ2lvbmFsRmxhZyh0ZXh0LCBpbmRleCkge1xuICAgICAgdmFyIGNvZGVQb2ludCA9IGdldENvZGVQb2ludCh0ZXh0LnN1YnN0cihpbmRleCwgMikpO1xuXG4gICAgICBpZiAoY29kZVBvaW50ICE9PSBCTEFDS19GTEFHX0NPREVfUE9JTlQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgaW5kZXggKz0gMjtcblxuICAgICAgd2hpbGUgKGNvdW50IDwgNSkge1xuICAgICAgICBjb2RlUG9pbnQgPSBnZXRDb2RlUG9pbnQodGV4dC5zdWJzdHIoaW5kZXgsIDIpKTtcblxuICAgICAgICBpZiAoY29kZVBvaW50IDwgQV9UQUdfQ09ERV9QT0lOVCB8fCBjb2RlUG9pbnQgPiBaX1RBR19DT0RFX1BPSU5UKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldENvZGVQb2ludCh0ZXh0LnN1YnN0cihpbmRleCwgMikpID09PSBDQU5DRUxfVEFHX0NPREVfUE9JTlQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0SXNMb2FkZWQoKSB7XG4gICAgICB0aGlzLmlzTG9hZGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgRm9udCA9IGZ1bmN0aW9uIEZvbnQoKSB7XG4gICAgICB0aGlzLmZvbnRzID0gW107XG4gICAgICB0aGlzLmNoYXJzID0gbnVsbDtcbiAgICAgIHRoaXMudHlwZWtpdExvYWRlZCA9IDA7XG4gICAgICB0aGlzLmlzTG9hZGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl93YXJuZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaW5pdFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgdGhpcy5zZXRJc0xvYWRlZEJpbmRlZCA9IHRoaXMuc2V0SXNMb2FkZWQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuY2hlY2tMb2FkZWRGb250c0JpbmRlZCA9IHRoaXMuY2hlY2tMb2FkZWRGb250cy5iaW5kKHRoaXMpO1xuICAgIH07XG5cbiAgICBGb250LmlzTW9kaWZpZXIgPSBpc01vZGlmaWVyO1xuICAgIEZvbnQuaXNaZXJvV2lkdGhKb2luZXIgPSBpc1plcm9XaWR0aEpvaW5lcjtcbiAgICBGb250LmlzRmxhZ0Vtb2ppID0gaXNGbGFnRW1vamk7XG4gICAgRm9udC5pc1JlZ2lvbmFsQ29kZSA9IGlzUmVnaW9uYWxDb2RlO1xuICAgIEZvbnQuaXNDb21iaW5lZENoYXJhY3RlciA9IGlzQ29tYmluZWRDaGFyYWN0ZXI7XG4gICAgRm9udC5pc1JlZ2lvbmFsRmxhZyA9IGlzUmVnaW9uYWxGbGFnO1xuICAgIEZvbnQuaXNWYXJpYXRpb25TZWxlY3RvciA9IGlzVmFyaWF0aW9uU2VsZWN0b3I7XG4gICAgRm9udC5CTEFDS19GTEFHX0NPREVfUE9JTlQgPSBCTEFDS19GTEFHX0NPREVfUE9JTlQ7XG4gICAgdmFyIGZvbnRQcm90b3R5cGUgPSB7XG4gICAgICBhZGRDaGFyczogYWRkQ2hhcnMsXG4gICAgICBhZGRGb250czogYWRkRm9udHMsXG4gICAgICBnZXRDaGFyRGF0YTogZ2V0Q2hhckRhdGEsXG4gICAgICBnZXRGb250QnlOYW1lOiBnZXRGb250QnlOYW1lLFxuICAgICAgbWVhc3VyZVRleHQ6IG1lYXN1cmVUZXh0LFxuICAgICAgY2hlY2tMb2FkZWRGb250czogY2hlY2tMb2FkZWRGb250cyxcbiAgICAgIHNldElzTG9hZGVkOiBzZXRJc0xvYWRlZFxuICAgIH07XG4gICAgRm9udC5wcm90b3R5cGUgPSBmb250UHJvdG90eXBlO1xuICAgIHJldHVybiBGb250O1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gU2xvdE1hbmFnZXIoYW5pbWF0aW9uRGF0YSkge1xuICAgIHRoaXMuYW5pbWF0aW9uRGF0YSA9IGFuaW1hdGlvbkRhdGE7XG4gIH1cblxuICBTbG90TWFuYWdlci5wcm90b3R5cGUuZ2V0UHJvcCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uRGF0YS5zbG90cyAmJiB0aGlzLmFuaW1hdGlvbkRhdGEuc2xvdHNbZGF0YS5zaWRdKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkYXRhLCB0aGlzLmFuaW1hdGlvbkRhdGEuc2xvdHNbZGF0YS5zaWRdLnApO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNsb3RGYWN0b3J5KGFuaW1hdGlvbkRhdGEpIHtcbiAgICByZXR1cm4gbmV3IFNsb3RNYW5hZ2VyKGFuaW1hdGlvbkRhdGEpO1xuICB9XG5cbiAgZnVuY3Rpb24gUmVuZGVyYWJsZUVsZW1lbnQoKSB7fVxuXG4gIFJlbmRlcmFibGVFbGVtZW50LnByb3RvdHlwZSA9IHtcbiAgICBpbml0UmVuZGVyYWJsZTogZnVuY3Rpb24gaW5pdFJlbmRlcmFibGUoKSB7XG4gICAgICAvLyBsYXllcidzIHZpc2liaWxpdHkgcmVsYXRlZCB0byBpbnBvaW50IGFuZCBvdXRwb2ludC4gUmVuYW1lIGlzVmlzaWJsZSB0byBpc0luUmFuZ2VcbiAgICAgIHRoaXMuaXNJblJhbmdlID0gZmFsc2U7IC8vIGxheWVyJ3MgZGlzcGxheSBzdGF0ZVxuXG4gICAgICB0aGlzLmhpZGRlbiA9IGZhbHNlOyAvLyBJZiBsYXllcidzIHRyYW5zcGFyZW5jeSBlcXVhbHMgMCwgaXQgY2FuIGJlIGhpZGRlblxuXG4gICAgICB0aGlzLmlzVHJhbnNwYXJlbnQgPSBmYWxzZTsgLy8gbGlzdCBvZiBhbmltYXRlZCBjb21wb25lbnRzXG5cbiAgICAgIHRoaXMucmVuZGVyYWJsZUNvbXBvbmVudHMgPSBbXTtcbiAgICB9LFxuICAgIGFkZFJlbmRlcmFibGVDb21wb25lbnQ6IGZ1bmN0aW9uIGFkZFJlbmRlcmFibGVDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50cy5pbmRleE9mKGNvbXBvbmVudCkgPT09IC0xKSB7XG4gICAgICAgIHRoaXMucmVuZGVyYWJsZUNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlUmVuZGVyYWJsZUNvbXBvbmVudDogZnVuY3Rpb24gcmVtb3ZlUmVuZGVyYWJsZUNvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlcmFibGVDb21wb25lbnRzLmluZGV4T2YoY29tcG9uZW50KSAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50cy5zcGxpY2UodGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50cy5pbmRleE9mKGNvbXBvbmVudCksIDEpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJlcGFyZVJlbmRlcmFibGVGcmFtZTogZnVuY3Rpb24gcHJlcGFyZVJlbmRlcmFibGVGcmFtZShudW0pIHtcbiAgICAgIHRoaXMuY2hlY2tMYXllckxpbWl0cyhudW0pO1xuICAgIH0sXG4gICAgY2hlY2tUcmFuc3BhcmVuY3k6IGZ1bmN0aW9uIGNoZWNrVHJhbnNwYXJlbmN5KCkge1xuICAgICAgaWYgKHRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3Auby52IDw9IDApIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVHJhbnNwYXJlbnQgJiYgdGhpcy5nbG9iYWxEYXRhLnJlbmRlckNvbmZpZy5oaWRlT25UcmFuc3BhcmVudCkge1xuICAgICAgICAgIHRoaXMuaXNUcmFuc3BhcmVudCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1RyYW5zcGFyZW50KSB7XG4gICAgICAgIHRoaXMuaXNUcmFuc3BhcmVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKiBJbml0aWFsaXplcyBmcmFtZSByZWxhdGVkIHByb3BlcnRpZXMuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1cclxuICAgICAgICogY3VycmVudCBmcmFtZSBudW1iZXIgaW4gTGF5ZXIncyB0aW1lXHJcbiAgICAgICAqXHJcbiAgICAgICAqL1xuICAgIGNoZWNrTGF5ZXJMaW1pdHM6IGZ1bmN0aW9uIGNoZWNrTGF5ZXJMaW1pdHMobnVtKSB7XG4gICAgICBpZiAodGhpcy5kYXRhLmlwIC0gdGhpcy5kYXRhLnN0IDw9IG51bSAmJiB0aGlzLmRhdGEub3AgLSB0aGlzLmRhdGEuc3QgPiBudW0pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNJblJhbmdlICE9PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLl9tZGYgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuX21kZiA9IHRydWU7XG4gICAgICAgICAgdGhpcy5pc0luUmFuZ2UgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNJblJhbmdlICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmdsb2JhbERhdGEuX21kZiA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNJblJhbmdlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyUmVuZGVyYWJsZTogZnVuY3Rpb24gcmVuZGVyUmVuZGVyYWJsZSgpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMucmVuZGVyYWJsZUNvbXBvbmVudHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50c1tpXS5yZW5kZXJGcmFtZSh0aGlzLl9pc0ZpcnN0RnJhbWUpO1xuICAgICAgfVxuICAgICAgLyogdGhpcy5tYXNrTWFuYWdlci5yZW5kZXJGcmFtZSh0aGlzLmZpbmFsVHJhbnNmb3JtLm1hdCk7XHJcbiAgICAgICAgICB0aGlzLnJlbmRlcmFibGVFZmZlY3RzTWFuYWdlci5yZW5kZXJGcmFtZSh0aGlzLl9pc0ZpcnN0RnJhbWUpOyAqL1xuXG4gICAgfSxcbiAgICBzb3VyY2VSZWN0QXRUaW1lOiBmdW5jdGlvbiBzb3VyY2VSZWN0QXRUaW1lKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB3aWR0aDogMTAwLFxuICAgICAgICBoZWlnaHQ6IDEwMFxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldExheWVyU2l6ZTogZnVuY3Rpb24gZ2V0TGF5ZXJTaXplKCkge1xuICAgICAgaWYgKHRoaXMuZGF0YS50eSA9PT0gNSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHc6IHRoaXMuZGF0YS50ZXh0RGF0YS53aWR0aCxcbiAgICAgICAgICBoOiB0aGlzLmRhdGEudGV4dERhdGEuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHc6IHRoaXMuZGF0YS53aWR0aCxcbiAgICAgICAgaDogdGhpcy5kYXRhLmhlaWdodFxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEJsZW5kTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYmxlbmRNb2RlRW51bXMgPSB7XG4gICAgICAwOiAnc291cmNlLW92ZXInLFxuICAgICAgMTogJ211bHRpcGx5JyxcbiAgICAgIDI6ICdzY3JlZW4nLFxuICAgICAgMzogJ292ZXJsYXknLFxuICAgICAgNDogJ2RhcmtlbicsXG4gICAgICA1OiAnbGlnaHRlbicsXG4gICAgICA2OiAnY29sb3ItZG9kZ2UnLFxuICAgICAgNzogJ2NvbG9yLWJ1cm4nLFxuICAgICAgODogJ2hhcmQtbGlnaHQnLFxuICAgICAgOTogJ3NvZnQtbGlnaHQnLFxuICAgICAgMTA6ICdkaWZmZXJlbmNlJyxcbiAgICAgIDExOiAnZXhjbHVzaW9uJyxcbiAgICAgIDEyOiAnaHVlJyxcbiAgICAgIDEzOiAnc2F0dXJhdGlvbicsXG4gICAgICAxNDogJ2NvbG9yJyxcbiAgICAgIDE1OiAnbHVtaW5vc2l0eSdcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kZSkge1xuICAgICAgcmV0dXJuIGJsZW5kTW9kZUVudW1zW21vZGVdIHx8ICcnO1xuICAgIH07XG4gIH0oKTtcblxuICBmdW5jdGlvbiBTbGlkZXJFZmZlY3QoZGF0YSwgZWxlbSwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS52LCAwLCAwLCBjb250YWluZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gQW5nbGVFZmZlY3QoZGF0YSwgZWxlbSwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS52LCAwLCAwLCBjb250YWluZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29sb3JFZmZlY3QoZGF0YSwgZWxlbSwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS52LCAxLCAwLCBjb250YWluZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gUG9pbnRFZmZlY3QoZGF0YSwgZWxlbSwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS52LCAxLCAwLCBjb250YWluZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gTGF5ZXJJbmRleEVmZmVjdChkYXRhLCBlbGVtLCBjb250YWluZXIpIHtcbiAgICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnYsIDAsIDAsIGNvbnRhaW5lcik7XG4gIH1cblxuICBmdW5jdGlvbiBNYXNrSW5kZXhFZmZlY3QoZGF0YSwgZWxlbSwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS52LCAwLCAwLCBjb250YWluZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gQ2hlY2tib3hFZmZlY3QoZGF0YSwgZWxlbSwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS52LCAwLCAwLCBjb250YWluZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gTm9WYWx1ZUVmZmVjdCgpIHtcbiAgICB0aGlzLnAgPSB7fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEVmZmVjdHNNYW5hZ2VyKGRhdGEsIGVsZW1lbnQpIHtcbiAgICB2YXIgZWZmZWN0cyA9IGRhdGEuZWYgfHwgW107XG4gICAgdGhpcy5lZmZlY3RFbGVtZW50cyA9IFtdO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBlZmZlY3RzLmxlbmd0aDtcbiAgICB2YXIgZWZmZWN0SXRlbTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgZWZmZWN0SXRlbSA9IG5ldyBHcm91cEVmZmVjdChlZmZlY3RzW2ldLCBlbGVtZW50KTtcbiAgICAgIHRoaXMuZWZmZWN0RWxlbWVudHMucHVzaChlZmZlY3RJdGVtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBHcm91cEVmZmVjdChkYXRhLCBlbGVtZW50KSB7XG4gICAgdGhpcy5pbml0KGRhdGEsIGVsZW1lbnQpO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBHcm91cEVmZmVjdCk7XG4gIEdyb3VwRWZmZWN0LnByb3RvdHlwZS5nZXRWYWx1ZSA9IEdyb3VwRWZmZWN0LnByb3RvdHlwZS5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXM7XG5cbiAgR3JvdXBFZmZlY3QucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZGF0YSwgZWxlbWVudCkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5lZmZlY3RFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtZW50KTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5kYXRhLmVmLmxlbmd0aDtcbiAgICB2YXIgZWZmO1xuICAgIHZhciBlZmZlY3RzID0gdGhpcy5kYXRhLmVmO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBlZmYgPSBudWxsO1xuXG4gICAgICBzd2l0Y2ggKGVmZmVjdHNbaV0udHkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGVmZiA9IG5ldyBTbGlkZXJFZmZlY3QoZWZmZWN0c1tpXSwgZWxlbWVudCwgdGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGVmZiA9IG5ldyBBbmdsZUVmZmVjdChlZmZlY3RzW2ldLCBlbGVtZW50LCB0aGlzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgZWZmID0gbmV3IENvbG9yRWZmZWN0KGVmZmVjdHNbaV0sIGVsZW1lbnQsIHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBlZmYgPSBuZXcgUG9pbnRFZmZlY3QoZWZmZWN0c1tpXSwgZWxlbWVudCwgdGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0OlxuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgZWZmID0gbmV3IENoZWNrYm94RWZmZWN0KGVmZmVjdHNbaV0sIGVsZW1lbnQsIHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgZWZmID0gbmV3IExheWVySW5kZXhFZmZlY3QoZWZmZWN0c1tpXSwgZWxlbWVudCwgdGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICBlZmYgPSBuZXcgTWFza0luZGV4RWZmZWN0KGVmZmVjdHNbaV0sIGVsZW1lbnQsIHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBlZmYgPSBuZXcgRWZmZWN0c01hbmFnZXIoZWZmZWN0c1tpXSwgZWxlbWVudCwgdGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIGNhc2UgNjpcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGVmZiA9IG5ldyBOb1ZhbHVlRWZmZWN0KGVmZmVjdHNbaV0sIGVsZW1lbnQsIHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWZmKSB7XG4gICAgICAgIHRoaXMuZWZmZWN0RWxlbWVudHMucHVzaChlZmYpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBCYXNlRWxlbWVudCgpIHt9XG5cbiAgQmFzZUVsZW1lbnQucHJvdG90eXBlID0ge1xuICAgIGNoZWNrTWFza3M6IGZ1bmN0aW9uIGNoZWNrTWFza3MoKSB7XG4gICAgICBpZiAoIXRoaXMuZGF0YS5oYXNNYXNrKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZGF0YS5tYXNrc1Byb3BlcnRpZXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBpZiAodGhpcy5kYXRhLm1hc2tzUHJvcGVydGllc1tpXS5tb2RlICE9PSAnbicgJiYgdGhpcy5kYXRhLm1hc2tzUHJvcGVydGllc1tpXS5jbCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgaW5pdEV4cHJlc3Npb25zOiBmdW5jdGlvbiBpbml0RXhwcmVzc2lvbnMoKSB7XG4gICAgICB2YXIgZXhwcmVzc2lvbnNJbnRlcmZhY2VzID0gZ2V0RXhwcmVzc2lvbkludGVyZmFjZXMoKTtcblxuICAgICAgaWYgKCFleHByZXNzaW9uc0ludGVyZmFjZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgTGF5ZXJFeHByZXNzaW9uSW50ZXJmYWNlID0gZXhwcmVzc2lvbnNJbnRlcmZhY2VzKCdsYXllcicpO1xuICAgICAgdmFyIEVmZmVjdHNFeHByZXNzaW9uSW50ZXJmYWNlID0gZXhwcmVzc2lvbnNJbnRlcmZhY2VzKCdlZmZlY3RzJyk7XG4gICAgICB2YXIgU2hhcGVFeHByZXNzaW9uSW50ZXJmYWNlID0gZXhwcmVzc2lvbnNJbnRlcmZhY2VzKCdzaGFwZScpO1xuICAgICAgdmFyIFRleHRFeHByZXNzaW9uSW50ZXJmYWNlID0gZXhwcmVzc2lvbnNJbnRlcmZhY2VzKCd0ZXh0Jyk7XG4gICAgICB2YXIgQ29tcEV4cHJlc3Npb25JbnRlcmZhY2UgPSBleHByZXNzaW9uc0ludGVyZmFjZXMoJ2NvbXAnKTtcbiAgICAgIHRoaXMubGF5ZXJJbnRlcmZhY2UgPSBMYXllckV4cHJlc3Npb25JbnRlcmZhY2UodGhpcyk7XG5cbiAgICAgIGlmICh0aGlzLmRhdGEuaGFzTWFzayAmJiB0aGlzLm1hc2tNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMubGF5ZXJJbnRlcmZhY2UucmVnaXN0ZXJNYXNrSW50ZXJmYWNlKHRoaXMubWFza01hbmFnZXIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWZmZWN0c0ludGVyZmFjZSA9IEVmZmVjdHNFeHByZXNzaW9uSW50ZXJmYWNlLmNyZWF0ZUVmZmVjdHNJbnRlcmZhY2UodGhpcywgdGhpcy5sYXllckludGVyZmFjZSk7XG4gICAgICB0aGlzLmxheWVySW50ZXJmYWNlLnJlZ2lzdGVyRWZmZWN0c0ludGVyZmFjZShlZmZlY3RzSW50ZXJmYWNlKTtcblxuICAgICAgaWYgKHRoaXMuZGF0YS50eSA9PT0gMCB8fCB0aGlzLmRhdGEueHQpIHtcbiAgICAgICAgdGhpcy5jb21wSW50ZXJmYWNlID0gQ29tcEV4cHJlc3Npb25JbnRlcmZhY2UodGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS50eSA9PT0gNCkge1xuICAgICAgICB0aGlzLmxheWVySW50ZXJmYWNlLnNoYXBlSW50ZXJmYWNlID0gU2hhcGVFeHByZXNzaW9uSW50ZXJmYWNlKHRoaXMuc2hhcGVzRGF0YSwgdGhpcy5pdGVtc0RhdGEsIHRoaXMubGF5ZXJJbnRlcmZhY2UpO1xuICAgICAgICB0aGlzLmxheWVySW50ZXJmYWNlLmNvbnRlbnQgPSB0aGlzLmxheWVySW50ZXJmYWNlLnNoYXBlSW50ZXJmYWNlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGEudHkgPT09IDUpIHtcbiAgICAgICAgdGhpcy5sYXllckludGVyZmFjZS50ZXh0SW50ZXJmYWNlID0gVGV4dEV4cHJlc3Npb25JbnRlcmZhY2UodGhpcyk7XG4gICAgICAgIHRoaXMubGF5ZXJJbnRlcmZhY2UudGV4dCA9IHRoaXMubGF5ZXJJbnRlcmZhY2UudGV4dEludGVyZmFjZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldEJsZW5kTW9kZTogZnVuY3Rpb24gc2V0QmxlbmRNb2RlKCkge1xuICAgICAgdmFyIGJsZW5kTW9kZVZhbHVlID0gZ2V0QmxlbmRNb2RlKHRoaXMuZGF0YS5ibSk7XG4gICAgICB2YXIgZWxlbSA9IHRoaXMuYmFzZUVsZW1lbnQgfHwgdGhpcy5sYXllckVsZW1lbnQ7XG4gICAgICBlbGVtLnN0eWxlWydtaXgtYmxlbmQtbW9kZSddID0gYmxlbmRNb2RlVmFsdWU7XG4gICAgfSxcbiAgICBpbml0QmFzZURhdGE6IGZ1bmN0aW9uIGluaXRCYXNlRGF0YShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgICB0aGlzLmdsb2JhbERhdGEgPSBnbG9iYWxEYXRhO1xuICAgICAgdGhpcy5jb21wID0gY29tcDtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICB0aGlzLmxheWVySWQgPSBjcmVhdGVFbGVtZW50SUQoKTsgLy8gU3RyZXRjaCBmYWN0b3IgZm9yIG9sZCBhbmltYXRpb25zIG1pc3NpbmcgdGhpcyBwcm9wZXJ0eS5cblxuICAgICAgaWYgKCF0aGlzLmRhdGEuc3IpIHtcbiAgICAgICAgdGhpcy5kYXRhLnNyID0gMTtcbiAgICAgIH0gLy8gZWZmZWN0cyBtYW5hZ2VyXG5cblxuICAgICAgdGhpcy5lZmZlY3RzTWFuYWdlciA9IG5ldyBFZmZlY3RzTWFuYWdlcih0aGlzLmRhdGEsIHRoaXMsIHRoaXMuZHluYW1pY1Byb3BlcnRpZXMpO1xuICAgIH0sXG4gICAgZ2V0VHlwZTogZnVuY3Rpb24gZ2V0VHlwZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGU7XG4gICAgfSxcbiAgICBzb3VyY2VSZWN0QXRUaW1lOiBmdW5jdGlvbiBzb3VyY2VSZWN0QXRUaW1lKCkge31cbiAgfTtcblxuICAvKipcclxuICAgKiBAZmlsZVxyXG4gICAqIEhhbmRsZXMgZWxlbWVudCdzIGxheWVyIGZyYW1lIHVwZGF0ZS5cclxuICAgKiBDaGVja3MgbGF5ZXIgaW4gcG9pbnQgYW5kIG91dCBwb2ludFxyXG4gICAqXHJcbiAgICovXG4gIGZ1bmN0aW9uIEZyYW1lRWxlbWVudCgpIHt9XG5cbiAgRnJhbWVFbGVtZW50LnByb3RvdHlwZSA9IHtcbiAgICAvKipcclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqIEluaXRpYWxpemVzIGZyYW1lIHJlbGF0ZWQgcHJvcGVydGllcy5cclxuICAgICAgICpcclxuICAgICAgICovXG4gICAgaW5pdEZyYW1lOiBmdW5jdGlvbiBpbml0RnJhbWUoKSB7XG4gICAgICAvLyBzZXQgdG8gdHJ1ZSB3aGVuIGlucG9pbnQgaXMgcmVuZGVyZWRcbiAgICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IGZhbHNlOyAvLyBsaXN0IG9mIGFuaW1hdGVkIHByb3BlcnRpZXNcblxuICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllcyA9IFtdOyAvLyBJZiBsYXllciBoYXMgYmVlbiBtb2RpZmllZCBpbiBjdXJyZW50IHRpY2sgdGhpcyB3aWxsIGJlIHRydWVcblxuICAgICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICogQ2FsY3VsYXRlcyBhbGwgZHluYW1pYyB2YWx1ZXNcclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bVxyXG4gICAgICAgKiBjdXJyZW50IGZyYW1lIG51bWJlciBpbiBMYXllcidzIHRpbWVcclxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBpc1Zpc2libGVcclxuICAgICAgICogaWYgbGF5ZXJzIGlzIGN1cnJlbnRseSBpbiByYW5nZVxyXG4gICAgICAgKlxyXG4gICAgICAgKi9cbiAgICBwcmVwYXJlUHJvcGVydGllczogZnVuY3Rpb24gcHJlcGFyZVByb3BlcnRpZXMobnVtLCBpc1Zpc2libGUpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGlzVmlzaWJsZSB8fCB0aGlzLl9pc1BhcmVudCAmJiB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldLnByb3BUeXBlID09PSAndHJhbnNmb3JtJykge1xuICAgICAgICAgIHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV0uZ2V0VmFsdWUoKTtcblxuICAgICAgICAgIGlmICh0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldLl9tZGYpIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5fbWRmID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX21kZiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhZGREeW5hbWljUHJvcGVydHk6IGZ1bmN0aW9uIGFkZER5bmFtaWNQcm9wZXJ0eShwcm9wKSB7XG4gICAgICBpZiAodGhpcy5keW5hbWljUHJvcGVydGllcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xuICAgICAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIEZvb3RhZ2VFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmluaXRGcmFtZSgpO1xuICAgIHRoaXMuaW5pdFJlbmRlcmFibGUoKTtcbiAgICB0aGlzLmFzc2V0RGF0YSA9IGdsb2JhbERhdGEuZ2V0QXNzZXREYXRhKGRhdGEucmVmSWQpO1xuICAgIHRoaXMuZm9vdGFnZURhdGEgPSBnbG9iYWxEYXRhLmltYWdlTG9hZGVyLmdldEFzc2V0KHRoaXMuYXNzZXREYXRhKTtcbiAgICB0aGlzLmluaXRCYXNlRGF0YShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgfVxuXG4gIEZvb3RhZ2VFbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBleHRlbmRQcm90b3R5cGUoW1JlbmRlcmFibGVFbGVtZW50LCBCYXNlRWxlbWVudCwgRnJhbWVFbGVtZW50XSwgRm9vdGFnZUVsZW1lbnQpO1xuXG4gIEZvb3RhZ2VFbGVtZW50LnByb3RvdHlwZS5nZXRCYXNlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBGb290YWdlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBGb290YWdlRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIEZvb3RhZ2VFbGVtZW50LnByb3RvdHlwZS5pbml0RXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4cHJlc3Npb25zSW50ZXJmYWNlcyA9IGdldEV4cHJlc3Npb25JbnRlcmZhY2VzKCk7XG5cbiAgICBpZiAoIWV4cHJlc3Npb25zSW50ZXJmYWNlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBGb290YWdlSW50ZXJmYWNlID0gZXhwcmVzc2lvbnNJbnRlcmZhY2VzKCdmb290YWdlJyk7XG4gICAgdGhpcy5sYXllckludGVyZmFjZSA9IEZvb3RhZ2VJbnRlcmZhY2UodGhpcyk7XG4gIH07XG5cbiAgRm9vdGFnZUVsZW1lbnQucHJvdG90eXBlLmdldEZvb3RhZ2VEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmZvb3RhZ2VEYXRhO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEF1ZGlvRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy5pbml0RnJhbWUoKTtcbiAgICB0aGlzLmluaXRSZW5kZXJhYmxlKCk7XG4gICAgdGhpcy5hc3NldERhdGEgPSBnbG9iYWxEYXRhLmdldEFzc2V0RGF0YShkYXRhLnJlZklkKTtcbiAgICB0aGlzLmluaXRCYXNlRGF0YShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9jYW5QbGF5ID0gZmFsc2U7XG4gICAgdmFyIGFzc2V0UGF0aCA9IHRoaXMuZ2xvYmFsRGF0YS5nZXRBc3NldHNQYXRoKHRoaXMuYXNzZXREYXRhKTtcbiAgICB0aGlzLmF1ZGlvID0gdGhpcy5nbG9iYWxEYXRhLmF1ZGlvQ29udHJvbGxlci5jcmVhdGVBdWRpbyhhc3NldFBhdGgpO1xuICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gMDtcbiAgICB0aGlzLmdsb2JhbERhdGEuYXVkaW9Db250cm9sbGVyLmFkZEF1ZGlvKHRoaXMpO1xuICAgIHRoaXMuX3ZvbHVtZU11bHRpcGxpZXIgPSAxO1xuICAgIHRoaXMuX3ZvbHVtZSA9IDE7XG4gICAgdGhpcy5fcHJldmlvdXNWb2x1bWUgPSBudWxsO1xuICAgIHRoaXMudG0gPSBkYXRhLnRtID8gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS50bSwgMCwgZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIHRoaXMpIDoge1xuICAgICAgX3BsYWNlaG9sZGVyOiB0cnVlXG4gICAgfTtcbiAgICB0aGlzLmx2ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS5hdSAmJiBkYXRhLmF1Lmx2ID8gZGF0YS5hdS5sdiA6IHtcbiAgICAgIGs6IFsxMDBdXG4gICAgfSwgMSwgMC4wMSwgdGhpcyk7XG4gIH1cblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICB0aGlzLnByZXBhcmVSZW5kZXJhYmxlRnJhbWUobnVtLCB0cnVlKTtcbiAgICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdHJ1ZSk7XG5cbiAgICBpZiAoIXRoaXMudG0uX3BsYWNlaG9sZGVyKSB7XG4gICAgICB2YXIgdGltZVJlbWFwcGVkID0gdGhpcy50bS52O1xuICAgICAgdGhpcy5fY3VycmVudFRpbWUgPSB0aW1lUmVtYXBwZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gbnVtIC8gdGhpcy5kYXRhLnNyO1xuICAgIH1cblxuICAgIHRoaXMuX3ZvbHVtZSA9IHRoaXMubHYudlswXTtcbiAgICB2YXIgdG90YWxWb2x1bWUgPSB0aGlzLl92b2x1bWUgKiB0aGlzLl92b2x1bWVNdWx0aXBsaWVyO1xuXG4gICAgaWYgKHRoaXMuX3ByZXZpb3VzVm9sdW1lICE9PSB0b3RhbFZvbHVtZSkge1xuICAgICAgdGhpcy5fcHJldmlvdXNWb2x1bWUgPSB0b3RhbFZvbHVtZTtcbiAgICAgIHRoaXMuYXVkaW8udm9sdW1lKHRvdGFsVm9sdW1lKTtcbiAgICB9XG4gIH07XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtSZW5kZXJhYmxlRWxlbWVudCwgQmFzZUVsZW1lbnQsIEZyYW1lRWxlbWVudF0sIEF1ZGlvRWxlbWVudCk7XG5cbiAgQXVkaW9FbGVtZW50LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc0luUmFuZ2UgJiYgdGhpcy5fY2FuUGxheSkge1xuICAgICAgaWYgKCF0aGlzLl9pc1BsYXlpbmcpIHtcbiAgICAgICAgdGhpcy5hdWRpby5wbGF5KCk7XG4gICAgICAgIHRoaXMuYXVkaW8uc2Vlayh0aGlzLl9jdXJyZW50VGltZSAvIHRoaXMuZ2xvYmFsRGF0YS5mcmFtZVJhdGUpO1xuICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5hdWRpby5wbGF5aW5nKCkgfHwgTWF0aC5hYnModGhpcy5fY3VycmVudFRpbWUgLyB0aGlzLmdsb2JhbERhdGEuZnJhbWVSYXRlIC0gdGhpcy5hdWRpby5zZWVrKCkpID4gMC4xKSB7XG4gICAgICAgIHRoaXMuYXVkaW8uc2Vlayh0aGlzLl9jdXJyZW50VGltZSAvIHRoaXMuZ2xvYmFsRGF0YS5mcmFtZVJhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7Ly8gdGhpcy5hdWRpby5wbGF5KClcbiAgfTtcblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hdWRpby5wYXVzZSgpO1xuICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICB9O1xuXG4gIEF1ZGlvRWxlbWVudC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hdWRpby5wYXVzZSgpO1xuICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2NhblBsYXkgPSBmYWxzZTtcbiAgfTtcblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jYW5QbGF5ID0gdHJ1ZTtcbiAgfTtcblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLnNldFJhdGUgPSBmdW5jdGlvbiAocmF0ZVZhbHVlKSB7XG4gICAgdGhpcy5hdWRpby5yYXRlKHJhdGVWYWx1ZSk7XG4gIH07XG5cbiAgQXVkaW9FbGVtZW50LnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbiAodm9sdW1lVmFsdWUpIHtcbiAgICB0aGlzLl92b2x1bWVNdWx0aXBsaWVyID0gdm9sdW1lVmFsdWU7XG4gICAgdGhpcy5fcHJldmlvdXNWb2x1bWUgPSB2b2x1bWVWYWx1ZSAqIHRoaXMuX3ZvbHVtZTtcbiAgICB0aGlzLmF1ZGlvLnZvbHVtZSh0aGlzLl9wcmV2aW91c1ZvbHVtZSk7XG4gIH07XG5cbiAgQXVkaW9FbGVtZW50LnByb3RvdHlwZS5nZXRCYXNlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLnNvdXJjZVJlY3RBdFRpbWUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLmluaXRFeHByZXNzaW9ucyA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIGZ1bmN0aW9uIEJhc2VSZW5kZXJlcigpIHt9XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5jaGVja0xheWVycyA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xuICAgIHZhciBkYXRhO1xuICAgIHRoaXMuY29tcGxldGVMYXllcnMgPSB0cnVlO1xuXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIGlmICghdGhpcy5lbGVtZW50c1tpXSkge1xuICAgICAgICBkYXRhID0gdGhpcy5sYXllcnNbaV07XG5cbiAgICAgICAgaWYgKGRhdGEuaXAgLSBkYXRhLnN0IDw9IG51bSAtIHRoaXMubGF5ZXJzW2ldLnN0ICYmIGRhdGEub3AgLSBkYXRhLnN0ID4gbnVtIC0gdGhpcy5sYXllcnNbaV0uc3QpIHtcbiAgICAgICAgICB0aGlzLmJ1aWxkSXRlbShpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbXBsZXRlTGF5ZXJzID0gdGhpcy5lbGVtZW50c1tpXSA/IHRoaXMuY29tcGxldGVMYXllcnMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmNoZWNrUGVuZGluZ0VsZW1lbnRzKCk7XG4gIH07XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVJdGVtID0gZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgc3dpdGNoIChsYXllci50eSkge1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVJbWFnZShsYXllcik7XG5cbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29tcChsYXllcik7XG5cbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU29saWQobGF5ZXIpO1xuXG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU51bGwobGF5ZXIpO1xuXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNoYXBlKGxheWVyKTtcblxuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUZXh0KGxheWVyKTtcblxuICAgICAgY2FzZSA2OlxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVBdWRpbyhsYXllcik7XG5cbiAgICAgIGNhc2UgMTM6XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUNhbWVyYShsYXllcik7XG5cbiAgICAgIGNhc2UgMTU6XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUZvb3RhZ2UobGF5ZXIpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVOdWxsKGxheWVyKTtcbiAgICB9XG4gIH07XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVDYW1lcmEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdZb3VcXCdyZSB1c2luZyBhIDNkIGNhbWVyYS4gVHJ5IHRoZSBodG1sIHJlbmRlcmVyLicpO1xuICB9O1xuXG4gIEJhc2VSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlQXVkaW8gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQXVkaW9FbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVGb290YWdlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IEZvb3RhZ2VFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5idWlsZEFsbEl0ZW1zID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMuYnVpbGRJdGVtKGkpO1xuICAgIH1cblxuICAgIHRoaXMuY2hlY2tQZW5kaW5nRWxlbWVudHMoKTtcbiAgfTtcblxuICBCYXNlUmVuZGVyZXIucHJvdG90eXBlLmluY2x1ZGVMYXllcnMgPSBmdW5jdGlvbiAobmV3TGF5ZXJzKSB7XG4gICAgdGhpcy5jb21wbGV0ZUxheWVycyA9IGZhbHNlO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBuZXdMYXllcnMubGVuZ3RoO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBqID0gMDtcblxuICAgICAgd2hpbGUgKGogPCBqTGVuKSB7XG4gICAgICAgIGlmICh0aGlzLmxheWVyc1tqXS5pZCA9PT0gbmV3TGF5ZXJzW2ldLmlkKSB7XG4gICAgICAgICAgdGhpcy5sYXllcnNbal0gPSBuZXdMYXllcnNbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBqICs9IDE7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJhc2VSZW5kZXJlci5wcm90b3R5cGUuc2V0UHJvamVjdEludGVyZmFjZSA9IGZ1bmN0aW9uIChwSW50ZXJmYWNlKSB7XG4gICAgdGhpcy5nbG9iYWxEYXRhLnByb2plY3RJbnRlcmZhY2UgPSBwSW50ZXJmYWNlO1xuICB9O1xuXG4gIEJhc2VSZW5kZXJlci5wcm90b3R5cGUuaW5pdEl0ZW1zID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5nbG9iYWxEYXRhLnByb2dyZXNzaXZlTG9hZCkge1xuICAgICAgdGhpcy5idWlsZEFsbEl0ZW1zKCk7XG4gICAgfVxuICB9O1xuXG4gIEJhc2VSZW5kZXJlci5wcm90b3R5cGUuYnVpbGRFbGVtZW50UGFyZW50aW5nID0gZnVuY3Rpb24gKGVsZW1lbnQsIHBhcmVudE5hbWUsIGhpZXJhcmNoeSkge1xuICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG4gICAgdmFyIGxheWVycyA9IHRoaXMubGF5ZXJzO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gbGF5ZXJzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAobGF5ZXJzW2ldLmluZCA9PSBwYXJlbnROYW1lKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgICAgIGlmICghZWxlbWVudHNbaV0gfHwgZWxlbWVudHNbaV0gPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmJ1aWxkSXRlbShpKTtcbiAgICAgICAgICB0aGlzLmFkZFBlbmRpbmdFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhpZXJhcmNoeS5wdXNoKGVsZW1lbnRzW2ldKTtcbiAgICAgICAgICBlbGVtZW50c1tpXS5zZXRBc1BhcmVudCgpO1xuXG4gICAgICAgICAgaWYgKGxheWVyc1tpXS5wYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5idWlsZEVsZW1lbnRQYXJlbnRpbmcoZWxlbWVudCwgbGF5ZXJzW2ldLnBhcmVudCwgaGllcmFyY2h5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5zZXRIaWVyYXJjaHkoaGllcmFyY2h5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgIH1cbiAgfTtcblxuICBCYXNlUmVuZGVyZXIucHJvdG90eXBlLmFkZFBlbmRpbmdFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB0aGlzLnBlbmRpbmdFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICB9O1xuXG4gIEJhc2VSZW5kZXJlci5wcm90b3R5cGUuc2VhcmNoRXh0cmFDb21wb3NpdGlvbnMgPSBmdW5jdGlvbiAoYXNzZXRzKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IGFzc2V0cy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmIChhc3NldHNbaV0ueHQpIHtcbiAgICAgICAgdmFyIGNvbXAgPSB0aGlzLmNyZWF0ZUNvbXAoYXNzZXRzW2ldKTtcbiAgICAgICAgY29tcC5pbml0RXhwcmVzc2lvbnMoKTtcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhLnByb2plY3RJbnRlcmZhY2UucmVnaXN0ZXJDb21wb3NpdGlvbihjb21wKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5nZXRFbGVtZW50QnlJZCA9IGZ1bmN0aW9uIChpbmQpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldLmRhdGEuaW5kID09PSBpbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5nZXRFbGVtZW50QnlQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICB2YXIgcGF0aFZhbHVlID0gcGF0aC5zaGlmdCgpO1xuICAgIHZhciBlbGVtZW50O1xuXG4gICAgaWYgKHR5cGVvZiBwYXRoVmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50c1twYXRoVmFsdWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldLmRhdGEubm0gPT09IHBhdGhWYWx1ZSkge1xuICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudC5nZXRFbGVtZW50QnlQYXRoKHBhdGgpO1xuICB9O1xuXG4gIEJhc2VSZW5kZXJlci5wcm90b3R5cGUuc2V0dXBHbG9iYWxEYXRhID0gZnVuY3Rpb24gKGFuaW1EYXRhLCBmb250c0NvbnRhaW5lcikge1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlciA9IG5ldyBGb250TWFuYWdlcigpO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5zbG90TWFuYWdlciA9IHNsb3RGYWN0b3J5KGFuaW1EYXRhKTtcbiAgICB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuYWRkQ2hhcnMoYW5pbURhdGEuY2hhcnMpO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5hZGRGb250cyhhbmltRGF0YS5mb250cywgZm9udHNDb250YWluZXIpO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5nZXRBc3NldERhdGEgPSB0aGlzLmFuaW1hdGlvbkl0ZW0uZ2V0QXNzZXREYXRhLmJpbmQodGhpcy5hbmltYXRpb25JdGVtKTtcbiAgICB0aGlzLmdsb2JhbERhdGEuZ2V0QXNzZXRzUGF0aCA9IHRoaXMuYW5pbWF0aW9uSXRlbS5nZXRBc3NldHNQYXRoLmJpbmQodGhpcy5hbmltYXRpb25JdGVtKTtcbiAgICB0aGlzLmdsb2JhbERhdGEuaW1hZ2VMb2FkZXIgPSB0aGlzLmFuaW1hdGlvbkl0ZW0uaW1hZ2VQcmVsb2FkZXI7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmF1ZGlvQ29udHJvbGxlciA9IHRoaXMuYW5pbWF0aW9uSXRlbS5hdWRpb0NvbnRyb2xsZXI7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmZyYW1lSWQgPSAwO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5mcmFtZVJhdGUgPSBhbmltRGF0YS5mcjtcbiAgICB0aGlzLmdsb2JhbERhdGEubm0gPSBhbmltRGF0YS5ubTtcbiAgICB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUgPSB7XG4gICAgICB3OiBhbmltRGF0YS53LFxuICAgICAgaDogYW5pbURhdGEuaFxuICAgIH07XG4gIH07XG5cbiAgdmFyIGVmZmVjdFR5cGVzID0ge1xuICAgIFRSQU5TRk9STV9FRkZFQ1Q6ICd0cmFuc2Zvcm1FRmZlY3QnXG4gIH07XG5cbiAgZnVuY3Rpb24gVHJhbnNmb3JtRWxlbWVudCgpIHt9XG5cbiAgVHJhbnNmb3JtRWxlbWVudC5wcm90b3R5cGUgPSB7XG4gICAgaW5pdFRyYW5zZm9ybTogZnVuY3Rpb24gaW5pdFRyYW5zZm9ybSgpIHtcbiAgICAgIHZhciBtYXQgPSBuZXcgTWF0cml4KCk7XG4gICAgICB0aGlzLmZpbmFsVHJhbnNmb3JtID0ge1xuICAgICAgICBtUHJvcDogdGhpcy5kYXRhLmtzID8gVHJhbnNmb3JtUHJvcGVydHlGYWN0b3J5LmdldFRyYW5zZm9ybVByb3BlcnR5KHRoaXMsIHRoaXMuZGF0YS5rcywgdGhpcykgOiB7XG4gICAgICAgICAgbzogMFxuICAgICAgICB9LFxuICAgICAgICBfbWF0TWRmOiBmYWxzZSxcbiAgICAgICAgX2xvY2FsTWF0TWRmOiBmYWxzZSxcbiAgICAgICAgX29wTWRmOiBmYWxzZSxcbiAgICAgICAgbWF0OiBtYXQsXG4gICAgICAgIGxvY2FsTWF0OiBtYXQsXG4gICAgICAgIGxvY2FsT3BhY2l0eTogMVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuZGF0YS5hbykge1xuICAgICAgICB0aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLmF1dG9PcmllbnRlZCA9IHRydWU7XG4gICAgICB9IC8vIFRPRE86IGNoZWNrIFRZUEUgMTE6IEd1aWRlZCBlbGVtZW50c1xuXG5cbiAgICAgIGlmICh0aGlzLmRhdGEudHkgIT09IDExKSB7Ly8gdGhpcy5jcmVhdGVFbGVtZW50cygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyVHJhbnNmb3JtOiBmdW5jdGlvbiByZW5kZXJUcmFuc2Zvcm0oKSB7XG4gICAgICB0aGlzLmZpbmFsVHJhbnNmb3JtLl9vcE1kZiA9IHRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3Auby5fbWRmIHx8IHRoaXMuX2lzRmlyc3RGcmFtZTtcbiAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0uX21hdE1kZiA9IHRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3AuX21kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWU7XG5cbiAgICAgIGlmICh0aGlzLmhpZXJhcmNoeSkge1xuICAgICAgICB2YXIgbWF0O1xuICAgICAgICB2YXIgZmluYWxNYXQgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLm1hdDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoOyAvLyBDaGVja2luZyBpZiBhbnkgb2YgdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpY2VzIGluIHRoZSBoaWVyYXJjaHkgY2hhaW4gaGFzIGNoYW5nZWQuXG5cbiAgICAgICAgaWYgKCF0aGlzLmZpbmFsVHJhbnNmb3JtLl9tYXRNZGYpIHtcbiAgICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGllcmFyY2h5W2ldLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLl9tZGYpIHtcbiAgICAgICAgICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmKSB7XG4gICAgICAgICAgbWF0ID0gdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC52LnByb3BzO1xuICAgICAgICAgIGZpbmFsTWF0LmNsb25lRnJvbVByb3BzKG1hdCk7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGZpbmFsTWF0Lm11bHRpcGx5KHRoaXMuaGllcmFyY2h5W2ldLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLnYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmKSB7XG4gICAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0uX2xvY2FsTWF0TWRmID0gdGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5fb3BNZGYpIHtcbiAgICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5sb2NhbE9wYWNpdHkgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLm8udjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlckxvY2FsVHJhbnNmb3JtOiBmdW5jdGlvbiByZW5kZXJMb2NhbFRyYW5zZm9ybSgpIHtcbiAgICAgIGlmICh0aGlzLmxvY2FsVHJhbnNmb3Jtcykge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmxvY2FsVHJhbnNmb3Jtcy5sZW5ndGg7XG4gICAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0uX2xvY2FsTWF0TWRmID0gdGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmO1xuXG4gICAgICAgIGlmICghdGhpcy5maW5hbFRyYW5zZm9ybS5fbG9jYWxNYXRNZGYgfHwgIXRoaXMuZmluYWxUcmFuc2Zvcm0uX29wTWRmKSB7XG4gICAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvY2FsVHJhbnNmb3Jtc1tpXS5fbWRmKSB7XG4gICAgICAgICAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0uX2xvY2FsTWF0TWRmID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMubG9jYWxUcmFuc2Zvcm1zW2ldLl9vcE1kZiAmJiAhdGhpcy5maW5hbFRyYW5zZm9ybS5fb3BNZGYpIHtcbiAgICAgICAgICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5sb2NhbE9wYWNpdHkgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLm8udjtcbiAgICAgICAgICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5fb3BNZGYgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZmluYWxUcmFuc2Zvcm0uX2xvY2FsTWF0TWRmKSB7XG4gICAgICAgICAgdmFyIGxvY2FsTWF0ID0gdGhpcy5maW5hbFRyYW5zZm9ybS5sb2NhbE1hdDtcbiAgICAgICAgICB0aGlzLmxvY2FsVHJhbnNmb3Jtc1swXS5tYXRyaXguY2xvbmUobG9jYWxNYXQpO1xuXG4gICAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbG1hdCA9IHRoaXMubG9jYWxUcmFuc2Zvcm1zW2ldLm1hdHJpeDtcbiAgICAgICAgICAgIGxvY2FsTWF0Lm11bHRpcGx5KGxtYXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxvY2FsTWF0Lm11bHRpcGx5KHRoaXMuZmluYWxUcmFuc2Zvcm0ubWF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmZpbmFsVHJhbnNmb3JtLl9vcE1kZikge1xuICAgICAgICAgIHZhciBsb2NhbE9wID0gdGhpcy5maW5hbFRyYW5zZm9ybS5sb2NhbE9wYWNpdHk7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGxvY2FsT3AgKj0gdGhpcy5sb2NhbFRyYW5zZm9ybXNbaV0ub3BhY2l0eSAqIDAuMDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5sb2NhbE9wYWNpdHkgPSBsb2NhbE9wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzZWFyY2hFZmZlY3RUcmFuc2Zvcm1zOiBmdW5jdGlvbiBzZWFyY2hFZmZlY3RUcmFuc2Zvcm1zKCkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyYWJsZUVmZmVjdHNNYW5hZ2VyKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1FZmZlY3RzID0gdGhpcy5yZW5kZXJhYmxlRWZmZWN0c01hbmFnZXIuZ2V0RWZmZWN0cyhlZmZlY3RUeXBlcy5UUkFOU0ZPUk1fRUZGRUNUKTtcblxuICAgICAgICBpZiAodHJhbnNmb3JtRWZmZWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmxvY2FsVHJhbnNmb3JtcyA9IFtdO1xuICAgICAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0ubG9jYWxNYXQgPSBuZXcgTWF0cml4KCk7XG4gICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgIHZhciBsZW4gPSB0cmFuc2Zvcm1FZmZlY3RzLmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbFRyYW5zZm9ybXMucHVzaCh0cmFuc2Zvcm1FZmZlY3RzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGdsb2JhbFRvTG9jYWw6IGZ1bmN0aW9uIGdsb2JhbFRvTG9jYWwocHQpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1zID0gW107XG4gICAgICB0cmFuc2Zvcm1zLnB1c2godGhpcy5maW5hbFRyYW5zZm9ybSk7XG4gICAgICB2YXIgZmxhZyA9IHRydWU7XG4gICAgICB2YXIgY29tcCA9IHRoaXMuY29tcDtcblxuICAgICAgd2hpbGUgKGZsYWcpIHtcbiAgICAgICAgaWYgKGNvbXAuZmluYWxUcmFuc2Zvcm0pIHtcbiAgICAgICAgICBpZiAoY29tcC5kYXRhLmhhc01hc2spIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybXMuc3BsaWNlKDAsIDAsIGNvbXAuZmluYWxUcmFuc2Zvcm0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbXAgPSBjb21wLmNvbXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuICAgICAgdmFyIHB0TmV3O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcHROZXcgPSB0cmFuc2Zvcm1zW2ldLm1hdC5hcHBseVRvUG9pbnRBcnJheSgwLCAwLCAwKTsgLy8gcHROZXcgPSB0cmFuc2Zvcm1zW2ldLm1hdC5hcHBseVRvUG9pbnRBcnJheShwdFswXSxwdFsxXSxwdFsyXSk7XG5cbiAgICAgICAgcHQgPSBbcHRbMF0gLSBwdE5ld1swXSwgcHRbMV0gLSBwdE5ld1sxXSwgMF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwdDtcbiAgICB9LFxuICAgIG1IZWxwZXI6IG5ldyBNYXRyaXgoKVxuICB9O1xuXG4gIGZ1bmN0aW9uIE1hc2tFbGVtZW50KGRhdGEsIGVsZW1lbnQsIGdsb2JhbERhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5nbG9iYWxEYXRhID0gZ2xvYmFsRGF0YTtcbiAgICB0aGlzLnN0b3JlZERhdGEgPSBbXTtcbiAgICB0aGlzLm1hc2tzUHJvcGVydGllcyA9IHRoaXMuZGF0YS5tYXNrc1Byb3BlcnRpZXMgfHwgW107XG4gICAgdGhpcy5tYXNrRWxlbWVudCA9IG51bGw7XG4gICAgdmFyIGRlZnMgPSB0aGlzLmdsb2JhbERhdGEuZGVmcztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5tYXNrc1Byb3BlcnRpZXMgPyB0aGlzLm1hc2tzUHJvcGVydGllcy5sZW5ndGggOiAwO1xuICAgIHRoaXMudmlld0RhdGEgPSBjcmVhdGVTaXplZEFycmF5KGxlbik7XG4gICAgdGhpcy5zb2xpZFBhdGggPSAnJztcbiAgICB2YXIgcGF0aDtcbiAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMubWFza3NQcm9wZXJ0aWVzO1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGN1cnJlbnRNYXNrcyA9IFtdO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuO1xuICAgIHZhciBsYXllcklkID0gY3JlYXRlRWxlbWVudElEKCk7XG4gICAgdmFyIHJlY3Q7XG4gICAgdmFyIGV4cGFuc29yO1xuICAgIHZhciBmZU1vcnBoO1xuICAgIHZhciB4O1xuICAgIHZhciBtYXNrVHlwZSA9ICdjbGlwUGF0aCc7XG4gICAgdmFyIG1hc2tSZWYgPSAnY2xpcC1wYXRoJztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHByb3BlcnRpZXNbaV0ubW9kZSAhPT0gJ2EnICYmIHByb3BlcnRpZXNbaV0ubW9kZSAhPT0gJ24nIHx8IHByb3BlcnRpZXNbaV0uaW52IHx8IHByb3BlcnRpZXNbaV0uby5rICE9PSAxMDAgfHwgcHJvcGVydGllc1tpXS5vLngpIHtcbiAgICAgICAgbWFza1R5cGUgPSAnbWFzayc7XG4gICAgICAgIG1hc2tSZWYgPSAnbWFzayc7XG4gICAgICB9XG5cbiAgICAgIGlmICgocHJvcGVydGllc1tpXS5tb2RlID09PSAncycgfHwgcHJvcGVydGllc1tpXS5tb2RlID09PSAnaScpICYmIGNvdW50ID09PSAwKSB7XG4gICAgICAgIHJlY3QgPSBjcmVhdGVOUygncmVjdCcpO1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZSgnZmlsbCcsICcjZmZmZmZmJyk7XG4gICAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuZWxlbWVudC5jb21wLmRhdGEudyB8fCAwKTtcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuZWxlbWVudC5jb21wLmRhdGEuaCB8fCAwKTtcbiAgICAgICAgY3VycmVudE1hc2tzLnB1c2gocmVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWN0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcGF0aCA9IGNyZWF0ZU5TKCdwYXRoJyk7XG5cbiAgICAgIGlmIChwcm9wZXJ0aWVzW2ldLm1vZGUgPT09ICduJykge1xuICAgICAgICAvLyBUT0RPIG1vdmUgdGhpcyB0byBhIGZhY3Rvcnkgb3IgdG8gYSBjb25zdHJ1Y3RvclxuICAgICAgICB0aGlzLnZpZXdEYXRhW2ldID0ge1xuICAgICAgICAgIG9wOiBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLmVsZW1lbnQsIHByb3BlcnRpZXNbaV0ubywgMCwgMC4wMSwgdGhpcy5lbGVtZW50KSxcbiAgICAgICAgICBwcm9wOiBTaGFwZVByb3BlcnR5RmFjdG9yeS5nZXRTaGFwZVByb3AodGhpcy5lbGVtZW50LCBwcm9wZXJ0aWVzW2ldLCAzKSxcbiAgICAgICAgICBlbGVtOiBwYXRoLFxuICAgICAgICAgIGxhc3RQYXRoOiAnJ1xuICAgICAgICB9O1xuICAgICAgICBkZWZzLmFwcGVuZENoaWxkKHBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBwcm9wZXJ0aWVzW2ldLm1vZGUgPT09ICdzJyA/ICcjMDAwMDAwJyA6ICcjZmZmZmZmJyk7XG4gICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdjbGlwLXJ1bGUnLCAnbm9uemVybycpO1xuICAgICAgICB2YXIgZmlsdGVySUQ7XG5cbiAgICAgICAgaWYgKHByb3BlcnRpZXNbaV0ueC5rICE9PSAwKSB7XG4gICAgICAgICAgbWFza1R5cGUgPSAnbWFzayc7XG4gICAgICAgICAgbWFza1JlZiA9ICdtYXNrJztcbiAgICAgICAgICB4ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcy5lbGVtZW50LCBwcm9wZXJ0aWVzW2ldLngsIDAsIG51bGwsIHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgZmlsdGVySUQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICAgICAgICBleHBhbnNvciA9IGNyZWF0ZU5TKCdmaWx0ZXInKTtcbiAgICAgICAgICBleHBhbnNvci5zZXRBdHRyaWJ1dGUoJ2lkJywgZmlsdGVySUQpO1xuICAgICAgICAgIGZlTW9ycGggPSBjcmVhdGVOUygnZmVNb3JwaG9sb2d5Jyk7XG4gICAgICAgICAgZmVNb3JwaC5zZXRBdHRyaWJ1dGUoJ29wZXJhdG9yJywgJ2Vyb2RlJyk7XG4gICAgICAgICAgZmVNb3JwaC5zZXRBdHRyaWJ1dGUoJ2luJywgJ1NvdXJjZUdyYXBoaWMnKTtcbiAgICAgICAgICBmZU1vcnBoLnNldEF0dHJpYnV0ZSgncmFkaXVzJywgJzAnKTtcbiAgICAgICAgICBleHBhbnNvci5hcHBlbmRDaGlsZChmZU1vcnBoKTtcbiAgICAgICAgICBkZWZzLmFwcGVuZENoaWxkKGV4cGFuc29yKTtcbiAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgcHJvcGVydGllc1tpXS5tb2RlID09PSAncycgPyAnIzAwMDAwMCcgOiAnI2ZmZmZmZicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZlTW9ycGggPSBudWxsO1xuICAgICAgICAgIHggPSBudWxsO1xuICAgICAgICB9IC8vIFRPRE8gbW92ZSB0aGlzIHRvIGEgZmFjdG9yeSBvciB0byBhIGNvbnN0cnVjdG9yXG5cblxuICAgICAgICB0aGlzLnN0b3JlZERhdGFbaV0gPSB7XG4gICAgICAgICAgZWxlbTogcGF0aCxcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIGV4cGFuOiBmZU1vcnBoLFxuICAgICAgICAgIGxhc3RQYXRoOiAnJyxcbiAgICAgICAgICBsYXN0T3BlcmF0b3I6ICcnLFxuICAgICAgICAgIGZpbHRlcklkOiBmaWx0ZXJJRCxcbiAgICAgICAgICBsYXN0UmFkaXVzOiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHByb3BlcnRpZXNbaV0ubW9kZSA9PT0gJ2knKSB7XG4gICAgICAgICAgakxlbiA9IGN1cnJlbnRNYXNrcy5sZW5ndGg7XG4gICAgICAgICAgdmFyIGcgPSBjcmVhdGVOUygnZycpO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgZy5hcHBlbmRDaGlsZChjdXJyZW50TWFza3Nbal0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBtYXNrID0gY3JlYXRlTlMoJ21hc2snKTtcbiAgICAgICAgICBtYXNrLnNldEF0dHJpYnV0ZSgnbWFzay10eXBlJywgJ2FscGhhJyk7XG4gICAgICAgICAgbWFzay5zZXRBdHRyaWJ1dGUoJ2lkJywgbGF5ZXJJZCArICdfJyArIGNvdW50KTtcbiAgICAgICAgICBtYXNrLmFwcGVuZENoaWxkKHBhdGgpO1xuICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQobWFzayk7XG4gICAgICAgICAgZy5zZXRBdHRyaWJ1dGUoJ21hc2snLCAndXJsKCcgKyBnZXRMb2NhdGlvbkhyZWYoKSArICcjJyArIGxheWVySWQgKyAnXycgKyBjb3VudCArICcpJyk7XG4gICAgICAgICAgY3VycmVudE1hc2tzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgY3VycmVudE1hc2tzLnB1c2goZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudE1hc2tzLnB1c2gocGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcGVydGllc1tpXS5pbnYgJiYgIXRoaXMuc29saWRQYXRoKSB7XG4gICAgICAgICAgdGhpcy5zb2xpZFBhdGggPSB0aGlzLmNyZWF0ZUxheWVyU29saWRQYXRoKCk7XG4gICAgICAgIH0gLy8gVE9ETyBtb3ZlIHRoaXMgdG8gYSBmYWN0b3J5IG9yIHRvIGEgY29uc3RydWN0b3JcblxuXG4gICAgICAgIHRoaXMudmlld0RhdGFbaV0gPSB7XG4gICAgICAgICAgZWxlbTogcGF0aCxcbiAgICAgICAgICBsYXN0UGF0aDogJycsXG4gICAgICAgICAgb3A6IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMuZWxlbWVudCwgcHJvcGVydGllc1tpXS5vLCAwLCAwLjAxLCB0aGlzLmVsZW1lbnQpLFxuICAgICAgICAgIHByb3A6IFNoYXBlUHJvcGVydHlGYWN0b3J5LmdldFNoYXBlUHJvcCh0aGlzLmVsZW1lbnQsIHByb3BlcnRpZXNbaV0sIDMpLFxuICAgICAgICAgIGludlJlY3Q6IHJlY3RcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIXRoaXMudmlld0RhdGFbaV0ucHJvcC5rKSB7XG4gICAgICAgICAgdGhpcy5kcmF3UGF0aChwcm9wZXJ0aWVzW2ldLCB0aGlzLnZpZXdEYXRhW2ldLnByb3AudiwgdGhpcy52aWV3RGF0YVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm1hc2tFbGVtZW50ID0gY3JlYXRlTlMobWFza1R5cGUpO1xuICAgIGxlbiA9IGN1cnJlbnRNYXNrcy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMubWFza0VsZW1lbnQuYXBwZW5kQ2hpbGQoY3VycmVudE1hc2tzW2ldKTtcbiAgICB9XG5cbiAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICB0aGlzLm1hc2tFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCBsYXllcklkKTtcbiAgICAgIHRoaXMuZWxlbWVudC5tYXNrZWRFbGVtZW50LnNldEF0dHJpYnV0ZShtYXNrUmVmLCAndXJsKCcgKyBnZXRMb2NhdGlvbkhyZWYoKSArICcjJyArIGxheWVySWQgKyAnKScpO1xuICAgICAgZGVmcy5hcHBlbmRDaGlsZCh0aGlzLm1hc2tFbGVtZW50KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy52aWV3RGF0YS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5hZGRSZW5kZXJhYmxlQ29tcG9uZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIE1hc2tFbGVtZW50LnByb3RvdHlwZS5nZXRNYXNrUHJvcGVydHkgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIHRoaXMudmlld0RhdGFbcG9zXS5wcm9wO1xuICB9O1xuXG4gIE1hc2tFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChpc0ZpcnN0RnJhbWUpIHtcbiAgICB2YXIgZmluYWxNYXQgPSB0aGlzLmVsZW1lbnQuZmluYWxUcmFuc2Zvcm0ubWF0O1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLm1hc2tzUHJvcGVydGllcy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICh0aGlzLnZpZXdEYXRhW2ldLnByb3AuX21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgICAgdGhpcy5kcmF3UGF0aCh0aGlzLm1hc2tzUHJvcGVydGllc1tpXSwgdGhpcy52aWV3RGF0YVtpXS5wcm9wLnYsIHRoaXMudmlld0RhdGFbaV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy52aWV3RGF0YVtpXS5vcC5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xuICAgICAgICB0aGlzLnZpZXdEYXRhW2ldLmVsZW0uc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCB0aGlzLnZpZXdEYXRhW2ldLm9wLnYpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5tYXNrc1Byb3BlcnRpZXNbaV0ubW9kZSAhPT0gJ24nKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXdEYXRhW2ldLmludlJlY3QgJiYgKHRoaXMuZWxlbWVudC5maW5hbFRyYW5zZm9ybS5tUHJvcC5fbWRmIHx8IGlzRmlyc3RGcmFtZSkpIHtcbiAgICAgICAgICB0aGlzLnZpZXdEYXRhW2ldLmludlJlY3Quc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBmaW5hbE1hdC5nZXRJbnZlcnNlTWF0cml4KCkudG8yZENTUygpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnN0b3JlZERhdGFbaV0ueCAmJiAodGhpcy5zdG9yZWREYXRhW2ldLnguX21kZiB8fCBpc0ZpcnN0RnJhbWUpKSB7XG4gICAgICAgICAgdmFyIGZlTW9ycGggPSB0aGlzLnN0b3JlZERhdGFbaV0uZXhwYW47XG5cbiAgICAgICAgICBpZiAodGhpcy5zdG9yZWREYXRhW2ldLngudiA8IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3JlZERhdGFbaV0ubGFzdE9wZXJhdG9yICE9PSAnZXJvZGUnKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RvcmVkRGF0YVtpXS5sYXN0T3BlcmF0b3IgPSAnZXJvZGUnO1xuICAgICAgICAgICAgICB0aGlzLnN0b3JlZERhdGFbaV0uZWxlbS5zZXRBdHRyaWJ1dGUoJ2ZpbHRlcicsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgdGhpcy5zdG9yZWREYXRhW2ldLmZpbHRlcklkICsgJyknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmVNb3JwaC5zZXRBdHRyaWJ1dGUoJ3JhZGl1cycsIC10aGlzLnN0b3JlZERhdGFbaV0ueC52KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcmVkRGF0YVtpXS5sYXN0T3BlcmF0b3IgIT09ICdkaWxhdGUnKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RvcmVkRGF0YVtpXS5sYXN0T3BlcmF0b3IgPSAnZGlsYXRlJztcbiAgICAgICAgICAgICAgdGhpcy5zdG9yZWREYXRhW2ldLmVsZW0uc2V0QXR0cmlidXRlKCdmaWx0ZXInLCBudWxsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zdG9yZWREYXRhW2ldLmVsZW0uc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCB0aGlzLnN0b3JlZERhdGFbaV0ueC52ICogMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIE1hc2tFbGVtZW50LnByb3RvdHlwZS5nZXRNYXNrZWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXNrRWxlbWVudDtcbiAgfTtcblxuICBNYXNrRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlTGF5ZXJTb2xpZFBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhdGggPSAnTTAsMCAnO1xuICAgIHBhdGggKz0gJyBoJyArIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53O1xuICAgIHBhdGggKz0gJyB2JyArIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oO1xuICAgIHBhdGggKz0gJyBoLScgKyB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudztcbiAgICBwYXRoICs9ICcgdi0nICsgdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLmggKyAnICc7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG5cbiAgTWFza0VsZW1lbnQucHJvdG90eXBlLmRyYXdQYXRoID0gZnVuY3Rpb24gKHBhdGhEYXRhLCBwYXRoTm9kZXMsIHZpZXdEYXRhKSB7XG4gICAgdmFyIHBhdGhTdHJpbmcgPSAnIE0nICsgcGF0aE5vZGVzLnZbMF1bMF0gKyAnLCcgKyBwYXRoTm9kZXMudlswXVsxXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuICAgIGxlbiA9IHBhdGhOb2Rlcy5fbGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAvLyBwYXRoU3RyaW5nICs9IFwiIENcIitwYXRoTm9kZXMub1tpLTFdWzBdKycsJytwYXRoTm9kZXMub1tpLTFdWzFdICsgXCIgXCIrcGF0aE5vZGVzLmlbaV1bMF0rJywnK3BhdGhOb2Rlcy5pW2ldWzFdICsgXCIgXCIrcGF0aE5vZGVzLnZbaV1bMF0rJywnK3BhdGhOb2Rlcy52W2ldWzFdO1xuICAgICAgcGF0aFN0cmluZyArPSAnIEMnICsgcGF0aE5vZGVzLm9baSAtIDFdWzBdICsgJywnICsgcGF0aE5vZGVzLm9baSAtIDFdWzFdICsgJyAnICsgcGF0aE5vZGVzLmlbaV1bMF0gKyAnLCcgKyBwYXRoTm9kZXMuaVtpXVsxXSArICcgJyArIHBhdGhOb2Rlcy52W2ldWzBdICsgJywnICsgcGF0aE5vZGVzLnZbaV1bMV07XG4gICAgfSAvLyBwYXRoU3RyaW5nICs9IFwiIENcIitwYXRoTm9kZXMub1tpLTFdWzBdKycsJytwYXRoTm9kZXMub1tpLTFdWzFdICsgXCIgXCIrcGF0aE5vZGVzLmlbMF1bMF0rJywnK3BhdGhOb2Rlcy5pWzBdWzFdICsgXCIgXCIrcGF0aE5vZGVzLnZbMF1bMF0rJywnK3BhdGhOb2Rlcy52WzBdWzFdO1xuXG5cbiAgICBpZiAocGF0aE5vZGVzLmMgJiYgbGVuID4gMSkge1xuICAgICAgcGF0aFN0cmluZyArPSAnIEMnICsgcGF0aE5vZGVzLm9baSAtIDFdWzBdICsgJywnICsgcGF0aE5vZGVzLm9baSAtIDFdWzFdICsgJyAnICsgcGF0aE5vZGVzLmlbMF1bMF0gKyAnLCcgKyBwYXRoTm9kZXMuaVswXVsxXSArICcgJyArIHBhdGhOb2Rlcy52WzBdWzBdICsgJywnICsgcGF0aE5vZGVzLnZbMF1bMV07XG4gICAgfSAvLyBwYXRoTm9kZXMuX19yZW5kZXJlZFN0cmluZyA9IHBhdGhTdHJpbmc7XG5cblxuICAgIGlmICh2aWV3RGF0YS5sYXN0UGF0aCAhPT0gcGF0aFN0cmluZykge1xuICAgICAgdmFyIHBhdGhTaGFwZVZhbHVlID0gJyc7XG5cbiAgICAgIGlmICh2aWV3RGF0YS5lbGVtKSB7XG4gICAgICAgIGlmIChwYXRoTm9kZXMuYykge1xuICAgICAgICAgIHBhdGhTaGFwZVZhbHVlID0gcGF0aERhdGEuaW52ID8gdGhpcy5zb2xpZFBhdGggKyBwYXRoU3RyaW5nIDogcGF0aFN0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIHZpZXdEYXRhLmVsZW0uc2V0QXR0cmlidXRlKCdkJywgcGF0aFNoYXBlVmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB2aWV3RGF0YS5sYXN0UGF0aCA9IHBhdGhTdHJpbmc7XG4gICAgfVxuICB9O1xuXG4gIE1hc2tFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5nbG9iYWxEYXRhID0gbnVsbDtcbiAgICB0aGlzLm1hc2tFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgIHRoaXMubWFza3NQcm9wZXJ0aWVzID0gbnVsbDtcbiAgfTtcblxuICB2YXIgZmlsdGVyc0ZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iID0ge307XG4gICAgb2IuY3JlYXRlRmlsdGVyID0gY3JlYXRlRmlsdGVyO1xuICAgIG9iLmNyZWF0ZUFscGhhVG9MdW1pbmFuY2VGaWx0ZXIgPSBjcmVhdGVBbHBoYVRvTHVtaW5hbmNlRmlsdGVyO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRmlsdGVyKGZpbElkLCBza2lwQ29vcmRpbmF0ZXMpIHtcbiAgICAgIHZhciBmaWwgPSBjcmVhdGVOUygnZmlsdGVyJyk7XG4gICAgICBmaWwuc2V0QXR0cmlidXRlKCdpZCcsIGZpbElkKTtcblxuICAgICAgaWYgKHNraXBDb29yZGluYXRlcyAhPT0gdHJ1ZSkge1xuICAgICAgICBmaWwuc2V0QXR0cmlidXRlKCdmaWx0ZXJVbml0cycsICdvYmplY3RCb3VuZGluZ0JveCcpO1xuICAgICAgICBmaWwuc2V0QXR0cmlidXRlKCd4JywgJzAlJyk7XG4gICAgICAgIGZpbC5zZXRBdHRyaWJ1dGUoJ3knLCAnMCUnKTtcbiAgICAgICAgZmlsLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMTAwJScpO1xuICAgICAgICBmaWwuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnMTAwJScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmlsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFscGhhVG9MdW1pbmFuY2VGaWx0ZXIoKSB7XG4gICAgICB2YXIgZmVDb2xvck1hdHJpeCA9IGNyZWF0ZU5TKCdmZUNvbG9yTWF0cml4Jyk7XG4gICAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgndHlwZScsICdtYXRyaXgnKTtcbiAgICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnc1JHQicpO1xuICAgICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsICcwIDAgMCAxIDAgIDAgMCAwIDEgMCAgMCAwIDAgMSAwICAwIDAgMCAxIDEnKTtcbiAgICAgIHJldHVybiBmZUNvbG9yTWF0cml4O1xuICAgIH1cblxuICAgIHJldHVybiBvYjtcbiAgfSgpO1xuXG4gIHZhciBmZWF0dXJlU3VwcG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2IgPSB7XG4gICAgICBtYXNrVHlwZTogdHJ1ZSxcbiAgICAgIHN2Z0x1bWFIaWRkZW46IHRydWUsXG4gICAgICBvZmZzY3JlZW5DYW52YXM6IHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnXG4gICAgfTtcblxuICAgIGlmICgvTVNJRSAxMC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgL01TSUUgOS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgL3J2OjExLjAvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IC9FZGdlXFwvXFxkLi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgIG9iLm1hc2tUeXBlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKC9maXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgb2Iuc3ZnTHVtYUhpZGRlbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBvYjtcbiAgfSgpO1xuXG4gIHZhciByZWdpc3RlcmVkRWZmZWN0cyQxID0ge307XG4gIHZhciBpZFByZWZpeCA9ICdmaWx0ZXJfcmVzdWx0Xyc7XG5cbiAgZnVuY3Rpb24gU1ZHRWZmZWN0cyhlbGVtKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHNvdXJjZSA9ICdTb3VyY2VHcmFwaGljJztcbiAgICB2YXIgbGVuID0gZWxlbS5kYXRhLmVmID8gZWxlbS5kYXRhLmVmLmxlbmd0aCA6IDA7XG4gICAgdmFyIGZpbElkID0gY3JlYXRlRWxlbWVudElEKCk7XG4gICAgdmFyIGZpbCA9IGZpbHRlcnNGYWN0b3J5LmNyZWF0ZUZpbHRlcihmaWxJZCwgdHJ1ZSk7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB0aGlzLmZpbHRlcnMgPSBbXTtcbiAgICB2YXIgZmlsdGVyTWFuYWdlcjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgZmlsdGVyTWFuYWdlciA9IG51bGw7XG4gICAgICB2YXIgdHlwZSA9IGVsZW0uZGF0YS5lZltpXS50eTtcblxuICAgICAgaWYgKHJlZ2lzdGVyZWRFZmZlY3RzJDFbdHlwZV0pIHtcbiAgICAgICAgdmFyIEVmZmVjdCA9IHJlZ2lzdGVyZWRFZmZlY3RzJDFbdHlwZV0uZWZmZWN0O1xuICAgICAgICBmaWx0ZXJNYW5hZ2VyID0gbmV3IEVmZmVjdChmaWwsIGVsZW0uZWZmZWN0c01hbmFnZXIuZWZmZWN0RWxlbWVudHNbaV0sIGVsZW0sIGlkUHJlZml4ICsgY291bnQsIHNvdXJjZSk7XG4gICAgICAgIHNvdXJjZSA9IGlkUHJlZml4ICsgY291bnQ7XG5cbiAgICAgICAgaWYgKHJlZ2lzdGVyZWRFZmZlY3RzJDFbdHlwZV0uY291bnRzQXNFZmZlY3QpIHtcbiAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWx0ZXJNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMuZmlsdGVycy5wdXNoKGZpbHRlck1hbmFnZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb3VudCkge1xuICAgICAgZWxlbS5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQoZmlsKTtcbiAgICAgIGVsZW0ubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnZmlsdGVyJywgJ3VybCgnICsgZ2V0TG9jYXRpb25IcmVmKCkgKyAnIycgKyBmaWxJZCArICcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgIGVsZW0uYWRkUmVuZGVyYWJsZUNvbXBvbmVudCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBTVkdFZmZlY3RzLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChfaXNGaXJzdEZyYW1lKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuZmlsdGVycy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMuZmlsdGVyc1tpXS5yZW5kZXJGcmFtZShfaXNGaXJzdEZyYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgU1ZHRWZmZWN0cy5wcm90b3R5cGUuZ2V0RWZmZWN0cyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuZmlsdGVycy5sZW5ndGg7XG4gICAgdmFyIGVmZmVjdHMgPSBbXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMuZmlsdGVyc1tpXS50eXBlID09PSB0eXBlKSB7XG4gICAgICAgIGVmZmVjdHMucHVzaCh0aGlzLmZpbHRlcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlZmZlY3RzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyRWZmZWN0JDEoaWQsIGVmZmVjdCwgY291bnRzQXNFZmZlY3QpIHtcbiAgICByZWdpc3RlcmVkRWZmZWN0cyQxW2lkXSA9IHtcbiAgICAgIGVmZmVjdDogZWZmZWN0LFxuICAgICAgY291bnRzQXNFZmZlY3Q6IGNvdW50c0FzRWZmZWN0XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFNWR0Jhc2VFbGVtZW50KCkge31cblxuICBTVkdCYXNlRWxlbWVudC5wcm90b3R5cGUgPSB7XG4gICAgaW5pdFJlbmRlcmVyRWxlbWVudDogZnVuY3Rpb24gaW5pdFJlbmRlcmVyRWxlbWVudCgpIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50ID0gY3JlYXRlTlMoJ2cnKTtcbiAgICB9LFxuICAgIGNyZWF0ZUNvbnRhaW5lckVsZW1lbnRzOiBmdW5jdGlvbiBjcmVhdGVDb250YWluZXJFbGVtZW50cygpIHtcbiAgICAgIHRoaXMubWF0dGVFbGVtZW50ID0gY3JlYXRlTlMoJ2cnKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtZWRFbGVtZW50ID0gdGhpcy5sYXllckVsZW1lbnQ7XG4gICAgICB0aGlzLm1hc2tlZEVsZW1lbnQgPSB0aGlzLmxheWVyRWxlbWVudDtcbiAgICAgIHRoaXMuX3NpemVDaGFuZ2VkID0gZmFsc2U7XG4gICAgICB2YXIgbGF5ZXJFbGVtZW50UGFyZW50ID0gbnVsbDsgLy8gSWYgdGhpcyBsYXllciBhY3RzIGFzIGEgbWFzayBmb3IgdGhlIGZvbGxvd2luZyBsYXllclxuXG4gICAgICBpZiAodGhpcy5kYXRhLnRkKSB7XG4gICAgICAgIHRoaXMubWF0dGVNYXNrcyA9IHt9O1xuICAgICAgICB2YXIgZ2cgPSBjcmVhdGVOUygnZycpO1xuICAgICAgICBnZy5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5sYXllcklkKTtcbiAgICAgICAgZ2cuYXBwZW5kQ2hpbGQodGhpcy5sYXllckVsZW1lbnQpO1xuICAgICAgICBsYXllckVsZW1lbnRQYXJlbnQgPSBnZztcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQoZ2cpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGEudHQpIHtcbiAgICAgICAgdGhpcy5tYXR0ZUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5sYXllckVsZW1lbnQpO1xuICAgICAgICBsYXllckVsZW1lbnRQYXJlbnQgPSB0aGlzLm1hdHRlRWxlbWVudDtcbiAgICAgICAgdGhpcy5iYXNlRWxlbWVudCA9IHRoaXMubWF0dGVFbGVtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iYXNlRWxlbWVudCA9IHRoaXMubGF5ZXJFbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kYXRhLmxuKSB7XG4gICAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLmRhdGEubG4pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kYXRhLmNsKSB7XG4gICAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB0aGlzLmRhdGEuY2wpO1xuICAgICAgfSAvLyBDbGlwcGluZyBjb21wb3NpdGlvbnMgdG8gaGlkZSBjb250ZW50IHRoYXQgZXhjZWVkcyBib3VuZGFyaWVzLiBJZiBjb2xsYXBzZWQgdHJhbnNmb3JtYXRpb25zIGlzIG9uLCBjb21wb25lbnQgc2hvdWxkIG5vdCBiZSBjbGlwcGVkXG5cblxuICAgICAgaWYgKHRoaXMuZGF0YS50eSA9PT0gMCAmJiAhdGhpcy5kYXRhLmhkKSB7XG4gICAgICAgIHZhciBjcCA9IGNyZWF0ZU5TKCdjbGlwUGF0aCcpO1xuICAgICAgICB2YXIgcHQgPSBjcmVhdGVOUygncGF0aCcpO1xuICAgICAgICBwdC5zZXRBdHRyaWJ1dGUoJ2QnLCAnTTAsMCBMJyArIHRoaXMuZGF0YS53ICsgJywwIEwnICsgdGhpcy5kYXRhLncgKyAnLCcgKyB0aGlzLmRhdGEuaCArICcgTDAsJyArIHRoaXMuZGF0YS5oICsgJ3onKTtcbiAgICAgICAgdmFyIGNsaXBJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xuICAgICAgICBjcC5zZXRBdHRyaWJ1dGUoJ2lkJywgY2xpcElkKTtcbiAgICAgICAgY3AuYXBwZW5kQ2hpbGQocHQpO1xuICAgICAgICB0aGlzLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChjcCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY2hlY2tNYXNrcygpKSB7XG4gICAgICAgICAgdmFyIGNwR3JvdXAgPSBjcmVhdGVOUygnZycpO1xuICAgICAgICAgIGNwR3JvdXAuc2V0QXR0cmlidXRlKCdjbGlwLXBhdGgnLCAndXJsKCcgKyBnZXRMb2NhdGlvbkhyZWYoKSArICcjJyArIGNsaXBJZCArICcpJyk7XG4gICAgICAgICAgY3BHcm91cC5hcHBlbmRDaGlsZCh0aGlzLmxheWVyRWxlbWVudCk7XG4gICAgICAgICAgdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQgPSBjcEdyb3VwO1xuXG4gICAgICAgICAgaWYgKGxheWVyRWxlbWVudFBhcmVudCkge1xuICAgICAgICAgICAgbGF5ZXJFbGVtZW50UGFyZW50LmFwcGVuZENoaWxkKHRoaXMudHJhbnNmb3JtZWRFbGVtZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iYXNlRWxlbWVudCA9IHRoaXMudHJhbnNmb3JtZWRFbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgY2xpcElkICsgJyknKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kYXRhLmJtICE9PSAwKSB7XG4gICAgICAgIHRoaXMuc2V0QmxlbmRNb2RlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXJFbGVtZW50OiBmdW5jdGlvbiByZW5kZXJFbGVtZW50KCkge1xuICAgICAgaWYgKHRoaXMuZmluYWxUcmFuc2Zvcm0uX2xvY2FsTWF0TWRmKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtZWRFbGVtZW50LnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgdGhpcy5maW5hbFRyYW5zZm9ybS5sb2NhbE1hdC50bzJkQ1NTKCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5fb3BNZGYpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQuc2V0QXR0cmlidXRlKCdvcGFjaXR5JywgdGhpcy5maW5hbFRyYW5zZm9ybS5sb2NhbE9wYWNpdHkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVzdHJveUJhc2VFbGVtZW50OiBmdW5jdGlvbiBkZXN0cm95QmFzZUVsZW1lbnQoKSB7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLm1hdHRlRWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLm1hc2tNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB9LFxuICAgIGdldEJhc2VFbGVtZW50OiBmdW5jdGlvbiBnZXRCYXNlRWxlbWVudCgpIHtcbiAgICAgIGlmICh0aGlzLmRhdGEuaGQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmJhc2VFbGVtZW50O1xuICAgIH0sXG4gICAgY3JlYXRlUmVuZGVyYWJsZUNvbXBvbmVudHM6IGZ1bmN0aW9uIGNyZWF0ZVJlbmRlcmFibGVDb21wb25lbnRzKCkge1xuICAgICAgdGhpcy5tYXNrTWFuYWdlciA9IG5ldyBNYXNrRWxlbWVudCh0aGlzLmRhdGEsIHRoaXMsIHRoaXMuZ2xvYmFsRGF0YSk7XG4gICAgICB0aGlzLnJlbmRlcmFibGVFZmZlY3RzTWFuYWdlciA9IG5ldyBTVkdFZmZlY3RzKHRoaXMpO1xuICAgICAgdGhpcy5zZWFyY2hFZmZlY3RUcmFuc2Zvcm1zKCk7XG4gICAgfSxcbiAgICBnZXRNYXR0ZTogZnVuY3Rpb24gZ2V0TWF0dGUobWF0dGVUeXBlKSB7XG4gICAgICAvLyBUaGlzIHNob3VsZCBub3QgYmUgYSBjb21tb24gY2FzZS4gQnV0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB3ZSdsbCBjcmVhdGUgdGhlIG1hdHRlIG9iamVjdC5cbiAgICAgIC8vIEl0IHNvbHZlcyBhbmltYXRpb25zIHRoYXQgaGF2ZSB0d28gY29uc2VjdXRpdmUgbGF5ZXJzIG1hcmtlZCBhcyBtYXR0ZSBtYXNrcy5cbiAgICAgIC8vIFdoaWNoIGlzIGFuIHVuZGVmaW5lZCBiZWhhdmlvciBpbiBBRS5cbiAgICAgIGlmICghdGhpcy5tYXR0ZU1hc2tzKSB7XG4gICAgICAgIHRoaXMubWF0dGVNYXNrcyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMubWF0dGVNYXNrc1ttYXR0ZVR5cGVdKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXMubGF5ZXJJZCArICdfJyArIG1hdHRlVHlwZTtcbiAgICAgICAgdmFyIGZpbElkO1xuICAgICAgICB2YXIgZmlsO1xuICAgICAgICB2YXIgdXNlRWxlbWVudDtcbiAgICAgICAgdmFyIGdnO1xuXG4gICAgICAgIGlmIChtYXR0ZVR5cGUgPT09IDEgfHwgbWF0dGVUeXBlID09PSAzKSB7XG4gICAgICAgICAgdmFyIG1hc2tlciA9IGNyZWF0ZU5TKCdtYXNrJyk7XG4gICAgICAgICAgbWFza2VyLnNldEF0dHJpYnV0ZSgnaWQnLCBpZCk7XG4gICAgICAgICAgbWFza2VyLnNldEF0dHJpYnV0ZSgnbWFzay10eXBlJywgbWF0dGVUeXBlID09PSAzID8gJ2x1bWluYW5jZScgOiAnYWxwaGEnKTtcbiAgICAgICAgICB1c2VFbGVtZW50ID0gY3JlYXRlTlMoJ3VzZScpO1xuICAgICAgICAgIHVzZUVsZW1lbnQuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCAnaHJlZicsICcjJyArIHRoaXMubGF5ZXJJZCk7XG4gICAgICAgICAgbWFza2VyLmFwcGVuZENoaWxkKHVzZUVsZW1lbnQpO1xuICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKG1hc2tlcik7XG5cbiAgICAgICAgICBpZiAoIWZlYXR1cmVTdXBwb3J0Lm1hc2tUeXBlICYmIG1hdHRlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgbWFza2VyLnNldEF0dHJpYnV0ZSgnbWFzay10eXBlJywgJ2x1bWluYW5jZScpO1xuICAgICAgICAgICAgZmlsSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICAgICAgICAgIGZpbCA9IGZpbHRlcnNGYWN0b3J5LmNyZWF0ZUZpbHRlcihmaWxJZCk7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChmaWwpO1xuICAgICAgICAgICAgZmlsLmFwcGVuZENoaWxkKGZpbHRlcnNGYWN0b3J5LmNyZWF0ZUFscGhhVG9MdW1pbmFuY2VGaWx0ZXIoKSk7XG4gICAgICAgICAgICBnZyA9IGNyZWF0ZU5TKCdnJyk7XG4gICAgICAgICAgICBnZy5hcHBlbmRDaGlsZCh1c2VFbGVtZW50KTtcbiAgICAgICAgICAgIG1hc2tlci5hcHBlbmRDaGlsZChnZyk7XG4gICAgICAgICAgICBnZy5zZXRBdHRyaWJ1dGUoJ2ZpbHRlcicsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgZmlsSWQgKyAnKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtYXR0ZVR5cGUgPT09IDIpIHtcbiAgICAgICAgICB2YXIgbWFza0dyb3VwID0gY3JlYXRlTlMoJ21hc2snKTtcbiAgICAgICAgICBtYXNrR3JvdXAuc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgICBtYXNrR3JvdXAuc2V0QXR0cmlidXRlKCdtYXNrLXR5cGUnLCAnYWxwaGEnKTtcbiAgICAgICAgICB2YXIgbWFza0dyb3VwZXIgPSBjcmVhdGVOUygnZycpO1xuICAgICAgICAgIG1hc2tHcm91cC5hcHBlbmRDaGlsZChtYXNrR3JvdXBlcik7XG4gICAgICAgICAgZmlsSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICAgICAgICBmaWwgPSBmaWx0ZXJzRmFjdG9yeS5jcmVhdGVGaWx0ZXIoZmlsSWQpOyAvLy8gL1xuXG4gICAgICAgICAgdmFyIGZlQ1RyID0gY3JlYXRlTlMoJ2ZlQ29tcG9uZW50VHJhbnNmZXInKTtcbiAgICAgICAgICBmZUNUci5zZXRBdHRyaWJ1dGUoJ2luJywgJ1NvdXJjZUdyYXBoaWMnKTtcbiAgICAgICAgICBmaWwuYXBwZW5kQ2hpbGQoZmVDVHIpO1xuICAgICAgICAgIHZhciBmZUZ1bmMgPSBjcmVhdGVOUygnZmVGdW5jQScpO1xuICAgICAgICAgIGZlRnVuYy5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGFibGUnKTtcbiAgICAgICAgICBmZUZ1bmMuc2V0QXR0cmlidXRlKCd0YWJsZVZhbHVlcycsICcxLjAgMC4wJyk7XG4gICAgICAgICAgZmVDVHIuYXBwZW5kQ2hpbGQoZmVGdW5jKTsgLy8vIC9cblxuICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKGZpbCk7XG4gICAgICAgICAgdmFyIGFscGhhUmVjdCA9IGNyZWF0ZU5TKCdyZWN0Jyk7XG4gICAgICAgICAgYWxwaGFSZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLmNvbXAuZGF0YS53KTtcbiAgICAgICAgICBhbHBoYVJlY3Quc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmNvbXAuZGF0YS5oKTtcbiAgICAgICAgICBhbHBoYVJlY3Quc2V0QXR0cmlidXRlKCd4JywgJzAnKTtcbiAgICAgICAgICBhbHBoYVJlY3Quc2V0QXR0cmlidXRlKCd5JywgJzAnKTtcbiAgICAgICAgICBhbHBoYVJlY3Quc2V0QXR0cmlidXRlKCdmaWxsJywgJyNmZmZmZmYnKTtcbiAgICAgICAgICBhbHBoYVJlY3Quc2V0QXR0cmlidXRlKCdvcGFjaXR5JywgJzAnKTtcbiAgICAgICAgICBtYXNrR3JvdXBlci5zZXRBdHRyaWJ1dGUoJ2ZpbHRlcicsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgZmlsSWQgKyAnKScpO1xuICAgICAgICAgIG1hc2tHcm91cGVyLmFwcGVuZENoaWxkKGFscGhhUmVjdCk7XG4gICAgICAgICAgdXNlRWxlbWVudCA9IGNyZWF0ZU5TKCd1c2UnKTtcbiAgICAgICAgICB1c2VFbGVtZW50LnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgJ2hyZWYnLCAnIycgKyB0aGlzLmxheWVySWQpO1xuICAgICAgICAgIG1hc2tHcm91cGVyLmFwcGVuZENoaWxkKHVzZUVsZW1lbnQpO1xuXG4gICAgICAgICAgaWYgKCFmZWF0dXJlU3VwcG9ydC5tYXNrVHlwZSkge1xuICAgICAgICAgICAgbWFza0dyb3VwLnNldEF0dHJpYnV0ZSgnbWFzay10eXBlJywgJ2x1bWluYW5jZScpO1xuICAgICAgICAgICAgZmlsLmFwcGVuZENoaWxkKGZpbHRlcnNGYWN0b3J5LmNyZWF0ZUFscGhhVG9MdW1pbmFuY2VGaWx0ZXIoKSk7XG4gICAgICAgICAgICBnZyA9IGNyZWF0ZU5TKCdnJyk7XG4gICAgICAgICAgICBtYXNrR3JvdXBlci5hcHBlbmRDaGlsZChhbHBoYVJlY3QpO1xuICAgICAgICAgICAgZ2cuYXBwZW5kQ2hpbGQodGhpcy5sYXllckVsZW1lbnQpO1xuICAgICAgICAgICAgbWFza0dyb3VwZXIuYXBwZW5kQ2hpbGQoZ2cpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKG1hc2tHcm91cCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1hdHRlTWFza3NbbWF0dGVUeXBlXSA9IGlkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5tYXR0ZU1hc2tzW21hdHRlVHlwZV07XG4gICAgfSxcbiAgICBzZXRNYXR0ZTogZnVuY3Rpb24gc2V0TWF0dGUoaWQpIHtcbiAgICAgIGlmICghdGhpcy5tYXR0ZUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1hdHRlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21hc2snLCAndXJsKCcgKyBnZXRMb2NhdGlvbkhyZWYoKSArICcjJyArIGlkICsgJyknKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXHJcbiAgICogQGZpbGVcclxuICAgKiBIYW5kbGVzIEFFJ3MgbGF5ZXIgcGFyZW50aW5nIHByb3BlcnR5LlxyXG4gICAqXHJcbiAgICovXG4gIGZ1bmN0aW9uIEhpZXJhcmNoeUVsZW1lbnQoKSB7fVxuXG4gIEhpZXJhcmNoeUVsZW1lbnQucHJvdG90eXBlID0ge1xuICAgIC8qKlxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICogSW5pdGlhbGl6ZXMgaGllcmFyY2h5IHByb3BlcnRpZXNcclxuICAgICAgICpcclxuICAgICAgICovXG4gICAgaW5pdEhpZXJhcmNoeTogZnVuY3Rpb24gaW5pdEhpZXJhcmNoeSgpIHtcbiAgICAgIC8vIGVsZW1lbnQncyBwYXJlbnQgbGlzdFxuICAgICAgdGhpcy5oaWVyYXJjaHkgPSBbXTsgLy8gaWYgZWxlbWVudCBpcyBwYXJlbnQgb2YgYW5vdGhlciBsYXllciBfaXNQYXJlbnQgd2lsbCBiZSB0cnVlXG5cbiAgICAgIHRoaXMuX2lzUGFyZW50ID0gZmFsc2U7XG4gICAgICB0aGlzLmNoZWNrUGFyZW50aW5nKCk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICogU2V0cyBsYXllcidzIGhpZXJhcmNoeS5cclxuICAgICAgICogQHBhcmFtIHthcnJheX0gaGllcmFyY2hcclxuICAgICAgICogbGF5ZXIncyBwYXJlbnQgbGlzdFxyXG4gICAgICAgKlxyXG4gICAgICAgKi9cbiAgICBzZXRIaWVyYXJjaHk6IGZ1bmN0aW9uIHNldEhpZXJhcmNoeShoaWVyYXJjaHkpIHtcbiAgICAgIHRoaXMuaGllcmFyY2h5ID0gaGllcmFyY2h5O1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqIFNldHMgbGF5ZXIgYXMgcGFyZW50LlxyXG4gICAgICAgKlxyXG4gICAgICAgKi9cbiAgICBzZXRBc1BhcmVudDogZnVuY3Rpb24gc2V0QXNQYXJlbnQoKSB7XG4gICAgICB0aGlzLl9pc1BhcmVudCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICogU2VhcmNoZXMgbGF5ZXIncyBwYXJlbnRpbmcgY2hhaW5cclxuICAgICAgICpcclxuICAgICAgICovXG4gICAgY2hlY2tQYXJlbnRpbmc6IGZ1bmN0aW9uIGNoZWNrUGFyZW50aW5nKCkge1xuICAgICAgaWYgKHRoaXMuZGF0YS5wYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmNvbXAuYnVpbGRFbGVtZW50UGFyZW50aW5nKHRoaXMsIHRoaXMuZGF0YS5wYXJlbnQsIFtdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gUmVuZGVyYWJsZURPTUVsZW1lbnQoKSB7fVxuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9wcm90b3R5cGUgPSB7XG4gICAgICBpbml0RWxlbWVudDogZnVuY3Rpb24gaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgICAgICB0aGlzLmluaXRGcmFtZSgpO1xuICAgICAgICB0aGlzLmluaXRCYXNlRGF0YShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgICAgICAgdGhpcy5pbml0VHJhbnNmb3JtKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICAgICAgICB0aGlzLmluaXRIaWVyYXJjaHkoKTtcbiAgICAgICAgdGhpcy5pbml0UmVuZGVyYWJsZSgpO1xuICAgICAgICB0aGlzLmluaXRSZW5kZXJlckVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVDb250YWluZXJFbGVtZW50cygpO1xuICAgICAgICB0aGlzLmNyZWF0ZVJlbmRlcmFibGVDb21wb25lbnRzKCk7XG4gICAgICAgIHRoaXMuY3JlYXRlQ29udGVudCgpO1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIH0sXG4gICAgICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnSElERScsIHRoaXMpO1xuICAgICAgICBpZiAoIXRoaXMuaGlkZGVuICYmICghdGhpcy5pc0luUmFuZ2UgfHwgdGhpcy5pc1RyYW5zcGFyZW50KSkge1xuICAgICAgICAgIHZhciBlbGVtID0gdGhpcy5iYXNlRWxlbWVudCB8fCB0aGlzLmxheWVyRWxlbWVudDtcbiAgICAgICAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgdGhpcy5oaWRkZW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1NIT1cnLCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNJblJhbmdlICYmICF0aGlzLmlzVHJhbnNwYXJlbnQpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuZGF0YS5oZCkge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzLmJhc2VFbGVtZW50IHx8IHRoaXMubGF5ZXJFbGVtZW50O1xuICAgICAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZW5kZXJGcmFtZTogZnVuY3Rpb24gcmVuZGVyRnJhbWUoKSB7XG4gICAgICAgIC8vIElmIGl0IGlzIGV4cG9ydGVkIGFzIGhpZGRlbiAoZGF0YS5oZCA9PT0gdHJ1ZSkgbm8gbmVlZCB0byByZW5kZXJcbiAgICAgICAgLy8gSWYgaXQgaXMgbm90IHZpc2libGUgbm8gbmVlZCB0byByZW5kZXJcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5oZCB8fCB0aGlzLmhpZGRlbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVuZGVyVHJhbnNmb3JtKCk7XG4gICAgICAgIHRoaXMucmVuZGVyUmVuZGVyYWJsZSgpO1xuICAgICAgICB0aGlzLnJlbmRlckxvY2FsVHJhbnNmb3JtKCk7XG4gICAgICAgIHRoaXMucmVuZGVyRWxlbWVudCgpO1xuICAgICAgICB0aGlzLnJlbmRlcklubmVyQ29udGVudCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcbiAgICAgICAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlbmRlcklubmVyQ29udGVudDogZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50KCkge30sXG4gICAgICBwcmVwYXJlRnJhbWU6IGZ1bmN0aW9uIHByZXBhcmVGcmFtZShudW0pIHtcbiAgICAgICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJlcGFyZVJlbmRlcmFibGVGcmFtZShudW0pO1xuICAgICAgICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdGhpcy5pc0luUmFuZ2UpO1xuICAgICAgICB0aGlzLmNoZWNrVHJhbnNwYXJlbmN5KCk7XG4gICAgICB9LFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5pbm5lckVsZW0gPSBudWxsO1xuICAgICAgICB0aGlzLmRlc3Ryb3lCYXNlRWxlbWVudCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgZXh0ZW5kUHJvdG90eXBlKFtSZW5kZXJhYmxlRWxlbWVudCwgY3JlYXRlUHJveHlGdW5jdGlvbihfcHJvdG90eXBlKV0sIFJlbmRlcmFibGVET01FbGVtZW50KTtcbiAgfSkoKTtcblxuICBmdW5jdGlvbiBJSW1hZ2VFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmFzc2V0RGF0YSA9IGdsb2JhbERhdGEuZ2V0QXNzZXREYXRhKGRhdGEucmVmSWQpO1xuXG4gICAgaWYgKHRoaXMuYXNzZXREYXRhICYmIHRoaXMuYXNzZXREYXRhLnNpZCkge1xuICAgICAgdGhpcy5hc3NldERhdGEgPSBnbG9iYWxEYXRhLnNsb3RNYW5hZ2VyLmdldFByb3AodGhpcy5hc3NldERhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gICAgdGhpcy5zb3VyY2VSZWN0ID0ge1xuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHdpZHRoOiB0aGlzLmFzc2V0RGF0YS53LFxuICAgICAgaGVpZ2h0OiB0aGlzLmFzc2V0RGF0YS5oXG4gICAgfTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIFNWR0Jhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVET01FbGVtZW50XSwgSUltYWdlRWxlbWVudCk7XG5cbiAgSUltYWdlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXNzZXRQYXRoID0gdGhpcy5nbG9iYWxEYXRhLmdldEFzc2V0c1BhdGgodGhpcy5hc3NldERhdGEpO1xuICAgIHRoaXMuaW5uZXJFbGVtID0gY3JlYXRlTlMoJ2ltYWdlJyk7XG4gICAgdGhpcy5pbm5lckVsZW0uc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuYXNzZXREYXRhLncgKyAncHgnKTtcbiAgICB0aGlzLmlubmVyRWxlbS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuYXNzZXREYXRhLmggKyAncHgnKTtcbiAgICB0aGlzLmlubmVyRWxlbS5zZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCB0aGlzLmFzc2V0RGF0YS5wciB8fCB0aGlzLmdsb2JhbERhdGEucmVuZGVyQ29uZmlnLmltYWdlUHJlc2VydmVBc3BlY3RSYXRpbyk7XG4gICAgdGhpcy5pbm5lckVsZW0uc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCAnaHJlZicsIGFzc2V0UGF0aCk7XG4gICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5pbm5lckVsZW0pO1xuICB9O1xuXG4gIElJbWFnZUVsZW1lbnQucHJvdG90eXBlLnNvdXJjZVJlY3RBdFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlUmVjdDtcbiAgfTtcblxuICBmdW5jdGlvbiBQcm9jZXNzZWRFbGVtZW50KGVsZW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgdGhpcy5lbGVtID0gZWxlbWVudDtcbiAgICB0aGlzLnBvcyA9IHBvc2l0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gSVNoYXBlRWxlbWVudCgpIHt9XG5cbiAgSVNoYXBlRWxlbWVudC5wcm90b3R5cGUgPSB7XG4gICAgYWRkU2hhcGVUb01vZGlmaWVyczogZnVuY3Rpb24gYWRkU2hhcGVUb01vZGlmaWVycyhkYXRhKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSB0aGlzLnNoYXBlTW9kaWZpZXJzLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHRoaXMuc2hhcGVNb2RpZmllcnNbaV0uYWRkU2hhcGUoZGF0YSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc1NoYXBlSW5BbmltYXRlZE1vZGlmaWVyczogZnVuY3Rpb24gaXNTaGFwZUluQW5pbWF0ZWRNb2RpZmllcnMoZGF0YSkge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuc2hhcGVNb2RpZmllcnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBpZiAodGhpcy5zaGFwZU1vZGlmaWVyc1tpXS5pc0FuaW1hdGVkV2l0aFNoYXBlKGRhdGEpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgcmVuZGVyTW9kaWZpZXJzOiBmdW5jdGlvbiByZW5kZXJNb2RpZmllcnMoKSB7XG4gICAgICBpZiAoIXRoaXMuc2hhcGVNb2RpZmllcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gdGhpcy5zaGFwZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5zaGFwZXNbaV0uc2gucmVzZXQoKTtcbiAgICAgIH1cblxuICAgICAgbGVuID0gdGhpcy5zaGFwZU1vZGlmaWVycy5sZW5ndGg7XG4gICAgICB2YXIgc2hvdWxkQnJlYWtQcm9jZXNzO1xuXG4gICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBzaG91bGRCcmVha1Byb2Nlc3MgPSB0aGlzLnNoYXBlTW9kaWZpZXJzW2ldLnByb2Nlc3NTaGFwZXModGhpcy5faXNGaXJzdEZyYW1lKTsgLy8gd29ya2Fyb3VuZCB0byBmaXggY2FzZXMgd2hlcmUgYSByZXBlYXRlciByZXNldHMgdGhlIHNoYXBlIHNvIHRoZSBmb2xsb3dpbmcgcHJvY2Vzc2VzIGdldCBjYWxsZWQgdHdpY2VcbiAgICAgICAgLy8gVE9ETzogZmluZCBhIGJldHRlciBzb2x1dGlvbiBmb3IgdGhpc1xuXG4gICAgICAgIGlmIChzaG91bGRCcmVha1Byb2Nlc3MpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc2VhcmNoUHJvY2Vzc2VkRWxlbWVudDogZnVuY3Rpb24gc2VhcmNoUHJvY2Vzc2VkRWxlbWVudChlbGVtKSB7XG4gICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnByb2Nlc3NlZEVsZW1lbnRzO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgaWYgKGVsZW1lbnRzW2ldLmVsZW0gPT09IGVsZW0pIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudHNbaV0ucG9zO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIGFkZFByb2Nlc3NlZEVsZW1lbnQ6IGZ1bmN0aW9uIGFkZFByb2Nlc3NlZEVsZW1lbnQoZWxlbSwgcG9zKSB7XG4gICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnByb2Nlc3NlZEVsZW1lbnRzO1xuICAgICAgdmFyIGkgPSBlbGVtZW50cy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpKSB7XG4gICAgICAgIGkgLT0gMTtcblxuICAgICAgICBpZiAoZWxlbWVudHNbaV0uZWxlbSA9PT0gZWxlbSkge1xuICAgICAgICAgIGVsZW1lbnRzW2ldLnBvcyA9IHBvcztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWxlbWVudHMucHVzaChuZXcgUHJvY2Vzc2VkRWxlbWVudChlbGVtLCBwb3MpKTtcbiAgICB9LFxuICAgIHByZXBhcmVGcmFtZTogZnVuY3Rpb24gcHJlcGFyZUZyYW1lKG51bSkge1xuICAgICAgdGhpcy5wcmVwYXJlUmVuZGVyYWJsZUZyYW1lKG51bSk7XG4gICAgICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdGhpcy5pc0luUmFuZ2UpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgbGluZUNhcEVudW0gPSB7XG4gICAgMTogJ2J1dHQnLFxuICAgIDI6ICdyb3VuZCcsXG4gICAgMzogJ3NxdWFyZSdcbiAgfTtcbiAgdmFyIGxpbmVKb2luRW51bSA9IHtcbiAgICAxOiAnbWl0ZXInLFxuICAgIDI6ICdyb3VuZCcsXG4gICAgMzogJ2JldmVsJ1xuICB9O1xuXG4gIGZ1bmN0aW9uIFNWR1NoYXBlRGF0YSh0cmFuc2Zvcm1lcnMsIGxldmVsLCBzaGFwZSkge1xuICAgIHRoaXMuY2FjaGVzID0gW107XG4gICAgdGhpcy5zdHlsZXMgPSBbXTtcbiAgICB0aGlzLnRyYW5zZm9ybWVycyA9IHRyYW5zZm9ybWVycztcbiAgICB0aGlzLmxTdHIgPSAnJztcbiAgICB0aGlzLnNoID0gc2hhcGU7XG4gICAgdGhpcy5sdmwgPSBsZXZlbDsgLy8gVE9ETyBmaW5kIGlmIHRoZXJlIGFyZSBzb21lIGNhc2VzIHdoZXJlIF9pc0FuaW1hdGVkIGNhbiBiZSBmYWxzZS5cbiAgICAvLyBGb3Igbm93LCBzaW5jZSBzaGFwZXMgYWRkIHVwIHdpdGggb3RoZXIgc2hhcGVzLiBUaGV5IGhhdmUgdG8gYmUgY2FsY3VsYXRlZCBldmVyeSB0aW1lLlxuICAgIC8vIE9uZSB3YXkgb2YgZmluZGluZyBvdXQgaXMgY2hlY2tpbmcgaWYgYWxsIHN0eWxlcyBhc3NvY2lhdGVkIHRvIHRoaXMgc2hhcGUgZGVwZW5kIG9ubHkgb2YgdGhpcyBzaGFwZVxuXG4gICAgdGhpcy5faXNBbmltYXRlZCA9ICEhc2hhcGUuazsgLy8gVE9ETzogY29tbWVudGluZyB0aGlzIGZvciBub3cgc2luY2UgYWxsIHNoYXBlcyBhcmUgYW5pbWF0ZWRcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdHJhbnNmb3JtZXJzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAodHJhbnNmb3JtZXJzW2ldLm1Qcm9wcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5faXNBbmltYXRlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpICs9IDE7XG4gICAgfVxuICB9XG5cbiAgU1ZHU2hhcGVEYXRhLnByb3RvdHlwZS5zZXRBc0FuaW1hdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSB0cnVlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFNWR1N0eWxlRGF0YShkYXRhLCBsZXZlbCkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy50eXBlID0gZGF0YS50eTtcbiAgICB0aGlzLmQgPSAnJztcbiAgICB0aGlzLmx2bCA9IGxldmVsO1xuICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICAgIHRoaXMuY2xvc2VkID0gZGF0YS5oZCA9PT0gdHJ1ZTtcbiAgICB0aGlzLnBFbGVtID0gY3JlYXRlTlMoJ3BhdGgnKTtcbiAgICB0aGlzLm1zRWxlbSA9IG51bGw7XG4gIH1cblxuICBTVkdTdHlsZURhdGEucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZCA9ICcnO1xuICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIERhc2hQcm9wZXJ0eShlbGVtLCBkYXRhLCByZW5kZXJlciwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICB0aGlzLmZyYW1lSWQgPSAtMTtcbiAgICB0aGlzLmRhdGFQcm9wcyA9IGNyZWF0ZVNpemVkQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLmsgPSBmYWxzZTtcbiAgICB0aGlzLmRhc2hTdHIgPSAnJztcbiAgICB0aGlzLmRhc2hBcnJheSA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBkYXRhLmxlbmd0aCA/IGRhdGEubGVuZ3RoIC0gMSA6IDApO1xuICAgIHRoaXMuZGFzaG9mZnNldCA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCAxKTtcbiAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoY29udGFpbmVyKTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gZGF0YS5sZW5ndGggfHwgMDtcbiAgICB2YXIgcHJvcDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgcHJvcCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGFbaV0udiwgMCwgMCwgdGhpcyk7XG4gICAgICB0aGlzLmsgPSBwcm9wLmsgfHwgdGhpcy5rO1xuICAgICAgdGhpcy5kYXRhUHJvcHNbaV0gPSB7XG4gICAgICAgIG46IGRhdGFbaV0ubixcbiAgICAgICAgcDogcHJvcFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaykge1xuICAgICAgdGhpcy5nZXRWYWx1ZSh0cnVlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gdGhpcy5rO1xuICB9XG5cbiAgRGFzaFByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChmb3JjZVJlbmRlcikge1xuICAgIGlmICh0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLmZyYW1lSWQgJiYgIWZvcmNlUmVuZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5mcmFtZUlkID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZDtcbiAgICB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcygpO1xuICAgIHRoaXMuX21kZiA9IHRoaXMuX21kZiB8fCBmb3JjZVJlbmRlcjtcblxuICAgIGlmICh0aGlzLl9tZGYpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmRhdGFQcm9wcy5sZW5ndGg7XG5cbiAgICAgIGlmICh0aGlzLnJlbmRlcmVyID09PSAnc3ZnJykge1xuICAgICAgICB0aGlzLmRhc2hTdHIgPSAnJztcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFQcm9wc1tpXS5uICE9PSAnbycpIHtcbiAgICAgICAgICBpZiAodGhpcy5yZW5kZXJlciA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICAgIHRoaXMuZGFzaFN0ciArPSAnICcgKyB0aGlzLmRhdGFQcm9wc1tpXS5wLnY7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGFzaEFycmF5W2ldID0gdGhpcy5kYXRhUHJvcHNbaV0ucC52O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRhc2hvZmZzZXRbMF0gPSB0aGlzLmRhdGFQcm9wc1tpXS5wLnY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBEYXNoUHJvcGVydHkpO1xuXG4gIGZ1bmN0aW9uIFNWR1N0cm9rZVN0eWxlRGF0YShlbGVtLCBkYXRhLCBzdHlsZU9iKSB7XG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xuICAgIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcztcbiAgICB0aGlzLm8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm8sIDAsIDAuMDEsIHRoaXMpO1xuICAgIHRoaXMudyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEudywgMCwgbnVsbCwgdGhpcyk7XG4gICAgdGhpcy5kID0gbmV3IERhc2hQcm9wZXJ0eShlbGVtLCBkYXRhLmQgfHwge30sICdzdmcnLCB0aGlzKTtcbiAgICB0aGlzLmMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmMsIDEsIDI1NSwgdGhpcyk7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlT2I7XG4gICAgdGhpcy5faXNBbmltYXRlZCA9ICEhdGhpcy5faXNBbmltYXRlZDtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgU1ZHU3Ryb2tlU3R5bGVEYXRhKTtcblxuICBmdW5jdGlvbiBTVkdGaWxsU3R5bGVEYXRhKGVsZW0sIGRhdGEsIHN0eWxlT2IpIHtcbiAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzO1xuICAgIHRoaXMubyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEubywgMCwgMC4wMSwgdGhpcyk7XG4gICAgdGhpcy5jID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5jLCAxLCAyNTUsIHRoaXMpO1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZU9iO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBTVkdGaWxsU3R5bGVEYXRhKTtcblxuICBmdW5jdGlvbiBTVkdOb1N0eWxlRGF0YShlbGVtLCBkYXRhLCBzdHlsZU9iKSB7XG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xuICAgIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcztcbiAgICB0aGlzLnN0eWxlID0gc3R5bGVPYjtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgU1ZHTm9TdHlsZURhdGEpO1xuXG4gIGZ1bmN0aW9uIEdyYWRpZW50UHJvcGVydHkoZWxlbSwgZGF0YSwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmMgPSBjcmVhdGVUeXBlZEFycmF5KCd1aW50OGMnLCBkYXRhLnAgKiA0KTtcbiAgICB2YXIgY0xlbmd0aCA9IGRhdGEuay5rWzBdLnMgPyBkYXRhLmsua1swXS5zLmxlbmd0aCAtIGRhdGEucCAqIDQgOiBkYXRhLmsuay5sZW5ndGggLSBkYXRhLnAgKiA0O1xuICAgIHRoaXMubyA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBjTGVuZ3RoKTtcbiAgICB0aGlzLl9jbWRmID0gZmFsc2U7XG4gICAgdGhpcy5fb21kZiA9IGZhbHNlO1xuICAgIHRoaXMuX2NvbGxhcHNhYmxlID0gdGhpcy5jaGVja0NvbGxhcHNhYmxlKCk7XG4gICAgdGhpcy5faGFzT3BhY2l0eSA9IGNMZW5ndGg7XG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdGhpcy5wcm9wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5rLCAxLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLmsgPSB0aGlzLnByb3AuaztcbiAgICB0aGlzLmdldFZhbHVlKHRydWUpO1xuICB9XG5cbiAgR3JhZGllbnRQcm9wZXJ0eS5wcm90b3R5cGUuY29tcGFyZVBvaW50cyA9IGZ1bmN0aW9uICh2YWx1ZXMsIHBvaW50cykge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdGhpcy5vLmxlbmd0aCAvIDI7XG4gICAgdmFyIGRpZmY7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgZGlmZiA9IE1hdGguYWJzKHZhbHVlc1tpICogNF0gLSB2YWx1ZXNbcG9pbnRzICogNCArIGkgKiAyXSk7XG5cbiAgICAgIGlmIChkaWZmID4gMC4wMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBHcmFkaWVudFByb3BlcnR5LnByb3RvdHlwZS5jaGVja0NvbGxhcHNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm8ubGVuZ3RoIC8gMiAhPT0gdGhpcy5jLmxlbmd0aCAvIDQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kYXRhLmsua1swXS5zKSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgbGVuID0gdGhpcy5kYXRhLmsuay5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIGlmICghdGhpcy5jb21wYXJlUG9pbnRzKHRoaXMuZGF0YS5rLmtbaV0ucywgdGhpcy5kYXRhLnApKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXRoaXMuY29tcGFyZVBvaW50cyh0aGlzLmRhdGEuay5rLCB0aGlzLmRhdGEucCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBHcmFkaWVudFByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChmb3JjZVJlbmRlcikge1xuICAgIHRoaXMucHJvcC5nZXRWYWx1ZSgpO1xuICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICAgIHRoaXMuX2NtZGYgPSBmYWxzZTtcbiAgICB0aGlzLl9vbWRmID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5wcm9wLl9tZGYgfHwgZm9yY2VSZW5kZXIpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZGF0YS5wICogNDtcbiAgICAgIHZhciBtdWx0O1xuICAgICAgdmFyIHZhbDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIG11bHQgPSBpICUgNCA9PT0gMCA/IDEwMCA6IDI1NTtcbiAgICAgICAgdmFsID0gTWF0aC5yb3VuZCh0aGlzLnByb3AudltpXSAqIG11bHQpO1xuXG4gICAgICAgIGlmICh0aGlzLmNbaV0gIT09IHZhbCkge1xuICAgICAgICAgIHRoaXMuY1tpXSA9IHZhbDtcbiAgICAgICAgICB0aGlzLl9jbWRmID0gIWZvcmNlUmVuZGVyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm8ubGVuZ3RoKSB7XG4gICAgICAgIGxlbiA9IHRoaXMucHJvcC52Lmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSB0aGlzLmRhdGEucCAqIDQ7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIG11bHQgPSBpICUgMiA9PT0gMCA/IDEwMCA6IDE7XG4gICAgICAgICAgdmFsID0gaSAlIDIgPT09IDAgPyBNYXRoLnJvdW5kKHRoaXMucHJvcC52W2ldICogMTAwKSA6IHRoaXMucHJvcC52W2ldO1xuXG4gICAgICAgICAgaWYgKHRoaXMub1tpIC0gdGhpcy5kYXRhLnAgKiA0XSAhPT0gdmFsKSB7XG4gICAgICAgICAgICB0aGlzLm9baSAtIHRoaXMuZGF0YS5wICogNF0gPSB2YWw7XG4gICAgICAgICAgICB0aGlzLl9vbWRmID0gIWZvcmNlUmVuZGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9tZGYgPSAhZm9yY2VSZW5kZXI7XG4gICAgfVxuICB9O1xuXG4gIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgR3JhZGllbnRQcm9wZXJ0eSk7XG5cbiAgZnVuY3Rpb24gU1ZHR3JhZGllbnRGaWxsU3R5bGVEYXRhKGVsZW0sIGRhdGEsIHN0eWxlT2IpIHtcbiAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzO1xuICAgIHRoaXMuaW5pdEdyYWRpZW50RGF0YShlbGVtLCBkYXRhLCBzdHlsZU9iKTtcbiAgfVxuXG4gIFNWR0dyYWRpZW50RmlsbFN0eWxlRGF0YS5wcm90b3R5cGUuaW5pdEdyYWRpZW50RGF0YSA9IGZ1bmN0aW9uIChlbGVtLCBkYXRhLCBzdHlsZU9iKSB7XG4gICAgdGhpcy5vID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5vLCAwLCAwLjAxLCB0aGlzKTtcbiAgICB0aGlzLnMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnMsIDEsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMuZSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuZSwgMSwgbnVsbCwgdGhpcyk7XG4gICAgdGhpcy5oID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5oIHx8IHtcbiAgICAgIGs6IDBcbiAgICB9LCAwLCAwLjAxLCB0aGlzKTtcbiAgICB0aGlzLmEgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmEgfHwge1xuICAgICAgazogMFxuICAgIH0sIDAsIGRlZ1RvUmFkcywgdGhpcyk7XG4gICAgdGhpcy5nID0gbmV3IEdyYWRpZW50UHJvcGVydHkoZWxlbSwgZGF0YS5nLCB0aGlzKTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGVPYjtcbiAgICB0aGlzLnN0b3BzID0gW107XG4gICAgdGhpcy5zZXRHcmFkaWVudERhdGEoc3R5bGVPYi5wRWxlbSwgZGF0YSk7XG4gICAgdGhpcy5zZXRHcmFkaWVudE9wYWNpdHkoZGF0YSwgc3R5bGVPYik7XG4gICAgdGhpcy5faXNBbmltYXRlZCA9ICEhdGhpcy5faXNBbmltYXRlZDtcbiAgfTtcblxuICBTVkdHcmFkaWVudEZpbGxTdHlsZURhdGEucHJvdG90eXBlLnNldEdyYWRpZW50RGF0YSA9IGZ1bmN0aW9uIChwYXRoRWxlbWVudCwgZGF0YSkge1xuICAgIHZhciBncmFkaWVudElkID0gY3JlYXRlRWxlbWVudElEKCk7XG4gICAgdmFyIGdmaWxsID0gY3JlYXRlTlMoZGF0YS50ID09PSAxID8gJ2xpbmVhckdyYWRpZW50JyA6ICdyYWRpYWxHcmFkaWVudCcpO1xuICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgnaWQnLCBncmFkaWVudElkKTtcbiAgICBnZmlsbC5zZXRBdHRyaWJ1dGUoJ3NwcmVhZE1ldGhvZCcsICdwYWQnKTtcbiAgICBnZmlsbC5zZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VW5pdHMnLCAndXNlclNwYWNlT25Vc2UnKTtcbiAgICB2YXIgc3RvcHMgPSBbXTtcbiAgICB2YXIgc3RvcDtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICBqTGVuID0gZGF0YS5nLnAgKiA0O1xuXG4gICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gNCkge1xuICAgICAgc3RvcCA9IGNyZWF0ZU5TKCdzdG9wJyk7XG4gICAgICBnZmlsbC5hcHBlbmRDaGlsZChzdG9wKTtcbiAgICAgIHN0b3BzLnB1c2goc3RvcCk7XG4gICAgfVxuXG4gICAgcGF0aEVsZW1lbnQuc2V0QXR0cmlidXRlKGRhdGEudHkgPT09ICdnZicgPyAnZmlsbCcgOiAnc3Ryb2tlJywgJ3VybCgnICsgZ2V0TG9jYXRpb25IcmVmKCkgKyAnIycgKyBncmFkaWVudElkICsgJyknKTtcbiAgICB0aGlzLmdmID0gZ2ZpbGw7XG4gICAgdGhpcy5jc3QgPSBzdG9wcztcbiAgfTtcblxuICBTVkdHcmFkaWVudEZpbGxTdHlsZURhdGEucHJvdG90eXBlLnNldEdyYWRpZW50T3BhY2l0eSA9IGZ1bmN0aW9uIChkYXRhLCBzdHlsZU9iKSB7XG4gICAgaWYgKHRoaXMuZy5faGFzT3BhY2l0eSAmJiAhdGhpcy5nLl9jb2xsYXBzYWJsZSkge1xuICAgICAgdmFyIHN0b3A7XG4gICAgICB2YXIgajtcbiAgICAgIHZhciBqTGVuO1xuICAgICAgdmFyIG1hc2sgPSBjcmVhdGVOUygnbWFzaycpO1xuICAgICAgdmFyIG1hc2tFbGVtZW50ID0gY3JlYXRlTlMoJ3BhdGgnKTtcbiAgICAgIG1hc2suYXBwZW5kQ2hpbGQobWFza0VsZW1lbnQpO1xuICAgICAgdmFyIG9wYWNpdHlJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xuICAgICAgdmFyIG1hc2tJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xuICAgICAgbWFzay5zZXRBdHRyaWJ1dGUoJ2lkJywgbWFza0lkKTtcbiAgICAgIHZhciBvcEZpbGwgPSBjcmVhdGVOUyhkYXRhLnQgPT09IDEgPyAnbGluZWFyR3JhZGllbnQnIDogJ3JhZGlhbEdyYWRpZW50Jyk7XG4gICAgICBvcEZpbGwuc2V0QXR0cmlidXRlKCdpZCcsIG9wYWNpdHlJZCk7XG4gICAgICBvcEZpbGwuc2V0QXR0cmlidXRlKCdzcHJlYWRNZXRob2QnLCAncGFkJyk7XG4gICAgICBvcEZpbGwuc2V0QXR0cmlidXRlKCdncmFkaWVudFVuaXRzJywgJ3VzZXJTcGFjZU9uVXNlJyk7XG4gICAgICBqTGVuID0gZGF0YS5nLmsua1swXS5zID8gZGF0YS5nLmsua1swXS5zLmxlbmd0aCA6IGRhdGEuZy5rLmsubGVuZ3RoO1xuICAgICAgdmFyIHN0b3BzID0gdGhpcy5zdG9wcztcblxuICAgICAgZm9yIChqID0gZGF0YS5nLnAgKiA0OyBqIDwgakxlbjsgaiArPSAyKSB7XG4gICAgICAgIHN0b3AgPSBjcmVhdGVOUygnc3RvcCcpO1xuICAgICAgICBzdG9wLnNldEF0dHJpYnV0ZSgnc3RvcC1jb2xvcicsICdyZ2IoMjU1LDI1NSwyNTUpJyk7XG4gICAgICAgIG9wRmlsbC5hcHBlbmRDaGlsZChzdG9wKTtcbiAgICAgICAgc3RvcHMucHVzaChzdG9wKTtcbiAgICAgIH1cblxuICAgICAgbWFza0VsZW1lbnQuc2V0QXR0cmlidXRlKGRhdGEudHkgPT09ICdnZicgPyAnZmlsbCcgOiAnc3Ryb2tlJywgJ3VybCgnICsgZ2V0TG9jYXRpb25IcmVmKCkgKyAnIycgKyBvcGFjaXR5SWQgKyAnKScpO1xuXG4gICAgICBpZiAoZGF0YS50eSA9PT0gJ2dzJykge1xuICAgICAgICBtYXNrRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgbGluZUNhcEVudW1bZGF0YS5sYyB8fCAyXSk7XG4gICAgICAgIG1hc2tFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgbGluZUpvaW5FbnVtW2RhdGEubGogfHwgMl0pO1xuXG4gICAgICAgIGlmIChkYXRhLmxqID09PSAxKSB7XG4gICAgICAgICAgbWFza0VsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHJva2UtbWl0ZXJsaW1pdCcsIGRhdGEubWwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMub2YgPSBvcEZpbGw7XG4gICAgICB0aGlzLm1zID0gbWFzaztcbiAgICAgIHRoaXMub3N0ID0gc3RvcHM7XG4gICAgICB0aGlzLm1hc2tJZCA9IG1hc2tJZDtcbiAgICAgIHN0eWxlT2IubXNFbGVtID0gbWFza0VsZW1lbnQ7XG4gICAgfVxuICB9O1xuXG4gIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgU1ZHR3JhZGllbnRGaWxsU3R5bGVEYXRhKTtcblxuICBmdW5jdGlvbiBTVkdHcmFkaWVudFN0cm9rZVN0eWxlRGF0YShlbGVtLCBkYXRhLCBzdHlsZU9iKSB7XG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xuICAgIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcztcbiAgICB0aGlzLncgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLncsIDAsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMuZCA9IG5ldyBEYXNoUHJvcGVydHkoZWxlbSwgZGF0YS5kIHx8IHt9LCAnc3ZnJywgdGhpcyk7XG4gICAgdGhpcy5pbml0R3JhZGllbnREYXRhKGVsZW0sIGRhdGEsIHN0eWxlT2IpO1xuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSAhIXRoaXMuX2lzQW5pbWF0ZWQ7XG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW1NWR0dyYWRpZW50RmlsbFN0eWxlRGF0YSwgRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgU1ZHR3JhZGllbnRTdHJva2VTdHlsZURhdGEpO1xuXG4gIGZ1bmN0aW9uIFNoYXBlR3JvdXBEYXRhKCkge1xuICAgIHRoaXMuaXQgPSBbXTtcbiAgICB0aGlzLnByZXZWaWV3RGF0YSA9IFtdO1xuICAgIHRoaXMuZ3IgPSBjcmVhdGVOUygnZycpO1xuICB9XG5cbiAgZnVuY3Rpb24gU1ZHVHJhbnNmb3JtRGF0YShtUHJvcHMsIG9wLCBjb250YWluZXIpIHtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IHtcbiAgICAgIG1Qcm9wczogbVByb3BzLFxuICAgICAgb3A6IG9wLFxuICAgICAgY29udGFpbmVyOiBjb250YWluZXJcbiAgICB9O1xuICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gdGhpcy50cmFuc2Zvcm0ubVByb3BzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCB8fCB0aGlzLnRyYW5zZm9ybS5vcC5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoO1xuICB9XG5cbiAgdmFyIGJ1aWxkU2hhcGVTdHJpbmcgPSBmdW5jdGlvbiBidWlsZFNoYXBlU3RyaW5nKHBhdGhOb2RlcywgbGVuZ3RoLCBjbG9zZWQsIG1hdCkge1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICB2YXIgX28gPSBwYXRoTm9kZXMubztcbiAgICB2YXIgX2kgPSBwYXRoTm9kZXMuaTtcbiAgICB2YXIgX3YgPSBwYXRoTm9kZXMudjtcbiAgICB2YXIgaTtcbiAgICB2YXIgc2hhcGVTdHJpbmcgPSAnIE0nICsgbWF0LmFwcGx5VG9Qb2ludFN0cmluZ2lmaWVkKF92WzBdWzBdLCBfdlswXVsxXSk7XG5cbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHNoYXBlU3RyaW5nICs9ICcgQycgKyBtYXQuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQoX29baSAtIDFdWzBdLCBfb1tpIC0gMV1bMV0pICsgJyAnICsgbWF0LmFwcGx5VG9Qb2ludFN0cmluZ2lmaWVkKF9pW2ldWzBdLCBfaVtpXVsxXSkgKyAnICcgKyBtYXQuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQoX3ZbaV1bMF0sIF92W2ldWzFdKTtcbiAgICB9XG5cbiAgICBpZiAoY2xvc2VkICYmIGxlbmd0aCkge1xuICAgICAgc2hhcGVTdHJpbmcgKz0gJyBDJyArIG1hdC5hcHBseVRvUG9pbnRTdHJpbmdpZmllZChfb1tpIC0gMV1bMF0sIF9vW2kgLSAxXVsxXSkgKyAnICcgKyBtYXQuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQoX2lbMF1bMF0sIF9pWzBdWzFdKSArICcgJyArIG1hdC5hcHBseVRvUG9pbnRTdHJpbmdpZmllZChfdlswXVswXSwgX3ZbMF1bMV0pO1xuICAgICAgc2hhcGVTdHJpbmcgKz0gJ3onO1xuICAgIH1cblxuICAgIHJldHVybiBzaGFwZVN0cmluZztcbiAgfTtcblxuICB2YXIgU1ZHRWxlbWVudHNSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2lkZW50aXR5TWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuXG4gICAgdmFyIF9tYXRyaXhIZWxwZXIgPSBuZXcgTWF0cml4KCk7XG5cbiAgICB2YXIgb2IgPSB7XG4gICAgICBjcmVhdGVSZW5kZXJGdW5jdGlvbjogY3JlYXRlUmVuZGVyRnVuY3Rpb25cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVuZGVyRnVuY3Rpb24oZGF0YSkge1xuICAgICAgc3dpdGNoIChkYXRhLnR5KSB7XG4gICAgICAgIGNhc2UgJ2ZsJzpcbiAgICAgICAgICByZXR1cm4gcmVuZGVyRmlsbDtcblxuICAgICAgICBjYXNlICdnZic6XG4gICAgICAgICAgcmV0dXJuIHJlbmRlckdyYWRpZW50O1xuXG4gICAgICAgIGNhc2UgJ2dzJzpcbiAgICAgICAgICByZXR1cm4gcmVuZGVyR3JhZGllbnRTdHJva2U7XG5cbiAgICAgICAgY2FzZSAnc3QnOlxuICAgICAgICAgIHJldHVybiByZW5kZXJTdHJva2U7XG5cbiAgICAgICAgY2FzZSAnc2gnOlxuICAgICAgICBjYXNlICdlbCc6XG4gICAgICAgIGNhc2UgJ3JjJzpcbiAgICAgICAgY2FzZSAnc3InOlxuICAgICAgICAgIHJldHVybiByZW5kZXJQYXRoO1xuXG4gICAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgICByZXR1cm4gcmVuZGVyQ29udGVudFRyYW5zZm9ybTtcblxuICAgICAgICBjYXNlICdubyc6XG4gICAgICAgICAgcmV0dXJuIHJlbmRlck5vb3A7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXJDb250ZW50VHJhbnNmb3JtKHN0eWxlRGF0YSwgaXRlbURhdGEsIGlzRmlyc3RGcmFtZSkge1xuICAgICAgaWYgKGlzRmlyc3RGcmFtZSB8fCBpdGVtRGF0YS50cmFuc2Zvcm0ub3AuX21kZikge1xuICAgICAgICBpdGVtRGF0YS50cmFuc2Zvcm0uY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScsIGl0ZW1EYXRhLnRyYW5zZm9ybS5vcC52KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRmlyc3RGcmFtZSB8fCBpdGVtRGF0YS50cmFuc2Zvcm0ubVByb3BzLl9tZGYpIHtcbiAgICAgICAgaXRlbURhdGEudHJhbnNmb3JtLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIGl0ZW1EYXRhLnRyYW5zZm9ybS5tUHJvcHMudi50bzJkQ1NTKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlck5vb3AoKSB7fVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyUGF0aChzdHlsZURhdGEsIGl0ZW1EYXRhLCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHZhciBqO1xuICAgICAgdmFyIGpMZW47XG4gICAgICB2YXIgcGF0aFN0cmluZ1RyYW5zZm9ybWVkO1xuICAgICAgdmFyIHJlZHJhdztcbiAgICAgIHZhciBwYXRoTm9kZXM7XG4gICAgICB2YXIgbDtcbiAgICAgIHZhciBsTGVuID0gaXRlbURhdGEuc3R5bGVzLmxlbmd0aDtcbiAgICAgIHZhciBsdmwgPSBpdGVtRGF0YS5sdmw7XG4gICAgICB2YXIgcGF0aHM7XG4gICAgICB2YXIgbWF0O1xuICAgICAgdmFyIGl0ZXJhdGlvbnM7XG4gICAgICB2YXIgaztcblxuICAgICAgZm9yIChsID0gMDsgbCA8IGxMZW47IGwgKz0gMSkge1xuICAgICAgICByZWRyYXcgPSBpdGVtRGF0YS5zaC5fbWRmIHx8IGlzRmlyc3RGcmFtZTtcblxuICAgICAgICBpZiAoaXRlbURhdGEuc3R5bGVzW2xdLmx2bCA8IGx2bCkge1xuICAgICAgICAgIG1hdCA9IF9tYXRyaXhIZWxwZXIucmVzZXQoKTtcbiAgICAgICAgICBpdGVyYXRpb25zID0gbHZsIC0gaXRlbURhdGEuc3R5bGVzW2xdLmx2bDtcbiAgICAgICAgICBrID0gaXRlbURhdGEudHJhbnNmb3JtZXJzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICB3aGlsZSAoIXJlZHJhdyAmJiBpdGVyYXRpb25zID4gMCkge1xuICAgICAgICAgICAgcmVkcmF3ID0gaXRlbURhdGEudHJhbnNmb3JtZXJzW2tdLm1Qcm9wcy5fbWRmIHx8IHJlZHJhdztcbiAgICAgICAgICAgIGl0ZXJhdGlvbnMgLT0gMTtcbiAgICAgICAgICAgIGsgLT0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmVkcmF3KSB7XG4gICAgICAgICAgICBpdGVyYXRpb25zID0gbHZsIC0gaXRlbURhdGEuc3R5bGVzW2xdLmx2bDtcbiAgICAgICAgICAgIGsgPSBpdGVtRGF0YS50cmFuc2Zvcm1lcnMubGVuZ3RoIC0gMTtcblxuICAgICAgICAgICAgd2hpbGUgKGl0ZXJhdGlvbnMgPiAwKSB7XG4gICAgICAgICAgICAgIG1hdC5tdWx0aXBseShpdGVtRGF0YS50cmFuc2Zvcm1lcnNba10ubVByb3BzLnYpO1xuICAgICAgICAgICAgICBpdGVyYXRpb25zIC09IDE7XG4gICAgICAgICAgICAgIGsgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0ID0gX2lkZW50aXR5TWF0cml4O1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aHMgPSBpdGVtRGF0YS5zaC5wYXRocztcbiAgICAgICAgakxlbiA9IHBhdGhzLl9sZW5ndGg7XG5cbiAgICAgICAgaWYgKHJlZHJhdykge1xuICAgICAgICAgIHBhdGhTdHJpbmdUcmFuc2Zvcm1lZCA9ICcnO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgcGF0aE5vZGVzID0gcGF0aHMuc2hhcGVzW2pdO1xuXG4gICAgICAgICAgICBpZiAocGF0aE5vZGVzICYmIHBhdGhOb2Rlcy5fbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHBhdGhTdHJpbmdUcmFuc2Zvcm1lZCArPSBidWlsZFNoYXBlU3RyaW5nKHBhdGhOb2RlcywgcGF0aE5vZGVzLl9sZW5ndGgsIHBhdGhOb2Rlcy5jLCBtYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGl0ZW1EYXRhLmNhY2hlc1tsXSA9IHBhdGhTdHJpbmdUcmFuc2Zvcm1lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoU3RyaW5nVHJhbnNmb3JtZWQgPSBpdGVtRGF0YS5jYWNoZXNbbF07XG4gICAgICAgIH1cblxuICAgICAgICBpdGVtRGF0YS5zdHlsZXNbbF0uZCArPSBzdHlsZURhdGEuaGQgPT09IHRydWUgPyAnJyA6IHBhdGhTdHJpbmdUcmFuc2Zvcm1lZDtcbiAgICAgICAgaXRlbURhdGEuc3R5bGVzW2xdLl9tZGYgPSByZWRyYXcgfHwgaXRlbURhdGEuc3R5bGVzW2xdLl9tZGY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyRmlsbChzdHlsZURhdGEsIGl0ZW1EYXRhLCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHZhciBzdHlsZUVsZW0gPSBpdGVtRGF0YS5zdHlsZTtcblxuICAgICAgaWYgKGl0ZW1EYXRhLmMuX21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgICAgc3R5bGVFbGVtLnBFbGVtLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdyZ2IoJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzBdKSArICcsJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzFdKSArICcsJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzJdKSArICcpJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtRGF0YS5vLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICAgIHN0eWxlRWxlbS5wRWxlbS5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsIGl0ZW1EYXRhLm8udik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyR3JhZGllbnRTdHJva2Uoc3R5bGVEYXRhLCBpdGVtRGF0YSwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICByZW5kZXJHcmFkaWVudChzdHlsZURhdGEsIGl0ZW1EYXRhLCBpc0ZpcnN0RnJhbWUpO1xuICAgICAgcmVuZGVyU3Ryb2tlKHN0eWxlRGF0YSwgaXRlbURhdGEsIGlzRmlyc3RGcmFtZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyR3JhZGllbnQoc3R5bGVEYXRhLCBpdGVtRGF0YSwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICB2YXIgZ2ZpbGwgPSBpdGVtRGF0YS5nZjtcbiAgICAgIHZhciBoYXNPcGFjaXR5ID0gaXRlbURhdGEuZy5faGFzT3BhY2l0eTtcbiAgICAgIHZhciBwdDEgPSBpdGVtRGF0YS5zLnY7XG4gICAgICB2YXIgcHQyID0gaXRlbURhdGEuZS52O1xuXG4gICAgICBpZiAoaXRlbURhdGEuby5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xuICAgICAgICB2YXIgYXR0ciA9IHN0eWxlRGF0YS50eSA9PT0gJ2dmJyA/ICdmaWxsLW9wYWNpdHknIDogJ3N0cm9rZS1vcGFjaXR5JztcbiAgICAgICAgaXRlbURhdGEuc3R5bGUucEVsZW0uc2V0QXR0cmlidXRlKGF0dHIsIGl0ZW1EYXRhLm8udik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtRGF0YS5zLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICAgIHZhciBhdHRyMSA9IHN0eWxlRGF0YS50ID09PSAxID8gJ3gxJyA6ICdjeCc7XG4gICAgICAgIHZhciBhdHRyMiA9IGF0dHIxID09PSAneDEnID8gJ3kxJyA6ICdjeSc7XG4gICAgICAgIGdmaWxsLnNldEF0dHJpYnV0ZShhdHRyMSwgcHQxWzBdKTtcbiAgICAgICAgZ2ZpbGwuc2V0QXR0cmlidXRlKGF0dHIyLCBwdDFbMV0pO1xuXG4gICAgICAgIGlmIChoYXNPcGFjaXR5ICYmICFpdGVtRGF0YS5nLl9jb2xsYXBzYWJsZSkge1xuICAgICAgICAgIGl0ZW1EYXRhLm9mLnNldEF0dHJpYnV0ZShhdHRyMSwgcHQxWzBdKTtcbiAgICAgICAgICBpdGVtRGF0YS5vZi5zZXRBdHRyaWJ1dGUoYXR0cjIsIHB0MVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHN0b3BzO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuO1xuICAgICAgdmFyIHN0b3A7XG5cbiAgICAgIGlmIChpdGVtRGF0YS5nLl9jbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xuICAgICAgICBzdG9wcyA9IGl0ZW1EYXRhLmNzdDtcbiAgICAgICAgdmFyIGNWYWx1ZXMgPSBpdGVtRGF0YS5nLmM7XG4gICAgICAgIGxlbiA9IHN0b3BzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBzdG9wID0gc3RvcHNbaV07XG4gICAgICAgICAgc3RvcC5zZXRBdHRyaWJ1dGUoJ29mZnNldCcsIGNWYWx1ZXNbaSAqIDRdICsgJyUnKTtcbiAgICAgICAgICBzdG9wLnNldEF0dHJpYnV0ZSgnc3RvcC1jb2xvcicsICdyZ2IoJyArIGNWYWx1ZXNbaSAqIDQgKyAxXSArICcsJyArIGNWYWx1ZXNbaSAqIDQgKyAyXSArICcsJyArIGNWYWx1ZXNbaSAqIDQgKyAzXSArICcpJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhhc09wYWNpdHkgJiYgKGl0ZW1EYXRhLmcuX29tZGYgfHwgaXNGaXJzdEZyYW1lKSkge1xuICAgICAgICB2YXIgb1ZhbHVlcyA9IGl0ZW1EYXRhLmcubztcblxuICAgICAgICBpZiAoaXRlbURhdGEuZy5fY29sbGFwc2FibGUpIHtcbiAgICAgICAgICBzdG9wcyA9IGl0ZW1EYXRhLmNzdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdG9wcyA9IGl0ZW1EYXRhLm9zdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbiA9IHN0b3BzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBzdG9wID0gc3RvcHNbaV07XG5cbiAgICAgICAgICBpZiAoIWl0ZW1EYXRhLmcuX2NvbGxhcHNhYmxlKSB7XG4gICAgICAgICAgICBzdG9wLnNldEF0dHJpYnV0ZSgnb2Zmc2V0Jywgb1ZhbHVlc1tpICogMl0gKyAnJScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0b3Auc2V0QXR0cmlidXRlKCdzdG9wLW9wYWNpdHknLCBvVmFsdWVzW2kgKiAyICsgMV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZURhdGEudCA9PT0gMSkge1xuICAgICAgICBpZiAoaXRlbURhdGEuZS5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xuICAgICAgICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgneDInLCBwdDJbMF0pO1xuICAgICAgICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgneTInLCBwdDJbMV0pO1xuXG4gICAgICAgICAgaWYgKGhhc09wYWNpdHkgJiYgIWl0ZW1EYXRhLmcuX2NvbGxhcHNhYmxlKSB7XG4gICAgICAgICAgICBpdGVtRGF0YS5vZi5zZXRBdHRyaWJ1dGUoJ3gyJywgcHQyWzBdKTtcbiAgICAgICAgICAgIGl0ZW1EYXRhLm9mLnNldEF0dHJpYnV0ZSgneTInLCBwdDJbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJhZDtcblxuICAgICAgICBpZiAoaXRlbURhdGEucy5fbWRmIHx8IGl0ZW1EYXRhLmUuX21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgICAgICByYWQgPSBNYXRoLnNxcnQoTWF0aC5wb3cocHQxWzBdIC0gcHQyWzBdLCAyKSArIE1hdGgucG93KHB0MVsxXSAtIHB0MlsxXSwgMikpO1xuICAgICAgICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgncicsIHJhZCk7XG5cbiAgICAgICAgICBpZiAoaGFzT3BhY2l0eSAmJiAhaXRlbURhdGEuZy5fY29sbGFwc2FibGUpIHtcbiAgICAgICAgICAgIGl0ZW1EYXRhLm9mLnNldEF0dHJpYnV0ZSgncicsIHJhZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW1EYXRhLmUuX21kZiB8fCBpdGVtRGF0YS5oLl9tZGYgfHwgaXRlbURhdGEuYS5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xuICAgICAgICAgIGlmICghcmFkKSB7XG4gICAgICAgICAgICByYWQgPSBNYXRoLnNxcnQoTWF0aC5wb3cocHQxWzBdIC0gcHQyWzBdLCAyKSArIE1hdGgucG93KHB0MVsxXSAtIHB0MlsxXSwgMikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBhbmcgPSBNYXRoLmF0YW4yKHB0MlsxXSAtIHB0MVsxXSwgcHQyWzBdIC0gcHQxWzBdKTtcbiAgICAgICAgICB2YXIgcGVyY2VudCA9IGl0ZW1EYXRhLmgudjtcblxuICAgICAgICAgIGlmIChwZXJjZW50ID49IDEpIHtcbiAgICAgICAgICAgIHBlcmNlbnQgPSAwLjk5O1xuICAgICAgICAgIH0gZWxzZSBpZiAocGVyY2VudCA8PSAtMSkge1xuICAgICAgICAgICAgcGVyY2VudCA9IC0wLjk5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkaXN0ID0gcmFkICogcGVyY2VudDtcbiAgICAgICAgICB2YXIgeCA9IE1hdGguY29zKGFuZyArIGl0ZW1EYXRhLmEudikgKiBkaXN0ICsgcHQxWzBdO1xuICAgICAgICAgIHZhciB5ID0gTWF0aC5zaW4oYW5nICsgaXRlbURhdGEuYS52KSAqIGRpc3QgKyBwdDFbMV07XG4gICAgICAgICAgZ2ZpbGwuc2V0QXR0cmlidXRlKCdmeCcsIHgpO1xuICAgICAgICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgnZnknLCB5KTtcblxuICAgICAgICAgIGlmIChoYXNPcGFjaXR5ICYmICFpdGVtRGF0YS5nLl9jb2xsYXBzYWJsZSkge1xuICAgICAgICAgICAgaXRlbURhdGEub2Yuc2V0QXR0cmlidXRlKCdmeCcsIHgpO1xuICAgICAgICAgICAgaXRlbURhdGEub2Yuc2V0QXR0cmlidXRlKCdmeScsIHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBnZmlsbC5zZXRBdHRyaWJ1dGUoJ2Z5JywnMjAwJyk7XG5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXJTdHJva2Uoc3R5bGVEYXRhLCBpdGVtRGF0YSwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICB2YXIgc3R5bGVFbGVtID0gaXRlbURhdGEuc3R5bGU7XG4gICAgICB2YXIgZCA9IGl0ZW1EYXRhLmQ7XG5cbiAgICAgIGlmIChkICYmIChkLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSAmJiBkLmRhc2hTdHIpIHtcbiAgICAgICAgc3R5bGVFbGVtLnBFbGVtLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIGQuZGFzaFN0cik7XG4gICAgICAgIHN0eWxlRWxlbS5wRWxlbS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0JywgZC5kYXNob2Zmc2V0WzBdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1EYXRhLmMgJiYgKGl0ZW1EYXRhLmMuX21kZiB8fCBpc0ZpcnN0RnJhbWUpKSB7XG4gICAgICAgIHN0eWxlRWxlbS5wRWxlbS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICdyZ2IoJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzBdKSArICcsJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzFdKSArICcsJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzJdKSArICcpJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtRGF0YS5vLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICAgIHN0eWxlRWxlbS5wRWxlbS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1vcGFjaXR5JywgaXRlbURhdGEuby52KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1EYXRhLncuX21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgICAgc3R5bGVFbGVtLnBFbGVtLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgaXRlbURhdGEudy52KTtcblxuICAgICAgICBpZiAoc3R5bGVFbGVtLm1zRWxlbSkge1xuICAgICAgICAgIHN0eWxlRWxlbS5tc0VsZW0uc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBpdGVtRGF0YS53LnYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iO1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gU1ZHU2hhcGVFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICAvLyBMaXN0IG9mIGRyYXdhYmxlIGVsZW1lbnRzXG4gICAgdGhpcy5zaGFwZXMgPSBbXTsgLy8gRnVsbCBzaGFwZSBkYXRhXG5cbiAgICB0aGlzLnNoYXBlc0RhdGEgPSBkYXRhLnNoYXBlczsgLy8gTGlzdCBvZiBzdHlsZXMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gc2hhcGVzXG5cbiAgICB0aGlzLnN0eWxlc0xpc3QgPSBbXTsgLy8gTGlzdCBvZiBtb2RpZmllcnMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gc2hhcGVzXG5cbiAgICB0aGlzLnNoYXBlTW9kaWZpZXJzID0gW107IC8vIExpc3Qgb2YgaXRlbXMgaW4gc2hhcGUgdHJlZVxuXG4gICAgdGhpcy5pdGVtc0RhdGEgPSBbXTsgLy8gTGlzdCBvZiBpdGVtcyBpbiBwcmV2aW91cyBzaGFwZSB0cmVlXG5cbiAgICB0aGlzLnByb2Nlc3NlZEVsZW1lbnRzID0gW107IC8vIExpc3Qgb2YgYW5pbWF0ZWQgY29tcG9uZW50c1xuXG4gICAgdGhpcy5hbmltYXRlZENvbnRlbnRzID0gW107XG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTsgLy8gTW92aW5nIGFueSBwcm9wZXJ0eSB0aGF0IGRvZXNuJ3QgZ2V0IHRvbyBtdWNoIGFjY2VzcyBhZnRlciBpbml0aWFsaXphdGlvbiBiZWNhdXNlIG9mIHY4IHdheSBvZiBoYW5kbGluZyBtb3JlIHRoYW4gMTAgcHJvcGVydGllcy5cbiAgICAvLyBMaXN0IG9mIGVsZW1lbnRzIHRoYXQgaGF2ZSBiZWVuIGNyZWF0ZWRcblxuICAgIHRoaXMucHJldlZpZXdEYXRhID0gW107IC8vIE1vdmluZyBhbnkgcHJvcGVydHkgdGhhdCBkb2Vzbid0IGdldCB0b28gbXVjaCBhY2Nlc3MgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gYmVjYXVzZSBvZiB2OCB3YXkgb2YgaGFuZGxpbmcgbW9yZSB0aGFuIDEwIHByb3BlcnRpZXMuXG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBTVkdCYXNlRWxlbWVudCwgSVNoYXBlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRE9NRWxlbWVudF0sIFNWR1NoYXBlRWxlbWVudCk7XG5cbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5pbml0U2Vjb25kYXJ5RWxlbWVudCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuaWRlbnRpdHlNYXRyaXggPSBuZXcgTWF0cml4KCk7XG5cbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5idWlsZEV4cHJlc3Npb25JbnRlcmZhY2UgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBTVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZWFyY2hTaGFwZXModGhpcy5zaGFwZXNEYXRhLCB0aGlzLml0ZW1zRGF0YSwgdGhpcy5wcmV2Vmlld0RhdGEsIHRoaXMubGF5ZXJFbGVtZW50LCAwLCBbXSwgdHJ1ZSk7XG4gICAgdGhpcy5maWx0ZXJVbmlxdWVTaGFwZXMoKTtcbiAgfTtcbiAgLypcclxuICBUaGlzIG1ldGhvZCBzZWFyY2hlcyBmb3IgbXVsdGlwbGUgc2hhcGVzIHRoYXQgYWZmZWN0IGEgc2luZ2xlIGVsZW1lbnQgYW5kIG9uZSBvZiB0aGVtIGlzIGFuaW1hdGVkXHJcbiAgKi9cblxuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuZmlsdGVyVW5pcXVlU2hhcGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLnNoYXBlcy5sZW5ndGg7XG4gICAgdmFyIHNoYXBlO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuID0gdGhpcy5zdHlsZXNMaXN0Lmxlbmd0aDtcbiAgICB2YXIgc3R5bGU7XG4gICAgdmFyIHRlbXBTaGFwZXMgPSBbXTtcbiAgICB2YXIgYXJlQW5pbWF0ZWQgPSBmYWxzZTtcblxuICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgIHN0eWxlID0gdGhpcy5zdHlsZXNMaXN0W2pdO1xuICAgICAgYXJlQW5pbWF0ZWQgPSBmYWxzZTtcbiAgICAgIHRlbXBTaGFwZXMubGVuZ3RoID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHNoYXBlID0gdGhpcy5zaGFwZXNbaV07XG5cbiAgICAgICAgaWYgKHNoYXBlLnN0eWxlcy5pbmRleE9mKHN0eWxlKSAhPT0gLTEpIHtcbiAgICAgICAgICB0ZW1wU2hhcGVzLnB1c2goc2hhcGUpO1xuICAgICAgICAgIGFyZUFuaW1hdGVkID0gc2hhcGUuX2lzQW5pbWF0ZWQgfHwgYXJlQW5pbWF0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRlbXBTaGFwZXMubGVuZ3RoID4gMSAmJiBhcmVBbmltYXRlZCkge1xuICAgICAgICB0aGlzLnNldFNoYXBlc0FzQW5pbWF0ZWQodGVtcFNoYXBlcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuc2V0U2hhcGVzQXNBbmltYXRlZCA9IGZ1bmN0aW9uIChzaGFwZXMpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gc2hhcGVzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgc2hhcGVzW2ldLnNldEFzQW5pbWF0ZWQoKTtcbiAgICB9XG4gIH07XG5cbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTdHlsZUVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSwgbGV2ZWwpIHtcbiAgICAvLyBUT0RPOiBwcmV2ZW50IGRyYXdpbmcgb2YgaGlkZGVuIHN0eWxlc1xuICAgIHZhciBlbGVtZW50RGF0YTtcbiAgICB2YXIgc3R5bGVPYiA9IG5ldyBTVkdTdHlsZURhdGEoZGF0YSwgbGV2ZWwpO1xuICAgIHZhciBwYXRoRWxlbWVudCA9IHN0eWxlT2IucEVsZW07XG5cbiAgICBpZiAoZGF0YS50eSA9PT0gJ3N0Jykge1xuICAgICAgZWxlbWVudERhdGEgPSBuZXcgU1ZHU3Ryb2tlU3R5bGVEYXRhKHRoaXMsIGRhdGEsIHN0eWxlT2IpO1xuICAgIH0gZWxzZSBpZiAoZGF0YS50eSA9PT0gJ2ZsJykge1xuICAgICAgZWxlbWVudERhdGEgPSBuZXcgU1ZHRmlsbFN0eWxlRGF0YSh0aGlzLCBkYXRhLCBzdHlsZU9iKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdnZicgfHwgZGF0YS50eSA9PT0gJ2dzJykge1xuICAgICAgdmFyIEdyYWRpZW50Q29uc3RydWN0b3IgPSBkYXRhLnR5ID09PSAnZ2YnID8gU1ZHR3JhZGllbnRGaWxsU3R5bGVEYXRhIDogU1ZHR3JhZGllbnRTdHJva2VTdHlsZURhdGE7XG4gICAgICBlbGVtZW50RGF0YSA9IG5ldyBHcmFkaWVudENvbnN0cnVjdG9yKHRoaXMsIGRhdGEsIHN0eWxlT2IpO1xuICAgICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQoZWxlbWVudERhdGEuZ2YpO1xuXG4gICAgICBpZiAoZWxlbWVudERhdGEubWFza0lkKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKGVsZW1lbnREYXRhLm1zKTtcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQoZWxlbWVudERhdGEub2YpO1xuICAgICAgICBwYXRoRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21hc2snLCAndXJsKCcgKyBnZXRMb2NhdGlvbkhyZWYoKSArICcjJyArIGVsZW1lbnREYXRhLm1hc2tJZCArICcpJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkYXRhLnR5ID09PSAnbm8nKSB7XG4gICAgICBlbGVtZW50RGF0YSA9IG5ldyBTVkdOb1N0eWxlRGF0YSh0aGlzLCBkYXRhLCBzdHlsZU9iKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS50eSA9PT0gJ3N0JyB8fCBkYXRhLnR5ID09PSAnZ3MnKSB7XG4gICAgICBwYXRoRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgbGluZUNhcEVudW1bZGF0YS5sYyB8fCAyXSk7XG4gICAgICBwYXRoRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicsIGxpbmVKb2luRW51bVtkYXRhLmxqIHx8IDJdKTtcbiAgICAgIHBhdGhFbGVtZW50LnNldEF0dHJpYnV0ZSgnZmlsbC1vcGFjaXR5JywgJzAnKTtcblxuICAgICAgaWYgKGRhdGEubGogPT09IDEpIHtcbiAgICAgICAgcGF0aEVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHJva2UtbWl0ZXJsaW1pdCcsIGRhdGEubWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkYXRhLnIgPT09IDIpIHtcbiAgICAgIHBhdGhFbGVtZW50LnNldEF0dHJpYnV0ZSgnZmlsbC1ydWxlJywgJ2V2ZW5vZGQnKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sbikge1xuICAgICAgcGF0aEVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIGRhdGEubG4pO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmNsKSB7XG4gICAgICBwYXRoRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgZGF0YS5jbCk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuYm0pIHtcbiAgICAgIHBhdGhFbGVtZW50LnN0eWxlWydtaXgtYmxlbmQtbW9kZSddID0gZ2V0QmxlbmRNb2RlKGRhdGEuYm0pO1xuICAgIH1cblxuICAgIHRoaXMuc3R5bGVzTGlzdC5wdXNoKHN0eWxlT2IpO1xuICAgIHRoaXMuYWRkVG9BbmltYXRlZENvbnRlbnRzKGRhdGEsIGVsZW1lbnREYXRhKTtcbiAgICByZXR1cm4gZWxlbWVudERhdGE7XG4gIH07XG5cbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVHcm91cEVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBlbGVtZW50RGF0YSA9IG5ldyBTaGFwZUdyb3VwRGF0YSgpO1xuXG4gICAgaWYgKGRhdGEubG4pIHtcbiAgICAgIGVsZW1lbnREYXRhLmdyLnNldEF0dHJpYnV0ZSgnaWQnLCBkYXRhLmxuKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5jbCkge1xuICAgICAgZWxlbWVudERhdGEuZ3Iuc2V0QXR0cmlidXRlKCdjbGFzcycsIGRhdGEuY2wpO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmJtKSB7XG4gICAgICBlbGVtZW50RGF0YS5nci5zdHlsZVsnbWl4LWJsZW5kLW1vZGUnXSA9IGdldEJsZW5kTW9kZShkYXRhLmJtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudERhdGE7XG4gIH07XG5cbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVUcmFuc2Zvcm1FbGVtZW50ID0gZnVuY3Rpb24gKGRhdGEsIGNvbnRhaW5lcikge1xuICAgIHZhciB0cmFuc2Zvcm1Qcm9wZXJ0eSA9IFRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeS5nZXRUcmFuc2Zvcm1Qcm9wZXJ0eSh0aGlzLCBkYXRhLCB0aGlzKTtcbiAgICB2YXIgZWxlbWVudERhdGEgPSBuZXcgU1ZHVHJhbnNmb3JtRGF0YSh0cmFuc2Zvcm1Qcm9wZXJ0eSwgdHJhbnNmb3JtUHJvcGVydHkubywgY29udGFpbmVyKTtcbiAgICB0aGlzLmFkZFRvQW5pbWF0ZWRDb250ZW50cyhkYXRhLCBlbGVtZW50RGF0YSk7XG4gICAgcmV0dXJuIGVsZW1lbnREYXRhO1xuICB9O1xuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlU2hhcGVFbGVtZW50ID0gZnVuY3Rpb24gKGRhdGEsIG93blRyYW5zZm9ybWVycywgbGV2ZWwpIHtcbiAgICB2YXIgdHkgPSA0O1xuXG4gICAgaWYgKGRhdGEudHkgPT09ICdyYycpIHtcbiAgICAgIHR5ID0gNTtcbiAgICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdlbCcpIHtcbiAgICAgIHR5ID0gNjtcbiAgICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdzcicpIHtcbiAgICAgIHR5ID0gNztcbiAgICB9XG5cbiAgICB2YXIgc2hhcGVQcm9wZXJ0eSA9IFNoYXBlUHJvcGVydHlGYWN0b3J5LmdldFNoYXBlUHJvcCh0aGlzLCBkYXRhLCB0eSwgdGhpcyk7XG4gICAgdmFyIGVsZW1lbnREYXRhID0gbmV3IFNWR1NoYXBlRGF0YShvd25UcmFuc2Zvcm1lcnMsIGxldmVsLCBzaGFwZVByb3BlcnR5KTtcbiAgICB0aGlzLnNoYXBlcy5wdXNoKGVsZW1lbnREYXRhKTtcbiAgICB0aGlzLmFkZFNoYXBlVG9Nb2RpZmllcnMoZWxlbWVudERhdGEpO1xuICAgIHRoaXMuYWRkVG9BbmltYXRlZENvbnRlbnRzKGRhdGEsIGVsZW1lbnREYXRhKTtcbiAgICByZXR1cm4gZWxlbWVudERhdGE7XG4gIH07XG5cbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5hZGRUb0FuaW1hdGVkQ29udGVudHMgPSBmdW5jdGlvbiAoZGF0YSwgZWxlbWVudCkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdGhpcy5hbmltYXRlZENvbnRlbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAodGhpcy5hbmltYXRlZENvbnRlbnRzW2ldLmVsZW1lbnQgPT09IGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpICs9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5hbmltYXRlZENvbnRlbnRzLnB1c2goe1xuICAgICAgZm46IFNWR0VsZW1lbnRzUmVuZGVyZXIuY3JlYXRlUmVuZGVyRnVuY3Rpb24oZGF0YSksXG4gICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pO1xuICB9O1xuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuc2V0RWxlbWVudFN0eWxlcyA9IGZ1bmN0aW9uIChlbGVtZW50RGF0YSkge1xuICAgIHZhciBhcnIgPSBlbGVtZW50RGF0YS5zdHlsZXM7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW4gPSB0aGlzLnN0eWxlc0xpc3QubGVuZ3RoO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlc0xpc3Rbal0uY2xvc2VkKSB7XG4gICAgICAgIGFyci5wdXNoKHRoaXMuc3R5bGVzTGlzdFtqXSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUucmVsb2FkU2hhcGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuaXRlbXNEYXRhLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgdGhpcy5wcmV2Vmlld0RhdGFbaV0gPSB0aGlzLml0ZW1zRGF0YVtpXTtcbiAgICB9XG5cbiAgICB0aGlzLnNlYXJjaFNoYXBlcyh0aGlzLnNoYXBlc0RhdGEsIHRoaXMuaXRlbXNEYXRhLCB0aGlzLnByZXZWaWV3RGF0YSwgdGhpcy5sYXllckVsZW1lbnQsIDAsIFtdLCB0cnVlKTtcbiAgICB0aGlzLmZpbHRlclVuaXF1ZVNoYXBlcygpO1xuICAgIGxlbiA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldLmdldFZhbHVlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJNb2RpZmllcnMoKTtcbiAgfTtcblxuICBTVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLnNlYXJjaFNoYXBlcyA9IGZ1bmN0aW9uIChhcnIsIGl0ZW1zRGF0YSwgcHJldlZpZXdEYXRhLCBjb250YWluZXIsIGxldmVsLCB0cmFuc2Zvcm1lcnMsIHJlbmRlcikge1xuICAgIHZhciBvd25UcmFuc2Zvcm1lcnMgPSBbXS5jb25jYXQodHJhbnNmb3JtZXJzKTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW47XG4gICAgdmFyIG93blN0eWxlcyA9IFtdO1xuICAgIHZhciBvd25Nb2RpZmllcnMgPSBbXTtcbiAgICB2YXIgY3VycmVudFRyYW5zZm9ybTtcbiAgICB2YXIgbW9kaWZpZXI7XG4gICAgdmFyIHByb2Nlc3NlZFBvcztcblxuICAgIGZvciAoaSA9IGxlbjsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIHByb2Nlc3NlZFBvcyA9IHRoaXMuc2VhcmNoUHJvY2Vzc2VkRWxlbWVudChhcnJbaV0pO1xuXG4gICAgICBpZiAoIXByb2Nlc3NlZFBvcykge1xuICAgICAgICBhcnJbaV0uX3JlbmRlciA9IHJlbmRlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1zRGF0YVtpXSA9IHByZXZWaWV3RGF0YVtwcm9jZXNzZWRQb3MgLSAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFycltpXS50eSA9PT0gJ2ZsJyB8fCBhcnJbaV0udHkgPT09ICdzdCcgfHwgYXJyW2ldLnR5ID09PSAnZ2YnIHx8IGFycltpXS50eSA9PT0gJ2dzJyB8fCBhcnJbaV0udHkgPT09ICdubycpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0gPSB0aGlzLmNyZWF0ZVN0eWxlRWxlbWVudChhcnJbaV0sIGxldmVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0uc3R5bGUuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJyW2ldLl9yZW5kZXIpIHtcbiAgICAgICAgICBpZiAoaXRlbXNEYXRhW2ldLnN0eWxlLnBFbGVtLnBhcmVudE5vZGUgIT09IGNvbnRhaW5lcikge1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGl0ZW1zRGF0YVtpXS5zdHlsZS5wRWxlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb3duU3R5bGVzLnB1c2goaXRlbXNEYXRhW2ldLnN0eWxlKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAnZ3InKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgaXRlbXNEYXRhW2ldID0gdGhpcy5jcmVhdGVHcm91cEVsZW1lbnQoYXJyW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBqTGVuID0gaXRlbXNEYXRhW2ldLml0Lmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGl0ZW1zRGF0YVtpXS5wcmV2Vmlld0RhdGFbal0gPSBpdGVtc0RhdGFbaV0uaXRbal07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZWFyY2hTaGFwZXMoYXJyW2ldLml0LCBpdGVtc0RhdGFbaV0uaXQsIGl0ZW1zRGF0YVtpXS5wcmV2Vmlld0RhdGEsIGl0ZW1zRGF0YVtpXS5nciwgbGV2ZWwgKyAxLCBvd25UcmFuc2Zvcm1lcnMsIHJlbmRlcik7XG5cbiAgICAgICAgaWYgKGFycltpXS5fcmVuZGVyKSB7XG4gICAgICAgICAgaWYgKGl0ZW1zRGF0YVtpXS5nci5wYXJlbnROb2RlICE9PSBjb250YWluZXIpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChpdGVtc0RhdGFbaV0uZ3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICd0cicpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0gPSB0aGlzLmNyZWF0ZVRyYW5zZm9ybUVsZW1lbnQoYXJyW2ldLCBjb250YWluZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFRyYW5zZm9ybSA9IGl0ZW1zRGF0YVtpXS50cmFuc2Zvcm07XG4gICAgICAgIG93blRyYW5zZm9ybWVycy5wdXNoKGN1cnJlbnRUcmFuc2Zvcm0pO1xuICAgICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICdzaCcgfHwgYXJyW2ldLnR5ID09PSAncmMnIHx8IGFycltpXS50eSA9PT0gJ2VsJyB8fCBhcnJbaV0udHkgPT09ICdzcicpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0gPSB0aGlzLmNyZWF0ZVNoYXBlRWxlbWVudChhcnJbaV0sIG93blRyYW5zZm9ybWVycywgbGV2ZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRFbGVtZW50U3R5bGVzKGl0ZW1zRGF0YVtpXSk7XG4gICAgICB9IGVsc2UgaWYgKGFycltpXS50eSA9PT0gJ3RtJyB8fCBhcnJbaV0udHkgPT09ICdyZCcgfHwgYXJyW2ldLnR5ID09PSAnbXMnIHx8IGFycltpXS50eSA9PT0gJ3BiJyB8fCBhcnJbaV0udHkgPT09ICd6eicgfHwgYXJyW2ldLnR5ID09PSAnb3AnKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgbW9kaWZpZXIgPSBTaGFwZU1vZGlmaWVycy5nZXRNb2RpZmllcihhcnJbaV0udHkpO1xuICAgICAgICAgIG1vZGlmaWVyLmluaXQodGhpcywgYXJyW2ldKTtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0gPSBtb2RpZmllcjtcbiAgICAgICAgICB0aGlzLnNoYXBlTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGlmaWVyID0gaXRlbXNEYXRhW2ldO1xuICAgICAgICAgIG1vZGlmaWVyLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3duTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICdycCcpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcbiAgICAgICAgICBtb2RpZmllciA9IFNoYXBlTW9kaWZpZXJzLmdldE1vZGlmaWVyKGFycltpXS50eSk7XG4gICAgICAgICAgaXRlbXNEYXRhW2ldID0gbW9kaWZpZXI7XG4gICAgICAgICAgbW9kaWZpZXIuaW5pdCh0aGlzLCBhcnIsIGksIGl0ZW1zRGF0YSk7XG4gICAgICAgICAgdGhpcy5zaGFwZU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgICAgICAgICByZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RpZmllciA9IGl0ZW1zRGF0YVtpXTtcbiAgICAgICAgICBtb2RpZmllci5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3duTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFkZFByb2Nlc3NlZEVsZW1lbnQoYXJyW2ldLCBpICsgMSk7XG4gICAgfVxuXG4gICAgbGVuID0gb3duU3R5bGVzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgb3duU3R5bGVzW2ldLmNsb3NlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgbGVuID0gb3duTW9kaWZpZXJzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgb3duTW9kaWZpZXJzW2ldLmNsb3NlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVuZGVyTW9kaWZpZXJzKCk7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuc3R5bGVzTGlzdC5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMuc3R5bGVzTGlzdFtpXS5yZXNldCgpO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyU2hhcGUoKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMuc3R5bGVzTGlzdFtpXS5fbWRmIHx8IHRoaXMuX2lzRmlyc3RGcmFtZSkge1xuICAgICAgICBpZiAodGhpcy5zdHlsZXNMaXN0W2ldLm1zRWxlbSkge1xuICAgICAgICAgIHRoaXMuc3R5bGVzTGlzdFtpXS5tc0VsZW0uc2V0QXR0cmlidXRlKCdkJywgdGhpcy5zdHlsZXNMaXN0W2ldLmQpOyAvLyBBZGRpbmcgTTAgMCBmaXhlcyBzYW1lIG1hc2sgYnVnIG9uIGFsbCBicm93c2Vyc1xuXG4gICAgICAgICAgdGhpcy5zdHlsZXNMaXN0W2ldLmQgPSAnTTAgMCcgKyB0aGlzLnN0eWxlc0xpc3RbaV0uZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3R5bGVzTGlzdFtpXS5wRWxlbS5zZXRBdHRyaWJ1dGUoJ2QnLCB0aGlzLnN0eWxlc0xpc3RbaV0uZCB8fCAnTTAgMCcpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBTVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlclNoYXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmFuaW1hdGVkQ29udGVudHMubGVuZ3RoO1xuICAgIHZhciBhbmltYXRlZENvbnRlbnQ7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGFuaW1hdGVkQ29udGVudCA9IHRoaXMuYW5pbWF0ZWRDb250ZW50c1tpXTtcblxuICAgICAgaWYgKCh0aGlzLl9pc0ZpcnN0RnJhbWUgfHwgYW5pbWF0ZWRDb250ZW50LmVsZW1lbnQuX2lzQW5pbWF0ZWQpICYmIGFuaW1hdGVkQ29udGVudC5kYXRhICE9PSB0cnVlKSB7XG4gICAgICAgIGFuaW1hdGVkQ29udGVudC5mbihhbmltYXRlZENvbnRlbnQuZGF0YSwgYW5pbWF0ZWRDb250ZW50LmVsZW1lbnQsIHRoaXMuX2lzRmlyc3RGcmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlc3Ryb3lCYXNlRWxlbWVudCgpO1xuICAgIHRoaXMuc2hhcGVzRGF0YSA9IG51bGw7XG4gICAgdGhpcy5pdGVtc0RhdGEgPSBudWxsO1xuICB9O1xuXG4gIGZ1bmN0aW9uIExldHRlclByb3BzKG8sIHN3LCBzYywgZmMsIG0sIHApIHtcbiAgICB0aGlzLm8gPSBvO1xuICAgIHRoaXMuc3cgPSBzdztcbiAgICB0aGlzLnNjID0gc2M7XG4gICAgdGhpcy5mYyA9IGZjO1xuICAgIHRoaXMubSA9IG07XG4gICAgdGhpcy5wID0gcDtcbiAgICB0aGlzLl9tZGYgPSB7XG4gICAgICBvOiB0cnVlLFxuICAgICAgc3c6ICEhc3csXG4gICAgICBzYzogISFzYyxcbiAgICAgIGZjOiAhIWZjLFxuICAgICAgbTogdHJ1ZSxcbiAgICAgIHA6IHRydWVcbiAgICB9O1xuICB9XG5cbiAgTGV0dGVyUHJvcHMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChvLCBzdywgc2MsIGZjLCBtLCBwKSB7XG4gICAgdGhpcy5fbWRmLm8gPSBmYWxzZTtcbiAgICB0aGlzLl9tZGYuc3cgPSBmYWxzZTtcbiAgICB0aGlzLl9tZGYuc2MgPSBmYWxzZTtcbiAgICB0aGlzLl9tZGYuZmMgPSBmYWxzZTtcbiAgICB0aGlzLl9tZGYubSA9IGZhbHNlO1xuICAgIHRoaXMuX21kZi5wID0gZmFsc2U7XG4gICAgdmFyIHVwZGF0ZWQgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLm8gIT09IG8pIHtcbiAgICAgIHRoaXMubyA9IG87XG4gICAgICB0aGlzLl9tZGYubyA9IHRydWU7XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdyAhPT0gc3cpIHtcbiAgICAgIHRoaXMuc3cgPSBzdztcbiAgICAgIHRoaXMuX21kZi5zdyA9IHRydWU7XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zYyAhPT0gc2MpIHtcbiAgICAgIHRoaXMuc2MgPSBzYztcbiAgICAgIHRoaXMuX21kZi5zYyA9IHRydWU7XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mYyAhPT0gZmMpIHtcbiAgICAgIHRoaXMuZmMgPSBmYztcbiAgICAgIHRoaXMuX21kZi5mYyA9IHRydWU7XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tICE9PSBtKSB7XG4gICAgICB0aGlzLm0gPSBtO1xuICAgICAgdGhpcy5fbWRmLm0gPSB0cnVlO1xuICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHAubGVuZ3RoICYmICh0aGlzLnBbMF0gIT09IHBbMF0gfHwgdGhpcy5wWzFdICE9PSBwWzFdIHx8IHRoaXMucFs0XSAhPT0gcFs0XSB8fCB0aGlzLnBbNV0gIT09IHBbNV0gfHwgdGhpcy5wWzEyXSAhPT0gcFsxMl0gfHwgdGhpcy5wWzEzXSAhPT0gcFsxM10pKSB7XG4gICAgICB0aGlzLnAgPSBwO1xuICAgICAgdGhpcy5fbWRmLnAgPSB0cnVlO1xuICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZWQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gVGV4dFByb3BlcnR5KGVsZW0sIGRhdGEpIHtcbiAgICB0aGlzLl9mcmFtZUlkID0gaW5pdGlhbERlZmF1bHRGcmFtZTtcbiAgICB0aGlzLnB2ID0gJyc7XG4gICAgdGhpcy52ID0gJyc7XG4gICAgdGhpcy5rZiA9IGZhbHNlO1xuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XG5cbiAgICBpZiAoZGF0YS5kICYmIGRhdGEuZC5zaWQpIHtcbiAgICAgIGRhdGEuZCA9IGVsZW0uZ2xvYmFsRGF0YS5zbG90TWFuYWdlci5nZXRQcm9wKGRhdGEuZCk7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgIHRoaXMuY29tcCA9IHRoaXMuZWxlbS5jb21wO1xuICAgIHRoaXMua2V5c0luZGV4ID0gMDtcbiAgICB0aGlzLmNhblJlc2l6ZSA9IGZhbHNlO1xuICAgIHRoaXMubWluaW11bUZvbnRTaXplID0gMTtcbiAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZSA9IFtdO1xuICAgIHRoaXMuY3VycmVudERhdGEgPSB7XG4gICAgICBhc2NlbnQ6IDAsXG4gICAgICBib3hXaWR0aDogdGhpcy5kZWZhdWx0Qm94V2lkdGgsXG4gICAgICBmOiAnJyxcbiAgICAgIGZTdHlsZTogJycsXG4gICAgICBmV2VpZ2h0OiAnJyxcbiAgICAgIGZjOiAnJyxcbiAgICAgIGo6ICcnLFxuICAgICAganVzdGlmeU9mZnNldDogJycsXG4gICAgICBsOiBbXSxcbiAgICAgIGxoOiAwLFxuICAgICAgbGluZVdpZHRoczogW10sXG4gICAgICBsczogJycsXG4gICAgICBvZjogJycsXG4gICAgICBzOiAnJyxcbiAgICAgIHNjOiAnJyxcbiAgICAgIHN3OiAwLFxuICAgICAgdDogMCxcbiAgICAgIHRyOiAwLFxuICAgICAgc3o6IDAsXG4gICAgICBwczogbnVsbCxcbiAgICAgIGZpbGxDb2xvckFuaW06IGZhbHNlLFxuICAgICAgc3Ryb2tlQ29sb3JBbmltOiBmYWxzZSxcbiAgICAgIHN0cm9rZVdpZHRoQW5pbTogZmFsc2UsXG4gICAgICB5T2Zmc2V0OiAwLFxuICAgICAgZmluYWxTaXplOiAwLFxuICAgICAgZmluYWxUZXh0OiBbXSxcbiAgICAgIGZpbmFsTGluZUhlaWdodDogMCxcbiAgICAgIF9fY29tcGxldGU6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLmNvcHlEYXRhKHRoaXMuY3VycmVudERhdGEsIHRoaXMuZGF0YS5kLmtbMF0ucyk7XG5cbiAgICBpZiAoIXRoaXMuc2VhcmNoUHJvcGVydHkoKSkge1xuICAgICAgdGhpcy5jb21wbGV0ZVRleHREYXRhKHRoaXMuY3VycmVudERhdGEpO1xuICAgIH1cbiAgfVxuXG4gIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUuZGVmYXVsdEJveFdpZHRoID0gWzAsIDBdO1xuXG4gIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUuY29weURhdGEgPSBmdW5jdGlvbiAob2JqLCBkYXRhKSB7XG4gICAgZm9yICh2YXIgcyBpbiBkYXRhKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIHMpKSB7XG4gICAgICAgIG9ialtzXSA9IGRhdGFbc107XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLnNldEN1cnJlbnREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoIWRhdGEuX19jb21wbGV0ZSkge1xuICAgICAgdGhpcy5jb21wbGV0ZVRleHREYXRhKGRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudERhdGEgPSBkYXRhO1xuICAgIHRoaXMuY3VycmVudERhdGEuYm94V2lkdGggPSB0aGlzLmN1cnJlbnREYXRhLmJveFdpZHRoIHx8IHRoaXMuZGVmYXVsdEJveFdpZHRoO1xuICAgIHRoaXMuX21kZiA9IHRydWU7XG4gIH07XG5cbiAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5zZWFyY2hQcm9wZXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWFyY2hLZXlmcmFtZXMoKTtcbiAgfTtcblxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLnNlYXJjaEtleWZyYW1lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmtmID0gdGhpcy5kYXRhLmQuay5sZW5ndGggPiAxO1xuXG4gICAgaWYgKHRoaXMua2YpIHtcbiAgICAgIHRoaXMuYWRkRWZmZWN0KHRoaXMuZ2V0S2V5ZnJhbWVWYWx1ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5rZjtcbiAgfTtcblxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLmFkZEVmZmVjdCA9IGZ1bmN0aW9uIChlZmZlY3RGdW5jdGlvbikge1xuICAgIHRoaXMuZWZmZWN0c1NlcXVlbmNlLnB1c2goZWZmZWN0RnVuY3Rpb24pO1xuICAgIHRoaXMuZWxlbS5hZGREeW5hbWljUHJvcGVydHkodGhpcyk7XG4gIH07XG5cbiAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChfZmluYWxWYWx1ZSkge1xuICAgIGlmICgodGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5mcmFtZUlkIHx8ICF0aGlzLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGgpICYmICFfZmluYWxWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudERhdGEudCA9IHRoaXMuZGF0YS5kLmtbdGhpcy5rZXlzSW5kZXhdLnMudDtcbiAgICB2YXIgY3VycmVudFZhbHVlID0gdGhpcy5jdXJyZW50RGF0YTtcbiAgICB2YXIgY3VycmVudEluZGV4ID0gdGhpcy5rZXlzSW5kZXg7XG5cbiAgICBpZiAodGhpcy5sb2NrKSB7XG4gICAgICB0aGlzLnNldEN1cnJlbnREYXRhKHRoaXMuY3VycmVudERhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubG9jayA9IHRydWU7XG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcbiAgICB2YXIgZmluYWxWYWx1ZSA9IF9maW5hbFZhbHVlIHx8IHRoaXMuZGF0YS5kLmtbdGhpcy5rZXlzSW5kZXhdLnM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIC8vIENoZWNraW5nIGlmIGluZGV4IGNoYW5nZWQgdG8gcHJldmVudCBjcmVhdGluZyBhIG5ldyBvYmplY3QgZXZlcnkgdGltZSB0aGUgZXhwcmVzc2lvbiB1cGRhdGVzLlxuICAgICAgaWYgKGN1cnJlbnRJbmRleCAhPT0gdGhpcy5rZXlzSW5kZXgpIHtcbiAgICAgICAgZmluYWxWYWx1ZSA9IHRoaXMuZWZmZWN0c1NlcXVlbmNlW2ldKGZpbmFsVmFsdWUsIGZpbmFsVmFsdWUudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaW5hbFZhbHVlID0gdGhpcy5lZmZlY3RzU2VxdWVuY2VbaV0odGhpcy5jdXJyZW50RGF0YSwgZmluYWxWYWx1ZS50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFZhbHVlICE9PSBmaW5hbFZhbHVlKSB7XG4gICAgICB0aGlzLnNldEN1cnJlbnREYXRhKGZpbmFsVmFsdWUpO1xuICAgIH1cblxuICAgIHRoaXMudiA9IHRoaXMuY3VycmVudERhdGE7XG4gICAgdGhpcy5wdiA9IHRoaXMudjtcbiAgICB0aGlzLmxvY2sgPSBmYWxzZTtcbiAgICB0aGlzLmZyYW1lSWQgPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkO1xuICB9O1xuXG4gIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0S2V5ZnJhbWVWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGV4dEtleXMgPSB0aGlzLmRhdGEuZC5rO1xuICAgIHZhciBmcmFtZU51bSA9IHRoaXMuZWxlbS5jb21wLnJlbmRlcmVkRnJhbWU7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSB0ZXh0S2V5cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaSA8PSBsZW4gLSAxKSB7XG4gICAgICBpZiAoaSA9PT0gbGVuIC0gMSB8fCB0ZXh0S2V5c1tpICsgMV0udCA+IGZyYW1lTnVtKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMua2V5c0luZGV4ICE9PSBpKSB7XG4gICAgICB0aGlzLmtleXNJbmRleCA9IGk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kLmtbdGhpcy5rZXlzSW5kZXhdLnM7XG4gIH07XG5cbiAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5idWlsZEZpbmFsVGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgdmFyIGNoYXJhY3RlcnNBcnJheSA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdGV4dC5sZW5ndGg7XG4gICAgdmFyIGNoYXJDb2RlO1xuICAgIHZhciBzZWNvbmRDaGFyQ29kZTtcbiAgICB2YXIgc2hvdWxkQ29tYmluZSA9IGZhbHNlO1xuICAgIHZhciBzaG91bGRDb21iaW5lTmV4dCA9IGZhbHNlO1xuICAgIHZhciBjdXJyZW50Q2hhcnMgPSAnJztcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBzaG91bGRDb21iaW5lID0gc2hvdWxkQ29tYmluZU5leHQ7XG4gICAgICBzaG91bGRDb21iaW5lTmV4dCA9IGZhbHNlO1xuICAgICAgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICBjdXJyZW50Q2hhcnMgPSB0ZXh0LmNoYXJBdChpKTtcblxuICAgICAgaWYgKEZvbnRNYW5hZ2VyLmlzQ29tYmluZWRDaGFyYWN0ZXIoY2hhckNvZGUpKSB7XG4gICAgICAgIHNob3VsZENvbWJpbmUgPSB0cnVlOyAvLyBJdCdzIGEgcG90ZW50aWFsIHN1cnJvZ2F0ZSBwYWlyICh0aGlzIGlzIHRoZSBIaWdoIHN1cnJvZ2F0ZSlcbiAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgICBpZiAoRm9udE1hbmFnZXIuaXNSZWdpb25hbEZsYWcodGV4dCwgaSkpIHtcbiAgICAgICAgICBjdXJyZW50Q2hhcnMgPSB0ZXh0LnN1YnN0cihpLCAxNCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2Vjb25kQ2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaSArIDEpOyAvLyBJdCdzIGEgc3Vycm9nYXRlIHBhaXIgKHRoaXMgaXMgdGhlIExvdyBzdXJyb2dhdGUpXG5cbiAgICAgICAgICBpZiAoc2Vjb25kQ2hhckNvZGUgPj0gMHhEQzAwICYmIHNlY29uZENoYXJDb2RlIDw9IDB4REZGRikge1xuICAgICAgICAgICAgaWYgKEZvbnRNYW5hZ2VyLmlzTW9kaWZpZXIoY2hhckNvZGUsIHNlY29uZENoYXJDb2RlKSkge1xuICAgICAgICAgICAgICBjdXJyZW50Q2hhcnMgPSB0ZXh0LnN1YnN0cihpLCAyKTtcbiAgICAgICAgICAgICAgc2hvdWxkQ29tYmluZSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKEZvbnRNYW5hZ2VyLmlzRmxhZ0Vtb2ppKHRleHQuc3Vic3RyKGksIDQpKSkge1xuICAgICAgICAgICAgICBjdXJyZW50Q2hhcnMgPSB0ZXh0LnN1YnN0cihpLCA0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRDaGFycyA9IHRleHQuc3Vic3RyKGksIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA+IDB4REJGRikge1xuICAgICAgICBzZWNvbmRDaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChpICsgMSk7XG5cbiAgICAgICAgaWYgKEZvbnRNYW5hZ2VyLmlzVmFyaWF0aW9uU2VsZWN0b3IoY2hhckNvZGUpKSB7XG4gICAgICAgICAgc2hvdWxkQ29tYmluZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoRm9udE1hbmFnZXIuaXNaZXJvV2lkdGhKb2luZXIoY2hhckNvZGUpKSB7XG4gICAgICAgIHNob3VsZENvbWJpbmUgPSB0cnVlO1xuICAgICAgICBzaG91bGRDb21iaW5lTmV4dCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRDb21iaW5lKSB7XG4gICAgICAgIGNoYXJhY3RlcnNBcnJheVtjaGFyYWN0ZXJzQXJyYXkubGVuZ3RoIC0gMV0gKz0gY3VycmVudENoYXJzO1xuICAgICAgICBzaG91bGRDb21iaW5lID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGFyYWN0ZXJzQXJyYXkucHVzaChjdXJyZW50Q2hhcnMpO1xuICAgICAgfVxuXG4gICAgICBpICs9IGN1cnJlbnRDaGFycy5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYXJhY3RlcnNBcnJheTtcbiAgfTtcblxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLmNvbXBsZXRlVGV4dERhdGEgPSBmdW5jdGlvbiAoZG9jdW1lbnREYXRhKSB7XG4gICAgZG9jdW1lbnREYXRhLl9fY29tcGxldGUgPSB0cnVlO1xuICAgIHZhciBmb250TWFuYWdlciA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyO1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBsZXR0ZXJzID0gW107XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcbiAgICB2YXIgbmV3TGluZUZsYWc7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgdmFsO1xuICAgIHZhciBhbmNob3JHcm91cGluZyA9IGRhdGEubS5nO1xuICAgIHZhciBjdXJyZW50U2l6ZSA9IDA7XG4gICAgdmFyIGN1cnJlbnRQb3MgPSAwO1xuICAgIHZhciBjdXJyZW50TGluZSA9IDA7XG4gICAgdmFyIGxpbmVXaWR0aHMgPSBbXTtcbiAgICB2YXIgbGluZVdpZHRoID0gMDtcbiAgICB2YXIgbWF4TGluZVdpZHRoID0gMDtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgZm9udERhdGEgPSBmb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKTtcbiAgICB2YXIgY2hhckRhdGE7XG4gICAgdmFyIGNMZW5ndGggPSAwO1xuICAgIHZhciBmb250UHJvcHMgPSBnZXRGb250UHJvcGVydGllcyhmb250RGF0YSk7XG4gICAgZG9jdW1lbnREYXRhLmZXZWlnaHQgPSBmb250UHJvcHMud2VpZ2h0O1xuICAgIGRvY3VtZW50RGF0YS5mU3R5bGUgPSBmb250UHJvcHMuc3R5bGU7XG4gICAgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSA9IGRvY3VtZW50RGF0YS5zO1xuICAgIGRvY3VtZW50RGF0YS5maW5hbFRleHQgPSB0aGlzLmJ1aWxkRmluYWxUZXh0KGRvY3VtZW50RGF0YS50KTtcbiAgICBsZW4gPSBkb2N1bWVudERhdGEuZmluYWxUZXh0Lmxlbmd0aDtcbiAgICBkb2N1bWVudERhdGEuZmluYWxMaW5lSGVpZ2h0ID0gZG9jdW1lbnREYXRhLmxoO1xuICAgIHZhciB0cmFja2luZ09mZnNldCA9IGRvY3VtZW50RGF0YS50ciAvIDEwMDAgKiBkb2N1bWVudERhdGEuZmluYWxTaXplO1xuICAgIHZhciBjaGFyQ29kZTtcblxuICAgIGlmIChkb2N1bWVudERhdGEuc3opIHtcbiAgICAgIHZhciBmbGFnID0gdHJ1ZTtcbiAgICAgIHZhciBib3hXaWR0aCA9IGRvY3VtZW50RGF0YS5zelswXTtcbiAgICAgIHZhciBib3hIZWlnaHQgPSBkb2N1bWVudERhdGEuc3pbMV07XG4gICAgICB2YXIgY3VycmVudEhlaWdodDtcbiAgICAgIHZhciBmaW5hbFRleHQ7XG5cbiAgICAgIHdoaWxlIChmbGFnKSB7XG4gICAgICAgIGZpbmFsVGV4dCA9IHRoaXMuYnVpbGRGaW5hbFRleHQoZG9jdW1lbnREYXRhLnQpO1xuICAgICAgICBjdXJyZW50SGVpZ2h0ID0gMDtcbiAgICAgICAgbGluZVdpZHRoID0gMDtcbiAgICAgICAgbGVuID0gZmluYWxUZXh0Lmxlbmd0aDtcbiAgICAgICAgdHJhY2tpbmdPZmZzZXQgPSBkb2N1bWVudERhdGEudHIgLyAxMDAwICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZTtcbiAgICAgICAgdmFyIGxhc3RTcGFjZUluZGV4ID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgY2hhckNvZGUgPSBmaW5hbFRleHRbaV0uY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBuZXdMaW5lRmxhZyA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKGZpbmFsVGV4dFtpXSA9PT0gJyAnKSB7XG4gICAgICAgICAgICBsYXN0U3BhY2VJbmRleCA9IGk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PT0gMTMgfHwgY2hhckNvZGUgPT09IDMpIHtcbiAgICAgICAgICAgIGxpbmVXaWR0aCA9IDA7XG4gICAgICAgICAgICBuZXdMaW5lRmxhZyA9IHRydWU7XG4gICAgICAgICAgICBjdXJyZW50SGVpZ2h0ICs9IGRvY3VtZW50RGF0YS5maW5hbExpbmVIZWlnaHQgfHwgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAqIDEuMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZm9udE1hbmFnZXIuY2hhcnMpIHtcbiAgICAgICAgICAgIGNoYXJEYXRhID0gZm9udE1hbmFnZXIuZ2V0Q2hhckRhdGEoZmluYWxUZXh0W2ldLCBmb250RGF0YS5mU3R5bGUsIGZvbnREYXRhLmZGYW1pbHkpO1xuICAgICAgICAgICAgY0xlbmd0aCA9IG5ld0xpbmVGbGFnID8gMCA6IGNoYXJEYXRhLncgKiBkb2N1bWVudERhdGEuZmluYWxTaXplIC8gMTAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0Q2FudmFzSGVscGVyLmZvbnQgPSBkb2N1bWVudERhdGEucyArICdweCAnKyBmb250RGF0YS5mRmFtaWx5O1xuICAgICAgICAgICAgY0xlbmd0aCA9IGZvbnRNYW5hZ2VyLm1lYXN1cmVUZXh0KGZpbmFsVGV4dFtpXSwgZG9jdW1lbnREYXRhLmYsIGRvY3VtZW50RGF0YS5maW5hbFNpemUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsaW5lV2lkdGggKyBjTGVuZ3RoID4gYm94V2lkdGggJiYgZmluYWxUZXh0W2ldICE9PSAnICcpIHtcbiAgICAgICAgICAgIGlmIChsYXN0U3BhY2VJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgbGVuICs9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpID0gbGFzdFNwYWNlSW5kZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnRIZWlnaHQgKz0gZG9jdW1lbnREYXRhLmZpbmFsTGluZUhlaWdodCB8fCBkb2N1bWVudERhdGEuZmluYWxTaXplICogMS4yO1xuICAgICAgICAgICAgZmluYWxUZXh0LnNwbGljZShpLCBsYXN0U3BhY2VJbmRleCA9PT0gaSA/IDEgOiAwLCAnXFxyJyk7IC8vIGZpbmFsVGV4dCA9IGZpbmFsVGV4dC5zdWJzdHIoMCxpKSArIFwiXFxyXCIgKyBmaW5hbFRleHQuc3Vic3RyKGkgPT09IGxhc3RTcGFjZUluZGV4ID8gaSArIDEgOiBpKTtcblxuICAgICAgICAgICAgbGFzdFNwYWNlSW5kZXggPSAtMTtcbiAgICAgICAgICAgIGxpbmVXaWR0aCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpbmVXaWR0aCArPSBjTGVuZ3RoO1xuICAgICAgICAgICAgbGluZVdpZHRoICs9IHRyYWNraW5nT2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRIZWlnaHQgKz0gZm9udERhdGEuYXNjZW50ICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAvIDEwMDtcblxuICAgICAgICBpZiAodGhpcy5jYW5SZXNpemUgJiYgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSA+IHRoaXMubWluaW11bUZvbnRTaXplICYmIGJveEhlaWdodCA8IGN1cnJlbnRIZWlnaHQpIHtcbiAgICAgICAgICBkb2N1bWVudERhdGEuZmluYWxTaXplIC09IDE7XG4gICAgICAgICAgZG9jdW1lbnREYXRhLmZpbmFsTGluZUhlaWdodCA9IGRvY3VtZW50RGF0YS5maW5hbFNpemUgKiBkb2N1bWVudERhdGEubGggLyBkb2N1bWVudERhdGEucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb2N1bWVudERhdGEuZmluYWxUZXh0ID0gZmluYWxUZXh0O1xuICAgICAgICAgIGxlbiA9IGRvY3VtZW50RGF0YS5maW5hbFRleHQubGVuZ3RoO1xuICAgICAgICAgIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxpbmVXaWR0aCA9IC10cmFja2luZ09mZnNldDtcbiAgICBjTGVuZ3RoID0gMDtcbiAgICB2YXIgdW5jb2xsYXBzZWRTcGFjZXMgPSAwO1xuICAgIHZhciBjdXJyZW50Q2hhcjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgbmV3TGluZUZsYWcgPSBmYWxzZTtcbiAgICAgIGN1cnJlbnRDaGFyID0gZG9jdW1lbnREYXRhLmZpbmFsVGV4dFtpXTtcbiAgICAgIGNoYXJDb2RlID0gY3VycmVudENoYXIuY2hhckNvZGVBdCgwKTtcblxuICAgICAgaWYgKGNoYXJDb2RlID09PSAxMyB8fCBjaGFyQ29kZSA9PT0gMykge1xuICAgICAgICB1bmNvbGxhcHNlZFNwYWNlcyA9IDA7XG4gICAgICAgIGxpbmVXaWR0aHMucHVzaChsaW5lV2lkdGgpO1xuICAgICAgICBtYXhMaW5lV2lkdGggPSBsaW5lV2lkdGggPiBtYXhMaW5lV2lkdGggPyBsaW5lV2lkdGggOiBtYXhMaW5lV2lkdGg7XG4gICAgICAgIGxpbmVXaWR0aCA9IC0yICogdHJhY2tpbmdPZmZzZXQ7XG4gICAgICAgIHZhbCA9ICcnO1xuICAgICAgICBuZXdMaW5lRmxhZyA9IHRydWU7XG4gICAgICAgIGN1cnJlbnRMaW5lICs9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBjdXJyZW50Q2hhcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvbnRNYW5hZ2VyLmNoYXJzKSB7XG4gICAgICAgIGNoYXJEYXRhID0gZm9udE1hbmFnZXIuZ2V0Q2hhckRhdGEoY3VycmVudENoYXIsIGZvbnREYXRhLmZTdHlsZSwgZm9udE1hbmFnZXIuZ2V0Rm9udEJ5TmFtZShkb2N1bWVudERhdGEuZikuZkZhbWlseSk7XG4gICAgICAgIGNMZW5ndGggPSBuZXdMaW5lRmxhZyA/IDAgOiBjaGFyRGF0YS53ICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAvIDEwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHZhciBjaGFyV2lkdGggPSBmb250TWFuYWdlci5tZWFzdXJlVGV4dCh2YWwsIGRvY3VtZW50RGF0YS5mLCBkb2N1bWVudERhdGEuZmluYWxTaXplKTtcbiAgICAgICAgLy8gdENhbnZhc0hlbHBlci5mb250ID0gZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSArICdweCAnKyBmb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKS5mRmFtaWx5O1xuICAgICAgICBjTGVuZ3RoID0gZm9udE1hbmFnZXIubWVhc3VyZVRleHQodmFsLCBkb2N1bWVudERhdGEuZiwgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSk7XG4gICAgICB9IC8vXG5cblxuICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnICcpIHtcbiAgICAgICAgdW5jb2xsYXBzZWRTcGFjZXMgKz0gY0xlbmd0aCArIHRyYWNraW5nT2Zmc2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZVdpZHRoICs9IGNMZW5ndGggKyB0cmFja2luZ09mZnNldCArIHVuY29sbGFwc2VkU3BhY2VzO1xuICAgICAgICB1bmNvbGxhcHNlZFNwYWNlcyA9IDA7XG4gICAgICB9XG5cbiAgICAgIGxldHRlcnMucHVzaCh7XG4gICAgICAgIGw6IGNMZW5ndGgsXG4gICAgICAgIGFuOiBjTGVuZ3RoLFxuICAgICAgICBhZGQ6IGN1cnJlbnRTaXplLFxuICAgICAgICBuOiBuZXdMaW5lRmxhZyxcbiAgICAgICAgYW5JbmRleGVzOiBbXSxcbiAgICAgICAgdmFsOiB2YWwsXG4gICAgICAgIGxpbmU6IGN1cnJlbnRMaW5lLFxuICAgICAgICBhbmltYXRvckp1c3RpZnlPZmZzZXQ6IDBcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoYW5jaG9yR3JvdXBpbmcgPT0gMikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgICAgICBjdXJyZW50U2l6ZSArPSBjTGVuZ3RoO1xuXG4gICAgICAgIGlmICh2YWwgPT09ICcnIHx8IHZhbCA9PT0gJyAnIHx8IGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICBpZiAodmFsID09PSAnJyB8fCB2YWwgPT09ICcgJykge1xuICAgICAgICAgICAgY3VycmVudFNpemUgLT0gY0xlbmd0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aGlsZSAoY3VycmVudFBvcyA8PSBpKSB7XG4gICAgICAgICAgICBsZXR0ZXJzW2N1cnJlbnRQb3NdLmFuID0gY3VycmVudFNpemU7XG4gICAgICAgICAgICBsZXR0ZXJzW2N1cnJlbnRQb3NdLmluZCA9IGluZGV4O1xuICAgICAgICAgICAgbGV0dGVyc1tjdXJyZW50UG9zXS5leHRyYSA9IGNMZW5ndGg7XG4gICAgICAgICAgICBjdXJyZW50UG9zICs9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgICBjdXJyZW50U2l6ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYW5jaG9yR3JvdXBpbmcgPT0gMykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgICAgICBjdXJyZW50U2l6ZSArPSBjTGVuZ3RoO1xuXG4gICAgICAgIGlmICh2YWwgPT09ICcnIHx8IGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICBpZiAodmFsID09PSAnJykge1xuICAgICAgICAgICAgY3VycmVudFNpemUgLT0gY0xlbmd0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aGlsZSAoY3VycmVudFBvcyA8PSBpKSB7XG4gICAgICAgICAgICBsZXR0ZXJzW2N1cnJlbnRQb3NdLmFuID0gY3VycmVudFNpemU7XG4gICAgICAgICAgICBsZXR0ZXJzW2N1cnJlbnRQb3NdLmluZCA9IGluZGV4O1xuICAgICAgICAgICAgbGV0dGVyc1tjdXJyZW50UG9zXS5leHRyYSA9IGNMZW5ndGg7XG4gICAgICAgICAgICBjdXJyZW50UG9zICs9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudFNpemUgPSAwO1xuICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldHRlcnNbaW5kZXhdLmluZCA9IGluZGV4O1xuICAgICAgICBsZXR0ZXJzW2luZGV4XS5leHRyYSA9IDA7XG4gICAgICAgIGluZGV4ICs9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZG9jdW1lbnREYXRhLmwgPSBsZXR0ZXJzO1xuICAgIG1heExpbmVXaWR0aCA9IGxpbmVXaWR0aCA+IG1heExpbmVXaWR0aCA/IGxpbmVXaWR0aCA6IG1heExpbmVXaWR0aDtcbiAgICBsaW5lV2lkdGhzLnB1c2gobGluZVdpZHRoKTtcblxuICAgIGlmIChkb2N1bWVudERhdGEuc3opIHtcbiAgICAgIGRvY3VtZW50RGF0YS5ib3hXaWR0aCA9IGRvY3VtZW50RGF0YS5zelswXTtcbiAgICAgIGRvY3VtZW50RGF0YS5qdXN0aWZ5T2Zmc2V0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnREYXRhLmJveFdpZHRoID0gbWF4TGluZVdpZHRoO1xuXG4gICAgICBzd2l0Y2ggKGRvY3VtZW50RGF0YS5qKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBkb2N1bWVudERhdGEuanVzdGlmeU9mZnNldCA9IC1kb2N1bWVudERhdGEuYm94V2lkdGg7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGRvY3VtZW50RGF0YS5qdXN0aWZ5T2Zmc2V0ID0gLWRvY3VtZW50RGF0YS5ib3hXaWR0aCAvIDI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBkb2N1bWVudERhdGEuanVzdGlmeU9mZnNldCA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZG9jdW1lbnREYXRhLmxpbmVXaWR0aHMgPSBsaW5lV2lkdGhzO1xuICAgIHZhciBhbmltYXRvcnMgPSBkYXRhLmE7XG4gICAgdmFyIGFuaW1hdG9yRGF0YTtcbiAgICB2YXIgbGV0dGVyRGF0YTtcbiAgICBqTGVuID0gYW5pbWF0b3JzLmxlbmd0aDtcbiAgICB2YXIgYmFzZWQ7XG4gICAgdmFyIGluZDtcbiAgICB2YXIgaW5kZXhlcyA9IFtdO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgYW5pbWF0b3JEYXRhID0gYW5pbWF0b3JzW2pdO1xuXG4gICAgICBpZiAoYW5pbWF0b3JEYXRhLmEuc2MpIHtcbiAgICAgICAgZG9jdW1lbnREYXRhLnN0cm9rZUNvbG9yQW5pbSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmltYXRvckRhdGEuYS5zdykge1xuICAgICAgICBkb2N1bWVudERhdGEuc3Ryb2tlV2lkdGhBbmltID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFuaW1hdG9yRGF0YS5hLmZjIHx8IGFuaW1hdG9yRGF0YS5hLmZoIHx8IGFuaW1hdG9yRGF0YS5hLmZzIHx8IGFuaW1hdG9yRGF0YS5hLmZiKSB7XG4gICAgICAgIGRvY3VtZW50RGF0YS5maWxsQ29sb3JBbmltID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaW5kID0gMDtcbiAgICAgIGJhc2VkID0gYW5pbWF0b3JEYXRhLnMuYjtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGxldHRlckRhdGEgPSBsZXR0ZXJzW2ldO1xuICAgICAgICBsZXR0ZXJEYXRhLmFuSW5kZXhlc1tqXSA9IGluZDtcblxuICAgICAgICBpZiAoYmFzZWQgPT0gMSAmJiBsZXR0ZXJEYXRhLnZhbCAhPT0gJycgfHwgYmFzZWQgPT0gMiAmJiBsZXR0ZXJEYXRhLnZhbCAhPT0gJycgJiYgbGV0dGVyRGF0YS52YWwgIT09ICcgJyB8fCBiYXNlZCA9PSAzICYmIChsZXR0ZXJEYXRhLm4gfHwgbGV0dGVyRGF0YS52YWwgPT0gJyAnIHx8IGkgPT0gbGVuIC0gMSkgfHwgYmFzZWQgPT0gNCAmJiAobGV0dGVyRGF0YS5uIHx8IGkgPT0gbGVuIC0gMSkpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgICAgICAgIGlmIChhbmltYXRvckRhdGEucy5ybiA9PT0gMSkge1xuICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGluZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5kICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGF0YS5hW2pdLnMudG90YWxDaGFycyA9IGluZDtcbiAgICAgIHZhciBjdXJyZW50SW5kID0gLTE7XG4gICAgICB2YXIgbmV3SW5kO1xuXG4gICAgICBpZiAoYW5pbWF0b3JEYXRhLnMucm4gPT09IDEpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgbGV0dGVyRGF0YSA9IGxldHRlcnNbaV07XG5cbiAgICAgICAgICBpZiAoY3VycmVudEluZCAhPSBsZXR0ZXJEYXRhLmFuSW5kZXhlc1tqXSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICAgICAgICAgIGN1cnJlbnRJbmQgPSBsZXR0ZXJEYXRhLmFuSW5kZXhlc1tqXTtcbiAgICAgICAgICAgIG5ld0luZCA9IGluZGV4ZXMuc3BsaWNlKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGluZGV4ZXMubGVuZ3RoKSwgMSlbMF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0dGVyRGF0YS5hbkluZGV4ZXNbal0gPSBuZXdJbmQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBkb2N1bWVudERhdGEueU9mZnNldCA9IGRvY3VtZW50RGF0YS5maW5hbExpbmVIZWlnaHQgfHwgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAqIDEuMjtcbiAgICBkb2N1bWVudERhdGEubHMgPSBkb2N1bWVudERhdGEubHMgfHwgMDtcbiAgICBkb2N1bWVudERhdGEuYXNjZW50ID0gZm9udERhdGEuYXNjZW50ICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAvIDEwMDtcbiAgfTtcblxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLnVwZGF0ZURvY3VtZW50RGF0YSA9IGZ1bmN0aW9uIChuZXdEYXRhLCBpbmRleCkge1xuICAgIGluZGV4ID0gaW5kZXggPT09IHVuZGVmaW5lZCA/IHRoaXMua2V5c0luZGV4IDogaW5kZXg7XG4gICAgdmFyIGREYXRhID0gdGhpcy5jb3B5RGF0YSh7fSwgdGhpcy5kYXRhLmQua1tpbmRleF0ucyk7XG4gICAgZERhdGEgPSB0aGlzLmNvcHlEYXRhKGREYXRhLCBuZXdEYXRhKTtcbiAgICB0aGlzLmRhdGEuZC5rW2luZGV4XS5zID0gZERhdGE7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZShpbmRleCk7XG4gICAgdGhpcy5zZXRDdXJyZW50RGF0YShkRGF0YSk7XG4gICAgdGhpcy5lbGVtLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcbiAgfTtcblxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLnJlY2FsY3VsYXRlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIGREYXRhID0gdGhpcy5kYXRhLmQua1tpbmRleF0ucztcbiAgICBkRGF0YS5fX2NvbXBsZXRlID0gZmFsc2U7XG4gICAgdGhpcy5rZXlzSW5kZXggPSAwO1xuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgdGhpcy5nZXRWYWx1ZShkRGF0YSk7XG4gIH07XG5cbiAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5jYW5SZXNpemVGb250ID0gZnVuY3Rpb24gKF9jYW5SZXNpemUpIHtcbiAgICB0aGlzLmNhblJlc2l6ZSA9IF9jYW5SZXNpemU7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZSh0aGlzLmtleXNJbmRleCk7XG4gICAgdGhpcy5lbGVtLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcbiAgfTtcblxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLnNldE1pbmltdW1Gb250U2l6ZSA9IGZ1bmN0aW9uIChfZm9udFZhbHVlKSB7XG4gICAgdGhpcy5taW5pbXVtRm9udFNpemUgPSBNYXRoLmZsb29yKF9mb250VmFsdWUpIHx8IDE7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZSh0aGlzLmtleXNJbmRleCk7XG4gICAgdGhpcy5lbGVtLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcbiAgfTtcblxuICB2YXIgVGV4dFNlbGVjdG9yUHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXg7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluO1xuICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbiAgICBmdW5jdGlvbiBUZXh0U2VsZWN0b3JQcm9wRmFjdG9yeShlbGVtLCBkYXRhKSB7XG4gICAgICB0aGlzLl9jdXJyZW50VGV4dExlbmd0aCA9IC0xO1xuICAgICAgdGhpcy5rID0gZmFsc2U7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcbiAgICAgIHRoaXMuZmluYWxTID0gMDtcbiAgICAgIHRoaXMuZmluYWxFID0gMDtcbiAgICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtKTtcbiAgICAgIHRoaXMucyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucyB8fCB7XG4gICAgICAgIGs6IDBcbiAgICAgIH0sIDAsIDAsIHRoaXMpO1xuXG4gICAgICBpZiAoJ2UnIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5lID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5lLCAwLCAwLCB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZSA9IHtcbiAgICAgICAgICB2OiAxMDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5vIHx8IHtcbiAgICAgICAgazogMFxuICAgICAgfSwgMCwgMCwgdGhpcyk7XG4gICAgICB0aGlzLnhlID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS54ZSB8fCB7XG4gICAgICAgIGs6IDBcbiAgICAgIH0sIDAsIDAsIHRoaXMpO1xuICAgICAgdGhpcy5uZSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEubmUgfHwge1xuICAgICAgICBrOiAwXG4gICAgICB9LCAwLCAwLCB0aGlzKTtcbiAgICAgIHRoaXMuc20gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnNtIHx8IHtcbiAgICAgICAgazogMTAwXG4gICAgICB9LCAwLCAwLCB0aGlzKTtcbiAgICAgIHRoaXMuYSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuYSwgMCwgMC4wMSwgdGhpcyk7XG5cbiAgICAgIGlmICghdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIFRleHRTZWxlY3RvclByb3BGYWN0b3J5LnByb3RvdHlwZSA9IHtcbiAgICAgIGdldE11bHQ6IGZ1bmN0aW9uIGdldE11bHQoaW5kKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50VGV4dExlbmd0aCAhPT0gdGhpcy5lbGVtLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YS5sLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4MSA9IDA7XG4gICAgICAgIHZhciB5MSA9IDA7XG4gICAgICAgIHZhciB4MiA9IDE7XG4gICAgICAgIHZhciB5MiA9IDE7XG5cbiAgICAgICAgaWYgKHRoaXMubmUudiA+IDApIHtcbiAgICAgICAgICB4MSA9IHRoaXMubmUudiAvIDEwMC4wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHkxID0gLXRoaXMubmUudiAvIDEwMC4wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMueGUudiA+IDApIHtcbiAgICAgICAgICB4MiA9IDEuMCAtIHRoaXMueGUudiAvIDEwMC4wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHkyID0gMS4wICsgdGhpcy54ZS52IC8gMTAwLjA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWFzZXIgPSBCZXppZXJGYWN0b3J5LmdldEJlemllckVhc2luZyh4MSwgeTEsIHgyLCB5MikuZ2V0O1xuICAgICAgICB2YXIgbXVsdCA9IDA7XG4gICAgICAgIHZhciBzID0gdGhpcy5maW5hbFM7XG4gICAgICAgIHZhciBlID0gdGhpcy5maW5hbEU7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5kYXRhLnNoO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAyKSB7XG4gICAgICAgICAgaWYgKGUgPT09IHMpIHtcbiAgICAgICAgICAgIG11bHQgPSBpbmQgPj0gZSA/IDEgOiAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtdWx0ID0gbWF4KDAsIG1pbigwLjUgLyAoZSAtIHMpICsgKGluZCAtIHMpIC8gKGUgLSBzKSwgMSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG11bHQgPSBlYXNlcihtdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAzKSB7XG4gICAgICAgICAgaWYgKGUgPT09IHMpIHtcbiAgICAgICAgICAgIG11bHQgPSBpbmQgPj0gZSA/IDAgOiAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtdWx0ID0gMSAtIG1heCgwLCBtaW4oMC41IC8gKGUgLSBzKSArIChpbmQgLSBzKSAvIChlIC0gcyksIDEpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtdWx0ID0gZWFzZXIobXVsdCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gNCkge1xuICAgICAgICAgIGlmIChlID09PSBzKSB7XG4gICAgICAgICAgICBtdWx0ID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXVsdCA9IG1heCgwLCBtaW4oMC41IC8gKGUgLSBzKSArIChpbmQgLSBzKSAvIChlIC0gcyksIDEpKTtcblxuICAgICAgICAgICAgaWYgKG11bHQgPCAwLjUpIHtcbiAgICAgICAgICAgICAgbXVsdCAqPSAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbXVsdCA9IDEgLSAyICogKG11bHQgLSAwLjUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG11bHQgPSBlYXNlcihtdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA1KSB7XG4gICAgICAgICAgaWYgKGUgPT09IHMpIHtcbiAgICAgICAgICAgIG11bHQgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdG90ID0gZSAtIHM7XG4gICAgICAgICAgICAvKiBpbmQgKz0gMC41O1xyXG4gICAgICAgICAgICAgICAgICAgICAgbXVsdCA9IC00Lyh0b3QqdG90KSooaW5kKmluZCkrKDQvdG90KSppbmQ7ICovXG5cbiAgICAgICAgICAgIGluZCA9IG1pbihtYXgoMCwgaW5kICsgMC41IC0gcyksIGUgLSBzKTtcbiAgICAgICAgICAgIHZhciB4ID0gLXRvdCAvIDIgKyBpbmQ7XG4gICAgICAgICAgICB2YXIgYSA9IHRvdCAvIDI7XG4gICAgICAgICAgICBtdWx0ID0gTWF0aC5zcXJ0KDEgLSB4ICogeCAvIChhICogYSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG11bHQgPSBlYXNlcihtdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA2KSB7XG4gICAgICAgICAgaWYgKGUgPT09IHMpIHtcbiAgICAgICAgICAgIG11bHQgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmQgPSBtaW4obWF4KDAsIGluZCArIDAuNSAtIHMpLCBlIC0gcyk7XG4gICAgICAgICAgICBtdWx0ID0gKDEgKyBNYXRoLmNvcyhNYXRoLlBJICsgTWF0aC5QSSAqIDIgKiBpbmQgLyAoZSAtIHMpKSkgLyAyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbXVsdCA9IGVhc2VyKG11bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpbmQgPj0gZmxvb3IocykpIHtcbiAgICAgICAgICAgIGlmIChpbmQgLSBzIDwgMCkge1xuICAgICAgICAgICAgICBtdWx0ID0gbWF4KDAsIG1pbihtaW4oZSwgMSkgLSAocyAtIGluZCksIDEpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG11bHQgPSBtYXgoMCwgbWluKGUgLSBpbmQsIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtdWx0ID0gZWFzZXIobXVsdCk7XG4gICAgICAgIH0gLy8gU21vb3RobmVzcyBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgLy8gVGhlIHNtb290aG5lc3MgcmVwcmVzZW50cyBhIHJlZHVjZWQgcmFuZ2Ugb2YgdGhlIG9yaWdpbmFsIFswOyAxXSByYW5nZS5cbiAgICAgICAgLy8gaWYgc21vb3RobmVzcyBpcyAyNSUsIHRoZSBuZXcgcmFuZ2Ugd2lsbCBiZSBbMC4zNzU7IDAuNjI1XVxuICAgICAgICAvLyBTdGVwcyBhcmU6XG4gICAgICAgIC8vIC0gZmluZCB0aGUgbG93ZXIgdmFsdWUgb2YgdGhlIG5ldyByYW5nZSAodGhyZXNob2xkKVxuICAgICAgICAvLyAtIGlmIG11bHRpcGxpZXIgaXMgc21hbGxlciB0aGFuIHRoYXQgdmFsdWUsIGZsb29yIGl0IHRvIDBcbiAgICAgICAgLy8gLSBpZiBpdCBpcyBsYXJnZXIsXG4gICAgICAgIC8vICAgICAtIHN1YnRyYWN0IHRoZSB0aHJlc2hvbGRcbiAgICAgICAgLy8gICAgIC0gZGl2aWRlIGl0IGJ5IHRoZSBzbW9vdGhuZXNzICh0aGlzIHdpbGwgcmV0dXJuIHRoZSByYW5nZSB0byBbMDsgMV0pXG4gICAgICAgIC8vIE5vdGU6IElmIGl0IGRvZXNuJ3Qgd29yayBvbiBzb21lIHNjZW5hcmlvcywgY29uc2lkZXIgYXBwbHlpbmcgaXQgYmVmb3JlIHRoZSBlYXNlci5cblxuXG4gICAgICAgIGlmICh0aGlzLnNtLnYgIT09IDEwMCkge1xuICAgICAgICAgIHZhciBzbW9vdGhuZXNzID0gdGhpcy5zbS52ICogMC4wMTtcblxuICAgICAgICAgIGlmIChzbW9vdGhuZXNzID09PSAwKSB7XG4gICAgICAgICAgICBzbW9vdGhuZXNzID0gMC4wMDAwMDAwMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdGhyZXNob2xkID0gMC41IC0gc21vb3RobmVzcyAqIDAuNTtcblxuICAgICAgICAgIGlmIChtdWx0IDwgdGhyZXNob2xkKSB7XG4gICAgICAgICAgICBtdWx0ID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXVsdCA9IChtdWx0IC0gdGhyZXNob2xkKSAvIHNtb290aG5lc3M7XG5cbiAgICAgICAgICAgIGlmIChtdWx0ID4gMSkge1xuICAgICAgICAgICAgICBtdWx0ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbXVsdCAqIHRoaXMuYS52O1xuICAgICAgfSxcbiAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZShuZXdDaGFyc0ZsYWcpIHtcbiAgICAgICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcbiAgICAgICAgdGhpcy5fbWRmID0gbmV3Q2hhcnNGbGFnIHx8IHRoaXMuX21kZjtcbiAgICAgICAgdGhpcy5fY3VycmVudFRleHRMZW5ndGggPSB0aGlzLmVsZW0udGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLmwubGVuZ3RoIHx8IDA7XG5cbiAgICAgICAgaWYgKG5ld0NoYXJzRmxhZyAmJiB0aGlzLmRhdGEuciA9PT0gMikge1xuICAgICAgICAgIHRoaXMuZS52ID0gdGhpcy5fY3VycmVudFRleHRMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGl2aXNvciA9IHRoaXMuZGF0YS5yID09PSAyID8gMSA6IDEwMCAvIHRoaXMuZGF0YS50b3RhbENoYXJzO1xuICAgICAgICB2YXIgbyA9IHRoaXMuby52IC8gZGl2aXNvcjtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnMudiAvIGRpdmlzb3IgKyBvO1xuICAgICAgICB2YXIgZSA9IHRoaXMuZS52IC8gZGl2aXNvciArIG87XG5cbiAgICAgICAgaWYgKHMgPiBlKSB7XG4gICAgICAgICAgdmFyIF9zID0gcztcbiAgICAgICAgICBzID0gZTtcbiAgICAgICAgICBlID0gX3M7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZpbmFsUyA9IHM7XG4gICAgICAgIHRoaXMuZmluYWxFID0gZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgVGV4dFNlbGVjdG9yUHJvcEZhY3RvcnkpO1xuXG4gICAgZnVuY3Rpb24gZ2V0VGV4dFNlbGVjdG9yUHJvcChlbGVtLCBkYXRhLCBhcnIpIHtcbiAgICAgIHJldHVybiBuZXcgVGV4dFNlbGVjdG9yUHJvcEZhY3RvcnkoZWxlbSwgZGF0YSwgYXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ2V0VGV4dFNlbGVjdG9yUHJvcDogZ2V0VGV4dFNlbGVjdG9yUHJvcFxuICAgIH07XG4gIH0oKTtcblxuICBmdW5jdGlvbiBUZXh0QW5pbWF0b3JEYXRhUHJvcGVydHkoZWxlbSwgYW5pbWF0b3JQcm9wcywgY29udGFpbmVyKSB7XG4gICAgdmFyIGRlZmF1bHREYXRhID0ge1xuICAgICAgcHJvcFR5cGU6IGZhbHNlXG4gICAgfTtcbiAgICB2YXIgZ2V0UHJvcCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wO1xuICAgIHZhciB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcyA9IGFuaW1hdG9yUHJvcHMuYTtcbiAgICB0aGlzLmEgPSB7XG4gICAgICByOiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5yID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5yLCAwLCBkZWdUb1JhZHMsIGNvbnRhaW5lcikgOiBkZWZhdWx0RGF0YSxcbiAgICAgIHJ4OiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5yeCA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMucngsIDAsIGRlZ1RvUmFkcywgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgcnk6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLnJ5ID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5yeSwgMCwgZGVnVG9SYWRzLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICBzazogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuc2sgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLnNrLCAwLCBkZWdUb1JhZHMsIGNvbnRhaW5lcikgOiBkZWZhdWx0RGF0YSxcbiAgICAgIHNhOiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5zYSA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuc2EsIDAsIGRlZ1RvUmFkcywgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgczogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMucyA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMucywgMSwgMC4wMSwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgYTogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuYSA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuYSwgMSwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgbzogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMubyA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMubywgMCwgMC4wMSwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgcDogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMucCA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMucCwgMSwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgc3c6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLnN3ID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5zdywgMCwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgc2M6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLnNjID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5zYywgMSwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgZmM6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZjID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5mYywgMSwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgZmg6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZoID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5maCwgMCwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgZnM6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZzID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5mcywgMCwgMC4wMSwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgZmI6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZiID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5mYiwgMCwgMC4wMSwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgdDogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMudCA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMudCwgMCwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhXG4gICAgfTtcbiAgICB0aGlzLnMgPSBUZXh0U2VsZWN0b3JQcm9wLmdldFRleHRTZWxlY3RvclByb3AoZWxlbSwgYW5pbWF0b3JQcm9wcy5zLCBjb250YWluZXIpO1xuICAgIHRoaXMucy50ID0gYW5pbWF0b3JQcm9wcy5zLnQ7XG4gIH1cblxuICBmdW5jdGlvbiBUZXh0QW5pbWF0b3JQcm9wZXJ0eSh0ZXh0RGF0YSwgcmVuZGVyVHlwZSwgZWxlbSkge1xuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgdGhpcy5faGFzTWFza2VkUGF0aCA9IGZhbHNlO1xuICAgIHRoaXMuX2ZyYW1lSWQgPSAtMTtcbiAgICB0aGlzLl90ZXh0RGF0YSA9IHRleHREYXRhO1xuICAgIHRoaXMuX3JlbmRlclR5cGUgPSByZW5kZXJUeXBlO1xuICAgIHRoaXMuX2VsZW0gPSBlbGVtO1xuICAgIHRoaXMuX2FuaW1hdG9yc0RhdGEgPSBjcmVhdGVTaXplZEFycmF5KHRoaXMuX3RleHREYXRhLmEubGVuZ3RoKTtcbiAgICB0aGlzLl9wYXRoRGF0YSA9IHt9O1xuICAgIHRoaXMuX21vcmVPcHRpb25zID0ge1xuICAgICAgYWxpZ25tZW50OiB7fVxuICAgIH07XG4gICAgdGhpcy5yZW5kZXJlZExldHRlcnMgPSBbXTtcbiAgICB0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZyA9IGZhbHNlO1xuICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtKTtcbiAgfVxuXG4gIFRleHRBbmltYXRvclByb3BlcnR5LnByb3RvdHlwZS5zZWFyY2hQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLl90ZXh0RGF0YS5hLmxlbmd0aDtcbiAgICB2YXIgYW5pbWF0b3JQcm9wcztcbiAgICB2YXIgZ2V0UHJvcCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBhbmltYXRvclByb3BzID0gdGhpcy5fdGV4dERhdGEuYVtpXTtcbiAgICAgIHRoaXMuX2FuaW1hdG9yc0RhdGFbaV0gPSBuZXcgVGV4dEFuaW1hdG9yRGF0YVByb3BlcnR5KHRoaXMuX2VsZW0sIGFuaW1hdG9yUHJvcHMsIHRoaXMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl90ZXh0RGF0YS5wICYmICdtJyBpbiB0aGlzLl90ZXh0RGF0YS5wKSB7XG4gICAgICB0aGlzLl9wYXRoRGF0YSA9IHtcbiAgICAgICAgYTogZ2V0UHJvcCh0aGlzLl9lbGVtLCB0aGlzLl90ZXh0RGF0YS5wLmEsIDAsIDAsIHRoaXMpLFxuICAgICAgICBmOiBnZXRQcm9wKHRoaXMuX2VsZW0sIHRoaXMuX3RleHREYXRhLnAuZiwgMCwgMCwgdGhpcyksXG4gICAgICAgIGw6IGdldFByb3AodGhpcy5fZWxlbSwgdGhpcy5fdGV4dERhdGEucC5sLCAwLCAwLCB0aGlzKSxcbiAgICAgICAgcjogZ2V0UHJvcCh0aGlzLl9lbGVtLCB0aGlzLl90ZXh0RGF0YS5wLnIsIDAsIDAsIHRoaXMpLFxuICAgICAgICBwOiBnZXRQcm9wKHRoaXMuX2VsZW0sIHRoaXMuX3RleHREYXRhLnAucCwgMCwgMCwgdGhpcyksXG4gICAgICAgIG06IHRoaXMuX2VsZW0ubWFza01hbmFnZXIuZ2V0TWFza1Byb3BlcnR5KHRoaXMuX3RleHREYXRhLnAubSlcbiAgICAgIH07XG4gICAgICB0aGlzLl9oYXNNYXNrZWRQYXRoID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faGFzTWFza2VkUGF0aCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX21vcmVPcHRpb25zLmFsaWdubWVudCA9IGdldFByb3AodGhpcy5fZWxlbSwgdGhpcy5fdGV4dERhdGEubS5hLCAxLCAwLCB0aGlzKTtcbiAgfTtcblxuICBUZXh0QW5pbWF0b3JQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0TWVhc3VyZXMgPSBmdW5jdGlvbiAoZG9jdW1lbnREYXRhLCBsZXR0ZXJzQ2hhbmdlZEZsYWcpIHtcbiAgICB0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZyA9IGxldHRlcnNDaGFuZ2VkRmxhZztcblxuICAgIGlmICghdGhpcy5fbWRmICYmICF0aGlzLl9pc0ZpcnN0RnJhbWUgJiYgIWxldHRlcnNDaGFuZ2VkRmxhZyAmJiAoIXRoaXMuX2hhc01hc2tlZFBhdGggfHwgIXRoaXMuX3BhdGhEYXRhLm0uX21kZikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcbiAgICB2YXIgYWxpZ25tZW50ID0gdGhpcy5fbW9yZU9wdGlvbnMuYWxpZ25tZW50LnY7XG4gICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuX2FuaW1hdG9yc0RhdGE7XG4gICAgdmFyIHRleHREYXRhID0gdGhpcy5fdGV4dERhdGE7XG4gICAgdmFyIG1hdHJpeEhlbHBlciA9IHRoaXMubUhlbHBlcjtcbiAgICB2YXIgcmVuZGVyVHlwZSA9IHRoaXMuX3JlbmRlclR5cGU7XG4gICAgdmFyIHJlbmRlcmVkTGV0dGVyc0NvdW50ID0gdGhpcy5yZW5kZXJlZExldHRlcnMubGVuZ3RoO1xuICAgIHZhciB4UG9zO1xuICAgIHZhciB5UG9zO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG4gICAgdmFyIGxldHRlcnMgPSBkb2N1bWVudERhdGEubDtcbiAgICB2YXIgcGF0aEluZm87XG4gICAgdmFyIGN1cnJlbnRMZW5ndGg7XG4gICAgdmFyIGN1cnJlbnRQb2ludDtcbiAgICB2YXIgc2VnbWVudExlbmd0aDtcbiAgICB2YXIgZmxhZztcbiAgICB2YXIgcG9pbnRJbmQ7XG4gICAgdmFyIHNlZ21lbnRJbmQ7XG4gICAgdmFyIHByZXZQb2ludDtcbiAgICB2YXIgcG9pbnRzO1xuICAgIHZhciBzZWdtZW50cztcbiAgICB2YXIgcGFydGlhbExlbmd0aDtcbiAgICB2YXIgdG90YWxMZW5ndGg7XG4gICAgdmFyIHBlcmM7XG4gICAgdmFyIHRhbkFuZ2xlO1xuICAgIHZhciBtYXNrO1xuXG4gICAgaWYgKHRoaXMuX2hhc01hc2tlZFBhdGgpIHtcbiAgICAgIG1hc2sgPSB0aGlzLl9wYXRoRGF0YS5tO1xuXG4gICAgICBpZiAoIXRoaXMuX3BhdGhEYXRhLm4gfHwgdGhpcy5fcGF0aERhdGEuX21kZikge1xuICAgICAgICB2YXIgcGF0aHMgPSBtYXNrLnY7XG5cbiAgICAgICAgaWYgKHRoaXMuX3BhdGhEYXRhLnIudikge1xuICAgICAgICAgIHBhdGhzID0gcGF0aHMucmV2ZXJzZSgpO1xuICAgICAgICB9IC8vIFRPRE86IHJlbGVhc2UgYmV6aWVyIGRhdGEgY2FjaGVkIGZyb20gcHJldmlvdXMgcGF0aEluZm86IHRoaXMuX3BhdGhEYXRhLnBpXG5cblxuICAgICAgICBwYXRoSW5mbyA9IHtcbiAgICAgICAgICB0TGVuZ3RoOiAwLFxuICAgICAgICAgIHNlZ21lbnRzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBsZW4gPSBwYXRocy5fbGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGJlemllckRhdGE7XG4gICAgICAgIHRvdGFsTGVuZ3RoID0gMDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBiZXppZXJEYXRhID0gYmV6LmJ1aWxkQmV6aWVyRGF0YShwYXRocy52W2ldLCBwYXRocy52W2kgKyAxXSwgW3BhdGhzLm9baV1bMF0gLSBwYXRocy52W2ldWzBdLCBwYXRocy5vW2ldWzFdIC0gcGF0aHMudltpXVsxXV0sIFtwYXRocy5pW2kgKyAxXVswXSAtIHBhdGhzLnZbaSArIDFdWzBdLCBwYXRocy5pW2kgKyAxXVsxXSAtIHBhdGhzLnZbaSArIDFdWzFdXSk7XG4gICAgICAgICAgcGF0aEluZm8udExlbmd0aCArPSBiZXppZXJEYXRhLnNlZ21lbnRMZW5ndGg7XG4gICAgICAgICAgcGF0aEluZm8uc2VnbWVudHMucHVzaChiZXppZXJEYXRhKTtcbiAgICAgICAgICB0b3RhbExlbmd0aCArPSBiZXppZXJEYXRhLnNlZ21lbnRMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBpID0gbGVuO1xuXG4gICAgICAgIGlmIChtYXNrLnYuYykge1xuICAgICAgICAgIGJlemllckRhdGEgPSBiZXouYnVpbGRCZXppZXJEYXRhKHBhdGhzLnZbaV0sIHBhdGhzLnZbMF0sIFtwYXRocy5vW2ldWzBdIC0gcGF0aHMudltpXVswXSwgcGF0aHMub1tpXVsxXSAtIHBhdGhzLnZbaV1bMV1dLCBbcGF0aHMuaVswXVswXSAtIHBhdGhzLnZbMF1bMF0sIHBhdGhzLmlbMF1bMV0gLSBwYXRocy52WzBdWzFdXSk7XG4gICAgICAgICAgcGF0aEluZm8udExlbmd0aCArPSBiZXppZXJEYXRhLnNlZ21lbnRMZW5ndGg7XG4gICAgICAgICAgcGF0aEluZm8uc2VnbWVudHMucHVzaChiZXppZXJEYXRhKTtcbiAgICAgICAgICB0b3RhbExlbmd0aCArPSBiZXppZXJEYXRhLnNlZ21lbnRMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wYXRoRGF0YS5waSA9IHBhdGhJbmZvO1xuICAgICAgfVxuXG4gICAgICBwYXRoSW5mbyA9IHRoaXMuX3BhdGhEYXRhLnBpO1xuICAgICAgY3VycmVudExlbmd0aCA9IHRoaXMuX3BhdGhEYXRhLmYudjtcbiAgICAgIHNlZ21lbnRJbmQgPSAwO1xuICAgICAgcG9pbnRJbmQgPSAxO1xuICAgICAgc2VnbWVudExlbmd0aCA9IDA7XG4gICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgIHNlZ21lbnRzID0gcGF0aEluZm8uc2VnbWVudHM7XG5cbiAgICAgIGlmIChjdXJyZW50TGVuZ3RoIDwgMCAmJiBtYXNrLnYuYykge1xuICAgICAgICBpZiAocGF0aEluZm8udExlbmd0aCA8IE1hdGguYWJzKGN1cnJlbnRMZW5ndGgpKSB7XG4gICAgICAgICAgY3VycmVudExlbmd0aCA9IC1NYXRoLmFicyhjdXJyZW50TGVuZ3RoKSAlIHBhdGhJbmZvLnRMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBzZWdtZW50SW5kID0gc2VnbWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgcG9pbnRzID0gc2VnbWVudHNbc2VnbWVudEluZF0ucG9pbnRzO1xuICAgICAgICBwb2ludEluZCA9IHBvaW50cy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChjdXJyZW50TGVuZ3RoIDwgMCkge1xuICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gcG9pbnRzW3BvaW50SW5kXS5wYXJ0aWFsTGVuZ3RoO1xuICAgICAgICAgIHBvaW50SW5kIC09IDE7XG5cbiAgICAgICAgICBpZiAocG9pbnRJbmQgPCAwKSB7XG4gICAgICAgICAgICBzZWdtZW50SW5kIC09IDE7XG4gICAgICAgICAgICBwb2ludHMgPSBzZWdtZW50c1tzZWdtZW50SW5kXS5wb2ludHM7XG4gICAgICAgICAgICBwb2ludEluZCA9IHBvaW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwb2ludHMgPSBzZWdtZW50c1tzZWdtZW50SW5kXS5wb2ludHM7XG4gICAgICBwcmV2UG9pbnQgPSBwb2ludHNbcG9pbnRJbmQgLSAxXTtcbiAgICAgIGN1cnJlbnRQb2ludCA9IHBvaW50c1twb2ludEluZF07XG4gICAgICBwYXJ0aWFsTGVuZ3RoID0gY3VycmVudFBvaW50LnBhcnRpYWxMZW5ndGg7XG4gICAgfVxuXG4gICAgbGVuID0gbGV0dGVycy5sZW5ndGg7XG4gICAgeFBvcyA9IDA7XG4gICAgeVBvcyA9IDA7XG4gICAgdmFyIHlPZmYgPSBkb2N1bWVudERhdGEuZmluYWxTaXplICogMS4yICogMC43MTQ7XG4gICAgdmFyIGZpcnN0TGluZSA9IHRydWU7XG4gICAgdmFyIGFuaW1hdG9yUHJvcHM7XG4gICAgdmFyIGFuaW1hdG9yU2VsZWN0b3I7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW47XG4gICAgdmFyIGxldHRlclZhbHVlO1xuICAgIGpMZW4gPSBhbmltYXRvcnMubGVuZ3RoO1xuICAgIHZhciBtdWx0O1xuICAgIHZhciBpbmQgPSAtMTtcbiAgICB2YXIgb2ZmZjtcbiAgICB2YXIgeFBhdGhQb3M7XG4gICAgdmFyIHlQYXRoUG9zO1xuICAgIHZhciBpbml0UGF0aFBvcyA9IGN1cnJlbnRMZW5ndGg7XG4gICAgdmFyIGluaXRTZWdtZW50SW5kID0gc2VnbWVudEluZDtcbiAgICB2YXIgaW5pdFBvaW50SW5kID0gcG9pbnRJbmQ7XG4gICAgdmFyIGN1cnJlbnRMaW5lID0gLTE7XG4gICAgdmFyIGVsZW1PcGFjaXR5O1xuICAgIHZhciBzYztcbiAgICB2YXIgc3c7XG4gICAgdmFyIGZjO1xuICAgIHZhciBrO1xuICAgIHZhciBsZXR0ZXJTdztcbiAgICB2YXIgbGV0dGVyU2M7XG4gICAgdmFyIGxldHRlckZjO1xuICAgIHZhciBsZXR0ZXJNID0gJyc7XG4gICAgdmFyIGxldHRlclAgPSB0aGlzLmRlZmF1bHRQcm9wc0FycmF5O1xuICAgIHZhciBsZXR0ZXJPOyAvL1xuXG4gICAgaWYgKGRvY3VtZW50RGF0YS5qID09PSAyIHx8IGRvY3VtZW50RGF0YS5qID09PSAxKSB7XG4gICAgICB2YXIgYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ID0gMDtcbiAgICAgIHZhciBhbmltYXRvckZpcnN0Q2hhck9mZnNldCA9IDA7XG4gICAgICB2YXIganVzdGlmeU9mZnNldE11bHQgPSBkb2N1bWVudERhdGEuaiA9PT0gMiA/IC0wLjUgOiAtMTtcbiAgICAgIHZhciBsYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIGlzTmV3TGluZSA9IHRydWU7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAobGV0dGVyc1tpXS5uKSB7XG4gICAgICAgICAgaWYgKGFuaW1hdG9ySnVzdGlmeU9mZnNldCkge1xuICAgICAgICAgICAgYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ICs9IGFuaW1hdG9yRmlyc3RDaGFyT2Zmc2V0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdoaWxlIChsYXN0SW5kZXggPCBpKSB7XG4gICAgICAgICAgICBsZXR0ZXJzW2xhc3RJbmRleF0uYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ID0gYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0O1xuICAgICAgICAgICAgbGFzdEluZGV4ICs9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ID0gMDtcbiAgICAgICAgICBpc05ld0xpbmUgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGFuaW1hdG9yUHJvcHMgPSBhbmltYXRvcnNbal0uYTtcblxuICAgICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMudC5wcm9wVHlwZSkge1xuICAgICAgICAgICAgICBpZiAoaXNOZXdMaW5lICYmIGRvY3VtZW50RGF0YS5qID09PSAyKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0b3JGaXJzdENoYXJPZmZzZXQgKz0gYW5pbWF0b3JQcm9wcy50LnYgKiBqdXN0aWZ5T2Zmc2V0TXVsdDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcbiAgICAgICAgICAgICAgbXVsdCA9IGFuaW1hdG9yU2VsZWN0b3IuZ2V0TXVsdChsZXR0ZXJzW2ldLmFuSW5kZXhlc1tqXSwgdGV4dERhdGEuYVtqXS5zLnRvdGFsQ2hhcnMpO1xuXG4gICAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFuaW1hdG9ySnVzdGlmeU9mZnNldCArPSBhbmltYXRvclByb3BzLnQudiAqIG11bHRbMF0gKiBqdXN0aWZ5T2Zmc2V0TXVsdDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbmltYXRvckp1c3RpZnlPZmZzZXQgKz0gYW5pbWF0b3JQcm9wcy50LnYgKiBtdWx0ICoganVzdGlmeU9mZnNldE11bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpc05ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0KSB7XG4gICAgICAgIGFuaW1hdG9ySnVzdGlmeU9mZnNldCArPSBhbmltYXRvckZpcnN0Q2hhck9mZnNldDtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGxhc3RJbmRleCA8IGkpIHtcbiAgICAgICAgbGV0dGVyc1tsYXN0SW5kZXhdLmFuaW1hdG9ySnVzdGlmeU9mZnNldCA9IGFuaW1hdG9ySnVzdGlmeU9mZnNldDtcbiAgICAgICAgbGFzdEluZGV4ICs9IDE7XG4gICAgICB9XG4gICAgfSAvL1xuXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIG1hdHJpeEhlbHBlci5yZXNldCgpO1xuICAgICAgZWxlbU9wYWNpdHkgPSAxO1xuXG4gICAgICBpZiAobGV0dGVyc1tpXS5uKSB7XG4gICAgICAgIHhQb3MgPSAwO1xuICAgICAgICB5UG9zICs9IGRvY3VtZW50RGF0YS55T2Zmc2V0O1xuICAgICAgICB5UG9zICs9IGZpcnN0TGluZSA/IDEgOiAwO1xuICAgICAgICBjdXJyZW50TGVuZ3RoID0gaW5pdFBhdGhQb3M7XG4gICAgICAgIGZpcnN0TGluZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLl9oYXNNYXNrZWRQYXRoKSB7XG4gICAgICAgICAgc2VnbWVudEluZCA9IGluaXRTZWdtZW50SW5kO1xuICAgICAgICAgIHBvaW50SW5kID0gaW5pdFBvaW50SW5kO1xuICAgICAgICAgIHBvaW50cyA9IHNlZ21lbnRzW3NlZ21lbnRJbmRdLnBvaW50cztcbiAgICAgICAgICBwcmV2UG9pbnQgPSBwb2ludHNbcG9pbnRJbmQgLSAxXTtcbiAgICAgICAgICBjdXJyZW50UG9pbnQgPSBwb2ludHNbcG9pbnRJbmRdO1xuICAgICAgICAgIHBhcnRpYWxMZW5ndGggPSBjdXJyZW50UG9pbnQucGFydGlhbExlbmd0aDtcbiAgICAgICAgICBzZWdtZW50TGVuZ3RoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldHRlck0gPSAnJztcbiAgICAgICAgbGV0dGVyRmMgPSAnJztcbiAgICAgICAgbGV0dGVyU3cgPSAnJztcbiAgICAgICAgbGV0dGVyTyA9ICcnO1xuICAgICAgICBsZXR0ZXJQID0gdGhpcy5kZWZhdWx0UHJvcHNBcnJheTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNNYXNrZWRQYXRoKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnRMaW5lICE9PSBsZXR0ZXJzW2ldLmxpbmUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZG9jdW1lbnREYXRhLmopIHtcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gdG90YWxMZW5ndGggLSBkb2N1bWVudERhdGEubGluZVdpZHRoc1tsZXR0ZXJzW2ldLmxpbmVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9ICh0b3RhbExlbmd0aCAtIGRvY3VtZW50RGF0YS5saW5lV2lkdGhzW2xldHRlcnNbaV0ubGluZV0pIC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50TGluZSA9IGxldHRlcnNbaV0ubGluZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW5kICE9PSBsZXR0ZXJzW2ldLmluZCkge1xuICAgICAgICAgICAgaWYgKGxldHRlcnNbaW5kXSkge1xuICAgICAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9IGxldHRlcnNbaW5kXS5leHRyYTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudExlbmd0aCArPSBsZXR0ZXJzW2ldLmFuIC8gMjtcbiAgICAgICAgICAgIGluZCA9IGxldHRlcnNbaV0uaW5kO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gYWxpZ25tZW50WzBdICogbGV0dGVyc1tpXS5hbiAqIDAuMDA1O1xuICAgICAgICAgIHZhciBhbmltYXRvck9mZnNldCA9IDA7XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICBhbmltYXRvclByb3BzID0gYW5pbWF0b3JzW2pdLmE7XG5cbiAgICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLnAucHJvcFR5cGUpIHtcbiAgICAgICAgICAgICAgYW5pbWF0b3JTZWxlY3RvciA9IGFuaW1hdG9yc1tqXS5zO1xuICAgICAgICAgICAgICBtdWx0ID0gYW5pbWF0b3JTZWxlY3Rvci5nZXRNdWx0KGxldHRlcnNbaV0uYW5JbmRleGVzW2pdLCB0ZXh0RGF0YS5hW2pdLnMudG90YWxDaGFycyk7XG5cbiAgICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0b3JPZmZzZXQgKz0gYW5pbWF0b3JQcm9wcy5wLnZbMF0gKiBtdWx0WzBdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFuaW1hdG9yT2Zmc2V0ICs9IGFuaW1hdG9yUHJvcHMucC52WzBdICogbXVsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5hLnByb3BUeXBlKSB7XG4gICAgICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcbiAgICAgICAgICAgICAgbXVsdCA9IGFuaW1hdG9yU2VsZWN0b3IuZ2V0TXVsdChsZXR0ZXJzW2ldLmFuSW5kZXhlc1tqXSwgdGV4dERhdGEuYVtqXS5zLnRvdGFsQ2hhcnMpO1xuXG4gICAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFuaW1hdG9yT2Zmc2V0ICs9IGFuaW1hdG9yUHJvcHMuYS52WzBdICogbXVsdFswXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbmltYXRvck9mZnNldCArPSBhbmltYXRvclByb3BzLmEudlswXSAqIG11bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmbGFnID0gdHJ1ZTsgLy8gRm9yY2UgYWxpZ25tZW50IG9ubHkgd29ya3Mgd2l0aCBhIHNpbmdsZSBsaW5lIGZvciBub3dcblxuICAgICAgICAgIGlmICh0aGlzLl9wYXRoRGF0YS5hLnYpIHtcbiAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggPSBsZXR0ZXJzWzBdLmFuICogMC41ICsgKHRvdGFsTGVuZ3RoIC0gdGhpcy5fcGF0aERhdGEuZi52IC0gbGV0dGVyc1swXS5hbiAqIDAuNSAtIGxldHRlcnNbbGV0dGVycy5sZW5ndGggLSAxXS5hbiAqIDAuNSkgKiBpbmQgLyAobGVuIC0gMSk7XG4gICAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9IHRoaXMuX3BhdGhEYXRhLmYudjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aGlsZSAoZmxhZykge1xuICAgICAgICAgICAgaWYgKHNlZ21lbnRMZW5ndGggKyBwYXJ0aWFsTGVuZ3RoID49IGN1cnJlbnRMZW5ndGggKyBhbmltYXRvck9mZnNldCB8fCAhcG9pbnRzKSB7XG4gICAgICAgICAgICAgIHBlcmMgPSAoY3VycmVudExlbmd0aCArIGFuaW1hdG9yT2Zmc2V0IC0gc2VnbWVudExlbmd0aCkgLyBjdXJyZW50UG9pbnQucGFydGlhbExlbmd0aDtcbiAgICAgICAgICAgICAgeFBhdGhQb3MgPSBwcmV2UG9pbnQucG9pbnRbMF0gKyAoY3VycmVudFBvaW50LnBvaW50WzBdIC0gcHJldlBvaW50LnBvaW50WzBdKSAqIHBlcmM7XG4gICAgICAgICAgICAgIHlQYXRoUG9zID0gcHJldlBvaW50LnBvaW50WzFdICsgKGN1cnJlbnRQb2ludC5wb2ludFsxXSAtIHByZXZQb2ludC5wb2ludFsxXSkgKiBwZXJjO1xuICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKC1hbGlnbm1lbnRbMF0gKiBsZXR0ZXJzW2ldLmFuICogMC4wMDUsIC0oYWxpZ25tZW50WzFdICogeU9mZikgKiAwLjAxKTtcbiAgICAgICAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb2ludHMpIHtcbiAgICAgICAgICAgICAgc2VnbWVudExlbmd0aCArPSBjdXJyZW50UG9pbnQucGFydGlhbExlbmd0aDtcbiAgICAgICAgICAgICAgcG9pbnRJbmQgKz0gMTtcblxuICAgICAgICAgICAgICBpZiAocG9pbnRJbmQgPj0gcG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBvaW50SW5kID0gMDtcbiAgICAgICAgICAgICAgICBzZWdtZW50SW5kICs9IDE7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNlZ21lbnRzW3NlZ21lbnRJbmRdKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobWFzay52LmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50SW5kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gc2VnbWVudHNbc2VnbWVudEluZF0ucG9pbnRzO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudExlbmd0aCAtPSBjdXJyZW50UG9pbnQucGFydGlhbExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcG9pbnRzID0gc2VnbWVudHNbc2VnbWVudEluZF0ucG9pbnRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChwb2ludHMpIHtcbiAgICAgICAgICAgICAgICBwcmV2UG9pbnQgPSBjdXJyZW50UG9pbnQ7XG4gICAgICAgICAgICAgICAgY3VycmVudFBvaW50ID0gcG9pbnRzW3BvaW50SW5kXTtcbiAgICAgICAgICAgICAgICBwYXJ0aWFsTGVuZ3RoID0gY3VycmVudFBvaW50LnBhcnRpYWxMZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvZmZmID0gbGV0dGVyc1tpXS5hbiAvIDIgLSBsZXR0ZXJzW2ldLmFkZDtcbiAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKC1vZmZmLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZmID0gbGV0dGVyc1tpXS5hbiAvIDIgLSBsZXR0ZXJzW2ldLmFkZDtcbiAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKC1vZmZmLCAwLCAwKTsgLy8gR3JvdXBpbmcgYWxpZ25tZW50XG5cbiAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKC1hbGlnbm1lbnRbMF0gKiBsZXR0ZXJzW2ldLmFuICogMC4wMDUsIC1hbGlnbm1lbnRbMV0gKiB5T2ZmICogMC4wMSwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgYW5pbWF0b3JQcm9wcyA9IGFuaW1hdG9yc1tqXS5hO1xuXG4gICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMudC5wcm9wVHlwZSkge1xuICAgICAgICAgICAgYW5pbWF0b3JTZWxlY3RvciA9IGFuaW1hdG9yc1tqXS5zO1xuICAgICAgICAgICAgbXVsdCA9IGFuaW1hdG9yU2VsZWN0b3IuZ2V0TXVsdChsZXR0ZXJzW2ldLmFuSW5kZXhlc1tqXSwgdGV4dERhdGEuYVtqXS5zLnRvdGFsQ2hhcnMpOyAvLyBUaGlzIGNvbmRpdGlvbiBpcyB0byBwcmV2ZW50IGFwcGx5aW5nIHRyYWNraW5nIHRvIGZpcnN0IGNoYXJhY3RlciBpbiBlYWNoIGxpbmUuIE1pZ2h0IGJlIGJldHRlciB0byB1c2UgYSBib29sZWFuIFwiaXNOZXdMaW5lXCJcblxuICAgICAgICAgICAgaWYgKHhQb3MgIT09IDAgfHwgZG9jdW1lbnREYXRhLmogIT09IDApIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2hhc01hc2tlZFBhdGgpIHtcbiAgICAgICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gYW5pbWF0b3JQcm9wcy50LnYgKiBtdWx0WzBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9IGFuaW1hdG9yUHJvcHMudC52ICogbXVsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB4UG9zICs9IGFuaW1hdG9yUHJvcHMudC52ICogbXVsdFswXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4UG9zICs9IGFuaW1hdG9yUHJvcHMudC52ICogbXVsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb2N1bWVudERhdGEuc3Ryb2tlV2lkdGhBbmltKSB7XG4gICAgICAgICAgc3cgPSBkb2N1bWVudERhdGEuc3cgfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb2N1bWVudERhdGEuc3Ryb2tlQ29sb3JBbmltKSB7XG4gICAgICAgICAgaWYgKGRvY3VtZW50RGF0YS5zYykge1xuICAgICAgICAgICAgc2MgPSBbZG9jdW1lbnREYXRhLnNjWzBdLCBkb2N1bWVudERhdGEuc2NbMV0sIGRvY3VtZW50RGF0YS5zY1syXV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjID0gWzAsIDAsIDBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb2N1bWVudERhdGEuZmlsbENvbG9yQW5pbSAmJiBkb2N1bWVudERhdGEuZmMpIHtcbiAgICAgICAgICBmYyA9IFtkb2N1bWVudERhdGEuZmNbMF0sIGRvY3VtZW50RGF0YS5mY1sxXSwgZG9jdW1lbnREYXRhLmZjWzJdXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICBhbmltYXRvclByb3BzID0gYW5pbWF0b3JzW2pdLmE7XG5cbiAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5hLnByb3BUeXBlKSB7XG4gICAgICAgICAgICBhbmltYXRvclNlbGVjdG9yID0gYW5pbWF0b3JzW2pdLnM7XG4gICAgICAgICAgICBtdWx0ID0gYW5pbWF0b3JTZWxlY3Rvci5nZXRNdWx0KGxldHRlcnNbaV0uYW5JbmRleGVzW2pdLCB0ZXh0RGF0YS5hW2pdLnMudG90YWxDaGFycyk7XG5cbiAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKC1hbmltYXRvclByb3BzLmEudlswXSAqIG11bHRbMF0sIC1hbmltYXRvclByb3BzLmEudlsxXSAqIG11bHRbMV0sIGFuaW1hdG9yUHJvcHMuYS52WzJdICogbXVsdFsyXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKC1hbmltYXRvclByb3BzLmEudlswXSAqIG11bHQsIC1hbmltYXRvclByb3BzLmEudlsxXSAqIG11bHQsIGFuaW1hdG9yUHJvcHMuYS52WzJdICogbXVsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgIGFuaW1hdG9yUHJvcHMgPSBhbmltYXRvcnNbal0uYTtcblxuICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLnMucHJvcFR5cGUpIHtcbiAgICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcbiAgICAgICAgICAgIG11bHQgPSBhbmltYXRvclNlbGVjdG9yLmdldE11bHQobGV0dGVyc1tpXS5hbkluZGV4ZXNbal0sIHRleHREYXRhLmFbal0ucy50b3RhbENoYXJzKTtcblxuICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci5zY2FsZSgxICsgKGFuaW1hdG9yUHJvcHMucy52WzBdIC0gMSkgKiBtdWx0WzBdLCAxICsgKGFuaW1hdG9yUHJvcHMucy52WzFdIC0gMSkgKiBtdWx0WzFdLCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci5zY2FsZSgxICsgKGFuaW1hdG9yUHJvcHMucy52WzBdIC0gMSkgKiBtdWx0LCAxICsgKGFuaW1hdG9yUHJvcHMucy52WzFdIC0gMSkgKiBtdWx0LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgYW5pbWF0b3JQcm9wcyA9IGFuaW1hdG9yc1tqXS5hO1xuICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcbiAgICAgICAgICBtdWx0ID0gYW5pbWF0b3JTZWxlY3Rvci5nZXRNdWx0KGxldHRlcnNbaV0uYW5JbmRleGVzW2pdLCB0ZXh0RGF0YS5hW2pdLnMudG90YWxDaGFycyk7XG5cbiAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5zay5wcm9wVHlwZSkge1xuICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci5za2V3RnJvbUF4aXMoLWFuaW1hdG9yUHJvcHMuc2sudiAqIG11bHRbMF0sIGFuaW1hdG9yUHJvcHMuc2EudiAqIG11bHRbMV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnNrZXdGcm9tQXhpcygtYW5pbWF0b3JQcm9wcy5zay52ICogbXVsdCwgYW5pbWF0b3JQcm9wcy5zYS52ICogbXVsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMuci5wcm9wVHlwZSkge1xuICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci5yb3RhdGVaKC1hbmltYXRvclByb3BzLnIudiAqIG11bHRbMl0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnJvdGF0ZVooLWFuaW1hdG9yUHJvcHMuci52ICogbXVsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMucnkucHJvcFR5cGUpIHtcbiAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIucm90YXRlWShhbmltYXRvclByb3BzLnJ5LnYgKiBtdWx0WzFdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci5yb3RhdGVZKGFuaW1hdG9yUHJvcHMucnkudiAqIG11bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLnJ4LnByb3BUeXBlKSB7XG4gICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnJvdGF0ZVgoYW5pbWF0b3JQcm9wcy5yeC52ICogbXVsdFswXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIucm90YXRlWChhbmltYXRvclByb3BzLnJ4LnYgKiBtdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5vLnByb3BUeXBlKSB7XG4gICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgZWxlbU9wYWNpdHkgKz0gKGFuaW1hdG9yUHJvcHMuby52ICogbXVsdFswXSAtIGVsZW1PcGFjaXR5KSAqIG11bHRbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtT3BhY2l0eSArPSAoYW5pbWF0b3JQcm9wcy5vLnYgKiBtdWx0IC0gZWxlbU9wYWNpdHkpICogbXVsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZG9jdW1lbnREYXRhLnN0cm9rZVdpZHRoQW5pbSAmJiBhbmltYXRvclByb3BzLnN3LnByb3BUeXBlKSB7XG4gICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgc3cgKz0gYW5pbWF0b3JQcm9wcy5zdy52ICogbXVsdFswXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN3ICs9IGFuaW1hdG9yUHJvcHMuc3cudiAqIG11bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRvY3VtZW50RGF0YS5zdHJva2VDb2xvckFuaW0gJiYgYW5pbWF0b3JQcm9wcy5zYy5wcm9wVHlwZSkge1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IDM7IGsgKz0gMSkge1xuICAgICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzY1trXSArPSAoYW5pbWF0b3JQcm9wcy5zYy52W2tdIC0gc2Nba10pICogbXVsdFswXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY1trXSArPSAoYW5pbWF0b3JQcm9wcy5zYy52W2tdIC0gc2Nba10pICogbXVsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkb2N1bWVudERhdGEuZmlsbENvbG9yQW5pbSAmJiBkb2N1bWVudERhdGEuZmMpIHtcbiAgICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLmZjLnByb3BUeXBlKSB7XG4gICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCAzOyBrICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIGZjW2tdICs9IChhbmltYXRvclByb3BzLmZjLnZba10gLSBmY1trXSkgKiBtdWx0WzBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBmY1trXSArPSAoYW5pbWF0b3JQcm9wcy5mYy52W2tdIC0gZmNba10pICogbXVsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMuZmgucHJvcFR5cGUpIHtcbiAgICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZmMgPSBhZGRIdWVUb1JHQihmYywgYW5pbWF0b3JQcm9wcy5maC52ICogbXVsdFswXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmMgPSBhZGRIdWVUb1JHQihmYywgYW5pbWF0b3JQcm9wcy5maC52ICogbXVsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMuZnMucHJvcFR5cGUpIHtcbiAgICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZmMgPSBhZGRTYXR1cmF0aW9uVG9SR0IoZmMsIGFuaW1hdG9yUHJvcHMuZnMudiAqIG11bHRbMF0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZjID0gYWRkU2F0dXJhdGlvblRvUkdCKGZjLCBhbmltYXRvclByb3BzLmZzLnYgKiBtdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5mYi5wcm9wVHlwZSkge1xuICAgICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmYyA9IGFkZEJyaWdodG5lc3NUb1JHQihmYywgYW5pbWF0b3JQcm9wcy5mYi52ICogbXVsdFswXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmMgPSBhZGRCcmlnaHRuZXNzVG9SR0IoZmMsIGFuaW1hdG9yUHJvcHMuZmIudiAqIG11bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgIGFuaW1hdG9yUHJvcHMgPSBhbmltYXRvcnNbal0uYTtcblxuICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLnAucHJvcFR5cGUpIHtcbiAgICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcbiAgICAgICAgICAgIG11bHQgPSBhbmltYXRvclNlbGVjdG9yLmdldE11bHQobGV0dGVyc1tpXS5hbkluZGV4ZXNbal0sIHRleHREYXRhLmFbal0ucy50b3RhbENoYXJzKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2hhc01hc2tlZFBhdGgpIHtcbiAgICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSgwLCBhbmltYXRvclByb3BzLnAudlsxXSAqIG11bHRbMF0sIC1hbmltYXRvclByb3BzLnAudlsyXSAqIG11bHRbMV0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoMCwgYW5pbWF0b3JQcm9wcy5wLnZbMV0gKiBtdWx0LCAtYW5pbWF0b3JQcm9wcy5wLnZbMl0gKiBtdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKGFuaW1hdG9yUHJvcHMucC52WzBdICogbXVsdFswXSwgYW5pbWF0b3JQcm9wcy5wLnZbMV0gKiBtdWx0WzFdLCAtYW5pbWF0b3JQcm9wcy5wLnZbMl0gKiBtdWx0WzJdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoYW5pbWF0b3JQcm9wcy5wLnZbMF0gKiBtdWx0LCBhbmltYXRvclByb3BzLnAudlsxXSAqIG11bHQsIC1hbmltYXRvclByb3BzLnAudlsyXSAqIG11bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb2N1bWVudERhdGEuc3Ryb2tlV2lkdGhBbmltKSB7XG4gICAgICAgICAgbGV0dGVyU3cgPSBzdyA8IDAgPyAwIDogc3c7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9jdW1lbnREYXRhLnN0cm9rZUNvbG9yQW5pbSkge1xuICAgICAgICAgIGxldHRlclNjID0gJ3JnYignICsgTWF0aC5yb3VuZChzY1swXSAqIDI1NSkgKyAnLCcgKyBNYXRoLnJvdW5kKHNjWzFdICogMjU1KSArICcsJyArIE1hdGgucm91bmQoc2NbMl0gKiAyNTUpICsgJyknO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvY3VtZW50RGF0YS5maWxsQ29sb3JBbmltICYmIGRvY3VtZW50RGF0YS5mYykge1xuICAgICAgICAgIGxldHRlckZjID0gJ3JnYignICsgTWF0aC5yb3VuZChmY1swXSAqIDI1NSkgKyAnLCcgKyBNYXRoLnJvdW5kKGZjWzFdICogMjU1KSArICcsJyArIE1hdGgucm91bmQoZmNbMl0gKiAyNTUpICsgJyknO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2hhc01hc2tlZFBhdGgpIHtcbiAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKDAsIC1kb2N1bWVudERhdGEubHMpO1xuICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoMCwgYWxpZ25tZW50WzFdICogeU9mZiAqIDAuMDEgKyB5UG9zLCAwKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9wYXRoRGF0YS5wLnYpIHtcbiAgICAgICAgICAgIHRhbkFuZ2xlID0gKGN1cnJlbnRQb2ludC5wb2ludFsxXSAtIHByZXZQb2ludC5wb2ludFsxXSkgLyAoY3VycmVudFBvaW50LnBvaW50WzBdIC0gcHJldlBvaW50LnBvaW50WzBdKTtcbiAgICAgICAgICAgIHZhciByb3QgPSBNYXRoLmF0YW4odGFuQW5nbGUpICogMTgwIC8gTWF0aC5QSTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRQb2ludC5wb2ludFswXSA8IHByZXZQb2ludC5wb2ludFswXSkge1xuICAgICAgICAgICAgICByb3QgKz0gMTgwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXRyaXhIZWxwZXIucm90YXRlKC1yb3QgKiBNYXRoLlBJIC8gMTgwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKHhQYXRoUG9zLCB5UGF0aFBvcywgMCk7XG4gICAgICAgICAgY3VycmVudExlbmd0aCAtPSBhbGlnbm1lbnRbMF0gKiBsZXR0ZXJzW2ldLmFuICogMC4wMDU7XG5cbiAgICAgICAgICBpZiAobGV0dGVyc1tpICsgMV0gJiYgaW5kICE9PSBsZXR0ZXJzW2kgKyAxXS5pbmQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gbGV0dGVyc1tpXS5hbiAvIDI7XG4gICAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9IGRvY3VtZW50RGF0YS50ciAqIDAuMDAxICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSh4UG9zLCB5UG9zLCAwKTtcblxuICAgICAgICAgIGlmIChkb2N1bWVudERhdGEucHMpIHtcbiAgICAgICAgICAgIC8vIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoZG9jdW1lbnREYXRhLnBzWzBdLGRvY3VtZW50RGF0YS5wc1sxXSwwKTtcbiAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoZG9jdW1lbnREYXRhLnBzWzBdLCBkb2N1bWVudERhdGEucHNbMV0gKyBkb2N1bWVudERhdGEuYXNjZW50LCAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzd2l0Y2ggKGRvY3VtZW50RGF0YS5qKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUobGV0dGVyc1tpXS5hbmltYXRvckp1c3RpZnlPZmZzZXQgKyBkb2N1bWVudERhdGEuanVzdGlmeU9mZnNldCArIChkb2N1bWVudERhdGEuYm94V2lkdGggLSBkb2N1bWVudERhdGEubGluZVdpZHRoc1tsZXR0ZXJzW2ldLmxpbmVdKSwgMCwgMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUobGV0dGVyc1tpXS5hbmltYXRvckp1c3RpZnlPZmZzZXQgKyBkb2N1bWVudERhdGEuanVzdGlmeU9mZnNldCArIChkb2N1bWVudERhdGEuYm94V2lkdGggLSBkb2N1bWVudERhdGEubGluZVdpZHRoc1tsZXR0ZXJzW2ldLmxpbmVdKSAvIDIsIDAsIDApO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSgwLCAtZG9jdW1lbnREYXRhLmxzKTtcbiAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKG9mZmYsIDAsIDApO1xuICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoYWxpZ25tZW50WzBdICogbGV0dGVyc1tpXS5hbiAqIDAuMDA1LCBhbGlnbm1lbnRbMV0gKiB5T2ZmICogMC4wMSwgMCk7XG4gICAgICAgICAgeFBvcyArPSBsZXR0ZXJzW2ldLmwgKyBkb2N1bWVudERhdGEudHIgKiAwLjAwMSAqIGRvY3VtZW50RGF0YS5maW5hbFNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVuZGVyVHlwZSA9PT0gJ2h0bWwnKSB7XG4gICAgICAgICAgbGV0dGVyTSA9IG1hdHJpeEhlbHBlci50b0NTUygpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlbmRlclR5cGUgPT09ICdzdmcnKSB7XG4gICAgICAgICAgbGV0dGVyTSA9IG1hdHJpeEhlbHBlci50bzJkQ1NTKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0dGVyUCA9IFttYXRyaXhIZWxwZXIucHJvcHNbMF0sIG1hdHJpeEhlbHBlci5wcm9wc1sxXSwgbWF0cml4SGVscGVyLnByb3BzWzJdLCBtYXRyaXhIZWxwZXIucHJvcHNbM10sIG1hdHJpeEhlbHBlci5wcm9wc1s0XSwgbWF0cml4SGVscGVyLnByb3BzWzVdLCBtYXRyaXhIZWxwZXIucHJvcHNbNl0sIG1hdHJpeEhlbHBlci5wcm9wc1s3XSwgbWF0cml4SGVscGVyLnByb3BzWzhdLCBtYXRyaXhIZWxwZXIucHJvcHNbOV0sIG1hdHJpeEhlbHBlci5wcm9wc1sxMF0sIG1hdHJpeEhlbHBlci5wcm9wc1sxMV0sIG1hdHJpeEhlbHBlci5wcm9wc1sxMl0sIG1hdHJpeEhlbHBlci5wcm9wc1sxM10sIG1hdHJpeEhlbHBlci5wcm9wc1sxNF0sIG1hdHJpeEhlbHBlci5wcm9wc1sxNV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0dGVyTyA9IGVsZW1PcGFjaXR5O1xuICAgICAgfVxuXG4gICAgICBpZiAocmVuZGVyZWRMZXR0ZXJzQ291bnQgPD0gaSkge1xuICAgICAgICBsZXR0ZXJWYWx1ZSA9IG5ldyBMZXR0ZXJQcm9wcyhsZXR0ZXJPLCBsZXR0ZXJTdywgbGV0dGVyU2MsIGxldHRlckZjLCBsZXR0ZXJNLCBsZXR0ZXJQKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlZExldHRlcnMucHVzaChsZXR0ZXJWYWx1ZSk7XG4gICAgICAgIHJlbmRlcmVkTGV0dGVyc0NvdW50ICs9IDE7XG4gICAgICAgIHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldHRlclZhbHVlID0gdGhpcy5yZW5kZXJlZExldHRlcnNbaV07XG4gICAgICAgIHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnID0gbGV0dGVyVmFsdWUudXBkYXRlKGxldHRlck8sIGxldHRlclN3LCBsZXR0ZXJTYywgbGV0dGVyRmMsIGxldHRlck0sIGxldHRlclApIHx8IHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBUZXh0QW5pbWF0b3JQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2VsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLl9mcmFtZUlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZnJhbWVJZCA9IHRoaXMuX2VsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkO1xuICAgIHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzKCk7XG4gIH07XG5cbiAgVGV4dEFuaW1hdG9yUHJvcGVydHkucHJvdG90eXBlLm1IZWxwZXIgPSBuZXcgTWF0cml4KCk7XG4gIFRleHRBbmltYXRvclByb3BlcnR5LnByb3RvdHlwZS5kZWZhdWx0UHJvcHNBcnJheSA9IFtdO1xuICBleHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIFRleHRBbmltYXRvclByb3BlcnR5KTtcblxuICBmdW5jdGlvbiBJVGV4dEVsZW1lbnQoKSB7fVxuXG4gIElUZXh0RWxlbWVudC5wcm90b3R5cGUuaW5pdEVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgIHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnID0gdHJ1ZTtcbiAgICB0aGlzLmluaXRGcmFtZSgpO1xuICAgIHRoaXMuaW5pdEJhc2VEYXRhKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICAgIHRoaXMudGV4dFByb3BlcnR5ID0gbmV3IFRleHRQcm9wZXJ0eSh0aGlzLCBkYXRhLnQsIHRoaXMuZHluYW1pY1Byb3BlcnRpZXMpO1xuICAgIHRoaXMudGV4dEFuaW1hdG9yID0gbmV3IFRleHRBbmltYXRvclByb3BlcnR5KGRhdGEudCwgdGhpcy5yZW5kZXJUeXBlLCB0aGlzKTtcbiAgICB0aGlzLmluaXRUcmFuc2Zvcm0oZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gICAgdGhpcy5pbml0SGllcmFyY2h5KCk7XG4gICAgdGhpcy5pbml0UmVuZGVyYWJsZSgpO1xuICAgIHRoaXMuaW5pdFJlbmRlcmVyRWxlbWVudCgpO1xuICAgIHRoaXMuY3JlYXRlQ29udGFpbmVyRWxlbWVudHMoKTtcbiAgICB0aGlzLmNyZWF0ZVJlbmRlcmFibGVDb21wb25lbnRzKCk7XG4gICAgdGhpcy5jcmVhdGVDb250ZW50KCk7XG4gICAgdGhpcy5oaWRlKCk7XG4gICAgdGhpcy50ZXh0QW5pbWF0b3Iuc2VhcmNoUHJvcGVydGllcyh0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzKTtcbiAgfTtcblxuICBJVGV4dEVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICB0aGlzLnByZXBhcmVSZW5kZXJhYmxlRnJhbWUobnVtKTtcbiAgICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdGhpcy5pc0luUmFuZ2UpO1xuICB9O1xuXG4gIElUZXh0RWxlbWVudC5wcm90b3R5cGUuY3JlYXRlUGF0aFNoYXBlID0gZnVuY3Rpb24gKG1hdHJpeEhlbHBlciwgc2hhcGVzKSB7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW4gPSBzaGFwZXMubGVuZ3RoO1xuICAgIHZhciBwYXRoTm9kZXM7XG4gICAgdmFyIHNoYXBlU3RyID0gJyc7XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICBpZiAoc2hhcGVzW2pdLnR5ID09PSAnc2gnKSB7XG4gICAgICAgIHBhdGhOb2RlcyA9IHNoYXBlc1tqXS5rcy5rO1xuICAgICAgICBzaGFwZVN0ciArPSBidWlsZFNoYXBlU3RyaW5nKHBhdGhOb2RlcywgcGF0aE5vZGVzLmkubGVuZ3RoLCB0cnVlLCBtYXRyaXhIZWxwZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzaGFwZVN0cjtcbiAgfTtcblxuICBJVGV4dEVsZW1lbnQucHJvdG90eXBlLnVwZGF0ZURvY3VtZW50RGF0YSA9IGZ1bmN0aW9uIChuZXdEYXRhLCBpbmRleCkge1xuICAgIHRoaXMudGV4dFByb3BlcnR5LnVwZGF0ZURvY3VtZW50RGF0YShuZXdEYXRhLCBpbmRleCk7XG4gIH07XG5cbiAgSVRleHRFbGVtZW50LnByb3RvdHlwZS5jYW5SZXNpemVGb250ID0gZnVuY3Rpb24gKF9jYW5SZXNpemUpIHtcbiAgICB0aGlzLnRleHRQcm9wZXJ0eS5jYW5SZXNpemVGb250KF9jYW5SZXNpemUpO1xuICB9O1xuXG4gIElUZXh0RWxlbWVudC5wcm90b3R5cGUuc2V0TWluaW11bUZvbnRTaXplID0gZnVuY3Rpb24gKF9mb250U2l6ZSkge1xuICAgIHRoaXMudGV4dFByb3BlcnR5LnNldE1pbmltdW1Gb250U2l6ZShfZm9udFNpemUpO1xuICB9O1xuXG4gIElUZXh0RWxlbWVudC5wcm90b3R5cGUuYXBwbHlUZXh0UHJvcGVydGllc1RvTWF0cml4ID0gZnVuY3Rpb24gKGRvY3VtZW50RGF0YSwgbWF0cml4SGVscGVyLCBsaW5lTnVtYmVyLCB4UG9zLCB5UG9zKSB7XG4gICAgaWYgKGRvY3VtZW50RGF0YS5wcykge1xuICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZShkb2N1bWVudERhdGEucHNbMF0sIGRvY3VtZW50RGF0YS5wc1sxXSArIGRvY3VtZW50RGF0YS5hc2NlbnQsIDApO1xuICAgIH1cblxuICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoMCwgLWRvY3VtZW50RGF0YS5scywgMCk7XG5cbiAgICBzd2l0Y2ggKGRvY3VtZW50RGF0YS5qKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoZG9jdW1lbnREYXRhLmp1c3RpZnlPZmZzZXQgKyAoZG9jdW1lbnREYXRhLmJveFdpZHRoIC0gZG9jdW1lbnREYXRhLmxpbmVXaWR0aHNbbGluZU51bWJlcl0pLCAwLCAwKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZShkb2N1bWVudERhdGEuanVzdGlmeU9mZnNldCArIChkb2N1bWVudERhdGEuYm94V2lkdGggLSBkb2N1bWVudERhdGEubGluZVdpZHRoc1tsaW5lTnVtYmVyXSkgLyAyLCAwLCAwKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoeFBvcywgeVBvcywgMCk7XG4gIH07XG5cbiAgSVRleHRFbGVtZW50LnByb3RvdHlwZS5idWlsZENvbG9yID0gZnVuY3Rpb24gKGNvbG9yRGF0YSkge1xuICAgIHJldHVybiAncmdiKCcgKyBNYXRoLnJvdW5kKGNvbG9yRGF0YVswXSAqIDI1NSkgKyAnLCcgKyBNYXRoLnJvdW5kKGNvbG9yRGF0YVsxXSAqIDI1NSkgKyAnLCcgKyBNYXRoLnJvdW5kKGNvbG9yRGF0YVsyXSAqIDI1NSkgKyAnKSc7XG4gIH07XG5cbiAgSVRleHRFbGVtZW50LnByb3RvdHlwZS5lbXB0eVByb3AgPSBuZXcgTGV0dGVyUHJvcHMoKTtcblxuICBJVGV4dEVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBJVGV4dEVsZW1lbnQucHJvdG90eXBlLnZhbGlkYXRlVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy50ZXh0UHJvcGVydHkuX21kZiB8fCB0aGlzLnRleHRQcm9wZXJ0eS5faXNGaXJzdEZyYW1lKSB7XG4gICAgICB0aGlzLmJ1aWxkTmV3VGV4dCgpO1xuICAgICAgdGhpcy50ZXh0UHJvcGVydHkuX2lzRmlyc3RGcmFtZSA9IGZhbHNlO1xuICAgICAgdGhpcy50ZXh0UHJvcGVydHkuX21kZiA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZW1wdHlTaGFwZURhdGEgPSB7XG4gICAgc2hhcGVzOiBbXVxuICB9O1xuXG4gIGZ1bmN0aW9uIFNWR1RleHRMb3R0aWVFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLnRleHRTcGFucyA9IFtdO1xuICAgIHRoaXMucmVuZGVyVHlwZSA9ICdzdmcnO1xuICAgIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBTVkdCYXNlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRE9NRWxlbWVudCwgSVRleHRFbGVtZW50XSwgU1ZHVGV4dExvdHRpZUVsZW1lbnQpO1xuXG4gIFNWR1RleHRMb3R0aWVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmRhdGEuc2luZ2xlU2hhcGUgJiYgIXRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5jaGFycykge1xuICAgICAgdGhpcy50ZXh0Q29udGFpbmVyID0gY3JlYXRlTlMoJ3RleHQnKTtcbiAgICB9XG4gIH07XG5cbiAgU1ZHVGV4dExvdHRpZUVsZW1lbnQucHJvdG90eXBlLmJ1aWxkVGV4dENvbnRlbnRzID0gZnVuY3Rpb24gKHRleHRBcnJheSkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdGV4dEFycmF5Lmxlbmd0aDtcbiAgICB2YXIgdGV4dENvbnRlbnRzID0gW107XG4gICAgdmFyIGN1cnJlbnRUZXh0Q29udGVudCA9ICcnO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGlmICh0ZXh0QXJyYXlbaV0gPT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMTMpIHx8IHRleHRBcnJheVtpXSA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZSgzKSkge1xuICAgICAgICB0ZXh0Q29udGVudHMucHVzaChjdXJyZW50VGV4dENvbnRlbnQpO1xuICAgICAgICBjdXJyZW50VGV4dENvbnRlbnQgPSAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRUZXh0Q29udGVudCArPSB0ZXh0QXJyYXlbaV07XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMTtcbiAgICB9XG5cbiAgICB0ZXh0Q29udGVudHMucHVzaChjdXJyZW50VGV4dENvbnRlbnQpO1xuICAgIHJldHVybiB0ZXh0Q29udGVudHM7XG4gIH07XG5cbiAgU1ZHVGV4dExvdHRpZUVsZW1lbnQucHJvdG90eXBlLmJ1aWxkU2hhcGVEYXRhID0gZnVuY3Rpb24gKGRhdGEsIHNjYWxlKSB7XG4gICAgLy8gZGF0YSBzaG91bGQgcHJvYmFibHkgYmUgY2xvbmVkIHRvIGFwcGx5IHNjYWxlIHNlcGFyYXRlbHkgdG8gZWFjaCBpbnN0YW5jZSBvZiBhIHRleHQgb24gZGlmZmVyZW50IGxheWVyc1xuICAgIC8vIGJ1dCBzaW5jZSB0ZXh0IGludGVybmFsIGNvbnRlbnQgZ2V0cyBvbmx5IHJlbmRlcmVkIG9uY2UgYW5kIHRoZW4gaXQncyBuZXZlciByZXJlbmRlcmVkLFxuICAgIC8vIGl0J3MgcHJvYmFibHkgc2FmZSBub3QgdG8gY2xvbmUgZGF0YSBhbmQgcmV1c2UgYWx3YXlzIHRoZSBzYW1lIGluc3RhbmNlIGV2ZW4gaWYgdGhlIG9iamVjdCBpcyBtdXRhdGVkLlxuICAgIC8vIEF2b2lkaW5nIGNsb25pbmcgaXMgcHJlZmVycmVkIHNpbmNlIGNsb25pbmcgZWFjaCBjaGFyYWN0ZXIgc2hhcGUgZGF0YSBpcyBleHBlbnNpdmVcbiAgICBpZiAoZGF0YS5zaGFwZXMgJiYgZGF0YS5zaGFwZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgc2hhcGUgPSBkYXRhLnNoYXBlc1swXTtcblxuICAgICAgaWYgKHNoYXBlLml0KSB7XG4gICAgICAgIHZhciBzaGFwZUl0ZW0gPSBzaGFwZS5pdFtzaGFwZS5pdC5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoc2hhcGVJdGVtLnMpIHtcbiAgICAgICAgICBzaGFwZUl0ZW0ucy5rWzBdID0gc2NhbGU7XG4gICAgICAgICAgc2hhcGVJdGVtLnMua1sxXSA9IHNjYWxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgU1ZHVGV4dExvdHRpZUVsZW1lbnQucHJvdG90eXBlLmJ1aWxkTmV3VGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuICAgIHZhciBkb2N1bWVudERhdGEgPSB0aGlzLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YTtcbiAgICB0aGlzLnJlbmRlcmVkTGV0dGVycyA9IGNyZWF0ZVNpemVkQXJyYXkoZG9jdW1lbnREYXRhID8gZG9jdW1lbnREYXRhLmwubGVuZ3RoIDogMCk7XG5cbiAgICBpZiAoZG9jdW1lbnREYXRhLmZjKSB7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCB0aGlzLmJ1aWxkQ29sb3IoZG9jdW1lbnREYXRhLmZjKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnZmlsbCcsICdyZ2JhKDAsMCwwLDApJyk7XG4gICAgfVxuXG4gICAgaWYgKGRvY3VtZW50RGF0YS5zYykge1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHJva2UnLCB0aGlzLmJ1aWxkQ29sb3IoZG9jdW1lbnREYXRhLnNjKSk7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIGRvY3VtZW50RGF0YS5zdyk7XG4gICAgfVxuXG4gICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdmb250LXNpemUnLCBkb2N1bWVudERhdGEuZmluYWxTaXplKTtcbiAgICB2YXIgZm9udERhdGEgPSB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuZ2V0Rm9udEJ5TmFtZShkb2N1bWVudERhdGEuZik7XG5cbiAgICBpZiAoZm9udERhdGEuZkNsYXNzKSB7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgZm9udERhdGEuZkNsYXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdmb250LWZhbWlseScsIGZvbnREYXRhLmZGYW1pbHkpO1xuICAgICAgdmFyIGZXZWlnaHQgPSBkb2N1bWVudERhdGEuZldlaWdodDtcbiAgICAgIHZhciBmU3R5bGUgPSBkb2N1bWVudERhdGEuZlN0eWxlO1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdmb250LXN0eWxlJywgZlN0eWxlKTtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnZm9udC13ZWlnaHQnLCBmV2VpZ2h0KTtcbiAgICB9XG5cbiAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBkb2N1bWVudERhdGEudCk7XG4gICAgdmFyIGxldHRlcnMgPSBkb2N1bWVudERhdGEubCB8fCBbXTtcbiAgICB2YXIgdXNlc0dseXBocyA9ICEhdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmNoYXJzO1xuICAgIGxlbiA9IGxldHRlcnMubGVuZ3RoO1xuICAgIHZhciB0U3BhbjtcbiAgICB2YXIgbWF0cml4SGVscGVyID0gdGhpcy5tSGVscGVyO1xuICAgIHZhciBzaGFwZVN0ciA9ICcnO1xuICAgIHZhciBzaW5nbGVTaGFwZSA9IHRoaXMuZGF0YS5zaW5nbGVTaGFwZTtcbiAgICB2YXIgeFBvcyA9IDA7XG4gICAgdmFyIHlQb3MgPSAwO1xuICAgIHZhciBmaXJzdExpbmUgPSB0cnVlO1xuICAgIHZhciB0cmFja2luZ09mZnNldCA9IGRvY3VtZW50RGF0YS50ciAqIDAuMDAxICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZTtcblxuICAgIGlmIChzaW5nbGVTaGFwZSAmJiAhdXNlc0dseXBocyAmJiAhZG9jdW1lbnREYXRhLnN6KSB7XG4gICAgICB2YXIgdEVsZW1lbnQgPSB0aGlzLnRleHRDb250YWluZXI7XG4gICAgICB2YXIganVzdGlmeSA9ICdzdGFydCc7XG5cbiAgICAgIHN3aXRjaCAoZG9jdW1lbnREYXRhLmopIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGp1c3RpZnkgPSAnZW5kJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAganVzdGlmeSA9ICdtaWRkbGUnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAganVzdGlmeSA9ICdzdGFydCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHRFbGVtZW50LnNldEF0dHJpYnV0ZSgndGV4dC1hbmNob3InLCBqdXN0aWZ5KTtcbiAgICAgIHRFbGVtZW50LnNldEF0dHJpYnV0ZSgnbGV0dGVyLXNwYWNpbmcnLCB0cmFja2luZ09mZnNldCk7XG4gICAgICB2YXIgdGV4dENvbnRlbnQgPSB0aGlzLmJ1aWxkVGV4dENvbnRlbnRzKGRvY3VtZW50RGF0YS5maW5hbFRleHQpO1xuICAgICAgbGVuID0gdGV4dENvbnRlbnQubGVuZ3RoO1xuICAgICAgeVBvcyA9IGRvY3VtZW50RGF0YS5wcyA/IGRvY3VtZW50RGF0YS5wc1sxXSArIGRvY3VtZW50RGF0YS5hc2NlbnQgOiAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdFNwYW4gPSB0aGlzLnRleHRTcGFuc1tpXS5zcGFuIHx8IGNyZWF0ZU5TKCd0c3BhbicpO1xuICAgICAgICB0U3Bhbi50ZXh0Q29udGVudCA9IHRleHRDb250ZW50W2ldO1xuICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3gnLCAwKTtcbiAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCd5JywgeVBvcyk7XG4gICAgICAgIHRTcGFuLnN0eWxlLmRpc3BsYXkgPSAnaW5oZXJpdCc7XG4gICAgICAgIHRFbGVtZW50LmFwcGVuZENoaWxkKHRTcGFuKTtcblxuICAgICAgICBpZiAoIXRoaXMudGV4dFNwYW5zW2ldKSB7XG4gICAgICAgICAgdGhpcy50ZXh0U3BhbnNbaV0gPSB7XG4gICAgICAgICAgICBzcGFuOiBudWxsLFxuICAgICAgICAgICAgZ2x5cGg6IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50ZXh0U3BhbnNbaV0uc3BhbiA9IHRTcGFuO1xuICAgICAgICB5UG9zICs9IGRvY3VtZW50RGF0YS5maW5hbExpbmVIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKHRFbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNhY2hlZFNwYW5zTGVuZ3RoID0gdGhpcy50ZXh0U3BhbnMubGVuZ3RoO1xuICAgICAgdmFyIGNoYXJEYXRhO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRleHRTcGFuc1tpXSkge1xuICAgICAgICAgIHRoaXMudGV4dFNwYW5zW2ldID0ge1xuICAgICAgICAgICAgc3BhbjogbnVsbCxcbiAgICAgICAgICAgIGNoaWxkU3BhbjogbnVsbCxcbiAgICAgICAgICAgIGdseXBoOiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdXNlc0dseXBocyB8fCAhc2luZ2xlU2hhcGUgfHwgaSA9PT0gMCkge1xuICAgICAgICAgIHRTcGFuID0gY2FjaGVkU3BhbnNMZW5ndGggPiBpID8gdGhpcy50ZXh0U3BhbnNbaV0uc3BhbiA6IGNyZWF0ZU5TKHVzZXNHbHlwaHMgPyAnZycgOiAndGV4dCcpO1xuXG4gICAgICAgICAgaWYgKGNhY2hlZFNwYW5zTGVuZ3RoIDw9IGkpIHtcbiAgICAgICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCAnYnV0dCcpO1xuICAgICAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWpvaW4nLCAncm91bmQnKTtcbiAgICAgICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLW1pdGVybGltaXQnLCAnNCcpO1xuICAgICAgICAgICAgdGhpcy50ZXh0U3BhbnNbaV0uc3BhbiA9IHRTcGFuO1xuXG4gICAgICAgICAgICBpZiAodXNlc0dseXBocykge1xuICAgICAgICAgICAgICB2YXIgY2hpbGRTcGFuID0gY3JlYXRlTlMoJ2cnKTtcbiAgICAgICAgICAgICAgdFNwYW4uYXBwZW5kQ2hpbGQoY2hpbGRTcGFuKTtcbiAgICAgICAgICAgICAgdGhpcy50ZXh0U3BhbnNbaV0uY2hpbGRTcGFuID0gY2hpbGRTcGFuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnRleHRTcGFuc1tpXS5zcGFuID0gdFNwYW47XG4gICAgICAgICAgICB0aGlzLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZCh0U3Bhbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdFNwYW4uc3R5bGUuZGlzcGxheSA9ICdpbmhlcml0JztcbiAgICAgICAgfVxuXG4gICAgICAgIG1hdHJpeEhlbHBlci5yZXNldCgpO1xuXG4gICAgICAgIGlmIChzaW5nbGVTaGFwZSkge1xuICAgICAgICAgIGlmIChsZXR0ZXJzW2ldLm4pIHtcbiAgICAgICAgICAgIHhQb3MgPSAtdHJhY2tpbmdPZmZzZXQ7XG4gICAgICAgICAgICB5UG9zICs9IGRvY3VtZW50RGF0YS55T2Zmc2V0O1xuICAgICAgICAgICAgeVBvcyArPSBmaXJzdExpbmUgPyAxIDogMDtcbiAgICAgICAgICAgIGZpcnN0TGluZSA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYXBwbHlUZXh0UHJvcGVydGllc1RvTWF0cml4KGRvY3VtZW50RGF0YSwgbWF0cml4SGVscGVyLCBsZXR0ZXJzW2ldLmxpbmUsIHhQb3MsIHlQb3MpO1xuICAgICAgICAgIHhQb3MgKz0gbGV0dGVyc1tpXS5sIHx8IDA7IC8vIHhQb3MgKz0gbGV0dGVyc1tpXS52YWwgPT09ICcgJyA/IDAgOiB0cmFja2luZ09mZnNldDtcblxuICAgICAgICAgIHhQb3MgKz0gdHJhY2tpbmdPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXNlc0dseXBocykge1xuICAgICAgICAgIGNoYXJEYXRhID0gdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldENoYXJEYXRhKGRvY3VtZW50RGF0YS5maW5hbFRleHRbaV0sIGZvbnREYXRhLmZTdHlsZSwgdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldEZvbnRCeU5hbWUoZG9jdW1lbnREYXRhLmYpLmZGYW1pbHkpO1xuICAgICAgICAgIHZhciBnbHlwaEVsZW1lbnQ7IC8vIHQgPT09IDEgbWVhbnMgdGhlIGNoYXJhY3RlciBoYXMgYmVlbiByZXBsYWNlZCB3aXRoIGFuIGFuaW1hdGVkIHNoYXBlZFxuXG4gICAgICAgICAgaWYgKGNoYXJEYXRhLnQgPT09IDEpIHtcbiAgICAgICAgICAgIGdseXBoRWxlbWVudCA9IG5ldyBTVkdDb21wRWxlbWVudChjaGFyRGF0YS5kYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGVtcHR5U2hhcGVEYXRhO1xuXG4gICAgICAgICAgICBpZiAoY2hhckRhdGEuZGF0YSAmJiBjaGFyRGF0YS5kYXRhLnNoYXBlcykge1xuICAgICAgICAgICAgICBkYXRhID0gdGhpcy5idWlsZFNoYXBlRGF0YShjaGFyRGF0YS5kYXRhLCBkb2N1bWVudERhdGEuZmluYWxTaXplKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2x5cGhFbGVtZW50ID0gbmV3IFNWR1NoYXBlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnRleHRTcGFuc1tpXS5nbHlwaCkge1xuICAgICAgICAgICAgdmFyIGdseXBoID0gdGhpcy50ZXh0U3BhbnNbaV0uZ2x5cGg7XG4gICAgICAgICAgICB0aGlzLnRleHRTcGFuc1tpXS5jaGlsZFNwYW4ucmVtb3ZlQ2hpbGQoZ2x5cGgubGF5ZXJFbGVtZW50KTtcbiAgICAgICAgICAgIGdseXBoLmRlc3Ryb3koKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnRleHRTcGFuc1tpXS5nbHlwaCA9IGdseXBoRWxlbWVudDtcbiAgICAgICAgICBnbHlwaEVsZW1lbnQuX2RlYnVnID0gdHJ1ZTtcbiAgICAgICAgICBnbHlwaEVsZW1lbnQucHJlcGFyZUZyYW1lKDApO1xuICAgICAgICAgIGdseXBoRWxlbWVudC5yZW5kZXJGcmFtZSgpO1xuICAgICAgICAgIHRoaXMudGV4dFNwYW5zW2ldLmNoaWxkU3Bhbi5hcHBlbmRDaGlsZChnbHlwaEVsZW1lbnQubGF5ZXJFbGVtZW50KTsgLy8gd2hlbiB1c2luZyBhbmltYXRlZCBzaGFwZXMsIHRoZSBsYXllciB3aWxsIGJlIHNjYWxlZCBpbnN0ZWFkIG9mIHJlcGxhY2luZyB0aGUgaW50ZXJuYWwgc2NhbGVcbiAgICAgICAgICAvLyB0aGlzIG1pZ2h0IGhhdmUgaXNzdWVzIHdpdGggc3Ryb2tlcyBhbmQgbWlnaHQgbmVlZCBhIGRpZmZlcmVudCBzb2x1dGlvblxuXG4gICAgICAgICAgaWYgKGNoYXJEYXRhLnQgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dFNwYW5zW2ldLmNoaWxkU3Bhbi5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsICdzY2FsZSgnICsgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAvIDEwMCArICcsJyArIGRvY3VtZW50RGF0YS5maW5hbFNpemUgLyAxMDAgKyAnKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2luZ2xlU2hhcGUpIHtcbiAgICAgICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWF0cml4SGVscGVyLnByb3BzWzEyXSArICcsJyArIG1hdHJpeEhlbHBlci5wcm9wc1sxM10gKyAnKScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRTcGFuLnRleHRDb250ZW50ID0gbGV0dGVyc1tpXS52YWw7XG4gICAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZScsICd4bWw6c3BhY2UnLCAncHJlc2VydmUnKTtcbiAgICAgICAgfSAvL1xuXG4gICAgICB9XG5cbiAgICAgIGlmIChzaW5nbGVTaGFwZSAmJiB0U3Bhbikge1xuICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ2QnLCBzaGFwZVN0cik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKGkgPCB0aGlzLnRleHRTcGFucy5sZW5ndGgpIHtcbiAgICAgIHRoaXMudGV4dFNwYW5zW2ldLnNwYW4uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIGkgKz0gMTtcbiAgICB9XG5cbiAgICB0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XG4gIH07XG5cbiAgU1ZHVGV4dExvdHRpZUVsZW1lbnQucHJvdG90eXBlLnNvdXJjZVJlY3RBdFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wcmVwYXJlRnJhbWUodGhpcy5jb21wLnJlbmRlcmVkRnJhbWUgLSB0aGlzLmRhdGEuc3QpO1xuICAgIHRoaXMucmVuZGVySW5uZXJDb250ZW50KCk7XG5cbiAgICBpZiAodGhpcy5fc2l6ZUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX3NpemVDaGFuZ2VkID0gZmFsc2U7XG4gICAgICB2YXIgdGV4dEJveCA9IHRoaXMubGF5ZXJFbGVtZW50LmdldEJCb3goKTtcbiAgICAgIHRoaXMuYmJveCA9IHtcbiAgICAgICAgdG9wOiB0ZXh0Qm94LnksXG4gICAgICAgIGxlZnQ6IHRleHRCb3gueCxcbiAgICAgICAgd2lkdGg6IHRleHRCb3gud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGV4dEJveC5oZWlnaHRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYmJveDtcbiAgfTtcblxuICBTVkdUZXh0TG90dGllRWxlbWVudC5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMudGV4dFNwYW5zLmxlbmd0aDtcbiAgICB2YXIgZ2x5cGhFbGVtZW50O1xuICAgIHRoaXMucmVuZGVyZWRGcmFtZSA9IHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBnbHlwaEVsZW1lbnQgPSB0aGlzLnRleHRTcGFuc1tpXS5nbHlwaDtcblxuICAgICAgaWYgKGdseXBoRWxlbWVudCkge1xuICAgICAgICBnbHlwaEVsZW1lbnQucHJlcGFyZUZyYW1lKHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lIC0gdGhpcy5kYXRhLnN0KTtcblxuICAgICAgICBpZiAoZ2x5cGhFbGVtZW50Ll9tZGYpIHtcbiAgICAgICAgICB0aGlzLl9tZGYgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFNWR1RleHRMb3R0aWVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy52YWxpZGF0ZVRleHQoKTtcblxuICAgIGlmICghdGhpcy5kYXRhLnNpbmdsZVNoYXBlIHx8IHRoaXMuX21kZikge1xuICAgICAgdGhpcy50ZXh0QW5pbWF0b3IuZ2V0TWVhc3VyZXModGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGEsIHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnKTtcblxuICAgICAgaWYgKHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnIHx8IHRoaXMudGV4dEFuaW1hdG9yLmxldHRlcnNDaGFuZ2VkRmxhZykge1xuICAgICAgICB0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbGVuO1xuICAgICAgICB2YXIgcmVuZGVyZWRMZXR0ZXJzID0gdGhpcy50ZXh0QW5pbWF0b3IucmVuZGVyZWRMZXR0ZXJzO1xuICAgICAgICB2YXIgbGV0dGVycyA9IHRoaXMudGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLmw7XG4gICAgICAgIGxlbiA9IGxldHRlcnMubGVuZ3RoO1xuICAgICAgICB2YXIgcmVuZGVyZWRMZXR0ZXI7XG4gICAgICAgIHZhciB0ZXh0U3BhbjtcbiAgICAgICAgdmFyIGdseXBoRWxlbWVudDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAoIWxldHRlcnNbaV0ubikge1xuICAgICAgICAgICAgcmVuZGVyZWRMZXR0ZXIgPSByZW5kZXJlZExldHRlcnNbaV07XG4gICAgICAgICAgICB0ZXh0U3BhbiA9IHRoaXMudGV4dFNwYW5zW2ldLnNwYW47XG4gICAgICAgICAgICBnbHlwaEVsZW1lbnQgPSB0aGlzLnRleHRTcGFuc1tpXS5nbHlwaDtcblxuICAgICAgICAgICAgaWYgKGdseXBoRWxlbWVudCkge1xuICAgICAgICAgICAgICBnbHlwaEVsZW1lbnQucmVuZGVyRnJhbWUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyLl9tZGYubSkge1xuICAgICAgICAgICAgICB0ZXh0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIHJlbmRlcmVkTGV0dGVyLm0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIuX21kZi5vKSB7XG4gICAgICAgICAgICAgIHRleHRTcGFuLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScsIHJlbmRlcmVkTGV0dGVyLm8pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIuX21kZi5zdykge1xuICAgICAgICAgICAgICB0ZXh0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIHJlbmRlcmVkTGV0dGVyLnN3KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyLl9tZGYuc2MpIHtcbiAgICAgICAgICAgICAgdGV4dFNwYW4uc2V0QXR0cmlidXRlKCdzdHJva2UnLCByZW5kZXJlZExldHRlci5zYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZW5kZXJlZExldHRlci5fbWRmLmZjKSB7XG4gICAgICAgICAgICAgIHRleHRTcGFuLnNldEF0dHJpYnV0ZSgnZmlsbCcsIHJlbmRlcmVkTGV0dGVyLmZjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gSVNvbGlkRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbSUltYWdlRWxlbWVudF0sIElTb2xpZEVsZW1lbnQpO1xuXG4gIElTb2xpZEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlY3QgPSBjcmVhdGVOUygncmVjdCcpOyAvLy8gL3JlY3Quc3R5bGUud2lkdGggPSB0aGlzLmRhdGEuc3c7XG4gICAgLy8vIC9yZWN0LnN0eWxlLmhlaWdodCA9IHRoaXMuZGF0YS5zaDtcbiAgICAvLy8gL3JlY3Quc3R5bGUuZmlsbCA9IHRoaXMuZGF0YS5zYztcblxuICAgIHJlY3Quc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuZGF0YS5zdyk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuZGF0YS5zaCk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCB0aGlzLmRhdGEuc2MpO1xuICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKHJlY3QpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIE51bGxFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmluaXRGcmFtZSgpO1xuICAgIHRoaXMuaW5pdEJhc2VEYXRhKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICAgIHRoaXMuaW5pdEZyYW1lKCk7XG4gICAgdGhpcy5pbml0VHJhbnNmb3JtKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICAgIHRoaXMuaW5pdEhpZXJhcmNoeSgpO1xuICB9XG5cbiAgTnVsbEVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdHJ1ZSk7XG4gIH07XG5cbiAgTnVsbEVsZW1lbnQucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKCkge307XG5cbiAgTnVsbEVsZW1lbnQucHJvdG90eXBlLmdldEJhc2VFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIE51bGxFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge307XG5cbiAgTnVsbEVsZW1lbnQucHJvdG90eXBlLnNvdXJjZVJlY3RBdFRpbWUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBOdWxsRWxlbWVudC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudF0sIE51bGxFbGVtZW50KTtcblxuICBmdW5jdGlvbiBTVkdSZW5kZXJlckJhc2UoKSB7fVxuXG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZVJlbmRlcmVyXSwgU1ZHUmVuZGVyZXJCYXNlKTtcblxuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLmNyZWF0ZU51bGwgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgTnVsbEVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcblxuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLmNyZWF0ZVNoYXBlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IFNWR1NoYXBlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIFNWR1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlVGV4dCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBTVkdUZXh0TG90dGllRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIFNWR1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlSW1hZ2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgSUltYWdlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIFNWR1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlU29saWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgSVNvbGlkRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIFNWR1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY29uZmlnQW5pbWF0aW9uID0gZnVuY3Rpb24gKGFuaW1EYXRhKSB7XG4gICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgneG1sbnMnLCAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnKTtcbiAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd4bWxuczp4bGluaycsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyk7XG5cbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcudmlld0JveFNpemUpIHtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCB0aGlzLnJlbmRlckNvbmZpZy52aWV3Qm94U2l6ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCAnMCAwICcgKyBhbmltRGF0YS53ICsgJyAnICsgYW5pbURhdGEuaCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnJlbmRlckNvbmZpZy52aWV3Qm94T25seSkge1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBhbmltRGF0YS53KTtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGFuaW1EYXRhLmgpO1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoMCwwLDApJztcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zdHlsZS5jb250ZW50VmlzaWJpbGl0eSA9IHRoaXMucmVuZGVyQ29uZmlnLmNvbnRlbnRWaXNpYmlsaXR5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlbmRlckNvbmZpZy53aWR0aCkge1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLnJlbmRlckNvbmZpZy53aWR0aCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVuZGVyQ29uZmlnLmhlaWdodCkge1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5yZW5kZXJDb25maWcuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcuY2xhc3NOYW1lKSB7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIHRoaXMucmVuZGVyQ29uZmlnLmNsYXNzTmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVuZGVyQ29uZmlnLmlkKSB7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMucmVuZGVyQ29uZmlnLmlkKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcuZm9jdXNhYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2ZvY3VzYWJsZScsIHRoaXMucmVuZGVyQ29uZmlnLmZvY3VzYWJsZSk7XG4gICAgfVxuXG4gICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycsIHRoaXMucmVuZGVyQ29uZmlnLnByZXNlcnZlQXNwZWN0UmF0aW8pOyAvLyB0aGlzLmxheWVyRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoMCwwLDApJztcbiAgICAvLyB0aGlzLmxheWVyRWxlbWVudC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSB0aGlzLmxheWVyRWxlbWVudC5zdHlsZS5tb3pUcmFuc2Zvcm1PcmlnaW4gPSB0aGlzLmxheWVyRWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm1PcmlnaW4gPSB0aGlzLmxheWVyRWxlbWVudC5zdHlsZVsnLXdlYmtpdC10cmFuc2Zvcm0nXSA9IFwiMHB4IDBweCAwcHhcIjtcblxuICAgIHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuc3ZnRWxlbWVudCk7IC8vIE1hc2sgYW5pbWF0aW9uXG5cbiAgICB2YXIgZGVmcyA9IHRoaXMuZ2xvYmFsRGF0YS5kZWZzO1xuICAgIHRoaXMuc2V0dXBHbG9iYWxEYXRhKGFuaW1EYXRhLCBkZWZzKTtcbiAgICB0aGlzLmdsb2JhbERhdGEucHJvZ3Jlc3NpdmVMb2FkID0gdGhpcy5yZW5kZXJDb25maWcucHJvZ3Jlc3NpdmVMb2FkO1xuICAgIHRoaXMuZGF0YSA9IGFuaW1EYXRhO1xuICAgIHZhciBtYXNrRWxlbWVudCA9IGNyZWF0ZU5TKCdjbGlwUGF0aCcpO1xuICAgIHZhciByZWN0ID0gY3JlYXRlTlMoJ3JlY3QnKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBhbmltRGF0YS53KTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgYW5pbURhdGEuaCk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3gnLCAwKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgneScsIDApO1xuICAgIHZhciBtYXNrSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICBtYXNrRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgbWFza0lkKTtcbiAgICBtYXNrRWxlbWVudC5hcHBlbmRDaGlsZChyZWN0KTtcbiAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgbWFza0lkICsgJyknKTtcbiAgICBkZWZzLmFwcGVuZENoaWxkKG1hc2tFbGVtZW50KTtcbiAgICB0aGlzLmxheWVycyA9IGFuaW1EYXRhLmxheWVycztcbiAgICB0aGlzLmVsZW1lbnRzID0gY3JlYXRlU2l6ZWRBcnJheShhbmltRGF0YS5sYXllcnMubGVuZ3RoKTtcbiAgfTtcblxuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlci5pbm5lclRleHQgPSAnJztcbiAgICB9XG5cbiAgICB0aGlzLmxheWVyRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMgPSBudWxsO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmxheWVycyA/IHRoaXMubGF5ZXJzLmxlbmd0aCA6IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldICYmIHRoaXMuZWxlbWVudHNbaV0uZGVzdHJveSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRoaXMuYW5pbWF0aW9uSXRlbSA9IG51bGw7XG4gIH07XG5cbiAgU1ZHUmVuZGVyZXJCYXNlLnByb3RvdHlwZS51cGRhdGVDb250YWluZXJTaXplID0gZnVuY3Rpb24gKCkge307XG5cbiAgU1ZHUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5maW5kSW5kZXhCeUluZCA9IGZ1bmN0aW9uIChpbmQpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IHRoaXMubGF5ZXJzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMubGF5ZXJzW2ldLmluZCA9PT0gaW5kKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLmJ1aWxkSXRlbSA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgaWYgKGVsZW1lbnRzW3Bvc10gfHwgdGhpcy5sYXllcnNbcG9zXS50eSA9PT0gOTkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50c1twb3NdID0gdHJ1ZTtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuY3JlYXRlSXRlbSh0aGlzLmxheWVyc1twb3NdKTtcbiAgICBlbGVtZW50c1twb3NdID0gZWxlbWVudDtcblxuICAgIGlmIChnZXRFeHByZXNzaW9uc1BsdWdpbigpKSB7XG4gICAgICBpZiAodGhpcy5sYXllcnNbcG9zXS50eSA9PT0gMCkge1xuICAgICAgICB0aGlzLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5yZWdpc3RlckNvbXBvc2l0aW9uKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LmluaXRFeHByZXNzaW9ucygpO1xuICAgIH1cblxuICAgIHRoaXMuYXBwZW5kRWxlbWVudEluUG9zKGVsZW1lbnQsIHBvcyk7XG5cbiAgICBpZiAodGhpcy5sYXllcnNbcG9zXS50dCkge1xuICAgICAgdmFyIGVsZW1lbnRJbmRleCA9ICd0cCcgaW4gdGhpcy5sYXllcnNbcG9zXSA/IHRoaXMuZmluZEluZGV4QnlJbmQodGhpcy5sYXllcnNbcG9zXS50cCkgOiBwb3MgLSAxO1xuXG4gICAgICBpZiAoZWxlbWVudEluZGV4ID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5lbGVtZW50c1tlbGVtZW50SW5kZXhdIHx8IHRoaXMuZWxlbWVudHNbZWxlbWVudEluZGV4XSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmJ1aWxkSXRlbShlbGVtZW50SW5kZXgpO1xuICAgICAgICB0aGlzLmFkZFBlbmRpbmdFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1hdHRlRWxlbWVudCA9IGVsZW1lbnRzW2VsZW1lbnRJbmRleF07XG4gICAgICAgIHZhciBtYXR0ZU1hc2sgPSBtYXR0ZUVsZW1lbnQuZ2V0TWF0dGUodGhpcy5sYXllcnNbcG9zXS50dCk7XG4gICAgICAgIGVsZW1lbnQuc2V0TWF0dGUobWF0dGVNYXNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU1ZHUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jaGVja1BlbmRpbmdFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB3aGlsZSAodGhpcy5wZW5kaW5nRWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGVuZGluZ0VsZW1lbnRzLnBvcCgpO1xuICAgICAgZWxlbWVudC5jaGVja1BhcmVudGluZygpO1xuXG4gICAgICBpZiAoZWxlbWVudC5kYXRhLnR0KSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0gPT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50SW5kZXggPSAndHAnIGluIGVsZW1lbnQuZGF0YSA/IHRoaXMuZmluZEluZGV4QnlJbmQoZWxlbWVudC5kYXRhLnRwKSA6IGkgLSAxO1xuICAgICAgICAgICAgdmFyIG1hdHRlRWxlbWVudCA9IHRoaXMuZWxlbWVudHNbZWxlbWVudEluZGV4XTtcbiAgICAgICAgICAgIHZhciBtYXR0ZU1hc2sgPSBtYXR0ZUVsZW1lbnQuZ2V0TWF0dGUodGhpcy5sYXllcnNbaV0udHQpO1xuICAgICAgICAgICAgZWxlbWVudC5zZXRNYXR0ZShtYXR0ZU1hc2spO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFNWR1JlbmRlcmVyQmFzZS5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyZWRGcmFtZSA9PT0gbnVtIHx8IHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG51bSA9PT0gbnVsbCkge1xuICAgICAgbnVtID0gdGhpcy5yZW5kZXJlZEZyYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbmRlcmVkRnJhbWUgPSBudW07XG4gICAgfSAvLyBjb25zb2xlLmxvZygnLS0tLS0tLScpO1xuICAgIC8vIGNvbnNvbGUubG9nKCdGUkFNRSAnLG51bSk7XG5cblxuICAgIHRoaXMuZ2xvYmFsRGF0YS5mcmFtZU51bSA9IG51bTtcbiAgICB0aGlzLmdsb2JhbERhdGEuZnJhbWVJZCArPSAxO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5wcm9qZWN0SW50ZXJmYWNlLmN1cnJlbnRGcmFtZSA9IG51bTtcbiAgICB0aGlzLmdsb2JhbERhdGEuX21kZiA9IGZhbHNlO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XG5cbiAgICBpZiAoIXRoaXMuY29tcGxldGVMYXllcnMpIHtcbiAgICAgIHRoaXMuY2hlY2tMYXllcnMobnVtKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKHRoaXMuY29tcGxldGVMYXllcnMgfHwgdGhpcy5lbGVtZW50c1tpXSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLnByZXBhcmVGcmFtZShudW0gLSB0aGlzLmxheWVyc1tpXS5zdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZ2xvYmFsRGF0YS5fbWRmKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcGxldGVMYXllcnMgfHwgdGhpcy5lbGVtZW50c1tpXSkge1xuICAgICAgICAgIHRoaXMuZWxlbWVudHNbaV0ucmVuZGVyRnJhbWUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLmFwcGVuZEVsZW1lbnRJblBvcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBwb3MpIHtcbiAgICB2YXIgbmV3RWxlbWVudCA9IGVsZW1lbnQuZ2V0QmFzZUVsZW1lbnQoKTtcblxuICAgIGlmICghbmV3RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbmV4dEVsZW1lbnQ7XG5cbiAgICB3aGlsZSAoaSA8IHBvcykge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0gJiYgdGhpcy5lbGVtZW50c1tpXSAhPT0gdHJ1ZSAmJiB0aGlzLmVsZW1lbnRzW2ldLmdldEJhc2VFbGVtZW50KCkpIHtcbiAgICAgICAgbmV4dEVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW2ldLmdldEJhc2VFbGVtZW50KCk7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMTtcbiAgICB9XG5cbiAgICBpZiAobmV4dEVsZW1lbnQpIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50Lmluc2VydEJlZm9yZShuZXdFbGVtZW50LCBuZXh0RWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKG5ld0VsZW1lbnQpO1xuICAgIH1cbiAgfTtcblxuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5sYXllckVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfTtcblxuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5sYXllckVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gIH07XG5cbiAgZnVuY3Rpb24gSUNvbXBFbGVtZW50KCkge31cblxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVET01FbGVtZW50XSwgSUNvbXBFbGVtZW50KTtcblxuICBJQ29tcEVsZW1lbnQucHJvdG90eXBlLmluaXRFbGVtZW50ID0gZnVuY3Rpb24gKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmluaXRGcmFtZSgpO1xuICAgIHRoaXMuaW5pdEJhc2VEYXRhKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICAgIHRoaXMuaW5pdFRyYW5zZm9ybShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgICB0aGlzLmluaXRSZW5kZXJhYmxlKCk7XG4gICAgdGhpcy5pbml0SGllcmFyY2h5KCk7XG4gICAgdGhpcy5pbml0UmVuZGVyZXJFbGVtZW50KCk7XG4gICAgdGhpcy5jcmVhdGVDb250YWluZXJFbGVtZW50cygpO1xuICAgIHRoaXMuY3JlYXRlUmVuZGVyYWJsZUNvbXBvbmVudHMoKTtcblxuICAgIGlmICh0aGlzLmRhdGEueHQgfHwgIWdsb2JhbERhdGEucHJvZ3Jlc3NpdmVMb2FkKSB7XG4gICAgICB0aGlzLmJ1aWxkQWxsSXRlbXMoKTtcbiAgICB9XG5cbiAgICB0aGlzLmhpZGUoKTtcbiAgfTtcbiAgLyogSUNvbXBFbGVtZW50LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKXtcclxuICAgICAgaWYoIXRoaXMuaGlkZGVuKXtcclxuICAgICAgICAgIHRoaXMuaGlkZUVsZW1lbnQoKTtcclxuICAgICAgICAgIHZhciBpLGxlbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xyXG4gICAgICAgICAgZm9yKCBpID0gMDsgaSA8IGxlbjsgaSs9MSApe1xyXG4gICAgICAgICAgICAgIGlmKHRoaXMuZWxlbWVudHNbaV0pe1xyXG4gICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLmhpZGUoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICB9OyAqL1xuXG5cbiAgSUNvbXBFbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWUgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgdGhpcy5wcmVwYXJlUmVuZGVyYWJsZUZyYW1lKG51bSk7XG4gICAgdGhpcy5wcmVwYXJlUHJvcGVydGllcyhudW0sIHRoaXMuaXNJblJhbmdlKTtcblxuICAgIGlmICghdGhpcy5pc0luUmFuZ2UgJiYgIXRoaXMuZGF0YS54dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy50bS5fcGxhY2Vob2xkZXIpIHtcbiAgICAgIHZhciB0aW1lUmVtYXBwZWQgPSB0aGlzLnRtLnY7XG5cbiAgICAgIGlmICh0aW1lUmVtYXBwZWQgPT09IHRoaXMuZGF0YS5vcCkge1xuICAgICAgICB0aW1lUmVtYXBwZWQgPSB0aGlzLmRhdGEub3AgLSAxO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbmRlcmVkRnJhbWUgPSB0aW1lUmVtYXBwZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVuZGVyZWRGcmFtZSA9IG51bSAvIHRoaXMuZGF0YS5zcjtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG5cbiAgICBpZiAoIXRoaXMuY29tcGxldGVMYXllcnMpIHtcbiAgICAgIHRoaXMuY2hlY2tMYXllcnModGhpcy5yZW5kZXJlZEZyYW1lKTtcbiAgICB9IC8vIFRoaXMgaXRlcmF0aW9uIG5lZWRzIHRvIGJlIGJhY2t3YXJkcyBiZWNhdXNlIG9mIGhvdyBleHByZXNzaW9ucyBjb25uZWN0IGJldHdlZW4gZWFjaCBvdGhlclxuXG5cbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKHRoaXMuY29tcGxldGVMYXllcnMgfHwgdGhpcy5lbGVtZW50c1tpXSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLnByZXBhcmVGcmFtZSh0aGlzLnJlbmRlcmVkRnJhbWUgLSB0aGlzLmxheWVyc1tpXS5zdCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0uX21kZikge1xuICAgICAgICAgIHRoaXMuX21kZiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgSUNvbXBFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMubGF5ZXJzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMuY29tcGxldGVMYXllcnMgfHwgdGhpcy5lbGVtZW50c1tpXSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLnJlbmRlckZyYW1lKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIElDb21wRWxlbWVudC5wcm90b3R5cGUuc2V0RWxlbWVudHMgPSBmdW5jdGlvbiAoZWxlbXMpIHtcbiAgICB0aGlzLmVsZW1lbnRzID0gZWxlbXM7XG4gIH07XG5cbiAgSUNvbXBFbGVtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50cztcbiAgfTtcblxuICBJQ29tcEVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3lFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAodGhpcy5lbGVtZW50c1tpXSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgSUNvbXBFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVzdHJveUVsZW1lbnRzKCk7XG4gICAgdGhpcy5kZXN0cm95QmFzZUVsZW1lbnQoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBTVkdDb21wRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy5sYXllcnMgPSBkYXRhLmxheWVycztcbiAgICB0aGlzLnN1cHBvcnRzM2QgPSB0cnVlO1xuICAgIHRoaXMuY29tcGxldGVMYXllcnMgPSBmYWxzZTtcbiAgICB0aGlzLnBlbmRpbmdFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuZWxlbWVudHMgPSB0aGlzLmxheWVycyA/IGNyZWF0ZVNpemVkQXJyYXkodGhpcy5sYXllcnMubGVuZ3RoKSA6IFtdO1xuICAgIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gICAgdGhpcy50bSA9IGRhdGEudG0gPyBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLnRtLCAwLCBnbG9iYWxEYXRhLmZyYW1lUmF0ZSwgdGhpcykgOiB7XG4gICAgICBfcGxhY2Vob2xkZXI6IHRydWVcbiAgICB9O1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtTVkdSZW5kZXJlckJhc2UsIElDb21wRWxlbWVudCwgU1ZHQmFzZUVsZW1lbnRdLCBTVkdDb21wRWxlbWVudCk7XG5cbiAgU1ZHQ29tcEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbXAgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgU1ZHQ29tcEVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcblxuICBmdW5jdGlvbiBTVkdSZW5kZXJlcihhbmltYXRpb25JdGVtLCBjb25maWcpIHtcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0gPSBhbmltYXRpb25JdGVtO1xuICAgIHRoaXMubGF5ZXJzID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlcmVkRnJhbWUgPSAtMTtcbiAgICB0aGlzLnN2Z0VsZW1lbnQgPSBjcmVhdGVOUygnc3ZnJyk7XG4gICAgdmFyIGFyaWFMYWJlbCA9ICcnO1xuXG4gICAgaWYgKGNvbmZpZyAmJiBjb25maWcudGl0bGUpIHtcbiAgICAgIHZhciB0aXRsZUVsZW1lbnQgPSBjcmVhdGVOUygndGl0bGUnKTtcbiAgICAgIHZhciB0aXRsZUlkID0gY3JlYXRlRWxlbWVudElEKCk7XG4gICAgICB0aXRsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRpdGxlSWQpO1xuICAgICAgdGl0bGVFbGVtZW50LnRleHRDb250ZW50ID0gY29uZmlnLnRpdGxlO1xuICAgICAgdGhpcy5zdmdFbGVtZW50LmFwcGVuZENoaWxkKHRpdGxlRWxlbWVudCk7XG4gICAgICBhcmlhTGFiZWwgKz0gdGl0bGVJZDtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5kZXNjcmlwdGlvbikge1xuICAgICAgdmFyIGRlc2NFbGVtZW50ID0gY3JlYXRlTlMoJ2Rlc2MnKTtcbiAgICAgIHZhciBkZXNjSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICAgIGRlc2NFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCBkZXNjSWQpO1xuICAgICAgZGVzY0VsZW1lbnQudGV4dENvbnRlbnQgPSBjb25maWcuZGVzY3JpcHRpb247XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuYXBwZW5kQ2hpbGQoZGVzY0VsZW1lbnQpO1xuICAgICAgYXJpYUxhYmVsICs9ICcgJyArIGRlc2NJZDtcbiAgICB9XG5cbiAgICBpZiAoYXJpYUxhYmVsKSB7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsbGVkYnknLCBhcmlhTGFiZWwpO1xuICAgIH1cblxuICAgIHZhciBkZWZzID0gY3JlYXRlTlMoJ2RlZnMnKTtcbiAgICB0aGlzLnN2Z0VsZW1lbnQuYXBwZW5kQ2hpbGQoZGVmcyk7XG4gICAgdmFyIG1hc2tFbGVtZW50ID0gY3JlYXRlTlMoJ2cnKTtcbiAgICB0aGlzLnN2Z0VsZW1lbnQuYXBwZW5kQ2hpbGQobWFza0VsZW1lbnQpO1xuICAgIHRoaXMubGF5ZXJFbGVtZW50ID0gbWFza0VsZW1lbnQ7XG4gICAgdGhpcy5yZW5kZXJDb25maWcgPSB7XG4gICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBjb25maWcgJiYgY29uZmlnLnByZXNlcnZlQXNwZWN0UmF0aW8gfHwgJ3hNaWRZTWlkIG1lZXQnLFxuICAgICAgaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvOiBjb25maWcgJiYgY29uZmlnLmltYWdlUHJlc2VydmVBc3BlY3RSYXRpbyB8fCAneE1pZFlNaWQgc2xpY2UnLFxuICAgICAgY29udGVudFZpc2liaWxpdHk6IGNvbmZpZyAmJiBjb25maWcuY29udGVudFZpc2liaWxpdHkgfHwgJ3Zpc2libGUnLFxuICAgICAgcHJvZ3Jlc3NpdmVMb2FkOiBjb25maWcgJiYgY29uZmlnLnByb2dyZXNzaXZlTG9hZCB8fCBmYWxzZSxcbiAgICAgIGhpZGVPblRyYW5zcGFyZW50OiAhKGNvbmZpZyAmJiBjb25maWcuaGlkZU9uVHJhbnNwYXJlbnQgPT09IGZhbHNlKSxcbiAgICAgIHZpZXdCb3hPbmx5OiBjb25maWcgJiYgY29uZmlnLnZpZXdCb3hPbmx5IHx8IGZhbHNlLFxuICAgICAgdmlld0JveFNpemU6IGNvbmZpZyAmJiBjb25maWcudmlld0JveFNpemUgfHwgZmFsc2UsXG4gICAgICBjbGFzc05hbWU6IGNvbmZpZyAmJiBjb25maWcuY2xhc3NOYW1lIHx8ICcnLFxuICAgICAgaWQ6IGNvbmZpZyAmJiBjb25maWcuaWQgfHwgJycsXG4gICAgICBmb2N1c2FibGU6IGNvbmZpZyAmJiBjb25maWcuZm9jdXNhYmxlLFxuICAgICAgZmlsdGVyU2l6ZToge1xuICAgICAgICB3aWR0aDogY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLndpZHRoIHx8ICcxMDAlJyxcbiAgICAgICAgaGVpZ2h0OiBjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUuaGVpZ2h0IHx8ICcxMDAlJyxcbiAgICAgICAgeDogY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLnggfHwgJzAlJyxcbiAgICAgICAgeTogY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLnkgfHwgJzAlJ1xuICAgICAgfSxcbiAgICAgIHdpZHRoOiBjb25maWcgJiYgY29uZmlnLndpZHRoLFxuICAgICAgaGVpZ2h0OiBjb25maWcgJiYgY29uZmlnLmhlaWdodCxcbiAgICAgIHJ1bkV4cHJlc3Npb25zOiAhY29uZmlnIHx8IGNvbmZpZy5ydW5FeHByZXNzaW9ucyA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5ydW5FeHByZXNzaW9uc1xuICAgIH07XG4gICAgdGhpcy5nbG9iYWxEYXRhID0ge1xuICAgICAgX21kZjogZmFsc2UsXG4gICAgICBmcmFtZU51bTogLTEsXG4gICAgICBkZWZzOiBkZWZzLFxuICAgICAgcmVuZGVyQ29uZmlnOiB0aGlzLnJlbmRlckNvbmZpZ1xuICAgIH07XG4gICAgdGhpcy5lbGVtZW50cyA9IFtdO1xuICAgIHRoaXMucGVuZGluZ0VsZW1lbnRzID0gW107XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlcmVyVHlwZSA9ICdzdmcnO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtTVkdSZW5kZXJlckJhc2VdLCBTVkdSZW5kZXJlcik7XG5cbiAgU1ZHUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUNvbXAgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgU1ZHQ29tcEVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcblxuICBmdW5jdGlvbiBTaGFwZVRyYW5zZm9ybU1hbmFnZXIoKSB7XG4gICAgdGhpcy5zZXF1ZW5jZXMgPSB7fTtcbiAgICB0aGlzLnNlcXVlbmNlTGlzdCA9IFtdO1xuICAgIHRoaXMudHJhbnNmb3JtX2tleV9jb3VudCA9IDA7XG4gIH1cblxuICBTaGFwZVRyYW5zZm9ybU1hbmFnZXIucHJvdG90eXBlID0ge1xuICAgIGFkZFRyYW5zZm9ybVNlcXVlbmNlOiBmdW5jdGlvbiBhZGRUcmFuc2Zvcm1TZXF1ZW5jZSh0cmFuc2Zvcm1zKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSB0cmFuc2Zvcm1zLmxlbmd0aDtcbiAgICAgIHZhciBrZXkgPSAnXyc7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBrZXkgKz0gdHJhbnNmb3Jtc1tpXS50cmFuc2Zvcm0ua2V5ICsgJ18nO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VxdWVuY2UgPSB0aGlzLnNlcXVlbmNlc1trZXldO1xuXG4gICAgICBpZiAoIXNlcXVlbmNlKSB7XG4gICAgICAgIHNlcXVlbmNlID0ge1xuICAgICAgICAgIHRyYW5zZm9ybXM6IFtdLmNvbmNhdCh0cmFuc2Zvcm1zKSxcbiAgICAgICAgICBmaW5hbFRyYW5zZm9ybTogbmV3IE1hdHJpeCgpLFxuICAgICAgICAgIF9tZGY6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VxdWVuY2VzW2tleV0gPSBzZXF1ZW5jZTtcbiAgICAgICAgdGhpcy5zZXF1ZW5jZUxpc3QucHVzaChzZXF1ZW5jZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXF1ZW5jZTtcbiAgICB9LFxuICAgIHByb2Nlc3NTZXF1ZW5jZTogZnVuY3Rpb24gcHJvY2Vzc1NlcXVlbmNlKHNlcXVlbmNlLCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBsZW4gPSBzZXF1ZW5jZS50cmFuc2Zvcm1zLmxlbmd0aDtcbiAgICAgIHZhciBfbWRmID0gaXNGaXJzdEZyYW1lO1xuXG4gICAgICB3aGlsZSAoaSA8IGxlbiAmJiAhaXNGaXJzdEZyYW1lKSB7XG4gICAgICAgIGlmIChzZXF1ZW5jZS50cmFuc2Zvcm1zW2ldLnRyYW5zZm9ybS5tUHJvcHMuX21kZikge1xuICAgICAgICAgIF9tZGYgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoX21kZikge1xuICAgICAgICBzZXF1ZW5jZS5maW5hbFRyYW5zZm9ybS5yZXNldCgpO1xuXG4gICAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgc2VxdWVuY2UuZmluYWxUcmFuc2Zvcm0ubXVsdGlwbHkoc2VxdWVuY2UudHJhbnNmb3Jtc1tpXS50cmFuc2Zvcm0ubVByb3BzLnYpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlcXVlbmNlLl9tZGYgPSBfbWRmO1xuICAgIH0sXG4gICAgcHJvY2Vzc1NlcXVlbmNlczogZnVuY3Rpb24gcHJvY2Vzc1NlcXVlbmNlcyhpc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuc2VxdWVuY2VMaXN0Lmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc1NlcXVlbmNlKHRoaXMuc2VxdWVuY2VMaXN0W2ldLCBpc0ZpcnN0RnJhbWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0TmV3S2V5OiBmdW5jdGlvbiBnZXROZXdLZXkoKSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybV9rZXlfY291bnQgKz0gMTtcbiAgICAgIHJldHVybiAnXycgKyB0aGlzLnRyYW5zZm9ybV9rZXlfY291bnQ7XG4gICAgfVxuICB9O1xuXG4gIHZhciBsdW1hTG9hZGVyID0gZnVuY3Rpb24gbHVtYUxvYWRlcigpIHtcbiAgICB2YXIgaWQgPSAnX19sb3R0aWVfZWxlbWVudF9sdW1hX2J1ZmZlcic7XG4gICAgdmFyIGx1bWFCdWZmZXIgPSBudWxsO1xuICAgIHZhciBsdW1hQnVmZmVyQ3R4ID0gbnVsbDtcbiAgICB2YXIgc3ZnID0gbnVsbDsgLy8gVGhpcyBhbHRlcm5hdGUgc29sdXRpb24gaGFzIGEgc2xpZ2h0IGRlbGF5IGJlZm9yZSB0aGUgZmlsdGVyIGlzIGFwcGxpZWQsIHJlc3VsdGluZyBpbiBhIGZsaWNrZXIgb24gdGhlIGZpcnN0IGZyYW1lLlxuICAgIC8vIEtlZXBpbmcgdGhpcyBoZXJlIGZvciByZWZlcmVuY2UsIGFuZCBpbiB0aGUgZnV0dXJlLCBpZiBvZmZzY3JlZW4gY2FudmFzIHN1cHBvcnRzIHVybCBmaWx0ZXJzLCB0aGlzIGNhbiBiZSB1c2VkLlxuICAgIC8vIEZvciBub3csIG5laXRoZXIgb2YgdGhlbSB3b3JrIGZvciBvZmZzY3JlZW4gY2FudmFzLCBzbyBjYW52YXMgd29ya2VycyBjYW4ndCBzdXBwb3J0IHRoZSBsdW1hIHRyYWNrIG1hdHRlIG1hc2suXG4gICAgLy8gTmFtaW5nIGl0IHNvbHV0aW9uIDIgdG8gbWFyayB0aGUgZXh0cmEgY29tbWVudCBsaW5lcy5cblxuICAgIC8qXHJcbiAgICB2YXIgc3ZnU3RyaW5nID0gW1xyXG4gICAgICAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+JyxcclxuICAgICAgJzxmaWx0ZXIgaWQ9XCInICsgaWQgKyAnXCI+JyxcclxuICAgICAgJzxmZUNvbG9yTWF0cml4IHR5cGU9XCJtYXRyaXhcIiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9XCJzUkdCXCIgdmFsdWVzPVwiJyxcclxuICAgICAgJzAuMywgMC4zLCAwLjMsIDAsIDAsICcsXHJcbiAgICAgICcwLjMsIDAuMywgMC4zLCAwLCAwLCAnLFxyXG4gICAgICAnMC4zLCAwLjMsIDAuMywgMCwgMCwgJyxcclxuICAgICAgJzAuMywgMC4zLCAwLjMsIDAsIDAnLFxyXG4gICAgICAnXCIvPicsXHJcbiAgICAgICc8L2ZpbHRlcj4nLFxyXG4gICAgICAnPC9zdmc+JyxcclxuICAgIF0uam9pbignJyk7XHJcbiAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtzdmdTdHJpbmddLCB7IHR5cGU6ICdpbWFnZS9zdmcreG1sJyB9KTtcclxuICAgIHZhciB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUx1bWFTdmdGaWx0ZXIoKSB7XG4gICAgICB2YXIgX3N2ZyA9IGNyZWF0ZU5TKCdzdmcnKTtcblxuICAgICAgdmFyIGZpbCA9IGNyZWF0ZU5TKCdmaWx0ZXInKTtcbiAgICAgIHZhciBtYXRyaXggPSBjcmVhdGVOUygnZmVDb2xvck1hdHJpeCcpO1xuICAgICAgZmlsLnNldEF0dHJpYnV0ZSgnaWQnLCBpZCk7XG4gICAgICBtYXRyaXguc2V0QXR0cmlidXRlKCd0eXBlJywgJ21hdHJpeCcpO1xuICAgICAgbWF0cml4LnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ3NSR0InKTtcbiAgICAgIG1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsICcwLjMsIDAuMywgMC4zLCAwLCAwLCAwLjMsIDAuMywgMC4zLCAwLCAwLCAwLjMsIDAuMywgMC4zLCAwLCAwLCAwLjMsIDAuMywgMC4zLCAwLCAwJyk7XG4gICAgICBmaWwuYXBwZW5kQ2hpbGQobWF0cml4KTtcblxuICAgICAgX3N2Zy5hcHBlbmRDaGlsZChmaWwpO1xuXG4gICAgICBfc3ZnLnNldEF0dHJpYnV0ZSgnaWQnLCBpZCArICdfc3ZnJyk7XG5cbiAgICAgIGlmIChmZWF0dXJlU3VwcG9ydC5zdmdMdW1hSGlkZGVuKSB7XG4gICAgICAgIF9zdmcuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9zdmc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZEx1bWEoKSB7XG4gICAgICBpZiAoIWx1bWFCdWZmZXIpIHtcbiAgICAgICAgc3ZnID0gY3JlYXRlTHVtYVN2Z0ZpbHRlcigpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN2Zyk7XG4gICAgICAgIGx1bWFCdWZmZXIgPSBjcmVhdGVUYWcoJ2NhbnZhcycpO1xuICAgICAgICBsdW1hQnVmZmVyQ3R4ID0gbHVtYUJ1ZmZlci5nZXRDb250ZXh0KCcyZCcpOyAvLyBsdW1hQnVmZmVyQ3R4LmZpbHRlciA9IGB1cmwoJyR7dXJsfSNfX2xvdHRpZV9lbGVtZW50X2x1bWFfYnVmZmVyJylgOyAvLyBwYXJ0IG9mIHNvbHV0aW9uIDJcblxuICAgICAgICBsdW1hQnVmZmVyQ3R4LmZpbHRlciA9ICd1cmwoIycgKyBpZCArICcpJztcbiAgICAgICAgbHVtYUJ1ZmZlckN0eC5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICAgIGx1bWFCdWZmZXJDdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0THVtYShjYW52YXMpIHtcbiAgICAgIGlmICghbHVtYUJ1ZmZlcikge1xuICAgICAgICBsb2FkTHVtYSgpO1xuICAgICAgfVxuXG4gICAgICBsdW1hQnVmZmVyLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgbHVtYUJ1ZmZlci5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0OyAvLyBsdW1hQnVmZmVyQ3R4LmZpbHRlciA9IGB1cmwoJyR7dXJsfSNfX2xvdHRpZV9lbGVtZW50X2x1bWFfYnVmZmVyJylgOyAvLyBwYXJ0IG9mIHNvbHV0aW9uIDJcblxuICAgICAgbHVtYUJ1ZmZlckN0eC5maWx0ZXIgPSAndXJsKCMnICsgaWQgKyAnKSc7XG4gICAgICByZXR1cm4gbHVtYUJ1ZmZlcjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbG9hZDogbG9hZEx1bWEsXG4gICAgICBnZXQ6IGdldEx1bWFcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKGZlYXR1cmVTdXBwb3J0Lm9mZnNjcmVlbkNhbnZhcykge1xuICAgICAgcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgfVxuXG4gICAgdmFyIGNhbnZhcyA9IGNyZWF0ZVRhZygnY2FudmFzJyk7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG5cbiAgdmFyIGFzc2V0TG9hZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsb2FkTHVtYUNhbnZhczogbHVtYUxvYWRlci5sb2FkLFxuICAgICAgZ2V0THVtYUNhbnZhczogbHVtYUxvYWRlci5nZXQsXG4gICAgICBjcmVhdGVDYW52YXM6IGNyZWF0ZUNhbnZhc1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgcmVnaXN0ZXJlZEVmZmVjdHMgPSB7fTtcblxuICBmdW5jdGlvbiBDVkVmZmVjdHMoZWxlbSkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBlbGVtLmRhdGEuZWYgPyBlbGVtLmRhdGEuZWYubGVuZ3RoIDogMDtcbiAgICB0aGlzLmZpbHRlcnMgPSBbXTtcbiAgICB2YXIgZmlsdGVyTWFuYWdlcjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgZmlsdGVyTWFuYWdlciA9IG51bGw7XG4gICAgICB2YXIgdHlwZSA9IGVsZW0uZGF0YS5lZltpXS50eTtcblxuICAgICAgaWYgKHJlZ2lzdGVyZWRFZmZlY3RzW3R5cGVdKSB7XG4gICAgICAgIHZhciBFZmZlY3QgPSByZWdpc3RlcmVkRWZmZWN0c1t0eXBlXS5lZmZlY3Q7XG4gICAgICAgIGZpbHRlck1hbmFnZXIgPSBuZXcgRWZmZWN0KGVsZW0uZWZmZWN0c01hbmFnZXIuZWZmZWN0RWxlbWVudHNbaV0sIGVsZW0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlsdGVyTWFuYWdlcikge1xuICAgICAgICB0aGlzLmZpbHRlcnMucHVzaChmaWx0ZXJNYW5hZ2VyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5maWx0ZXJzLmxlbmd0aCkge1xuICAgICAgZWxlbS5hZGRSZW5kZXJhYmxlQ29tcG9uZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIENWRWZmZWN0cy5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoX2lzRmlyc3RGcmFtZSkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmZpbHRlcnMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICB0aGlzLmZpbHRlcnNbaV0ucmVuZGVyRnJhbWUoX2lzRmlyc3RGcmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIENWRWZmZWN0cy5wcm90b3R5cGUuZ2V0RWZmZWN0cyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuZmlsdGVycy5sZW5ndGg7XG4gICAgdmFyIGVmZmVjdHMgPSBbXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMuZmlsdGVyc1tpXS50eXBlID09PSB0eXBlKSB7XG4gICAgICAgIGVmZmVjdHMucHVzaCh0aGlzLmZpbHRlcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlZmZlY3RzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyRWZmZWN0KGlkLCBlZmZlY3QpIHtcbiAgICByZWdpc3RlcmVkRWZmZWN0c1tpZF0gPSB7XG4gICAgICBlZmZlY3Q6IGVmZmVjdFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBDVk1hc2tFbGVtZW50KGRhdGEsIGVsZW1lbnQpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5tYXNrc1Byb3BlcnRpZXMgPSB0aGlzLmRhdGEubWFza3NQcm9wZXJ0aWVzIHx8IFtdO1xuICAgIHRoaXMudmlld0RhdGEgPSBjcmVhdGVTaXplZEFycmF5KHRoaXMubWFza3NQcm9wZXJ0aWVzLmxlbmd0aCk7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMubWFza3NQcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICB2YXIgaGFzTWFza3MgPSBmYWxzZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMubWFza3NQcm9wZXJ0aWVzW2ldLm1vZGUgIT09ICduJykge1xuICAgICAgICBoYXNNYXNrcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudmlld0RhdGFbaV0gPSBTaGFwZVByb3BlcnR5RmFjdG9yeS5nZXRTaGFwZVByb3AodGhpcy5lbGVtZW50LCB0aGlzLm1hc2tzUHJvcGVydGllc1tpXSwgMyk7XG4gICAgfVxuXG4gICAgdGhpcy5oYXNNYXNrcyA9IGhhc01hc2tzO1xuXG4gICAgaWYgKGhhc01hc2tzKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuYWRkUmVuZGVyYWJsZUNvbXBvbmVudCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBDVk1hc2tFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaGFzTWFza3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5lbGVtZW50LmZpbmFsVHJhbnNmb3JtLm1hdDtcbiAgICB2YXIgY3R4ID0gdGhpcy5lbGVtZW50LmNhbnZhc0NvbnRleHQ7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMubWFza3NQcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICB2YXIgcHQ7XG4gICAgdmFyIHB0cztcbiAgICB2YXIgZGF0YTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICh0aGlzLm1hc2tzUHJvcGVydGllc1tpXS5tb2RlICE9PSAnbicpIHtcbiAgICAgICAgaWYgKHRoaXMubWFza3NQcm9wZXJ0aWVzW2ldLmludikge1xuICAgICAgICAgIGN0eC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh0aGlzLmVsZW1lbnQuZ2xvYmFsRGF0YS5jb21wU2l6ZS53LCAwKTtcbiAgICAgICAgICBjdHgubGluZVRvKHRoaXMuZWxlbWVudC5nbG9iYWxEYXRhLmNvbXBTaXplLncsIHRoaXMuZWxlbWVudC5nbG9iYWxEYXRhLmNvbXBTaXplLmgpO1xuICAgICAgICAgIGN0eC5saW5lVG8oMCwgdGhpcy5lbGVtZW50Lmdsb2JhbERhdGEuY29tcFNpemUuaCk7XG4gICAgICAgICAgY3R4LmxpbmVUbygwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEgPSB0aGlzLnZpZXdEYXRhW2ldLnY7XG4gICAgICAgIHB0ID0gdHJhbnNmb3JtLmFwcGx5VG9Qb2ludEFycmF5KGRhdGEudlswXVswXSwgZGF0YS52WzBdWzFdLCAwKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhwdFswXSwgcHRbMV0pO1xuICAgICAgICB2YXIgajtcbiAgICAgICAgdmFyIGpMZW4gPSBkYXRhLl9sZW5ndGg7XG5cbiAgICAgICAgZm9yIChqID0gMTsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgIHB0cyA9IHRyYW5zZm9ybS5hcHBseVRvVHJpcGxlUG9pbnRzKGRhdGEub1tqIC0gMV0sIGRhdGEuaVtqXSwgZGF0YS52W2pdKTtcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhwdHNbMF0sIHB0c1sxXSwgcHRzWzJdLCBwdHNbM10sIHB0c1s0XSwgcHRzWzVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHB0cyA9IHRyYW5zZm9ybS5hcHBseVRvVHJpcGxlUG9pbnRzKGRhdGEub1tqIC0gMV0sIGRhdGEuaVswXSwgZGF0YS52WzBdKTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8ocHRzWzBdLCBwdHNbMV0sIHB0c1syXSwgcHRzWzNdLCBwdHNbNF0sIHB0c1s1XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50Lmdsb2JhbERhdGEucmVuZGVyZXIuc2F2ZSh0cnVlKTtcbiAgICBjdHguY2xpcCgpO1xuICB9O1xuXG4gIENWTWFza0VsZW1lbnQucHJvdG90eXBlLmdldE1hc2tQcm9wZXJ0eSA9IE1hc2tFbGVtZW50LnByb3RvdHlwZS5nZXRNYXNrUHJvcGVydHk7XG5cbiAgQ1ZNYXNrRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICB9O1xuXG4gIGZ1bmN0aW9uIENWQmFzZUVsZW1lbnQoKSB7fVxuXG4gIHZhciBvcGVyYXRpb25zTWFwID0ge1xuICAgIDE6ICdzb3VyY2UtaW4nLFxuICAgIDI6ICdzb3VyY2Utb3V0JyxcbiAgICAzOiAnc291cmNlLWluJyxcbiAgICA0OiAnc291cmNlLW91dCdcbiAgfTtcbiAgQ1ZCYXNlRWxlbWVudC5wcm90b3R5cGUgPSB7XG4gICAgY3JlYXRlRWxlbWVudHM6IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRzKCkge30sXG4gICAgaW5pdFJlbmRlcmVyRWxlbWVudDogZnVuY3Rpb24gaW5pdFJlbmRlcmVyRWxlbWVudCgpIHt9LFxuICAgIGNyZWF0ZUNvbnRhaW5lckVsZW1lbnRzOiBmdW5jdGlvbiBjcmVhdGVDb250YWluZXJFbGVtZW50cygpIHtcbiAgICAgIC8vIElmIHRoZSBsYXllciBpcyBtYXNrZWQgd2Ugd2lsbCB1c2UgdHdvIGJ1ZmZlcnMgdG8gc3RvcmUgZWFjaCBkaWZmZXJlbnQgc3RhdGVzIG9mIHRoZSBkcmF3aW5nXG4gICAgICAvLyBUaGlzIHNvbHV0aW9uIGlzIG5vdCBpZGVhbCBmb3Igc2V2ZXJhbCByZWFzb24uIEJ1dCB1bmZvcnR1bmF0ZWx5LCBiZWNhdXNlIG9mIHRoZSByZWN1cnNpdmVcbiAgICAgIC8vIG5hdHVyZSBvZiB0aGUgcmVuZGVyIHRyZWUsIGl0J3MgdGhlIG9ubHkgc2ltcGxlIHdheSB0byBtYWtlIHN1cmUgb25lIGlubmVyIG1hc2sgZG9lc24ndCBvdmVycmlkZSBhbiBvdXRlciBtYXNrLlxuICAgICAgLy8gVE9ETzogdHJ5IHRvIHJlZHVjZSB0aGUgc2l6ZSBvZiB0aGVzZSBidWZmZXJzIHRvIHRoZSBzaXplIG9mIHRoZSBjb21wb3NpdGlvbiBjb250YW5pbmcgdGhlIGxheWVyXG4gICAgICAvLyBJdCBtaWdodCBiZSBjaGFsbGVuZ2luZyBiZWNhdXNlIHRoZSBsYXllciBtb3N0IGxpa2VseSBpcyB0cmFuc2Zvcm1lZCBpbiBzb21lIHdheVxuICAgICAgaWYgKHRoaXMuZGF0YS50dCA+PSAxKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IFtdO1xuICAgICAgICB2YXIgY2FudmFzQ29udGV4dCA9IHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0O1xuICAgICAgICB2YXIgYnVmZmVyQ2FudmFzID0gYXNzZXRMb2FkZXIuY3JlYXRlQ2FudmFzKGNhbnZhc0NvbnRleHQuY2FudmFzLndpZHRoLCBjYW52YXNDb250ZXh0LmNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB0aGlzLmJ1ZmZlcnMucHVzaChidWZmZXJDYW52YXMpO1xuICAgICAgICB2YXIgYnVmZmVyQ2FudmFzMiA9IGFzc2V0TG9hZGVyLmNyZWF0ZUNhbnZhcyhjYW52YXNDb250ZXh0LmNhbnZhcy53aWR0aCwgY2FudmFzQ29udGV4dC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5idWZmZXJzLnB1c2goYnVmZmVyQ2FudmFzMik7XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YS50dCA+PSAzICYmICFkb2N1bWVudC5faXNQcm94eSkge1xuICAgICAgICAgIGFzc2V0TG9hZGVyLmxvYWRMdW1hQ2FudmFzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5jYW52YXNDb250ZXh0ID0gdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQ7XG4gICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcyA9IHRoaXMuZ2xvYmFsRGF0YS50cmFuc2Zvcm1DYW52YXM7XG4gICAgICB0aGlzLnJlbmRlcmFibGVFZmZlY3RzTWFuYWdlciA9IG5ldyBDVkVmZmVjdHModGhpcyk7XG4gICAgICB0aGlzLnNlYXJjaEVmZmVjdFRyYW5zZm9ybXMoKTtcbiAgICB9LFxuICAgIGNyZWF0ZUNvbnRlbnQ6IGZ1bmN0aW9uIGNyZWF0ZUNvbnRlbnQoKSB7fSxcbiAgICBzZXRCbGVuZE1vZGU6IGZ1bmN0aW9uIHNldEJsZW5kTW9kZSgpIHtcbiAgICAgIHZhciBnbG9iYWxEYXRhID0gdGhpcy5nbG9iYWxEYXRhO1xuXG4gICAgICBpZiAoZ2xvYmFsRGF0YS5ibGVuZE1vZGUgIT09IHRoaXMuZGF0YS5ibSkge1xuICAgICAgICBnbG9iYWxEYXRhLmJsZW5kTW9kZSA9IHRoaXMuZGF0YS5ibTtcbiAgICAgICAgdmFyIGJsZW5kTW9kZVZhbHVlID0gZ2V0QmxlbmRNb2RlKHRoaXMuZGF0YS5ibSk7XG4gICAgICAgIGdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBibGVuZE1vZGVWYWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZVJlbmRlcmFibGVDb21wb25lbnRzOiBmdW5jdGlvbiBjcmVhdGVSZW5kZXJhYmxlQ29tcG9uZW50cygpIHtcbiAgICAgIHRoaXMubWFza01hbmFnZXIgPSBuZXcgQ1ZNYXNrRWxlbWVudCh0aGlzLmRhdGEsIHRoaXMpO1xuICAgICAgdGhpcy50cmFuc2Zvcm1FZmZlY3RzID0gdGhpcy5yZW5kZXJhYmxlRWZmZWN0c01hbmFnZXIuZ2V0RWZmZWN0cyhlZmZlY3RUeXBlcy5UUkFOU0ZPUk1fRUZGRUNUKTtcbiAgICB9LFxuICAgIGhpZGVFbGVtZW50OiBmdW5jdGlvbiBoaWRlRWxlbWVudCgpIHtcbiAgICAgIGlmICghdGhpcy5oaWRkZW4gJiYgKCF0aGlzLmlzSW5SYW5nZSB8fCB0aGlzLmlzVHJhbnNwYXJlbnQpKSB7XG4gICAgICAgIHRoaXMuaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3dFbGVtZW50OiBmdW5jdGlvbiBzaG93RWxlbWVudCgpIHtcbiAgICAgIGlmICh0aGlzLmlzSW5SYW5nZSAmJiAhdGhpcy5pc1RyYW5zcGFyZW50KSB7XG4gICAgICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgICAgIHRoaXMubWFza01hbmFnZXIuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbGVhckNhbnZhczogZnVuY3Rpb24gY2xlYXJDYW52YXMoY2FudmFzQ29udGV4dCkge1xuICAgICAgY2FudmFzQ29udGV4dC5jbGVhclJlY3QodGhpcy50cmFuc2Zvcm1DYW52YXMudHgsIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR5LCB0aGlzLnRyYW5zZm9ybUNhbnZhcy53ICogdGhpcy50cmFuc2Zvcm1DYW52YXMuc3gsIHRoaXMudHJhbnNmb3JtQ2FudmFzLmggKiB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeSk7XG4gICAgfSxcbiAgICBwcmVwYXJlTGF5ZXI6IGZ1bmN0aW9uIHByZXBhcmVMYXllcigpIHtcbiAgICAgIGlmICh0aGlzLmRhdGEudHQgPj0gMSkge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXJzWzBdO1xuICAgICAgICB2YXIgYnVmZmVyQ3R4ID0gYnVmZmVyLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHRoaXMuY2xlYXJDYW52YXMoYnVmZmVyQ3R4KTsgLy8gb24gdGhlIGZpcnN0IGJ1ZmZlciB3ZSBzdG9yZSB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZ2xvYmFsIGRyYXdpbmdcblxuICAgICAgICBidWZmZXJDdHguZHJhd0ltYWdlKHRoaXMuY2FudmFzQ29udGV4dC5jYW52YXMsIDAsIDApOyAvLyBUaGUgbmV4dCBmb3VyIGxpbmVzIGFyZSB0byBjbGVhciB0aGUgY2FudmFzXG4gICAgICAgIC8vIFRPRE86IENoZWNrIGlmIHRoZXJlIGlzIGEgd2F5IHRvIGNsZWFyIHRoZSBjYW52YXMgd2l0aG91dCByZXNldHRpbmcgdGhlIHRyYW5zZm9ybVxuXG4gICAgICAgIHRoaXMuY3VycmVudFRyYW5zZm9ybSA9IHRoaXMuY2FudmFzQ29udGV4dC5nZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgdGhpcy5jbGVhckNhbnZhcyh0aGlzLmNhbnZhc0NvbnRleHQpO1xuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuc2V0VHJhbnNmb3JtKHRoaXMuY3VycmVudFRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBleGl0TGF5ZXI6IGZ1bmN0aW9uIGV4aXRMYXllcigpIHtcbiAgICAgIGlmICh0aGlzLmRhdGEudHQgPj0gMSkge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXJzWzFdOyAvLyBPbiB0aGUgc2Vjb25kIGJ1ZmZlciB3ZSBzdG9yZSB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZ2xvYmFsIGRyYXdpbmdcbiAgICAgICAgLy8gdGhhdCBvbmx5IGNvbnRhaW5zIHRoZSBjb250ZW50IG9mIHRoaXMgbGF5ZXJcbiAgICAgICAgLy8gKGlmIGl0IGlzIGEgY29tcG9zaXRpb24sIGl0IGFsc28gaW5jbHVkZXMgdGhlIG5lc3RlZCBsYXllcnMpXG5cbiAgICAgICAgdmFyIGJ1ZmZlckN0eCA9IGJ1ZmZlci5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB0aGlzLmNsZWFyQ2FudmFzKGJ1ZmZlckN0eCk7XG4gICAgICAgIGJ1ZmZlckN0eC5kcmF3SW1hZ2UodGhpcy5jYW52YXNDb250ZXh0LmNhbnZhcywgMCwgMCk7IC8vIFdlIGNsZWFyIHRoZSBjYW52YXMgYWdhaW5cblxuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICB0aGlzLmNsZWFyQ2FudmFzKHRoaXMuY2FudmFzQ29udGV4dCk7XG4gICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5zZXRUcmFuc2Zvcm0odGhpcy5jdXJyZW50VHJhbnNmb3JtKTsgLy8gV2UgZHJhdyB0aGUgbWFza1xuXG4gICAgICAgIHZhciBtYXNrID0gdGhpcy5jb21wLmdldEVsZW1lbnRCeUlkKCd0cCcgaW4gdGhpcy5kYXRhID8gdGhpcy5kYXRhLnRwIDogdGhpcy5kYXRhLmluZCAtIDEpO1xuICAgICAgICBtYXNrLnJlbmRlckZyYW1lKHRydWUpOyAvLyBXZSBkcmF3IHRoZSBzZWNvbmQgYnVmZmVyICh0aGF0IGNvbnRhaW5zIHRoZSBjb250ZW50IG9mIHRoaXMgbGF5ZXIpXG5cbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTsgLy8gSWYgdGhlIG1hc2sgaXMgYSBMdW1hIG1hdHRlLCB3ZSBuZWVkIHRvIGRvIHR3byBleHRyYSBwYWludGluZyBvcGVyYXRpb25zXG4gICAgICAgIC8vIHRoZSBfaXNQcm94eSBjaGVjayBpcyB0byBhdm9pZCBkcmF3aW5nIGEgZmFrZSBjYW52YXMgaW4gd29ya2VycyB0aGF0IHdpbGwgdGhyb3cgYW4gZXJyb3JcblxuICAgICAgICBpZiAodGhpcy5kYXRhLnR0ID49IDMgJiYgIWRvY3VtZW50Ll9pc1Byb3h5KSB7XG4gICAgICAgICAgLy8gV2UgY29weSB0aGUgcGFpbnRlZCBtYXNrIHRvIGEgYnVmZmVyIHRoYXQgaGFzIGEgY29sb3IgbWF0cml4IGZpbHRlciBhcHBsaWVkIHRvIGl0XG4gICAgICAgICAgLy8gdGhhdCBhcHBsaWVzIHRoZSByZ2IgdmFsdWVzIHRvIHRoZSBhbHBoYSBjaGFubmVsXG4gICAgICAgICAgdmFyIGx1bWFCdWZmZXIgPSBhc3NldExvYWRlci5nZXRMdW1hQ2FudmFzKHRoaXMuY2FudmFzQ29udGV4dC5jYW52YXMpO1xuICAgICAgICAgIHZhciBsdW1hQnVmZmVyQ3R4ID0gbHVtYUJ1ZmZlci5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgIGx1bWFCdWZmZXJDdHguZHJhd0ltYWdlKHRoaXMuY2FudmFzQ29udGV4dC5jYW52YXMsIDAsIDApO1xuICAgICAgICAgIHRoaXMuY2xlYXJDYW52YXModGhpcy5jYW52YXNDb250ZXh0KTsgLy8gd2UgcmVwYWludCB0aGUgY29udGV4dCB3aXRoIHRoZSBtYXNrIGFwcGxpZWQgdG8gaXRcblxuICAgICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5kcmF3SW1hZ2UobHVtYUJ1ZmZlciwgMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gb3BlcmF0aW9uc01hcFt0aGlzLmRhdGEudHRdO1xuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuZHJhd0ltYWdlKGJ1ZmZlciwgMCwgMCk7IC8vIFdlIGZpbmFsbHkgZHJhdyB0aGUgZmlyc3QgYnVmZmVyICh0aGF0IGNvbnRhaW5zIHRoZSBjb250ZW50IG9mIHRoZSBnbG9iYWwgZHJhd2luZylcbiAgICAgICAgLy8gV2UgdXNlIGRlc3RpbmF0aW9uLW92ZXIgdG8gZHJhdyB0aGUgZ2xvYmFsIGRyYXdpbmcgYmVsb3cgdGhlIGN1cnJlbnQgbGF5ZXJcblxuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW92ZXInO1xuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuZHJhd0ltYWdlKHRoaXMuYnVmZmVyc1swXSwgMCwgMCk7XG4gICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5zZXRUcmFuc2Zvcm0odGhpcy5jdXJyZW50VHJhbnNmb3JtKTsgLy8gV2UgcmVzZXQgdGhlIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiB0byBzb3VyY2Utb3ZlciwgdGhlIHN0YW5kYXJkIHR5cGUgb2Ygb3BlcmF0aW9uXG5cbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXJGcmFtZTogZnVuY3Rpb24gcmVuZGVyRnJhbWUoZm9yY2VSZW5kZXIpIHtcbiAgICAgIGlmICh0aGlzLmhpZGRlbiB8fCB0aGlzLmRhdGEuaGQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kYXRhLnRkID09PSAxICYmICFmb3JjZVJlbmRlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVuZGVyVHJhbnNmb3JtKCk7XG4gICAgICB0aGlzLnJlbmRlclJlbmRlcmFibGUoKTtcbiAgICAgIHRoaXMucmVuZGVyTG9jYWxUcmFuc2Zvcm0oKTtcbiAgICAgIHRoaXMuc2V0QmxlbmRNb2RlKCk7XG4gICAgICB2YXIgZm9yY2VSZWFsU3RhY2sgPSB0aGlzLmRhdGEudHkgPT09IDA7XG4gICAgICB0aGlzLnByZXBhcmVMYXllcigpO1xuICAgICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyLnNhdmUoZm9yY2VSZWFsU3RhY2spO1xuICAgICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyLmN0eFRyYW5zZm9ybSh0aGlzLmZpbmFsVHJhbnNmb3JtLmxvY2FsTWF0LnByb3BzKTtcbiAgICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5jdHhPcGFjaXR5KHRoaXMuZmluYWxUcmFuc2Zvcm0ubG9jYWxPcGFjaXR5KTtcbiAgICAgIHRoaXMucmVuZGVySW5uZXJDb250ZW50KCk7XG4gICAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIucmVzdG9yZShmb3JjZVJlYWxTdGFjayk7XG4gICAgICB0aGlzLmV4aXRMYXllcigpO1xuXG4gICAgICBpZiAodGhpcy5tYXNrTWFuYWdlci5oYXNNYXNrcykge1xuICAgICAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIucmVzdG9yZSh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2lzRmlyc3RGcmFtZSkge1xuICAgICAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHQgPSBudWxsO1xuICAgICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICAgIHRoaXMuZ2xvYmFsRGF0YSA9IG51bGw7XG4gICAgICB0aGlzLm1hc2tNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB9LFxuICAgIG1IZWxwZXI6IG5ldyBNYXRyaXgoKVxuICB9O1xuICBDVkJhc2VFbGVtZW50LnByb3RvdHlwZS5oaWRlID0gQ1ZCYXNlRWxlbWVudC5wcm90b3R5cGUuaGlkZUVsZW1lbnQ7XG4gIENWQmFzZUVsZW1lbnQucHJvdG90eXBlLnNob3cgPSBDVkJhc2VFbGVtZW50LnByb3RvdHlwZS5zaG93RWxlbWVudDtcblxuICBmdW5jdGlvbiBDVlNoYXBlRGF0YShlbGVtZW50LCBkYXRhLCBzdHlsZXMsIHRyYW5zZm9ybXNNYW5hZ2VyKSB7XG4gICAgdGhpcy5zdHlsZWRTaGFwZXMgPSBbXTtcbiAgICB0aGlzLnRyID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xuICAgIHZhciB0eSA9IDQ7XG5cbiAgICBpZiAoZGF0YS50eSA9PT0gJ3JjJykge1xuICAgICAgdHkgPSA1O1xuICAgIH0gZWxzZSBpZiAoZGF0YS50eSA9PT0gJ2VsJykge1xuICAgICAgdHkgPSA2O1xuICAgIH0gZWxzZSBpZiAoZGF0YS50eSA9PT0gJ3NyJykge1xuICAgICAgdHkgPSA3O1xuICAgIH1cblxuICAgIHRoaXMuc2ggPSBTaGFwZVByb3BlcnR5RmFjdG9yeS5nZXRTaGFwZVByb3AoZWxlbWVudCwgZGF0YSwgdHksIGVsZW1lbnQpO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBzdHlsZXMubGVuZ3RoO1xuICAgIHZhciBzdHlsZWRTaGFwZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKCFzdHlsZXNbaV0uY2xvc2VkKSB7XG4gICAgICAgIHN0eWxlZFNoYXBlID0ge1xuICAgICAgICAgIHRyYW5zZm9ybXM6IHRyYW5zZm9ybXNNYW5hZ2VyLmFkZFRyYW5zZm9ybVNlcXVlbmNlKHN0eWxlc1tpXS50cmFuc2Zvcm1zKSxcbiAgICAgICAgICB0ck5vZGVzOiBbXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0eWxlZFNoYXBlcy5wdXNoKHN0eWxlZFNoYXBlKTtcbiAgICAgICAgc3R5bGVzW2ldLmVsZW1lbnRzLnB1c2goc3R5bGVkU2hhcGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIENWU2hhcGVEYXRhLnByb3RvdHlwZS5zZXRBc0FuaW1hdGVkID0gU1ZHU2hhcGVEYXRhLnByb3RvdHlwZS5zZXRBc0FuaW1hdGVkO1xuXG4gIGZ1bmN0aW9uIENWU2hhcGVFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLnNoYXBlcyA9IFtdO1xuICAgIHRoaXMuc2hhcGVzRGF0YSA9IGRhdGEuc2hhcGVzO1xuICAgIHRoaXMuc3R5bGVzTGlzdCA9IFtdO1xuICAgIHRoaXMuaXRlbXNEYXRhID0gW107XG4gICAgdGhpcy5wcmV2Vmlld0RhdGEgPSBbXTtcbiAgICB0aGlzLnNoYXBlTW9kaWZpZXJzID0gW107XG4gICAgdGhpcy5wcm9jZXNzZWRFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMudHJhbnNmb3Jtc01hbmFnZXIgPSBuZXcgU2hhcGVUcmFuc2Zvcm1NYW5hZ2VyKCk7XG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIENWQmFzZUVsZW1lbnQsIElTaGFwZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZUVsZW1lbnRdLCBDVlNoYXBlRWxlbWVudCk7XG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudCA9IFJlbmRlcmFibGVET01FbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudDtcbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnRyYW5zZm9ybUhlbHBlciA9IHtcbiAgICBvcGFjaXR5OiAxLFxuICAgIF9vcE1kZjogZmFsc2VcbiAgfTtcbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmRhc2hSZXNldHRlciA9IFtdO1xuXG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2VhcmNoU2hhcGVzKHRoaXMuc2hhcGVzRGF0YSwgdGhpcy5pdGVtc0RhdGEsIHRoaXMucHJldlZpZXdEYXRhLCB0cnVlLCBbXSk7XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVN0eWxlRWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhLCB0cmFuc2Zvcm1zKSB7XG4gICAgdmFyIHN0eWxlRWxlbSA9IHtcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICB0eXBlOiBkYXRhLnR5LFxuICAgICAgcHJlVHJhbnNmb3JtczogdGhpcy50cmFuc2Zvcm1zTWFuYWdlci5hZGRUcmFuc2Zvcm1TZXF1ZW5jZSh0cmFuc2Zvcm1zKSxcbiAgICAgIHRyYW5zZm9ybXM6IFtdLFxuICAgICAgZWxlbWVudHM6IFtdLFxuICAgICAgY2xvc2VkOiBkYXRhLmhkID09PSB0cnVlXG4gICAgfTtcbiAgICB2YXIgZWxlbWVudERhdGEgPSB7fTtcblxuICAgIGlmIChkYXRhLnR5ID09PSAnZmwnIHx8IGRhdGEudHkgPT09ICdzdCcpIHtcbiAgICAgIGVsZW1lbnREYXRhLmMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLmMsIDEsIDI1NSwgdGhpcyk7XG5cbiAgICAgIGlmICghZWxlbWVudERhdGEuYy5rKSB7XG4gICAgICAgIHN0eWxlRWxlbS5jbyA9ICdyZ2IoJyArIGJtRmxvb3IoZWxlbWVudERhdGEuYy52WzBdKSArICcsJyArIGJtRmxvb3IoZWxlbWVudERhdGEuYy52WzFdKSArICcsJyArIGJtRmxvb3IoZWxlbWVudERhdGEuYy52WzJdKSArICcpJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdnZicgfHwgZGF0YS50eSA9PT0gJ2dzJykge1xuICAgICAgZWxlbWVudERhdGEucyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEucywgMSwgbnVsbCwgdGhpcyk7XG4gICAgICBlbGVtZW50RGF0YS5lID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS5lLCAxLCBudWxsLCB0aGlzKTtcbiAgICAgIGVsZW1lbnREYXRhLmggPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLmggfHwge1xuICAgICAgICBrOiAwXG4gICAgICB9LCAwLCAwLjAxLCB0aGlzKTtcbiAgICAgIGVsZW1lbnREYXRhLmEgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLmEgfHwge1xuICAgICAgICBrOiAwXG4gICAgICB9LCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xuICAgICAgZWxlbWVudERhdGEuZyA9IG5ldyBHcmFkaWVudFByb3BlcnR5KHRoaXMsIGRhdGEuZywgdGhpcyk7XG4gICAgfVxuXG4gICAgZWxlbWVudERhdGEubyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEubywgMCwgMC4wMSwgdGhpcyk7XG5cbiAgICBpZiAoZGF0YS50eSA9PT0gJ3N0JyB8fCBkYXRhLnR5ID09PSAnZ3MnKSB7XG4gICAgICBzdHlsZUVsZW0ubGMgPSBsaW5lQ2FwRW51bVtkYXRhLmxjIHx8IDJdO1xuICAgICAgc3R5bGVFbGVtLmxqID0gbGluZUpvaW5FbnVtW2RhdGEubGogfHwgMl07XG5cbiAgICAgIGlmIChkYXRhLmxqID09IDEpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICAgICAgc3R5bGVFbGVtLm1sID0gZGF0YS5tbDtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudERhdGEudyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEudywgMCwgbnVsbCwgdGhpcyk7XG5cbiAgICAgIGlmICghZWxlbWVudERhdGEudy5rKSB7XG4gICAgICAgIHN0eWxlRWxlbS53aSA9IGVsZW1lbnREYXRhLncudjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuZCkge1xuICAgICAgICB2YXIgZCA9IG5ldyBEYXNoUHJvcGVydHkodGhpcywgZGF0YS5kLCAnY2FudmFzJywgdGhpcyk7XG4gICAgICAgIGVsZW1lbnREYXRhLmQgPSBkO1xuXG4gICAgICAgIGlmICghZWxlbWVudERhdGEuZC5rKSB7XG4gICAgICAgICAgc3R5bGVFbGVtLmRhID0gZWxlbWVudERhdGEuZC5kYXNoQXJyYXk7XG4gICAgICAgICAgc3R5bGVFbGVtW1wiZG9cIl0gPSBlbGVtZW50RGF0YS5kLmRhc2hvZmZzZXRbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVFbGVtLnIgPSBkYXRhLnIgPT09IDIgPyAnZXZlbm9kZCcgOiAnbm9uemVybyc7XG4gICAgfVxuXG4gICAgdGhpcy5zdHlsZXNMaXN0LnB1c2goc3R5bGVFbGVtKTtcbiAgICBlbGVtZW50RGF0YS5zdHlsZSA9IHN0eWxlRWxlbTtcbiAgICByZXR1cm4gZWxlbWVudERhdGE7XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUdyb3VwRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlbWVudERhdGEgPSB7XG4gICAgICBpdDogW10sXG4gICAgICBwcmV2Vmlld0RhdGE6IFtdXG4gICAgfTtcbiAgICByZXR1cm4gZWxlbWVudERhdGE7XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVRyYW5zZm9ybUVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBlbGVtZW50RGF0YSA9IHtcbiAgICAgIHRyYW5zZm9ybToge1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICBfb3BNZGY6IGZhbHNlLFxuICAgICAgICBrZXk6IHRoaXMudHJhbnNmb3Jtc01hbmFnZXIuZ2V0TmV3S2V5KCksXG4gICAgICAgIG9wOiBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLm8sIDAsIDAuMDEsIHRoaXMpLFxuICAgICAgICBtUHJvcHM6IFRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeS5nZXRUcmFuc2Zvcm1Qcm9wZXJ0eSh0aGlzLCBkYXRhLCB0aGlzKVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGVsZW1lbnREYXRhO1xuICB9O1xuXG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTaGFwZUVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBlbGVtZW50RGF0YSA9IG5ldyBDVlNoYXBlRGF0YSh0aGlzLCBkYXRhLCB0aGlzLnN0eWxlc0xpc3QsIHRoaXMudHJhbnNmb3Jtc01hbmFnZXIpO1xuICAgIHRoaXMuc2hhcGVzLnB1c2goZWxlbWVudERhdGEpO1xuICAgIHRoaXMuYWRkU2hhcGVUb01vZGlmaWVycyhlbGVtZW50RGF0YSk7XG4gICAgcmV0dXJuIGVsZW1lbnREYXRhO1xuICB9O1xuXG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZWxvYWRTaGFwZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5pdGVtc0RhdGEubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICB0aGlzLnByZXZWaWV3RGF0YVtpXSA9IHRoaXMuaXRlbXNEYXRhW2ldO1xuICAgIH1cblxuICAgIHRoaXMuc2VhcmNoU2hhcGVzKHRoaXMuc2hhcGVzRGF0YSwgdGhpcy5pdGVtc0RhdGEsIHRoaXMucHJldlZpZXdEYXRhLCB0cnVlLCBbXSk7XG4gICAgbGVuID0gdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV0uZ2V0VmFsdWUoKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlck1vZGlmaWVycygpO1xuICAgIHRoaXMudHJhbnNmb3Jtc01hbmFnZXIucHJvY2Vzc1NlcXVlbmNlcyh0aGlzLl9pc0ZpcnN0RnJhbWUpO1xuICB9O1xuXG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5hZGRUcmFuc2Zvcm1Ub1N0eWxlTGlzdCA9IGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5zdHlsZXNMaXN0Lmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlc0xpc3RbaV0uY2xvc2VkKSB7XG4gICAgICAgIHRoaXMuc3R5bGVzTGlzdFtpXS50cmFuc2Zvcm1zLnB1c2godHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbW92ZVRyYW5zZm9ybUZyb21TdHlsZUxpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuc3R5bGVzTGlzdC5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICghdGhpcy5zdHlsZXNMaXN0W2ldLmNsb3NlZCkge1xuICAgICAgICB0aGlzLnN0eWxlc0xpc3RbaV0udHJhbnNmb3Jtcy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNsb3NlU3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlcykge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBzdHlsZXMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBzdHlsZXNbaV0uY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnNlYXJjaFNoYXBlcyA9IGZ1bmN0aW9uIChhcnIsIGl0ZW1zRGF0YSwgcHJldlZpZXdEYXRhLCBzaG91bGRSZW5kZXIsIHRyYW5zZm9ybXMpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW47XG4gICAgdmFyIG93blN0eWxlcyA9IFtdO1xuICAgIHZhciBvd25Nb2RpZmllcnMgPSBbXTtcbiAgICB2YXIgcHJvY2Vzc2VkUG9zO1xuICAgIHZhciBtb2RpZmllcjtcbiAgICB2YXIgY3VycmVudFRyYW5zZm9ybTtcbiAgICB2YXIgb3duVHJhbnNmb3JtcyA9IFtdLmNvbmNhdCh0cmFuc2Zvcm1zKTtcblxuICAgIGZvciAoaSA9IGxlbjsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIHByb2Nlc3NlZFBvcyA9IHRoaXMuc2VhcmNoUHJvY2Vzc2VkRWxlbWVudChhcnJbaV0pO1xuXG4gICAgICBpZiAoIXByb2Nlc3NlZFBvcykge1xuICAgICAgICBhcnJbaV0uX3Nob3VsZFJlbmRlciA9IHNob3VsZFJlbmRlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1zRGF0YVtpXSA9IHByZXZWaWV3RGF0YVtwcm9jZXNzZWRQb3MgLSAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFycltpXS50eSA9PT0gJ2ZsJyB8fCBhcnJbaV0udHkgPT09ICdzdCcgfHwgYXJyW2ldLnR5ID09PSAnZ2YnIHx8IGFycltpXS50eSA9PT0gJ2dzJykge1xuICAgICAgICBpZiAoIXByb2Nlc3NlZFBvcykge1xuICAgICAgICAgIGl0ZW1zRGF0YVtpXSA9IHRoaXMuY3JlYXRlU3R5bGVFbGVtZW50KGFycltpXSwgb3duVHJhbnNmb3Jtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbXNEYXRhW2ldLnN0eWxlLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3duU3R5bGVzLnB1c2goaXRlbXNEYXRhW2ldLnN0eWxlKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAnZ3InKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgaXRlbXNEYXRhW2ldID0gdGhpcy5jcmVhdGVHcm91cEVsZW1lbnQoYXJyW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBqTGVuID0gaXRlbXNEYXRhW2ldLml0Lmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGl0ZW1zRGF0YVtpXS5wcmV2Vmlld0RhdGFbal0gPSBpdGVtc0RhdGFbaV0uaXRbal07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZWFyY2hTaGFwZXMoYXJyW2ldLml0LCBpdGVtc0RhdGFbaV0uaXQsIGl0ZW1zRGF0YVtpXS5wcmV2Vmlld0RhdGEsIHNob3VsZFJlbmRlciwgb3duVHJhbnNmb3Jtcyk7XG4gICAgICB9IGVsc2UgaWYgKGFycltpXS50eSA9PT0gJ3RyJykge1xuICAgICAgICBpZiAoIXByb2Nlc3NlZFBvcykge1xuICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm0gPSB0aGlzLmNyZWF0ZVRyYW5zZm9ybUVsZW1lbnQoYXJyW2ldKTtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0gPSBjdXJyZW50VHJhbnNmb3JtO1xuICAgICAgICB9XG5cbiAgICAgICAgb3duVHJhbnNmb3Jtcy5wdXNoKGl0ZW1zRGF0YVtpXSk7XG4gICAgICAgIHRoaXMuYWRkVHJhbnNmb3JtVG9TdHlsZUxpc3QoaXRlbXNEYXRhW2ldKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAnc2gnIHx8IGFycltpXS50eSA9PT0gJ3JjJyB8fCBhcnJbaV0udHkgPT09ICdlbCcgfHwgYXJyW2ldLnR5ID09PSAnc3InKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgaXRlbXNEYXRhW2ldID0gdGhpcy5jcmVhdGVTaGFwZUVsZW1lbnQoYXJyW2ldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICd0bScgfHwgYXJyW2ldLnR5ID09PSAncmQnIHx8IGFycltpXS50eSA9PT0gJ3BiJyB8fCBhcnJbaV0udHkgPT09ICd6eicgfHwgYXJyW2ldLnR5ID09PSAnb3AnKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgbW9kaWZpZXIgPSBTaGFwZU1vZGlmaWVycy5nZXRNb2RpZmllcihhcnJbaV0udHkpO1xuICAgICAgICAgIG1vZGlmaWVyLmluaXQodGhpcywgYXJyW2ldKTtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0gPSBtb2RpZmllcjtcbiAgICAgICAgICB0aGlzLnNoYXBlTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGlmaWVyID0gaXRlbXNEYXRhW2ldO1xuICAgICAgICAgIG1vZGlmaWVyLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3duTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICdycCcpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcbiAgICAgICAgICBtb2RpZmllciA9IFNoYXBlTW9kaWZpZXJzLmdldE1vZGlmaWVyKGFycltpXS50eSk7XG4gICAgICAgICAgaXRlbXNEYXRhW2ldID0gbW9kaWZpZXI7XG4gICAgICAgICAgbW9kaWZpZXIuaW5pdCh0aGlzLCBhcnIsIGksIGl0ZW1zRGF0YSk7XG4gICAgICAgICAgdGhpcy5zaGFwZU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgICAgICAgICBzaG91bGRSZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RpZmllciA9IGl0ZW1zRGF0YVtpXTtcbiAgICAgICAgICBtb2RpZmllci5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3duTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFkZFByb2Nlc3NlZEVsZW1lbnQoYXJyW2ldLCBpICsgMSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmVUcmFuc2Zvcm1Gcm9tU3R5bGVMaXN0KCk7XG4gICAgdGhpcy5jbG9zZVN0eWxlcyhvd25TdHlsZXMpO1xuICAgIGxlbiA9IG93bk1vZGlmaWVycy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIG93bk1vZGlmaWVyc1tpXS5jbG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudHJhbnNmb3JtSGVscGVyLm9wYWNpdHkgPSAxO1xuICAgIHRoaXMudHJhbnNmb3JtSGVscGVyLl9vcE1kZiA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyTW9kaWZpZXJzKCk7XG4gICAgdGhpcy50cmFuc2Zvcm1zTWFuYWdlci5wcm9jZXNzU2VxdWVuY2VzKHRoaXMuX2lzRmlyc3RGcmFtZSk7XG4gICAgdGhpcy5yZW5kZXJTaGFwZSh0aGlzLnRyYW5zZm9ybUhlbHBlciwgdGhpcy5zaGFwZXNEYXRhLCB0aGlzLml0ZW1zRGF0YSwgdHJ1ZSk7XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlclNoYXBlVHJhbnNmb3JtID0gZnVuY3Rpb24gKHBhcmVudFRyYW5zZm9ybSwgZ3JvdXBUcmFuc2Zvcm0pIHtcbiAgICBpZiAocGFyZW50VHJhbnNmb3JtLl9vcE1kZiB8fCBncm91cFRyYW5zZm9ybS5vcC5fbWRmIHx8IHRoaXMuX2lzRmlyc3RGcmFtZSkge1xuICAgICAgZ3JvdXBUcmFuc2Zvcm0ub3BhY2l0eSA9IHBhcmVudFRyYW5zZm9ybS5vcGFjaXR5O1xuICAgICAgZ3JvdXBUcmFuc2Zvcm0ub3BhY2l0eSAqPSBncm91cFRyYW5zZm9ybS5vcC52O1xuICAgICAgZ3JvdXBUcmFuc2Zvcm0uX29wTWRmID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmRyYXdMYXllciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5zdHlsZXNMaXN0Lmxlbmd0aDtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgaztcbiAgICB2YXIga0xlbjtcbiAgICB2YXIgZWxlbXM7XG4gICAgdmFyIG5vZGVzO1xuICAgIHZhciByZW5kZXJlciA9IHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlcjtcbiAgICB2YXIgY3R4ID0gdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQ7XG4gICAgdmFyIHR5cGU7XG4gICAgdmFyIGN1cnJlbnRTdHlsZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgY3VycmVudFN0eWxlID0gdGhpcy5zdHlsZXNMaXN0W2ldO1xuICAgICAgdHlwZSA9IGN1cnJlbnRTdHlsZS50eXBlOyAvLyBTa2lwcGluZyBzdHlsZSB3aGVuXG4gICAgICAvLyBTdHJva2Ugd2lkdGggZXF1YWxzIDBcbiAgICAgIC8vIHN0eWxlIHNob3VsZCBub3QgYmUgcmVuZGVyZWQgKGV4dHJhIHVudXNlZCByZXBlYXRlcnMpXG4gICAgICAvLyBjdXJyZW50IG9wYWNpdHkgZXF1YWxzIDBcbiAgICAgIC8vIGdsb2JhbCBvcGFjaXR5IGVxdWFscyAwXG5cbiAgICAgIGlmICghKCh0eXBlID09PSAnc3QnIHx8IHR5cGUgPT09ICdncycpICYmIGN1cnJlbnRTdHlsZS53aSA9PT0gMCB8fCAhY3VycmVudFN0eWxlLmRhdGEuX3Nob3VsZFJlbmRlciB8fCBjdXJyZW50U3R5bGUuY29PcCA9PT0gMCB8fCB0aGlzLmdsb2JhbERhdGEuY3VycmVudEdsb2JhbEFscGhhID09PSAwKSkge1xuICAgICAgICByZW5kZXJlci5zYXZlKCk7XG4gICAgICAgIGVsZW1zID0gY3VycmVudFN0eWxlLmVsZW1lbnRzO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnc3QnIHx8IHR5cGUgPT09ICdncycpIHtcbiAgICAgICAgICByZW5kZXJlci5jdHhTdHJva2VTdHlsZSh0eXBlID09PSAnc3QnID8gY3VycmVudFN0eWxlLmNvIDogY3VycmVudFN0eWxlLmdyZCk7IC8vIGN0eC5zdHJva2VTdHlsZSA9IHR5cGUgPT09ICdzdCcgPyBjdXJyZW50U3R5bGUuY28gOiBjdXJyZW50U3R5bGUuZ3JkO1xuXG4gICAgICAgICAgcmVuZGVyZXIuY3R4TGluZVdpZHRoKGN1cnJlbnRTdHlsZS53aSk7IC8vIGN0eC5saW5lV2lkdGggPSBjdXJyZW50U3R5bGUud2k7XG5cbiAgICAgICAgICByZW5kZXJlci5jdHhMaW5lQ2FwKGN1cnJlbnRTdHlsZS5sYyk7IC8vIGN0eC5saW5lQ2FwID0gY3VycmVudFN0eWxlLmxjO1xuXG4gICAgICAgICAgcmVuZGVyZXIuY3R4TGluZUpvaW4oY3VycmVudFN0eWxlLmxqKTsgLy8gY3R4LmxpbmVKb2luID0gY3VycmVudFN0eWxlLmxqO1xuXG4gICAgICAgICAgcmVuZGVyZXIuY3R4TWl0ZXJMaW1pdChjdXJyZW50U3R5bGUubWwgfHwgMCk7IC8vIGN0eC5taXRlckxpbWl0ID0gY3VycmVudFN0eWxlLm1sIHx8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVuZGVyZXIuY3R4RmlsbFN0eWxlKHR5cGUgPT09ICdmbCcgPyBjdXJyZW50U3R5bGUuY28gOiBjdXJyZW50U3R5bGUuZ3JkKTsgLy8gY3R4LmZpbGxTdHlsZSA9IHR5cGUgPT09ICdmbCcgPyBjdXJyZW50U3R5bGUuY28gOiBjdXJyZW50U3R5bGUuZ3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyZXIuY3R4T3BhY2l0eShjdXJyZW50U3R5bGUuY29PcCk7XG5cbiAgICAgICAgaWYgKHR5cGUgIT09ICdzdCcgJiYgdHlwZSAhPT0gJ2dzJykge1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlcmVyLmN0eFRyYW5zZm9ybShjdXJyZW50U3R5bGUucHJlVHJhbnNmb3Jtcy5maW5hbFRyYW5zZm9ybS5wcm9wcyk7XG4gICAgICAgIGpMZW4gPSBlbGVtcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgIGlmICh0eXBlID09PSAnc3QnIHx8IHR5cGUgPT09ICdncycpIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdHlsZS5kYSkge1xuICAgICAgICAgICAgICBjdHguc2V0TGluZURhc2goY3VycmVudFN0eWxlLmRhKTtcbiAgICAgICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gY3VycmVudFN0eWxlW1wiZG9cIl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9kZXMgPSBlbGVtc1tqXS50ck5vZGVzO1xuICAgICAgICAgIGtMZW4gPSBub2Rlcy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwga0xlbjsgayArPSAxKSB7XG4gICAgICAgICAgICBpZiAobm9kZXNba10udCA9PT0gJ20nKSB7XG4gICAgICAgICAgICAgIGN0eC5tb3ZlVG8obm9kZXNba10ucFswXSwgbm9kZXNba10ucFsxXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGVzW2tdLnQgPT09ICdjJykge1xuICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhub2Rlc1trXS5wdHNbMF0sIG5vZGVzW2tdLnB0c1sxXSwgbm9kZXNba10ucHRzWzJdLCBub2Rlc1trXS5wdHNbM10sIG5vZGVzW2tdLnB0c1s0XSwgbm9kZXNba10ucHRzWzVdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ3N0JyB8fCB0eXBlID09PSAnZ3MnKSB7XG4gICAgICAgICAgICAvLyBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICByZW5kZXJlci5jdHhTdHJva2UoKTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdHlsZS5kYSkge1xuICAgICAgICAgICAgICBjdHguc2V0TGluZURhc2godGhpcy5kYXNoUmVzZXR0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlICE9PSAnc3QnICYmIHR5cGUgIT09ICdncycpIHtcbiAgICAgICAgICAvLyBjdHguZmlsbChjdXJyZW50U3R5bGUucik7XG4gICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyLmN0eEZpbGwoY3VycmVudFN0eWxlLnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyZXIucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyU2hhcGUgPSBmdW5jdGlvbiAocGFyZW50VHJhbnNmb3JtLCBpdGVtcywgZGF0YSwgaXNNYWluKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgdmFyIGdyb3VwVHJhbnNmb3JtO1xuICAgIGdyb3VwVHJhbnNmb3JtID0gcGFyZW50VHJhbnNmb3JtO1xuXG4gICAgZm9yIChpID0gbGVuOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKGl0ZW1zW2ldLnR5ID09PSAndHInKSB7XG4gICAgICAgIGdyb3VwVHJhbnNmb3JtID0gZGF0YVtpXS50cmFuc2Zvcm07XG4gICAgICAgIHRoaXMucmVuZGVyU2hhcGVUcmFuc2Zvcm0ocGFyZW50VHJhbnNmb3JtLCBncm91cFRyYW5zZm9ybSk7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW1zW2ldLnR5ID09PSAnc2gnIHx8IGl0ZW1zW2ldLnR5ID09PSAnZWwnIHx8IGl0ZW1zW2ldLnR5ID09PSAncmMnIHx8IGl0ZW1zW2ldLnR5ID09PSAnc3InKSB7XG4gICAgICAgIHRoaXMucmVuZGVyUGF0aChpdGVtc1tpXSwgZGF0YVtpXSk7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW1zW2ldLnR5ID09PSAnZmwnKSB7XG4gICAgICAgIHRoaXMucmVuZGVyRmlsbChpdGVtc1tpXSwgZGF0YVtpXSwgZ3JvdXBUcmFuc2Zvcm0pO1xuICAgICAgfSBlbHNlIGlmIChpdGVtc1tpXS50eSA9PT0gJ3N0Jykge1xuICAgICAgICB0aGlzLnJlbmRlclN0cm9rZShpdGVtc1tpXSwgZGF0YVtpXSwgZ3JvdXBUcmFuc2Zvcm0pO1xuICAgICAgfSBlbHNlIGlmIChpdGVtc1tpXS50eSA9PT0gJ2dmJyB8fCBpdGVtc1tpXS50eSA9PT0gJ2dzJykge1xuICAgICAgICB0aGlzLnJlbmRlckdyYWRpZW50RmlsbChpdGVtc1tpXSwgZGF0YVtpXSwgZ3JvdXBUcmFuc2Zvcm0pO1xuICAgICAgfSBlbHNlIGlmIChpdGVtc1tpXS50eSA9PT0gJ2dyJykge1xuICAgICAgICB0aGlzLnJlbmRlclNoYXBlKGdyb3VwVHJhbnNmb3JtLCBpdGVtc1tpXS5pdCwgZGF0YVtpXS5pdCk7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW1zW2ldLnR5ID09PSAndG0nKSB7Ly9cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNNYWluKSB7XG4gICAgICB0aGlzLmRyYXdMYXllcigpO1xuICAgIH1cbiAgfTtcblxuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyU3R5bGVkU2hhcGUgPSBmdW5jdGlvbiAoc3R5bGVkU2hhcGUsIHNoYXBlKSB7XG4gICAgaWYgKHRoaXMuX2lzRmlyc3RGcmFtZSB8fCBzaGFwZS5fbWRmIHx8IHN0eWxlZFNoYXBlLnRyYW5zZm9ybXMuX21kZikge1xuICAgICAgdmFyIHNoYXBlTm9kZXMgPSBzdHlsZWRTaGFwZS50ck5vZGVzO1xuICAgICAgdmFyIHBhdGhzID0gc2hhcGUucGF0aHM7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW47XG4gICAgICB2YXIgajtcbiAgICAgIHZhciBqTGVuID0gcGF0aHMuX2xlbmd0aDtcbiAgICAgIHNoYXBlTm9kZXMubGVuZ3RoID0gMDtcbiAgICAgIHZhciBncm91cFRyYW5zZm9ybU1hdCA9IHN0eWxlZFNoYXBlLnRyYW5zZm9ybXMuZmluYWxUcmFuc2Zvcm07XG5cbiAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgdmFyIHBhdGhOb2RlcyA9IHBhdGhzLnNoYXBlc1tqXTtcblxuICAgICAgICBpZiAocGF0aE5vZGVzICYmIHBhdGhOb2Rlcy52KSB7XG4gICAgICAgICAgbGVuID0gcGF0aE5vZGVzLl9sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChpID09PSAxKSB7XG4gICAgICAgICAgICAgIHNoYXBlTm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgdDogJ20nLFxuICAgICAgICAgICAgICAgIHA6IGdyb3VwVHJhbnNmb3JtTWF0LmFwcGx5VG9Qb2ludEFycmF5KHBhdGhOb2Rlcy52WzBdWzBdLCBwYXRoTm9kZXMudlswXVsxXSwgMClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNoYXBlTm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgIHQ6ICdjJyxcbiAgICAgICAgICAgICAgcHRzOiBncm91cFRyYW5zZm9ybU1hdC5hcHBseVRvVHJpcGxlUG9pbnRzKHBhdGhOb2Rlcy5vW2kgLSAxXSwgcGF0aE5vZGVzLmlbaV0sIHBhdGhOb2Rlcy52W2ldKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICAgICAgc2hhcGVOb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdDogJ20nLFxuICAgICAgICAgICAgICBwOiBncm91cFRyYW5zZm9ybU1hdC5hcHBseVRvUG9pbnRBcnJheShwYXRoTm9kZXMudlswXVswXSwgcGF0aE5vZGVzLnZbMF1bMV0sIDApXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGF0aE5vZGVzLmMgJiYgbGVuKSB7XG4gICAgICAgICAgICBzaGFwZU5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICB0OiAnYycsXG4gICAgICAgICAgICAgIHB0czogZ3JvdXBUcmFuc2Zvcm1NYXQuYXBwbHlUb1RyaXBsZVBvaW50cyhwYXRoTm9kZXMub1tpIC0gMV0sIHBhdGhOb2Rlcy5pWzBdLCBwYXRoTm9kZXMudlswXSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2hhcGVOb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdDogJ3onXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3R5bGVkU2hhcGUudHJOb2RlcyA9IHNoYXBlTm9kZXM7XG4gICAgfVxuICB9O1xuXG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJQYXRoID0gZnVuY3Rpb24gKHBhdGhEYXRhLCBpdGVtRGF0YSkge1xuICAgIGlmIChwYXRoRGF0YS5oZCAhPT0gdHJ1ZSAmJiBwYXRoRGF0YS5fc2hvdWxkUmVuZGVyKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBpdGVtRGF0YS5zdHlsZWRTaGFwZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJTdHlsZWRTaGFwZShpdGVtRGF0YS5zdHlsZWRTaGFwZXNbaV0sIGl0ZW1EYXRhLnNoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlckZpbGwgPSBmdW5jdGlvbiAoc3R5bGVEYXRhLCBpdGVtRGF0YSwgZ3JvdXBUcmFuc2Zvcm0pIHtcbiAgICB2YXIgc3R5bGVFbGVtID0gaXRlbURhdGEuc3R5bGU7XG5cbiAgICBpZiAoaXRlbURhdGEuYy5fbWRmIHx8IHRoaXMuX2lzRmlyc3RGcmFtZSkge1xuICAgICAgc3R5bGVFbGVtLmNvID0gJ3JnYignICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMF0pICsgJywnICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMV0pICsgJywnICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMl0pICsgJyknO1xuICAgIH1cblxuICAgIGlmIChpdGVtRGF0YS5vLl9tZGYgfHwgZ3JvdXBUcmFuc2Zvcm0uX29wTWRmIHx8IHRoaXMuX2lzRmlyc3RGcmFtZSkge1xuICAgICAgc3R5bGVFbGVtLmNvT3AgPSBpdGVtRGF0YS5vLnYgKiBncm91cFRyYW5zZm9ybS5vcGFjaXR5O1xuICAgIH1cbiAgfTtcblxuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyR3JhZGllbnRGaWxsID0gZnVuY3Rpb24gKHN0eWxlRGF0YSwgaXRlbURhdGEsIGdyb3VwVHJhbnNmb3JtKSB7XG4gICAgdmFyIHN0eWxlRWxlbSA9IGl0ZW1EYXRhLnN0eWxlO1xuICAgIHZhciBncmQ7XG5cbiAgICBpZiAoIXN0eWxlRWxlbS5ncmQgfHwgaXRlbURhdGEuZy5fbWRmIHx8IGl0ZW1EYXRhLnMuX21kZiB8fCBpdGVtRGF0YS5lLl9tZGYgfHwgc3R5bGVEYXRhLnQgIT09IDEgJiYgKGl0ZW1EYXRhLmguX21kZiB8fCBpdGVtRGF0YS5hLl9tZGYpKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQ7XG4gICAgICB2YXIgcHQxID0gaXRlbURhdGEucy52O1xuICAgICAgdmFyIHB0MiA9IGl0ZW1EYXRhLmUudjtcblxuICAgICAgaWYgKHN0eWxlRGF0YS50ID09PSAxKSB7XG4gICAgICAgIGdyZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChwdDFbMF0sIHB0MVsxXSwgcHQyWzBdLCBwdDJbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJhZCA9IE1hdGguc3FydChNYXRoLnBvdyhwdDFbMF0gLSBwdDJbMF0sIDIpICsgTWF0aC5wb3cocHQxWzFdIC0gcHQyWzFdLCAyKSk7XG4gICAgICAgIHZhciBhbmcgPSBNYXRoLmF0YW4yKHB0MlsxXSAtIHB0MVsxXSwgcHQyWzBdIC0gcHQxWzBdKTtcbiAgICAgICAgdmFyIHBlcmNlbnQgPSBpdGVtRGF0YS5oLnY7XG5cbiAgICAgICAgaWYgKHBlcmNlbnQgPj0gMSkge1xuICAgICAgICAgIHBlcmNlbnQgPSAwLjk5O1xuICAgICAgICB9IGVsc2UgaWYgKHBlcmNlbnQgPD0gLTEpIHtcbiAgICAgICAgICBwZXJjZW50ID0gLTAuOTk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlzdCA9IHJhZCAqIHBlcmNlbnQ7XG4gICAgICAgIHZhciB4ID0gTWF0aC5jb3MoYW5nICsgaXRlbURhdGEuYS52KSAqIGRpc3QgKyBwdDFbMF07XG4gICAgICAgIHZhciB5ID0gTWF0aC5zaW4oYW5nICsgaXRlbURhdGEuYS52KSAqIGRpc3QgKyBwdDFbMV07XG4gICAgICAgIGdyZCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCh4LCB5LCAwLCBwdDFbMF0sIHB0MVsxXSwgcmFkKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gc3R5bGVEYXRhLmcucDtcbiAgICAgIHZhciBjVmFsdWVzID0gaXRlbURhdGEuZy5jO1xuICAgICAgdmFyIG9wYWNpdHkgPSAxO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGl0ZW1EYXRhLmcuX2hhc09wYWNpdHkgJiYgaXRlbURhdGEuZy5fY29sbGFwc2FibGUpIHtcbiAgICAgICAgICBvcGFjaXR5ID0gaXRlbURhdGEuZy5vW2kgKiAyICsgMV07XG4gICAgICAgIH1cblxuICAgICAgICBncmQuYWRkQ29sb3JTdG9wKGNWYWx1ZXNbaSAqIDRdIC8gMTAwLCAncmdiYSgnICsgY1ZhbHVlc1tpICogNCArIDFdICsgJywnICsgY1ZhbHVlc1tpICogNCArIDJdICsgJywnICsgY1ZhbHVlc1tpICogNCArIDNdICsgJywnICsgb3BhY2l0eSArICcpJyk7XG4gICAgICB9XG5cbiAgICAgIHN0eWxlRWxlbS5ncmQgPSBncmQ7XG4gICAgfVxuXG4gICAgc3R5bGVFbGVtLmNvT3AgPSBpdGVtRGF0YS5vLnYgKiBncm91cFRyYW5zZm9ybS5vcGFjaXR5O1xuICB9O1xuXG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJTdHJva2UgPSBmdW5jdGlvbiAoc3R5bGVEYXRhLCBpdGVtRGF0YSwgZ3JvdXBUcmFuc2Zvcm0pIHtcbiAgICB2YXIgc3R5bGVFbGVtID0gaXRlbURhdGEuc3R5bGU7XG4gICAgdmFyIGQgPSBpdGVtRGF0YS5kO1xuXG4gICAgaWYgKGQgJiYgKGQuX21kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWUpKSB7XG4gICAgICBzdHlsZUVsZW0uZGEgPSBkLmRhc2hBcnJheTtcbiAgICAgIHN0eWxlRWxlbVtcImRvXCJdID0gZC5kYXNob2Zmc2V0WzBdO1xuICAgIH1cblxuICAgIGlmIChpdGVtRGF0YS5jLl9tZGYgfHwgdGhpcy5faXNGaXJzdEZyYW1lKSB7XG4gICAgICBzdHlsZUVsZW0uY28gPSAncmdiKCcgKyBibUZsb29yKGl0ZW1EYXRhLmMudlswXSkgKyAnLCcgKyBibUZsb29yKGl0ZW1EYXRhLmMudlsxXSkgKyAnLCcgKyBibUZsb29yKGl0ZW1EYXRhLmMudlsyXSkgKyAnKSc7XG4gICAgfVxuXG4gICAgaWYgKGl0ZW1EYXRhLm8uX21kZiB8fCBncm91cFRyYW5zZm9ybS5fb3BNZGYgfHwgdGhpcy5faXNGaXJzdEZyYW1lKSB7XG4gICAgICBzdHlsZUVsZW0uY29PcCA9IGl0ZW1EYXRhLm8udiAqIGdyb3VwVHJhbnNmb3JtLm9wYWNpdHk7XG4gICAgfVxuXG4gICAgaWYgKGl0ZW1EYXRhLncuX21kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHN0eWxlRWxlbS53aSA9IGl0ZW1EYXRhLncudjtcbiAgICB9XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zaGFwZXNEYXRhID0gbnVsbDtcbiAgICB0aGlzLmdsb2JhbERhdGEgPSBudWxsO1xuICAgIHRoaXMuY2FudmFzQ29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5zdHlsZXNMaXN0Lmxlbmd0aCA9IDA7XG4gICAgdGhpcy5pdGVtc0RhdGEubGVuZ3RoID0gMDtcbiAgfTtcblxuICBmdW5jdGlvbiBDVlRleHRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLnRleHRTcGFucyA9IFtdO1xuICAgIHRoaXMueU9mZnNldCA9IDA7XG4gICAgdGhpcy5maWxsQ29sb3JBbmltID0gZmFsc2U7XG4gICAgdGhpcy5zdHJva2VDb2xvckFuaW0gPSBmYWxzZTtcbiAgICB0aGlzLnN0cm9rZVdpZHRoQW5pbSA9IGZhbHNlO1xuICAgIHRoaXMuc3Ryb2tlID0gZmFsc2U7XG4gICAgdGhpcy5maWxsID0gZmFsc2U7XG4gICAgdGhpcy5qdXN0aWZ5T2Zmc2V0ID0gMDtcbiAgICB0aGlzLmN1cnJlbnRSZW5kZXIgPSBudWxsO1xuICAgIHRoaXMucmVuZGVyVHlwZSA9ICdjYW52YXMnO1xuICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgZmlsbDogJ3JnYmEoMCwwLDAsMCknLFxuICAgICAgc3Ryb2tlOiAncmdiYSgwLDAsMCwwKScsXG4gICAgICBzV2lkdGg6IDAsXG4gICAgICBmVmFsdWU6ICcnXG4gICAgfTtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgQ1ZCYXNlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRWxlbWVudCwgSVRleHRFbGVtZW50XSwgQ1ZUZXh0RWxlbWVudCk7XG4gIENWVGV4dEVsZW1lbnQucHJvdG90eXBlLnRIZWxwZXIgPSBjcmVhdGVUYWcoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJyk7XG5cbiAgQ1ZUZXh0RWxlbWVudC5wcm90b3R5cGUuYnVpbGROZXdUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkb2N1bWVudERhdGEgPSB0aGlzLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YTtcbiAgICB0aGlzLnJlbmRlcmVkTGV0dGVycyA9IGNyZWF0ZVNpemVkQXJyYXkoZG9jdW1lbnREYXRhLmwgPyBkb2N1bWVudERhdGEubC5sZW5ndGggOiAwKTtcbiAgICB2YXIgaGFzRmlsbCA9IGZhbHNlO1xuXG4gICAgaWYgKGRvY3VtZW50RGF0YS5mYykge1xuICAgICAgaGFzRmlsbCA9IHRydWU7XG4gICAgICB0aGlzLnZhbHVlcy5maWxsID0gdGhpcy5idWlsZENvbG9yKGRvY3VtZW50RGF0YS5mYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmFsdWVzLmZpbGwgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgfVxuXG4gICAgdGhpcy5maWxsID0gaGFzRmlsbDtcbiAgICB2YXIgaGFzU3Ryb2tlID0gZmFsc2U7XG5cbiAgICBpZiAoZG9jdW1lbnREYXRhLnNjKSB7XG4gICAgICBoYXNTdHJva2UgPSB0cnVlO1xuICAgICAgdGhpcy52YWx1ZXMuc3Ryb2tlID0gdGhpcy5idWlsZENvbG9yKGRvY3VtZW50RGF0YS5zYyk7XG4gICAgICB0aGlzLnZhbHVlcy5zV2lkdGggPSBkb2N1bWVudERhdGEuc3c7XG4gICAgfVxuXG4gICAgdmFyIGZvbnREYXRhID0gdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldEZvbnRCeU5hbWUoZG9jdW1lbnREYXRhLmYpO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG4gICAgdmFyIGxldHRlcnMgPSBkb2N1bWVudERhdGEubDtcbiAgICB2YXIgbWF0cml4SGVscGVyID0gdGhpcy5tSGVscGVyO1xuICAgIHRoaXMuc3Ryb2tlID0gaGFzU3Ryb2tlO1xuICAgIHRoaXMudmFsdWVzLmZWYWx1ZSA9IGRvY3VtZW50RGF0YS5maW5hbFNpemUgKyAncHggJyArIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKS5mRmFtaWx5O1xuICAgIGxlbiA9IGRvY3VtZW50RGF0YS5maW5hbFRleHQubGVuZ3RoOyAvLyB0aGlzLnRIZWxwZXIuZm9udCA9IHRoaXMudmFsdWVzLmZWYWx1ZTtcblxuICAgIHZhciBjaGFyRGF0YTtcbiAgICB2YXIgc2hhcGVEYXRhO1xuICAgIHZhciBrO1xuICAgIHZhciBrTGVuO1xuICAgIHZhciBzaGFwZXM7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW47XG4gICAgdmFyIHBhdGhOb2RlcztcbiAgICB2YXIgY29tbWFuZHM7XG4gICAgdmFyIHBhdGhBcnI7XG4gICAgdmFyIHNpbmdsZVNoYXBlID0gdGhpcy5kYXRhLnNpbmdsZVNoYXBlO1xuICAgIHZhciB0cmFja2luZ09mZnNldCA9IGRvY3VtZW50RGF0YS50ciAqIDAuMDAxICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZTtcbiAgICB2YXIgeFBvcyA9IDA7XG4gICAgdmFyIHlQb3MgPSAwO1xuICAgIHZhciBmaXJzdExpbmUgPSB0cnVlO1xuICAgIHZhciBjbnQgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBjaGFyRGF0YSA9IHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRDaGFyRGF0YShkb2N1bWVudERhdGEuZmluYWxUZXh0W2ldLCBmb250RGF0YS5mU3R5bGUsIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKS5mRmFtaWx5KTtcbiAgICAgIHNoYXBlRGF0YSA9IGNoYXJEYXRhICYmIGNoYXJEYXRhLmRhdGEgfHwge307XG4gICAgICBtYXRyaXhIZWxwZXIucmVzZXQoKTtcblxuICAgICAgaWYgKHNpbmdsZVNoYXBlICYmIGxldHRlcnNbaV0ubikge1xuICAgICAgICB4UG9zID0gLXRyYWNraW5nT2Zmc2V0O1xuICAgICAgICB5UG9zICs9IGRvY3VtZW50RGF0YS55T2Zmc2V0O1xuICAgICAgICB5UG9zICs9IGZpcnN0TGluZSA/IDEgOiAwO1xuICAgICAgICBmaXJzdExpbmUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgc2hhcGVzID0gc2hhcGVEYXRhLnNoYXBlcyA/IHNoYXBlRGF0YS5zaGFwZXNbMF0uaXQgOiBbXTtcbiAgICAgIGpMZW4gPSBzaGFwZXMubGVuZ3RoO1xuICAgICAgbWF0cml4SGVscGVyLnNjYWxlKGRvY3VtZW50RGF0YS5maW5hbFNpemUgLyAxMDAsIGRvY3VtZW50RGF0YS5maW5hbFNpemUgLyAxMDApO1xuXG4gICAgICBpZiAoc2luZ2xlU2hhcGUpIHtcbiAgICAgICAgdGhpcy5hcHBseVRleHRQcm9wZXJ0aWVzVG9NYXRyaXgoZG9jdW1lbnREYXRhLCBtYXRyaXhIZWxwZXIsIGxldHRlcnNbaV0ubGluZSwgeFBvcywgeVBvcyk7XG4gICAgICB9XG5cbiAgICAgIGNvbW1hbmRzID0gY3JlYXRlU2l6ZWRBcnJheShqTGVuIC0gMSk7XG4gICAgICB2YXIgY29tbWFuZHNDb3VudGVyID0gMDtcblxuICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICBpZiAoc2hhcGVzW2pdLnR5ID09PSAnc2gnKSB7XG4gICAgICAgICAga0xlbiA9IHNoYXBlc1tqXS5rcy5rLmkubGVuZ3RoO1xuICAgICAgICAgIHBhdGhOb2RlcyA9IHNoYXBlc1tqXS5rcy5rO1xuICAgICAgICAgIHBhdGhBcnIgPSBbXTtcblxuICAgICAgICAgIGZvciAoayA9IDE7IGsgPCBrTGVuOyBrICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChrID09PSAxKSB7XG4gICAgICAgICAgICAgIHBhdGhBcnIucHVzaChtYXRyaXhIZWxwZXIuYXBwbHlUb1gocGF0aE5vZGVzLnZbMF1bMF0sIHBhdGhOb2Rlcy52WzBdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9ZKHBhdGhOb2Rlcy52WzBdWzBdLCBwYXRoTm9kZXMudlswXVsxXSwgMCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXRoQXJyLnB1c2gobWF0cml4SGVscGVyLmFwcGx5VG9YKHBhdGhOb2Rlcy5vW2sgLSAxXVswXSwgcGF0aE5vZGVzLm9bayAtIDFdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9ZKHBhdGhOb2Rlcy5vW2sgLSAxXVswXSwgcGF0aE5vZGVzLm9bayAtIDFdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9YKHBhdGhOb2Rlcy5pW2tdWzBdLCBwYXRoTm9kZXMuaVtrXVsxXSwgMCksIG1hdHJpeEhlbHBlci5hcHBseVRvWShwYXRoTm9kZXMuaVtrXVswXSwgcGF0aE5vZGVzLmlba11bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1gocGF0aE5vZGVzLnZba11bMF0sIHBhdGhOb2Rlcy52W2tdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9ZKHBhdGhOb2Rlcy52W2tdWzBdLCBwYXRoTm9kZXMudltrXVsxXSwgMCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhdGhBcnIucHVzaChtYXRyaXhIZWxwZXIuYXBwbHlUb1gocGF0aE5vZGVzLm9bayAtIDFdWzBdLCBwYXRoTm9kZXMub1trIC0gMV1bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1kocGF0aE5vZGVzLm9bayAtIDFdWzBdLCBwYXRoTm9kZXMub1trIC0gMV1bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1gocGF0aE5vZGVzLmlbMF1bMF0sIHBhdGhOb2Rlcy5pWzBdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9ZKHBhdGhOb2Rlcy5pWzBdWzBdLCBwYXRoTm9kZXMuaVswXVsxXSwgMCksIG1hdHJpeEhlbHBlci5hcHBseVRvWChwYXRoTm9kZXMudlswXVswXSwgcGF0aE5vZGVzLnZbMF1bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1kocGF0aE5vZGVzLnZbMF1bMF0sIHBhdGhOb2Rlcy52WzBdWzFdLCAwKSk7XG4gICAgICAgICAgY29tbWFuZHNbY29tbWFuZHNDb3VudGVyXSA9IHBhdGhBcnI7XG4gICAgICAgICAgY29tbWFuZHNDb3VudGVyICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNpbmdsZVNoYXBlKSB7XG4gICAgICAgIHhQb3MgKz0gbGV0dGVyc1tpXS5sO1xuICAgICAgICB4UG9zICs9IHRyYWNraW5nT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50ZXh0U3BhbnNbY250XSkge1xuICAgICAgICB0aGlzLnRleHRTcGFuc1tjbnRdLmVsZW0gPSBjb21tYW5kcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGV4dFNwYW5zW2NudF0gPSB7XG4gICAgICAgICAgZWxlbTogY29tbWFuZHNcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY250ICs9IDE7XG4gICAgfVxuICB9O1xuXG4gIENWVGV4dEVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnZhbGlkYXRlVGV4dCgpO1xuICAgIHZhciBjdHggPSB0aGlzLmNhbnZhc0NvbnRleHQ7XG4gICAgY3R4LmZvbnQgPSB0aGlzLnZhbHVlcy5mVmFsdWU7XG4gICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyLmN0eExpbmVDYXAoJ2J1dHQnKTsgLy8gY3R4LmxpbmVDYXAgPSAnYnV0dCc7XG5cbiAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIuY3R4TGluZUpvaW4oJ21pdGVyJyk7IC8vIGN0eC5saW5lSm9pbiA9ICdtaXRlcic7XG5cbiAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIuY3R4TWl0ZXJMaW1pdCg0KTsgLy8gY3R4Lm1pdGVyTGltaXQgPSA0O1xuXG4gICAgaWYgKCF0aGlzLmRhdGEuc2luZ2xlU2hhcGUpIHtcbiAgICAgIHRoaXMudGV4dEFuaW1hdG9yLmdldE1lYXN1cmVzKHRoaXMudGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLCB0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZyk7XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgaztcbiAgICB2YXIga0xlbjtcbiAgICB2YXIgcmVuZGVyZWRMZXR0ZXJzID0gdGhpcy50ZXh0QW5pbWF0b3IucmVuZGVyZWRMZXR0ZXJzO1xuICAgIHZhciBsZXR0ZXJzID0gdGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGEubDtcbiAgICBsZW4gPSBsZXR0ZXJzLmxlbmd0aDtcbiAgICB2YXIgcmVuZGVyZWRMZXR0ZXI7XG4gICAgdmFyIGxhc3RGaWxsID0gbnVsbDtcbiAgICB2YXIgbGFzdFN0cm9rZSA9IG51bGw7XG4gICAgdmFyIGxhc3RTdHJva2VXID0gbnVsbDtcbiAgICB2YXIgY29tbWFuZHM7XG4gICAgdmFyIHBhdGhBcnI7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAoIWxldHRlcnNbaV0ubikge1xuICAgICAgICByZW5kZXJlZExldHRlciA9IHJlbmRlcmVkTGV0dGVyc1tpXTtcblxuICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIpIHtcbiAgICAgICAgICByZW5kZXJlci5zYXZlKCk7XG4gICAgICAgICAgcmVuZGVyZXIuY3R4VHJhbnNmb3JtKHJlbmRlcmVkTGV0dGVyLnApO1xuICAgICAgICAgIHJlbmRlcmVyLmN0eE9wYWNpdHkocmVuZGVyZWRMZXR0ZXIubyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5maWxsKSB7XG4gICAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyICYmIHJlbmRlcmVkTGV0dGVyLmZjKSB7XG4gICAgICAgICAgICBpZiAobGFzdEZpbGwgIT09IHJlbmRlcmVkTGV0dGVyLmZjKSB7XG4gICAgICAgICAgICAgIHJlbmRlcmVyLmN0eEZpbGxTdHlsZShyZW5kZXJlZExldHRlci5mYyk7XG4gICAgICAgICAgICAgIGxhc3RGaWxsID0gcmVuZGVyZWRMZXR0ZXIuZmM7IC8vIGN0eC5maWxsU3R5bGUgPSByZW5kZXJlZExldHRlci5mYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RGaWxsICE9PSB0aGlzLnZhbHVlcy5maWxsKSB7XG4gICAgICAgICAgICBsYXN0RmlsbCA9IHRoaXMudmFsdWVzLmZpbGw7XG4gICAgICAgICAgICByZW5kZXJlci5jdHhGaWxsU3R5bGUodGhpcy52YWx1ZXMuZmlsbCk7IC8vIGN0eC5maWxsU3R5bGUgPSB0aGlzLnZhbHVlcy5maWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbW1hbmRzID0gdGhpcy50ZXh0U3BhbnNbaV0uZWxlbTtcbiAgICAgICAgICBqTGVuID0gY29tbWFuZHMubGVuZ3RoO1xuICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgcGF0aEFyciA9IGNvbW1hbmRzW2pdO1xuICAgICAgICAgICAga0xlbiA9IHBhdGhBcnIubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQubW92ZVRvKHBhdGhBcnJbMF0sIHBhdGhBcnJbMV0pO1xuXG4gICAgICAgICAgICBmb3IgKGsgPSAyOyBrIDwga0xlbjsgayArPSA2KSB7XG4gICAgICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0LmJlemllckN1cnZlVG8ocGF0aEFycltrXSwgcGF0aEFycltrICsgMV0sIHBhdGhBcnJbayArIDJdLCBwYXRoQXJyW2sgKyAzXSwgcGF0aEFycltrICsgNF0sIHBhdGhBcnJbayArIDVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICByZW5kZXJlci5jdHhGaWxsKCk7IC8vIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0LmZpbGwoKTtcbiAgICAgICAgICAvLy8gY3R4LmZpbGxUZXh0KHRoaXMudGV4dFNwYW5zW2ldLnZhbCwwLDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3Ryb2tlKSB7XG4gICAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyICYmIHJlbmRlcmVkTGV0dGVyLnN3KSB7XG4gICAgICAgICAgICBpZiAobGFzdFN0cm9rZVcgIT09IHJlbmRlcmVkTGV0dGVyLnN3KSB7XG4gICAgICAgICAgICAgIGxhc3RTdHJva2VXID0gcmVuZGVyZWRMZXR0ZXIuc3c7XG4gICAgICAgICAgICAgIHJlbmRlcmVyLmN0eExpbmVXaWR0aChyZW5kZXJlZExldHRlci5zdyk7IC8vIGN0eC5saW5lV2lkdGggPSByZW5kZXJlZExldHRlci5zdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RTdHJva2VXICE9PSB0aGlzLnZhbHVlcy5zV2lkdGgpIHtcbiAgICAgICAgICAgIGxhc3RTdHJva2VXID0gdGhpcy52YWx1ZXMuc1dpZHRoO1xuICAgICAgICAgICAgcmVuZGVyZXIuY3R4TGluZVdpZHRoKHRoaXMudmFsdWVzLnNXaWR0aCk7IC8vIGN0eC5saW5lV2lkdGggPSB0aGlzLnZhbHVlcy5zV2lkdGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyICYmIHJlbmRlcmVkTGV0dGVyLnNjKSB7XG4gICAgICAgICAgICBpZiAobGFzdFN0cm9rZSAhPT0gcmVuZGVyZWRMZXR0ZXIuc2MpIHtcbiAgICAgICAgICAgICAgbGFzdFN0cm9rZSA9IHJlbmRlcmVkTGV0dGVyLnNjO1xuICAgICAgICAgICAgICByZW5kZXJlci5jdHhTdHJva2VTdHlsZShyZW5kZXJlZExldHRlci5zYyk7IC8vIGN0eC5zdHJva2VTdHlsZSA9IHJlbmRlcmVkTGV0dGVyLnNjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobGFzdFN0cm9rZSAhPT0gdGhpcy52YWx1ZXMuc3Ryb2tlKSB7XG4gICAgICAgICAgICBsYXN0U3Ryb2tlID0gdGhpcy52YWx1ZXMuc3Ryb2tlO1xuICAgICAgICAgICAgcmVuZGVyZXIuY3R4U3Ryb2tlU3R5bGUodGhpcy52YWx1ZXMuc3Ryb2tlKTsgLy8gY3R4LnN0cm9rZVN0eWxlID0gdGhpcy52YWx1ZXMuc3Ryb2tlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbW1hbmRzID0gdGhpcy50ZXh0U3BhbnNbaV0uZWxlbTtcbiAgICAgICAgICBqTGVuID0gY29tbWFuZHMubGVuZ3RoO1xuICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgcGF0aEFyciA9IGNvbW1hbmRzW2pdO1xuICAgICAgICAgICAga0xlbiA9IHBhdGhBcnIubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQubW92ZVRvKHBhdGhBcnJbMF0sIHBhdGhBcnJbMV0pO1xuXG4gICAgICAgICAgICBmb3IgKGsgPSAyOyBrIDwga0xlbjsgayArPSA2KSB7XG4gICAgICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0LmJlemllckN1cnZlVG8ocGF0aEFycltrXSwgcGF0aEFycltrICsgMV0sIHBhdGhBcnJbayArIDJdLCBwYXRoQXJyW2sgKyAzXSwgcGF0aEFycltrICsgNF0sIHBhdGhBcnJbayArIDVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICByZW5kZXJlci5jdHhTdHJva2UoKTsgLy8gdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgLy8vIGN0eC5zdHJva2VUZXh0KGxldHRlcnNbaV0udmFsLDAsMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIpIHtcbiAgICAgICAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIENWSW1hZ2VFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmFzc2V0RGF0YSA9IGdsb2JhbERhdGEuZ2V0QXNzZXREYXRhKGRhdGEucmVmSWQpO1xuICAgIHRoaXMuaW1nID0gZ2xvYmFsRGF0YS5pbWFnZUxvYWRlci5nZXRBc3NldCh0aGlzLmFzc2V0RGF0YSk7XG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIENWQmFzZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZUVsZW1lbnRdLCBDVkltYWdlRWxlbWVudCk7XG4gIENWSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudCA9IFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuaW5pdEVsZW1lbnQ7XG4gIENWSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWUgPSBJSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWU7XG5cbiAgQ1ZJbWFnZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaW1nLndpZHRoICYmICh0aGlzLmFzc2V0RGF0YS53ICE9PSB0aGlzLmltZy53aWR0aCB8fCB0aGlzLmFzc2V0RGF0YS5oICE9PSB0aGlzLmltZy5oZWlnaHQpKSB7XG4gICAgICB2YXIgY2FudmFzID0gY3JlYXRlVGFnKCdjYW52YXMnKTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuYXNzZXREYXRhLnc7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5hc3NldERhdGEuaDtcbiAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHZhciBpbWdXID0gdGhpcy5pbWcud2lkdGg7XG4gICAgICB2YXIgaW1nSCA9IHRoaXMuaW1nLmhlaWdodDtcbiAgICAgIHZhciBpbWdSZWwgPSBpbWdXIC8gaW1nSDtcbiAgICAgIHZhciBjYW52YXNSZWwgPSB0aGlzLmFzc2V0RGF0YS53IC8gdGhpcy5hc3NldERhdGEuaDtcbiAgICAgIHZhciB3aWR0aENyb3A7XG4gICAgICB2YXIgaGVpZ2h0Q3JvcDtcbiAgICAgIHZhciBwYXIgPSB0aGlzLmFzc2V0RGF0YS5wciB8fCB0aGlzLmdsb2JhbERhdGEucmVuZGVyQ29uZmlnLmltYWdlUHJlc2VydmVBc3BlY3RSYXRpbztcblxuICAgICAgaWYgKGltZ1JlbCA+IGNhbnZhc1JlbCAmJiBwYXIgPT09ICd4TWlkWU1pZCBzbGljZScgfHwgaW1nUmVsIDwgY2FudmFzUmVsICYmIHBhciAhPT0gJ3hNaWRZTWlkIHNsaWNlJykge1xuICAgICAgICBoZWlnaHRDcm9wID0gaW1nSDtcbiAgICAgICAgd2lkdGhDcm9wID0gaGVpZ2h0Q3JvcCAqIGNhbnZhc1JlbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoQ3JvcCA9IGltZ1c7XG4gICAgICAgIGhlaWdodENyb3AgPSB3aWR0aENyb3AgLyBjYW52YXNSZWw7XG4gICAgICB9XG5cbiAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5pbWcsIChpbWdXIC0gd2lkdGhDcm9wKSAvIDIsIChpbWdIIC0gaGVpZ2h0Q3JvcCkgLyAyLCB3aWR0aENyb3AsIGhlaWdodENyb3AsIDAsIDAsIHRoaXMuYXNzZXREYXRhLncsIHRoaXMuYXNzZXREYXRhLmgpO1xuICAgICAgdGhpcy5pbWcgPSBjYW52YXM7XG4gICAgfVxuICB9O1xuXG4gIENWSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0LmRyYXdJbWFnZSh0aGlzLmltZywgMCwgMCk7XG4gIH07XG5cbiAgQ1ZJbWFnZUVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pbWcgPSBudWxsO1xuICB9O1xuXG4gIGZ1bmN0aW9uIENWU29saWRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgQ1ZCYXNlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRWxlbWVudF0sIENWU29saWRFbGVtZW50KTtcbiAgQ1ZTb2xpZEVsZW1lbnQucHJvdG90eXBlLmluaXRFbGVtZW50ID0gU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudDtcbiAgQ1ZTb2xpZEVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IElJbWFnZUVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZTtcblxuICBDVlNvbGlkRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHZhciBjdHggPSB0aGlzLmNhbnZhc0NvbnRleHQ7XG4gICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyLmN0eEZpbGxTdHlsZSh0aGlzLmRhdGEuc2MpOyAvLyBjdHguZmlsbFN0eWxlID0gdGhpcy5kYXRhLnNjO1xuXG4gICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyLmN0eEZpbGxSZWN0KDAsIDAsIHRoaXMuZGF0YS5zdywgdGhpcy5kYXRhLnNoKTsgLy8gY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuZGF0YS5zdywgdGhpcy5kYXRhLnNoKTtcbiAgICAvL1xuICB9O1xuXG4gIGZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyQmFzZSgpIHt9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlUmVuZGVyZXJdLCBDYW52YXNSZW5kZXJlckJhc2UpO1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlU2hhcGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQ1ZTaGFwZUVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmNyZWF0ZVRleHQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQ1ZUZXh0RWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlSW1hZ2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQ1ZJbWFnZUVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmNyZWF0ZVNvbGlkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IENWU29saWRFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jcmVhdGVOdWxsID0gU1ZHUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZU51bGw7XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jdHhUcmFuc2Zvcm0gPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICBpZiAocHJvcHNbMF0gPT09IDEgJiYgcHJvcHNbMV0gPT09IDAgJiYgcHJvcHNbNF0gPT09IDAgJiYgcHJvcHNbNV0gPT09IDEgJiYgcHJvcHNbMTJdID09PSAwICYmIHByb3BzWzEzXSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2FudmFzQ29udGV4dC50cmFuc2Zvcm0ocHJvcHNbMF0sIHByb3BzWzFdLCBwcm9wc1s0XSwgcHJvcHNbNV0sIHByb3BzWzEyXSwgcHJvcHNbMTNdKTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmN0eE9wYWNpdHkgPSBmdW5jdGlvbiAob3ApIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuZ2xvYmFsQWxwaGEgKj0gb3AgPCAwID8gMCA6IG9wO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3R4RmlsbFN0eWxlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0LmZpbGxTdHlsZSA9IHZhbHVlO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3R4U3Ryb2tlU3R5bGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuc3Ryb2tlU3R5bGUgPSB2YWx1ZTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmN0eExpbmVXaWR0aCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuY2FudmFzQ29udGV4dC5saW5lV2lkdGggPSB2YWx1ZTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmN0eExpbmVDYXAgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQubGluZUNhcCA9IHZhbHVlO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3R4TGluZUpvaW4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQubGluZUpvaW4gPSB2YWx1ZTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmN0eE1pdGVyTGltaXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQubWl0ZXJMaW1pdCA9IHZhbHVlO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3R4RmlsbCA9IGZ1bmN0aW9uIChydWxlKSB7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0LmZpbGwocnVsZSk7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jdHhGaWxsUmVjdCA9IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3R4U3Ryb2tlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2FudmFzQ29udGV4dC5zdHJva2UoKTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5yZW5kZXJDb25maWcuY2xlYXJDYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jb250ZXh0RGF0YS5yZXNldCgpO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuc2F2ZSgpO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uIChhY3Rpb25GbGFnKSB7XG4gICAgaWYgKCF0aGlzLnJlbmRlckNvbmZpZy5jbGVhckNhbnZhcykge1xuICAgICAgdGhpcy5jYW52YXNDb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uRmxhZykge1xuICAgICAgdGhpcy5nbG9iYWxEYXRhLmJsZW5kTW9kZSA9ICdzb3VyY2Utb3Zlcic7XG4gICAgfVxuXG4gICAgdGhpcy5jb250ZXh0RGF0YS5yZXN0b3JlKGFjdGlvbkZsYWcpO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY29uZmlnQW5pbWF0aW9uID0gZnVuY3Rpb24gKGFuaW1EYXRhKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyID0gY3JlYXRlVGFnKCdjYW52YXMnKTtcbiAgICAgIHZhciBjb250YWluZXJTdHlsZSA9IHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIuc3R5bGU7XG4gICAgICBjb250YWluZXJTdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgIGNvbnRhaW5lclN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgIHZhciBvcmlnaW4gPSAnMHB4IDBweCAwcHgnO1xuICAgICAgY29udGFpbmVyU3R5bGUudHJhbnNmb3JtT3JpZ2luID0gb3JpZ2luO1xuICAgICAgY29udGFpbmVyU3R5bGUubW96VHJhbnNmb3JtT3JpZ2luID0gb3JpZ2luO1xuICAgICAgY29udGFpbmVyU3R5bGUud2Via2l0VHJhbnNmb3JtT3JpZ2luID0gb3JpZ2luO1xuICAgICAgY29udGFpbmVyU3R5bGVbJy13ZWJraXQtdHJhbnNmb3JtJ10gPSBvcmlnaW47XG4gICAgICBjb250YWluZXJTdHlsZS5jb250ZW50VmlzaWJpbGl0eSA9IHRoaXMucmVuZGVyQ29uZmlnLmNvbnRlbnRWaXNpYmlsaXR5O1xuICAgICAgdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lcik7XG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHQgPSB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgIGlmICh0aGlzLnJlbmRlckNvbmZpZy5jbGFzc05hbWUpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdGhpcy5yZW5kZXJDb25maWcuY2xhc3NOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucmVuZGVyQ29uZmlnLmlkKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMucmVuZGVyQ29uZmlnLmlkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jYW52YXNDb250ZXh0ID0gdGhpcy5yZW5kZXJDb25maWcuY29udGV4dDtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRleHREYXRhLnNldENvbnRleHQodGhpcy5jYW52YXNDb250ZXh0KTtcbiAgICB0aGlzLmRhdGEgPSBhbmltRGF0YTtcbiAgICB0aGlzLmxheWVycyA9IGFuaW1EYXRhLmxheWVycztcbiAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcyA9IHtcbiAgICAgIHc6IGFuaW1EYXRhLncsXG4gICAgICBoOiBhbmltRGF0YS5oLFxuICAgICAgc3g6IDAsXG4gICAgICBzeTogMCxcbiAgICAgIHR4OiAwLFxuICAgICAgdHk6IDBcbiAgICB9O1xuICAgIHRoaXMuc2V0dXBHbG9iYWxEYXRhKGFuaW1EYXRhLCBkb2N1bWVudC5ib2R5KTtcbiAgICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dCA9IHRoaXMuY2FudmFzQ29udGV4dDtcbiAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIgPSB0aGlzO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5pc0Rhc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5wcm9ncmVzc2l2ZUxvYWQgPSB0aGlzLnJlbmRlckNvbmZpZy5wcm9ncmVzc2l2ZUxvYWQ7XG4gICAgdGhpcy5nbG9iYWxEYXRhLnRyYW5zZm9ybUNhbnZhcyA9IHRoaXMudHJhbnNmb3JtQ2FudmFzO1xuICAgIHRoaXMuZWxlbWVudHMgPSBjcmVhdGVTaXplZEFycmF5KGFuaW1EYXRhLmxheWVycy5sZW5ndGgpO1xuICAgIHRoaXMudXBkYXRlQ29udGFpbmVyU2l6ZSgpO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUudXBkYXRlQ29udGFpbmVyU2l6ZSA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHZhciBlbGVtZW50V2lkdGg7XG4gICAgdmFyIGVsZW1lbnRIZWlnaHQ7XG5cbiAgICBpZiAod2lkdGgpIHtcbiAgICAgIGVsZW1lbnRXaWR0aCA9IHdpZHRoO1xuICAgICAgZWxlbWVudEhlaWdodCA9IGhlaWdodDtcbiAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5jYW52YXMud2lkdGggPSBlbGVtZW50V2lkdGg7XG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHQuY2FudmFzLmhlaWdodCA9IGVsZW1lbnRIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlciAmJiB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyKSB7XG4gICAgICAgIGVsZW1lbnRXaWR0aCA9IHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyLm9mZnNldFdpZHRoO1xuICAgICAgICBlbGVtZW50SGVpZ2h0ID0gdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudFdpZHRoID0gdGhpcy5jYW52YXNDb250ZXh0LmNhbnZhcy53aWR0aDtcbiAgICAgICAgZWxlbWVudEhlaWdodCA9IHRoaXMuY2FudmFzQ29udGV4dC5jYW52YXMuaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHQuY2FudmFzLndpZHRoID0gZWxlbWVudFdpZHRoICogdGhpcy5yZW5kZXJDb25maWcuZHByO1xuICAgICAgdGhpcy5jYW52YXNDb250ZXh0LmNhbnZhcy5oZWlnaHQgPSBlbGVtZW50SGVpZ2h0ICogdGhpcy5yZW5kZXJDb25maWcuZHByO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50UmVsO1xuICAgIHZhciBhbmltYXRpb25SZWw7XG5cbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcucHJlc2VydmVBc3BlY3RSYXRpby5pbmRleE9mKCdtZWV0JykgIT09IC0xIHx8IHRoaXMucmVuZGVyQ29uZmlnLnByZXNlcnZlQXNwZWN0UmF0aW8uaW5kZXhPZignc2xpY2UnKSAhPT0gLTEpIHtcbiAgICAgIHZhciBwYXIgPSB0aGlzLnJlbmRlckNvbmZpZy5wcmVzZXJ2ZUFzcGVjdFJhdGlvLnNwbGl0KCcgJyk7XG4gICAgICB2YXIgZmlsbFR5cGUgPSBwYXJbMV0gfHwgJ21lZXQnO1xuICAgICAgdmFyIHBvcyA9IHBhclswXSB8fCAneE1pZFlNaWQnO1xuICAgICAgdmFyIHhQb3MgPSBwb3Muc3Vic3RyKDAsIDQpO1xuICAgICAgdmFyIHlQb3MgPSBwb3Muc3Vic3RyKDQpO1xuICAgICAgZWxlbWVudFJlbCA9IGVsZW1lbnRXaWR0aCAvIGVsZW1lbnRIZWlnaHQ7XG4gICAgICBhbmltYXRpb25SZWwgPSB0aGlzLnRyYW5zZm9ybUNhbnZhcy53IC8gdGhpcy50cmFuc2Zvcm1DYW52YXMuaDtcblxuICAgICAgaWYgKGFuaW1hdGlvblJlbCA+IGVsZW1lbnRSZWwgJiYgZmlsbFR5cGUgPT09ICdtZWV0JyB8fCBhbmltYXRpb25SZWwgPCBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnc2xpY2UnKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnN4ID0gZWxlbWVudFdpZHRoIC8gKHRoaXMudHJhbnNmb3JtQ2FudmFzLncgLyB0aGlzLnJlbmRlckNvbmZpZy5kcHIpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeSA9IGVsZW1lbnRXaWR0aCAvICh0aGlzLnRyYW5zZm9ybUNhbnZhcy53IC8gdGhpcy5yZW5kZXJDb25maWcuZHByKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnN4ID0gZWxlbWVudEhlaWdodCAvICh0aGlzLnRyYW5zZm9ybUNhbnZhcy5oIC8gdGhpcy5yZW5kZXJDb25maWcuZHByKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMuc3kgPSBlbGVtZW50SGVpZ2h0IC8gKHRoaXMudHJhbnNmb3JtQ2FudmFzLmggLyB0aGlzLnJlbmRlckNvbmZpZy5kcHIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoeFBvcyA9PT0gJ3hNaWQnICYmIChhbmltYXRpb25SZWwgPCBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnbWVldCcgfHwgYW5pbWF0aW9uUmVsID4gZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ3NsaWNlJykpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHggPSAoZWxlbWVudFdpZHRoIC0gdGhpcy50cmFuc2Zvcm1DYW52YXMudyAqIChlbGVtZW50SGVpZ2h0IC8gdGhpcy50cmFuc2Zvcm1DYW52YXMuaCkpIC8gMiAqIHRoaXMucmVuZGVyQ29uZmlnLmRwcjtcbiAgICAgIH0gZWxzZSBpZiAoeFBvcyA9PT0gJ3hNYXgnICYmIChhbmltYXRpb25SZWwgPCBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnbWVldCcgfHwgYW5pbWF0aW9uUmVsID4gZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ3NsaWNlJykpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHggPSAoZWxlbWVudFdpZHRoIC0gdGhpcy50cmFuc2Zvcm1DYW52YXMudyAqIChlbGVtZW50SGVpZ2h0IC8gdGhpcy50cmFuc2Zvcm1DYW52YXMuaCkpICogdGhpcy5yZW5kZXJDb25maWcuZHByO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHggPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoeVBvcyA9PT0gJ1lNaWQnICYmIChhbmltYXRpb25SZWwgPiBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnbWVldCcgfHwgYW5pbWF0aW9uUmVsIDwgZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ3NsaWNlJykpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHkgPSAoZWxlbWVudEhlaWdodCAtIHRoaXMudHJhbnNmb3JtQ2FudmFzLmggKiAoZWxlbWVudFdpZHRoIC8gdGhpcy50cmFuc2Zvcm1DYW52YXMudykpIC8gMiAqIHRoaXMucmVuZGVyQ29uZmlnLmRwcjtcbiAgICAgIH0gZWxzZSBpZiAoeVBvcyA9PT0gJ1lNYXgnICYmIChhbmltYXRpb25SZWwgPiBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnbWVldCcgfHwgYW5pbWF0aW9uUmVsIDwgZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ3NsaWNlJykpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHkgPSAoZWxlbWVudEhlaWdodCAtIHRoaXMudHJhbnNmb3JtQ2FudmFzLmggKiAoZWxlbWVudFdpZHRoIC8gdGhpcy50cmFuc2Zvcm1DYW52YXMudykpICogdGhpcy5yZW5kZXJDb25maWcuZHByO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHkgPSAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5yZW5kZXJDb25maWcucHJlc2VydmVBc3BlY3RSYXRpbyA9PT0gJ25vbmUnKSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeCA9IGVsZW1lbnRXaWR0aCAvICh0aGlzLnRyYW5zZm9ybUNhbnZhcy53IC8gdGhpcy5yZW5kZXJDb25maWcuZHByKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnN5ID0gZWxlbWVudEhlaWdodCAvICh0aGlzLnRyYW5zZm9ybUNhbnZhcy5oIC8gdGhpcy5yZW5kZXJDb25maWcuZHByKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR4ID0gMDtcbiAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMuc3ggPSB0aGlzLnJlbmRlckNvbmZpZy5kcHI7XG4gICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeSA9IHRoaXMucmVuZGVyQ29uZmlnLmRwcjtcbiAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR4ID0gMDtcbiAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR5ID0gMDtcbiAgICB9XG5cbiAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5wcm9wcyA9IFt0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeCwgMCwgMCwgMCwgMCwgdGhpcy50cmFuc2Zvcm1DYW52YXMuc3ksIDAsIDAsIDAsIDAsIDEsIDAsIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR4LCB0aGlzLnRyYW5zZm9ybUNhbnZhcy50eSwgMCwgMV07XG4gICAgLyogdmFyIGksIGxlbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xyXG4gICAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgICAgaWYodGhpcy5lbGVtZW50c1tpXSAmJiB0aGlzLmVsZW1lbnRzW2ldLmRhdGEudHkgPT09IDApe1xyXG4gICAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbaV0ucmVzaXplKHRoaXMuZ2xvYmFsRGF0YS50cmFuc2Zvcm1DYW52YXMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9ICovXG5cbiAgICB0aGlzLmN0eFRyYW5zZm9ybSh0aGlzLnRyYW5zZm9ybUNhbnZhcy5wcm9wcyk7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIHRoaXMuY2FudmFzQ29udGV4dC5yZWN0KDAsIDAsIHRoaXMudHJhbnNmb3JtQ2FudmFzLncsIHRoaXMudHJhbnNmb3JtQ2FudmFzLmgpO1xuICAgIHRoaXMuY2FudmFzQ29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuY2xpcCgpO1xuICAgIHRoaXMucmVuZGVyRnJhbWUodGhpcy5yZW5kZXJlZEZyYW1lLCB0cnVlKTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyQ29uZmlnLmNsZWFyQ2FudmFzICYmIHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlci5pbm5lclRleHQgPSAnJztcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5sYXllcnMgPyB0aGlzLmxheWVycy5sZW5ndGggOiAwO1xuXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldICYmIHRoaXMuZWxlbWVudHNbaV0uZGVzdHJveSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIgPSBudWxsO1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKG51bSwgZm9yY2VSZW5kZXIpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJlZEZyYW1lID09PSBudW0gJiYgdGhpcy5yZW5kZXJDb25maWcuY2xlYXJDYW52YXMgPT09IHRydWUgJiYgIWZvcmNlUmVuZGVyIHx8IHRoaXMuZGVzdHJveWVkIHx8IG51bSA9PT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmVkRnJhbWUgPSBudW07XG4gICAgdGhpcy5nbG9iYWxEYXRhLmZyYW1lTnVtID0gbnVtIC0gdGhpcy5hbmltYXRpb25JdGVtLl9pc0ZpcnN0RnJhbWU7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmZyYW1lSWQgKz0gMTtcbiAgICB0aGlzLmdsb2JhbERhdGEuX21kZiA9ICF0aGlzLnJlbmRlckNvbmZpZy5jbGVhckNhbnZhcyB8fCBmb3JjZVJlbmRlcjtcbiAgICB0aGlzLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5jdXJyZW50RnJhbWUgPSBudW07IC8vIGNvbnNvbGUubG9nKCctLS0tLS0tLScpO1xuICAgIC8vIGNvbnNvbGUubG9nKCdORVc6ICcsbnVtKTtcblxuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XG5cbiAgICBpZiAoIXRoaXMuY29tcGxldGVMYXllcnMpIHtcbiAgICAgIHRoaXMuY2hlY2tMYXllcnMobnVtKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKHRoaXMuY29tcGxldGVMYXllcnMgfHwgdGhpcy5lbGVtZW50c1tpXSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLnByZXBhcmVGcmFtZShudW0gLSB0aGlzLmxheWVyc1tpXS5zdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZ2xvYmFsRGF0YS5fbWRmKSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJDb25maWcuY2xlYXJDYW52YXMgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLnRyYW5zZm9ybUNhbnZhcy53LCB0aGlzLnRyYW5zZm9ybUNhbnZhcy5oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBpZiAodGhpcy5jb21wbGV0ZUxheWVycyB8fCB0aGlzLmVsZW1lbnRzW2ldKSB7XG4gICAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5yZW5kZXJGcmFtZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnJlbmRlckNvbmZpZy5jbGVhckNhbnZhcyAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5idWlsZEl0ZW0gPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcblxuICAgIGlmIChlbGVtZW50c1twb3NdIHx8IHRoaXMubGF5ZXJzW3Bvc10udHkgPT09IDk5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmNyZWF0ZUl0ZW0odGhpcy5sYXllcnNbcG9zXSwgdGhpcywgdGhpcy5nbG9iYWxEYXRhKTtcbiAgICBlbGVtZW50c1twb3NdID0gZWxlbWVudDtcbiAgICBlbGVtZW50LmluaXRFeHByZXNzaW9ucygpO1xuICAgIC8qIGlmKHRoaXMubGF5ZXJzW3Bvc10udHkgPT09IDApe1xyXG4gICAgICAgICAgZWxlbWVudC5yZXNpemUodGhpcy5nbG9iYWxEYXRhLnRyYW5zZm9ybUNhbnZhcyk7XHJcbiAgICAgIH0gKi9cbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmNoZWNrUGVuZGluZ0VsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHdoaWxlICh0aGlzLnBlbmRpbmdFbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wZW5kaW5nRWxlbWVudHMucG9wKCk7XG4gICAgICBlbGVtZW50LmNoZWNrUGFyZW50aW5nKCk7XG4gICAgfVxuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gIH07XG5cbiAgZnVuY3Rpb24gQ2FudmFzQ29udGV4dCgpIHtcbiAgICB0aGlzLm9wYWNpdHkgPSAtMTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCAxNik7XG4gICAgdGhpcy5maWxsU3R5bGUgPSAnJztcbiAgICB0aGlzLnN0cm9rZVN0eWxlID0gJyc7XG4gICAgdGhpcy5saW5lV2lkdGggPSAnJztcbiAgICB0aGlzLmxpbmVDYXAgPSAnJztcbiAgICB0aGlzLmxpbmVKb2luID0gJyc7XG4gICAgdGhpcy5taXRlckxpbWl0ID0gJyc7XG4gICAgdGhpcy5pZCA9IE1hdGgucmFuZG9tKCk7XG4gIH1cblxuICBmdW5jdGlvbiBDVkNvbnRleHREYXRhKCkge1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICB0aGlzLmNBcnJQb3MgPSAwO1xuICAgIHRoaXMuY1RyID0gbmV3IE1hdHJpeCgpO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSAxNTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgdmFyIGNhbnZhc0NvbnRleHQgPSBuZXcgQ2FudmFzQ29udGV4dCgpO1xuICAgICAgdGhpcy5zdGFja1tpXSA9IGNhbnZhc0NvbnRleHQ7XG4gICAgfVxuXG4gICAgdGhpcy5fbGVuZ3RoID0gbGVuO1xuICAgIHRoaXMubmF0aXZlQ29udGV4dCA9IG51bGw7XG4gICAgdGhpcy50cmFuc2Zvcm1NYXQgPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy5jdXJyZW50T3BhY2l0eSA9IDE7IC8vXG5cbiAgICB0aGlzLmN1cnJlbnRGaWxsU3R5bGUgPSAnJztcbiAgICB0aGlzLmFwcGxpZWRGaWxsU3R5bGUgPSAnJzsgLy9cblxuICAgIHRoaXMuY3VycmVudFN0cm9rZVN0eWxlID0gJyc7XG4gICAgdGhpcy5hcHBsaWVkU3Ryb2tlU3R5bGUgPSAnJzsgLy9cblxuICAgIHRoaXMuY3VycmVudExpbmVXaWR0aCA9ICcnO1xuICAgIHRoaXMuYXBwbGllZExpbmVXaWR0aCA9ICcnOyAvL1xuXG4gICAgdGhpcy5jdXJyZW50TGluZUNhcCA9ICcnO1xuICAgIHRoaXMuYXBwbGllZExpbmVDYXAgPSAnJzsgLy9cblxuICAgIHRoaXMuY3VycmVudExpbmVKb2luID0gJyc7XG4gICAgdGhpcy5hcHBsaWVkTGluZUpvaW4gPSAnJzsgLy9cblxuICAgIHRoaXMuYXBwbGllZE1pdGVyTGltaXQgPSAnJztcbiAgICB0aGlzLmN1cnJlbnRNaXRlckxpbWl0ID0gJyc7XG4gIH1cblxuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS5kdXBsaWNhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5ld0xlbmd0aCA9IHRoaXMuX2xlbmd0aCAqIDI7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZm9yIChpID0gdGhpcy5fbGVuZ3RoOyBpIDwgbmV3TGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHRoaXMuc3RhY2tbaV0gPSBuZXcgQ2FudmFzQ29udGV4dCgpO1xuICAgIH1cblxuICAgIHRoaXMuX2xlbmd0aCA9IG5ld0xlbmd0aDtcbiAgfTtcblxuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNBcnJQb3MgPSAwO1xuICAgIHRoaXMuY1RyLnJlc2V0KCk7XG4gICAgdGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLm9wYWNpdHkgPSAxO1xuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLnJlc3RvcmUgPSBmdW5jdGlvbiAoZm9yY2VSZXN0b3JlKSB7XG4gICAgdGhpcy5jQXJyUG9zIC09IDE7XG4gICAgdmFyIGN1cnJlbnRDb250ZXh0ID0gdGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdO1xuICAgIHZhciB0cmFuc2Zvcm0gPSBjdXJyZW50Q29udGV4dC50cmFuc2Zvcm07XG4gICAgdmFyIGk7XG4gICAgdmFyIGFyciA9IHRoaXMuY1RyLnByb3BzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgIGFycltpXSA9IHRyYW5zZm9ybVtpXTtcbiAgICB9XG5cbiAgICBpZiAoZm9yY2VSZXN0b3JlKSB7XG4gICAgICB0aGlzLm5hdGl2ZUNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgdmFyIHByZXZTdGFjayA9IHRoaXMuc3RhY2tbdGhpcy5jQXJyUG9zICsgMV07XG4gICAgICB0aGlzLmFwcGxpZWRGaWxsU3R5bGUgPSBwcmV2U3RhY2suZmlsbFN0eWxlO1xuICAgICAgdGhpcy5hcHBsaWVkU3Ryb2tlU3R5bGUgPSBwcmV2U3RhY2suc3Ryb2tlU3R5bGU7XG4gICAgICB0aGlzLmFwcGxpZWRMaW5lV2lkdGggPSBwcmV2U3RhY2subGluZVdpZHRoO1xuICAgICAgdGhpcy5hcHBsaWVkTGluZUNhcCA9IHByZXZTdGFjay5saW5lQ2FwO1xuICAgICAgdGhpcy5hcHBsaWVkTGluZUpvaW4gPSBwcmV2U3RhY2subGluZUpvaW47XG4gICAgICB0aGlzLmFwcGxpZWRNaXRlckxpbWl0ID0gcHJldlN0YWNrLm1pdGVyTGltaXQ7XG4gICAgfVxuXG4gICAgdGhpcy5uYXRpdmVDb250ZXh0LnNldFRyYW5zZm9ybSh0cmFuc2Zvcm1bMF0sIHRyYW5zZm9ybVsxXSwgdHJhbnNmb3JtWzRdLCB0cmFuc2Zvcm1bNV0sIHRyYW5zZm9ybVsxMl0sIHRyYW5zZm9ybVsxM10pO1xuXG4gICAgaWYgKGZvcmNlUmVzdG9yZSB8fCBjdXJyZW50Q29udGV4dC5vcGFjaXR5ICE9PSAtMSAmJiB0aGlzLmN1cnJlbnRPcGFjaXR5ICE9PSBjdXJyZW50Q29udGV4dC5vcGFjaXR5KSB7XG4gICAgICB0aGlzLm5hdGl2ZUNvbnRleHQuZ2xvYmFsQWxwaGEgPSBjdXJyZW50Q29udGV4dC5vcGFjaXR5O1xuICAgICAgdGhpcy5jdXJyZW50T3BhY2l0eSA9IGN1cnJlbnRDb250ZXh0Lm9wYWNpdHk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50RmlsbFN0eWxlID0gY3VycmVudENvbnRleHQuZmlsbFN0eWxlO1xuICAgIHRoaXMuY3VycmVudFN0cm9rZVN0eWxlID0gY3VycmVudENvbnRleHQuc3Ryb2tlU3R5bGU7XG4gICAgdGhpcy5jdXJyZW50TGluZVdpZHRoID0gY3VycmVudENvbnRleHQubGluZVdpZHRoO1xuICAgIHRoaXMuY3VycmVudExpbmVDYXAgPSBjdXJyZW50Q29udGV4dC5saW5lQ2FwO1xuICAgIHRoaXMuY3VycmVudExpbmVKb2luID0gY3VycmVudENvbnRleHQubGluZUpvaW47XG4gICAgdGhpcy5jdXJyZW50TWl0ZXJMaW1pdCA9IGN1cnJlbnRDb250ZXh0Lm1pdGVyTGltaXQ7XG4gIH07XG5cbiAgQ1ZDb250ZXh0RGF0YS5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIChzYXZlT25OYXRpdmVGbGFnKSB7XG4gICAgaWYgKHNhdmVPbk5hdGl2ZUZsYWcpIHtcbiAgICAgIHRoaXMubmF0aXZlQ29udGV4dC5zYXZlKCk7XG4gICAgfVxuXG4gICAgdmFyIHByb3BzID0gdGhpcy5jVHIucHJvcHM7XG5cbiAgICBpZiAodGhpcy5fbGVuZ3RoIDw9IHRoaXMuY0FyclBvcykge1xuICAgICAgdGhpcy5kdXBsaWNhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudFN0YWNrID0gdGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdO1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgIGN1cnJlbnRTdGFjay50cmFuc2Zvcm1baV0gPSBwcm9wc1tpXTtcbiAgICB9XG5cbiAgICB0aGlzLmNBcnJQb3MgKz0gMTtcbiAgICB2YXIgbmV3U3RhY2sgPSB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc107XG4gICAgbmV3U3RhY2sub3BhY2l0eSA9IGN1cnJlbnRTdGFjay5vcGFjaXR5O1xuICAgIG5ld1N0YWNrLmZpbGxTdHlsZSA9IGN1cnJlbnRTdGFjay5maWxsU3R5bGU7XG4gICAgbmV3U3RhY2suc3Ryb2tlU3R5bGUgPSBjdXJyZW50U3RhY2suc3Ryb2tlU3R5bGU7XG4gICAgbmV3U3RhY2subGluZVdpZHRoID0gY3VycmVudFN0YWNrLmxpbmVXaWR0aDtcbiAgICBuZXdTdGFjay5saW5lQ2FwID0gY3VycmVudFN0YWNrLmxpbmVDYXA7XG4gICAgbmV3U3RhY2subGluZUpvaW4gPSBjdXJyZW50U3RhY2subGluZUpvaW47XG4gICAgbmV3U3RhY2subWl0ZXJMaW1pdCA9IGN1cnJlbnRTdGFjay5taXRlckxpbWl0O1xuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLnNldE9wYWNpdHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ub3BhY2l0eSA9IHZhbHVlO1xuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLnNldENvbnRleHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLm5hdGl2ZUNvbnRleHQgPSB2YWx1ZTtcbiAgfTtcblxuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS5maWxsU3R5bGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLmZpbGxTdHlsZSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuY3VycmVudEZpbGxTdHlsZSA9IHZhbHVlO1xuICAgICAgdGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLmZpbGxTdHlsZSA9IHZhbHVlO1xuICAgIH1cbiAgfTtcblxuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS5zdHJva2VTdHlsZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10uc3Ryb2tlU3R5bGUgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTdHJva2VTdHlsZSA9IHZhbHVlO1xuICAgICAgdGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLnN0cm9rZVN0eWxlID0gdmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLmxpbmVXaWR0aCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ubGluZVdpZHRoICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5jdXJyZW50TGluZVdpZHRoID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ubGluZVdpZHRoID0gdmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLmxpbmVDYXAgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLmxpbmVDYXAgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmN1cnJlbnRMaW5lQ2FwID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ubGluZUNhcCA9IHZhbHVlO1xuICAgIH1cbiAgfTtcblxuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS5saW5lSm9pbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ubGluZUpvaW4gIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmN1cnJlbnRMaW5lSm9pbiA9IHZhbHVlO1xuICAgICAgdGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLmxpbmVKb2luID0gdmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLm1pdGVyTGltaXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLm1pdGVyTGltaXQgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmN1cnJlbnRNaXRlckxpbWl0ID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ubWl0ZXJMaW1pdCA9IHZhbHVlO1xuICAgIH1cbiAgfTtcblxuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB0aGlzLnRyYW5zZm9ybU1hdC5jbG9uZUZyb21Qcm9wcyhwcm9wcyk7IC8vIFRha2luZyB0aGUgbGFzdCB0cmFuc2Zvcm0gdmFsdWUgZnJvbSB0aGUgc3RvcmVkIHN0YWNrIG9mIHRyYW5zZm9ybXNcblxuICAgIHZhciBjdXJyZW50VHJhbnNmb3JtID0gdGhpcy5jVHI7IC8vIEFwcGx5aW5nIHRoZSBsYXN0IHRyYW5zZm9ybSB2YWx1ZSBhZnRlciB0aGUgbmV3IHRyYW5zZm9ybSB0byByZXNwZWN0IHRoZSBvcmRlciBvZiB0cmFuc2Zvcm1hdGlvbnNcblxuICAgIHRoaXMudHJhbnNmb3JtTWF0Lm11bHRpcGx5KGN1cnJlbnRUcmFuc2Zvcm0pOyAvLyBTdG9yaW5nIHRoZSBuZXcgdHJhbnNmb3JtZWQgdmFsdWUgaW4gdGhlIHN0b3JlZCB0cmFuc2Zvcm1cblxuICAgIGN1cnJlbnRUcmFuc2Zvcm0uY2xvbmVGcm9tUHJvcHModGhpcy50cmFuc2Zvcm1NYXQucHJvcHMpO1xuICAgIHZhciB0clByb3BzID0gY3VycmVudFRyYW5zZm9ybS5wcm9wczsgLy8gQXBwbHlpbmcgdGhlIG5ldyB0cmFuc2Zvcm0gdG8gdGhlIGNhbnZhc1xuXG4gICAgdGhpcy5uYXRpdmVDb250ZXh0LnNldFRyYW5zZm9ybSh0clByb3BzWzBdLCB0clByb3BzWzFdLCB0clByb3BzWzRdLCB0clByb3BzWzVdLCB0clByb3BzWzEyXSwgdHJQcm9wc1sxM10pO1xuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLm9wYWNpdHkgPSBmdW5jdGlvbiAob3ApIHtcbiAgICB2YXIgY3VycmVudE9wYWNpdHkgPSB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ub3BhY2l0eTtcbiAgICBjdXJyZW50T3BhY2l0eSAqPSBvcCA8IDAgPyAwIDogb3A7XG5cbiAgICBpZiAodGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLm9wYWNpdHkgIT09IGN1cnJlbnRPcGFjaXR5KSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50T3BhY2l0eSAhPT0gb3ApIHtcbiAgICAgICAgdGhpcy5uYXRpdmVDb250ZXh0Lmdsb2JhbEFscGhhID0gb3A7XG4gICAgICAgIHRoaXMuY3VycmVudE9wYWNpdHkgPSBvcDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLm9wYWNpdHkgPSBjdXJyZW50T3BhY2l0eTtcbiAgICB9XG4gIH07XG5cbiAgQ1ZDb250ZXh0RGF0YS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIChydWxlKSB7XG4gICAgaWYgKHRoaXMuYXBwbGllZEZpbGxTdHlsZSAhPT0gdGhpcy5jdXJyZW50RmlsbFN0eWxlKSB7XG4gICAgICB0aGlzLmFwcGxpZWRGaWxsU3R5bGUgPSB0aGlzLmN1cnJlbnRGaWxsU3R5bGU7XG4gICAgICB0aGlzLm5hdGl2ZUNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5hcHBsaWVkRmlsbFN0eWxlO1xuICAgIH1cblxuICAgIHRoaXMubmF0aXZlQ29udGV4dC5maWxsKHJ1bGUpO1xuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLmZpbGxSZWN0ID0gZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcbiAgICBpZiAodGhpcy5hcHBsaWVkRmlsbFN0eWxlICE9PSB0aGlzLmN1cnJlbnRGaWxsU3R5bGUpIHtcbiAgICAgIHRoaXMuYXBwbGllZEZpbGxTdHlsZSA9IHRoaXMuY3VycmVudEZpbGxTdHlsZTtcbiAgICAgIHRoaXMubmF0aXZlQ29udGV4dC5maWxsU3R5bGUgPSB0aGlzLmFwcGxpZWRGaWxsU3R5bGU7XG4gICAgfVxuXG4gICAgdGhpcy5uYXRpdmVDb250ZXh0LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLnN0cm9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5hcHBsaWVkU3Ryb2tlU3R5bGUgIT09IHRoaXMuY3VycmVudFN0cm9rZVN0eWxlKSB7XG4gICAgICB0aGlzLmFwcGxpZWRTdHJva2VTdHlsZSA9IHRoaXMuY3VycmVudFN0cm9rZVN0eWxlO1xuICAgICAgdGhpcy5uYXRpdmVDb250ZXh0LnN0cm9rZVN0eWxlID0gdGhpcy5hcHBsaWVkU3Ryb2tlU3R5bGU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYXBwbGllZExpbmVXaWR0aCAhPT0gdGhpcy5jdXJyZW50TGluZVdpZHRoKSB7XG4gICAgICB0aGlzLmFwcGxpZWRMaW5lV2lkdGggPSB0aGlzLmN1cnJlbnRMaW5lV2lkdGg7XG4gICAgICB0aGlzLm5hdGl2ZUNvbnRleHQubGluZVdpZHRoID0gdGhpcy5hcHBsaWVkTGluZVdpZHRoO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFwcGxpZWRMaW5lQ2FwICE9PSB0aGlzLmN1cnJlbnRMaW5lQ2FwKSB7XG4gICAgICB0aGlzLmFwcGxpZWRMaW5lQ2FwID0gdGhpcy5jdXJyZW50TGluZUNhcDtcbiAgICAgIHRoaXMubmF0aXZlQ29udGV4dC5saW5lQ2FwID0gdGhpcy5hcHBsaWVkTGluZUNhcDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hcHBsaWVkTGluZUpvaW4gIT09IHRoaXMuY3VycmVudExpbmVKb2luKSB7XG4gICAgICB0aGlzLmFwcGxpZWRMaW5lSm9pbiA9IHRoaXMuY3VycmVudExpbmVKb2luO1xuICAgICAgdGhpcy5uYXRpdmVDb250ZXh0LmxpbmVKb2luID0gdGhpcy5hcHBsaWVkTGluZUpvaW47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYXBwbGllZE1pdGVyTGltaXQgIT09IHRoaXMuY3VycmVudE1pdGVyTGltaXQpIHtcbiAgICAgIHRoaXMuYXBwbGllZE1pdGVyTGltaXQgPSB0aGlzLmN1cnJlbnRNaXRlckxpbWl0O1xuICAgICAgdGhpcy5uYXRpdmVDb250ZXh0Lm1pdGVyTGltaXQgPSB0aGlzLmFwcGxpZWRNaXRlckxpbWl0O1xuICAgIH1cblxuICAgIHRoaXMubmF0aXZlQ29udGV4dC5zdHJva2UoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBDVkNvbXBFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmNvbXBsZXRlTGF5ZXJzID0gZmFsc2U7XG4gICAgdGhpcy5sYXllcnMgPSBkYXRhLmxheWVycztcbiAgICB0aGlzLnBlbmRpbmdFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuZWxlbWVudHMgPSBjcmVhdGVTaXplZEFycmF5KHRoaXMubGF5ZXJzLmxlbmd0aCk7XG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgICB0aGlzLnRtID0gZGF0YS50bSA/IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEudG0sIDAsIGdsb2JhbERhdGEuZnJhbWVSYXRlLCB0aGlzKSA6IHtcbiAgICAgIF9wbGFjZWhvbGRlcjogdHJ1ZVxuICAgIH07XG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW0NhbnZhc1JlbmRlcmVyQmFzZSwgSUNvbXBFbGVtZW50LCBDVkJhc2VFbGVtZW50XSwgQ1ZDb21wRWxlbWVudCk7XG5cbiAgQ1ZDb21wRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdHggPSB0aGlzLmNhbnZhc0NvbnRleHQ7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oMCwgMCk7XG4gICAgY3R4LmxpbmVUbyh0aGlzLmRhdGEudywgMCk7XG4gICAgY3R4LmxpbmVUbyh0aGlzLmRhdGEudywgdGhpcy5kYXRhLmgpO1xuICAgIGN0eC5saW5lVG8oMCwgdGhpcy5kYXRhLmgpO1xuICAgIGN0eC5saW5lVG8oMCwgMCk7XG4gICAgY3R4LmNsaXAoKTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIGlmICh0aGlzLmNvbXBsZXRlTGF5ZXJzIHx8IHRoaXMuZWxlbWVudHNbaV0pIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5yZW5kZXJGcmFtZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBDVkNvbXBFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0pIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sYXllcnMgPSBudWxsO1xuICAgIHRoaXMuZWxlbWVudHMgPSBudWxsO1xuICB9O1xuXG4gIENWQ29tcEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbXAgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQ1ZDb21wRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKGFuaW1hdGlvbkl0ZW0sIGNvbmZpZykge1xuICAgIHRoaXMuYW5pbWF0aW9uSXRlbSA9IGFuaW1hdGlvbkl0ZW07XG4gICAgdGhpcy5yZW5kZXJDb25maWcgPSB7XG4gICAgICBjbGVhckNhbnZhczogY29uZmlnICYmIGNvbmZpZy5jbGVhckNhbnZhcyAhPT0gdW5kZWZpbmVkID8gY29uZmlnLmNsZWFyQ2FudmFzIDogdHJ1ZSxcbiAgICAgIGNvbnRleHQ6IGNvbmZpZyAmJiBjb25maWcuY29udGV4dCB8fCBudWxsLFxuICAgICAgcHJvZ3Jlc3NpdmVMb2FkOiBjb25maWcgJiYgY29uZmlnLnByb2dyZXNzaXZlTG9hZCB8fCBmYWxzZSxcbiAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IGNvbmZpZyAmJiBjb25maWcucHJlc2VydmVBc3BlY3RSYXRpbyB8fCAneE1pZFlNaWQgbWVldCcsXG4gICAgICBpbWFnZVByZXNlcnZlQXNwZWN0UmF0aW86IGNvbmZpZyAmJiBjb25maWcuaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvIHx8ICd4TWlkWU1pZCBzbGljZScsXG4gICAgICBjb250ZW50VmlzaWJpbGl0eTogY29uZmlnICYmIGNvbmZpZy5jb250ZW50VmlzaWJpbGl0eSB8fCAndmlzaWJsZScsXG4gICAgICBjbGFzc05hbWU6IGNvbmZpZyAmJiBjb25maWcuY2xhc3NOYW1lIHx8ICcnLFxuICAgICAgaWQ6IGNvbmZpZyAmJiBjb25maWcuaWQgfHwgJycsXG4gICAgICBydW5FeHByZXNzaW9uczogIWNvbmZpZyB8fCBjb25maWcucnVuRXhwcmVzc2lvbnMgPT09IHVuZGVmaW5lZCB8fCBjb25maWcucnVuRXhwcmVzc2lvbnNcbiAgICB9O1xuICAgIHRoaXMucmVuZGVyQ29uZmlnLmRwciA9IGNvbmZpZyAmJiBjb25maWcuZHByIHx8IDE7XG5cbiAgICBpZiAodGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyQ29uZmlnLmRwciA9IGNvbmZpZyAmJiBjb25maWcuZHByIHx8IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJlZEZyYW1lID0gLTE7XG4gICAgdGhpcy5nbG9iYWxEYXRhID0ge1xuICAgICAgZnJhbWVOdW06IC0xLFxuICAgICAgX21kZjogZmFsc2UsXG4gICAgICByZW5kZXJDb25maWc6IHRoaXMucmVuZGVyQ29uZmlnLFxuICAgICAgY3VycmVudEdsb2JhbEFscGhhOiAtMVxuICAgIH07XG4gICAgdGhpcy5jb250ZXh0RGF0YSA9IG5ldyBDVkNvbnRleHREYXRhKCk7XG4gICAgdGhpcy5lbGVtZW50cyA9IFtdO1xuICAgIHRoaXMucGVuZGluZ0VsZW1lbnRzID0gW107XG4gICAgdGhpcy50cmFuc2Zvcm1NYXQgPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy5jb21wbGV0ZUxheWVycyA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyZXJUeXBlID0gJ2NhbnZhcyc7XG5cbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcuY2xlYXJDYW52YXMpIHtcbiAgICAgIHRoaXMuY3R4VHJhbnNmb3JtID0gdGhpcy5jb250ZXh0RGF0YS50cmFuc2Zvcm0uYmluZCh0aGlzLmNvbnRleHREYXRhKTtcbiAgICAgIHRoaXMuY3R4T3BhY2l0eSA9IHRoaXMuY29udGV4dERhdGEub3BhY2l0eS5iaW5kKHRoaXMuY29udGV4dERhdGEpO1xuICAgICAgdGhpcy5jdHhGaWxsU3R5bGUgPSB0aGlzLmNvbnRleHREYXRhLmZpbGxTdHlsZS5iaW5kKHRoaXMuY29udGV4dERhdGEpO1xuICAgICAgdGhpcy5jdHhTdHJva2VTdHlsZSA9IHRoaXMuY29udGV4dERhdGEuc3Ryb2tlU3R5bGUuYmluZCh0aGlzLmNvbnRleHREYXRhKTtcbiAgICAgIHRoaXMuY3R4TGluZVdpZHRoID0gdGhpcy5jb250ZXh0RGF0YS5saW5lV2lkdGguYmluZCh0aGlzLmNvbnRleHREYXRhKTtcbiAgICAgIHRoaXMuY3R4TGluZUNhcCA9IHRoaXMuY29udGV4dERhdGEubGluZUNhcC5iaW5kKHRoaXMuY29udGV4dERhdGEpO1xuICAgICAgdGhpcy5jdHhMaW5lSm9pbiA9IHRoaXMuY29udGV4dERhdGEubGluZUpvaW4uYmluZCh0aGlzLmNvbnRleHREYXRhKTtcbiAgICAgIHRoaXMuY3R4TWl0ZXJMaW1pdCA9IHRoaXMuY29udGV4dERhdGEubWl0ZXJMaW1pdC5iaW5kKHRoaXMuY29udGV4dERhdGEpO1xuICAgICAgdGhpcy5jdHhGaWxsID0gdGhpcy5jb250ZXh0RGF0YS5maWxsLmJpbmQodGhpcy5jb250ZXh0RGF0YSk7XG4gICAgICB0aGlzLmN0eEZpbGxSZWN0ID0gdGhpcy5jb250ZXh0RGF0YS5maWxsUmVjdC5iaW5kKHRoaXMuY29udGV4dERhdGEpO1xuICAgICAgdGhpcy5jdHhTdHJva2UgPSB0aGlzLmNvbnRleHREYXRhLnN0cm9rZS5iaW5kKHRoaXMuY29udGV4dERhdGEpO1xuICAgICAgdGhpcy5zYXZlID0gdGhpcy5jb250ZXh0RGF0YS5zYXZlLmJpbmQodGhpcy5jb250ZXh0RGF0YSk7XG4gICAgfVxuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtDYW52YXNSZW5kZXJlckJhc2VdLCBDYW52YXNSZW5kZXJlcik7XG5cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUNvbXAgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQ1ZDb21wRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEhCYXNlRWxlbWVudCgpIHt9XG5cbiAgSEJhc2VFbGVtZW50LnByb3RvdHlwZSA9IHtcbiAgICBjaGVja0JsZW5kTW9kZTogZnVuY3Rpb24gY2hlY2tCbGVuZE1vZGUoKSB7fSxcbiAgICBpbml0UmVuZGVyZXJFbGVtZW50OiBmdW5jdGlvbiBpbml0UmVuZGVyZXJFbGVtZW50KCkge1xuICAgICAgdGhpcy5iYXNlRWxlbWVudCA9IGNyZWF0ZVRhZyh0aGlzLmRhdGEudGcgfHwgJ2RpdicpO1xuXG4gICAgICBpZiAodGhpcy5kYXRhLmhhc01hc2spIHtcbiAgICAgICAgdGhpcy5zdmdFbGVtZW50ID0gY3JlYXRlTlMoJ3N2ZycpO1xuICAgICAgICB0aGlzLmxheWVyRWxlbWVudCA9IGNyZWF0ZU5TKCdnJyk7XG4gICAgICAgIHRoaXMubWFza2VkRWxlbWVudCA9IHRoaXMubGF5ZXJFbGVtZW50O1xuICAgICAgICB0aGlzLnN2Z0VsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5sYXllckVsZW1lbnQpO1xuICAgICAgICB0aGlzLmJhc2VFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuc3ZnRWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxheWVyRWxlbWVudCA9IHRoaXMuYmFzZUVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIHN0eWxlRGl2KHRoaXMuYmFzZUVsZW1lbnQpO1xuICAgIH0sXG4gICAgY3JlYXRlQ29udGFpbmVyRWxlbWVudHM6IGZ1bmN0aW9uIGNyZWF0ZUNvbnRhaW5lckVsZW1lbnRzKCkge1xuICAgICAgdGhpcy5yZW5kZXJhYmxlRWZmZWN0c01hbmFnZXIgPSBuZXcgQ1ZFZmZlY3RzKHRoaXMpO1xuICAgICAgdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQgPSB0aGlzLmJhc2VFbGVtZW50O1xuICAgICAgdGhpcy5tYXNrZWRFbGVtZW50ID0gdGhpcy5sYXllckVsZW1lbnQ7XG5cbiAgICAgIGlmICh0aGlzLmRhdGEubG4pIHtcbiAgICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuZGF0YS5sbik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRhdGEuY2wpIHtcbiAgICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIHRoaXMuZGF0YS5jbCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRhdGEuYm0gIT09IDApIHtcbiAgICAgICAgdGhpcy5zZXRCbGVuZE1vZGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlckVsZW1lbnQ6IGZ1bmN0aW9uIHJlbmRlckVsZW1lbnQoKSB7XG4gICAgICB2YXIgdHJhbnNmb3JtZWRFbGVtZW50U3R5bGUgPSB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudCA/IHRoaXMudHJhbnNmb3JtZWRFbGVtZW50LnN0eWxlIDoge307XG5cbiAgICAgIGlmICh0aGlzLmZpbmFsVHJhbnNmb3JtLl9tYXRNZGYpIHtcbiAgICAgICAgdmFyIG1hdHJpeFZhbHVlID0gdGhpcy5maW5hbFRyYW5zZm9ybS5tYXQudG9DU1MoKTtcbiAgICAgICAgdHJhbnNmb3JtZWRFbGVtZW50U3R5bGUudHJhbnNmb3JtID0gbWF0cml4VmFsdWU7XG4gICAgICAgIHRyYW5zZm9ybWVkRWxlbWVudFN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IG1hdHJpeFZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5fb3BNZGYpIHtcbiAgICAgICAgdHJhbnNmb3JtZWRFbGVtZW50U3R5bGUub3BhY2l0eSA9IHRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3Auby52O1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyRnJhbWU6IGZ1bmN0aW9uIHJlbmRlckZyYW1lKCkge1xuICAgICAgLy8gSWYgaXQgaXMgZXhwb3J0ZWQgYXMgaGlkZGVuIChkYXRhLmhkID09PSB0cnVlKSBubyBuZWVkIHRvIHJlbmRlclxuICAgICAgLy8gSWYgaXQgaXMgbm90IHZpc2libGUgbm8gbmVlZCB0byByZW5kZXJcbiAgICAgIGlmICh0aGlzLmRhdGEuaGQgfHwgdGhpcy5oaWRkZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbmRlclRyYW5zZm9ybSgpO1xuICAgICAgdGhpcy5yZW5kZXJSZW5kZXJhYmxlKCk7XG4gICAgICB0aGlzLnJlbmRlckVsZW1lbnQoKTtcbiAgICAgIHRoaXMucmVuZGVySW5uZXJDb250ZW50KCk7XG5cbiAgICAgIGlmICh0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcbiAgICAgICAgdGhpcy5faXNGaXJzdEZyYW1lID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQgPSBudWxsO1xuICAgICAgdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQgPSBudWxsO1xuXG4gICAgICBpZiAodGhpcy5tYXR0ZUVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5tYXR0ZUVsZW1lbnQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5tYXNrTWFuYWdlcikge1xuICAgICAgICB0aGlzLm1hc2tNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tYXNrTWFuYWdlciA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVSZW5kZXJhYmxlQ29tcG9uZW50czogZnVuY3Rpb24gY3JlYXRlUmVuZGVyYWJsZUNvbXBvbmVudHMoKSB7XG4gICAgICB0aGlzLm1hc2tNYW5hZ2VyID0gbmV3IE1hc2tFbGVtZW50KHRoaXMuZGF0YSwgdGhpcywgdGhpcy5nbG9iYWxEYXRhKTtcbiAgICB9LFxuICAgIGFkZEVmZmVjdHM6IGZ1bmN0aW9uIGFkZEVmZmVjdHMoKSB7fSxcbiAgICBzZXRNYXR0ZTogZnVuY3Rpb24gc2V0TWF0dGUoKSB7fVxuICB9O1xuICBIQmFzZUVsZW1lbnQucHJvdG90eXBlLmdldEJhc2VFbGVtZW50ID0gU1ZHQmFzZUVsZW1lbnQucHJvdG90eXBlLmdldEJhc2VFbGVtZW50O1xuICBIQmFzZUVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3lCYXNlRWxlbWVudCA9IEhCYXNlRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveTtcbiAgSEJhc2VFbGVtZW50LnByb3RvdHlwZS5idWlsZEVsZW1lbnRQYXJlbnRpbmcgPSBCYXNlUmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkRWxlbWVudFBhcmVudGluZztcblxuICBmdW5jdGlvbiBIU29saWRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgSEJhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVET01FbGVtZW50XSwgSFNvbGlkRWxlbWVudCk7XG5cbiAgSFNvbGlkRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVjdDtcblxuICAgIGlmICh0aGlzLmRhdGEuaGFzTWFzaykge1xuICAgICAgcmVjdCA9IGNyZWF0ZU5TKCdyZWN0Jyk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLmRhdGEuc3cpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuZGF0YS5zaCk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZSgnZmlsbCcsIHRoaXMuZGF0YS5zYyk7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuZGF0YS5zdyk7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmRhdGEuc2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWN0ID0gY3JlYXRlVGFnKCdkaXYnKTtcbiAgICAgIHJlY3Quc3R5bGUud2lkdGggPSB0aGlzLmRhdGEuc3cgKyAncHgnO1xuICAgICAgcmVjdC5zdHlsZS5oZWlnaHQgPSB0aGlzLmRhdGEuc2ggKyAncHgnO1xuICAgICAgcmVjdC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmRhdGEuc2M7XG4gICAgfVxuXG4gICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQocmVjdCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gSFNoYXBlRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgLy8gTGlzdCBvZiBkcmF3YWJsZSBlbGVtZW50c1xuICAgIHRoaXMuc2hhcGVzID0gW107IC8vIEZ1bGwgc2hhcGUgZGF0YVxuXG4gICAgdGhpcy5zaGFwZXNEYXRhID0gZGF0YS5zaGFwZXM7IC8vIExpc3Qgb2Ygc3R5bGVzIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHNoYXBlc1xuXG4gICAgdGhpcy5zdHlsZXNMaXN0ID0gW107IC8vIExpc3Qgb2YgbW9kaWZpZXJzIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHNoYXBlc1xuXG4gICAgdGhpcy5zaGFwZU1vZGlmaWVycyA9IFtdOyAvLyBMaXN0IG9mIGl0ZW1zIGluIHNoYXBlIHRyZWVcblxuICAgIHRoaXMuaXRlbXNEYXRhID0gW107IC8vIExpc3Qgb2YgaXRlbXMgaW4gcHJldmlvdXMgc2hhcGUgdHJlZVxuXG4gICAgdGhpcy5wcm9jZXNzZWRFbGVtZW50cyA9IFtdOyAvLyBMaXN0IG9mIGFuaW1hdGVkIGNvbXBvbmVudHNcblxuICAgIHRoaXMuYW5pbWF0ZWRDb250ZW50cyA9IFtdO1xuICAgIHRoaXMuc2hhcGVzQ29udGFpbmVyID0gY3JlYXRlTlMoJ2cnKTtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApOyAvLyBNb3ZpbmcgYW55IHByb3BlcnR5IHRoYXQgZG9lc24ndCBnZXQgdG9vIG11Y2ggYWNjZXNzIGFmdGVyIGluaXRpYWxpemF0aW9uIGJlY2F1c2Ugb2Ygdjggd2F5IG9mIGhhbmRsaW5nIG1vcmUgdGhhbiAxMCBwcm9wZXJ0aWVzLlxuICAgIC8vIExpc3Qgb2YgZWxlbWVudHMgdGhhdCBoYXZlIGJlZW4gY3JlYXRlZFxuXG4gICAgdGhpcy5wcmV2Vmlld0RhdGEgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnRCQm94ID0ge1xuICAgICAgeDogOTk5OTk5LFxuICAgICAgeTogLTk5OTk5OSxcbiAgICAgIGg6IDAsXG4gICAgICB3OiAwXG4gICAgfTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIEhTb2xpZEVsZW1lbnQsIFNWR1NoYXBlRWxlbWVudCwgSEJhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVFbGVtZW50XSwgSFNoYXBlRWxlbWVudCk7XG4gIEhTaGFwZUVsZW1lbnQucHJvdG90eXBlLl9yZW5kZXJTaGFwZUZyYW1lID0gSFNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50O1xuXG4gIEhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnQ7XG4gICAgdGhpcy5iYXNlRWxlbWVudC5zdHlsZS5mb250U2l6ZSA9IDA7XG5cbiAgICBpZiAodGhpcy5kYXRhLmhhc01hc2spIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuc2hhcGVzQ29udGFpbmVyKTtcbiAgICAgIGNvbnQgPSB0aGlzLnN2Z0VsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnQgPSBjcmVhdGVOUygnc3ZnJyk7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuY29tcC5kYXRhID8gdGhpcy5jb21wLmRhdGEgOiB0aGlzLmdsb2JhbERhdGEuY29tcFNpemU7XG4gICAgICBjb250LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBzaXplLncpO1xuICAgICAgY29udC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHNpemUuaCk7XG4gICAgICBjb250LmFwcGVuZENoaWxkKHRoaXMuc2hhcGVzQ29udGFpbmVyKTtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKGNvbnQpO1xuICAgIH1cblxuICAgIHRoaXMuc2VhcmNoU2hhcGVzKHRoaXMuc2hhcGVzRGF0YSwgdGhpcy5pdGVtc0RhdGEsIHRoaXMucHJldlZpZXdEYXRhLCB0aGlzLnNoYXBlc0NvbnRhaW5lciwgMCwgW10sIHRydWUpO1xuICAgIHRoaXMuZmlsdGVyVW5pcXVlU2hhcGVzKCk7XG4gICAgdGhpcy5zaGFwZUNvbnQgPSBjb250O1xuICB9O1xuXG4gIEhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmdldFRyYW5zZm9ybWVkUG9pbnQgPSBmdW5jdGlvbiAodHJhbnNmb3JtZXJzLCBwb2ludCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0cmFuc2Zvcm1lcnMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBwb2ludCA9IHRyYW5zZm9ybWVyc1tpXS5tUHJvcHMudi5hcHBseVRvUG9pbnRBcnJheShwb2ludFswXSwgcG9pbnRbMV0sIDApO1xuICAgIH1cblxuICAgIHJldHVybiBwb2ludDtcbiAgfTtcblxuICBIU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jYWxjdWxhdGVTaGFwZUJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKGl0ZW0sIGJvdW5kaW5nQm94KSB7XG4gICAgdmFyIHNoYXBlID0gaXRlbS5zaC52O1xuICAgIHZhciB0cmFuc2Zvcm1lcnMgPSBpdGVtLnRyYW5zZm9ybWVycztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gc2hhcGUuX2xlbmd0aDtcbiAgICB2YXIgdlBvaW50O1xuICAgIHZhciBvUG9pbnQ7XG4gICAgdmFyIG5leHRJUG9pbnQ7XG4gICAgdmFyIG5leHRWUG9pbnQ7XG5cbiAgICBpZiAobGVuIDw9IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuIC0gMTsgaSArPSAxKSB7XG4gICAgICB2UG9pbnQgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnQodHJhbnNmb3JtZXJzLCBzaGFwZS52W2ldKTtcbiAgICAgIG9Qb2ludCA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludCh0cmFuc2Zvcm1lcnMsIHNoYXBlLm9baV0pO1xuICAgICAgbmV4dElQb2ludCA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludCh0cmFuc2Zvcm1lcnMsIHNoYXBlLmlbaSArIDFdKTtcbiAgICAgIG5leHRWUG9pbnQgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnQodHJhbnNmb3JtZXJzLCBzaGFwZS52W2kgKyAxXSk7XG4gICAgICB0aGlzLmNoZWNrQm91bmRzKHZQb2ludCwgb1BvaW50LCBuZXh0SVBvaW50LCBuZXh0VlBvaW50LCBib3VuZGluZ0JveCk7XG4gICAgfVxuXG4gICAgaWYgKHNoYXBlLmMpIHtcbiAgICAgIHZQb2ludCA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludCh0cmFuc2Zvcm1lcnMsIHNoYXBlLnZbaV0pO1xuICAgICAgb1BvaW50ID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50KHRyYW5zZm9ybWVycywgc2hhcGUub1tpXSk7XG4gICAgICBuZXh0SVBvaW50ID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50KHRyYW5zZm9ybWVycywgc2hhcGUuaVswXSk7XG4gICAgICBuZXh0VlBvaW50ID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50KHRyYW5zZm9ybWVycywgc2hhcGUudlswXSk7XG4gICAgICB0aGlzLmNoZWNrQm91bmRzKHZQb2ludCwgb1BvaW50LCBuZXh0SVBvaW50LCBuZXh0VlBvaW50LCBib3VuZGluZ0JveCk7XG4gICAgfVxuICB9O1xuXG4gIEhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNoZWNrQm91bmRzID0gZnVuY3Rpb24gKHZQb2ludCwgb1BvaW50LCBuZXh0SVBvaW50LCBuZXh0VlBvaW50LCBib3VuZGluZ0JveCkge1xuICAgIHRoaXMuZ2V0Qm91bmRzT2ZDdXJ2ZSh2UG9pbnQsIG9Qb2ludCwgbmV4dElQb2ludCwgbmV4dFZQb2ludCk7XG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuc2hhcGVCb3VuZGluZ0JveDtcbiAgICBib3VuZGluZ0JveC54ID0gYm1NaW4oYm91bmRzLmxlZnQsIGJvdW5kaW5nQm94LngpO1xuICAgIGJvdW5kaW5nQm94LnhNYXggPSBibU1heChib3VuZHMucmlnaHQsIGJvdW5kaW5nQm94LnhNYXgpO1xuICAgIGJvdW5kaW5nQm94LnkgPSBibU1pbihib3VuZHMudG9wLCBib3VuZGluZ0JveC55KTtcbiAgICBib3VuZGluZ0JveC55TWF4ID0gYm1NYXgoYm91bmRzLmJvdHRvbSwgYm91bmRpbmdCb3gueU1heCk7XG4gIH07XG5cbiAgSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuc2hhcGVCb3VuZGluZ0JveCA9IHtcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIHRvcDogMCxcbiAgICBib3R0b206IDBcbiAgfTtcbiAgSFNoYXBlRWxlbWVudC5wcm90b3R5cGUudGVtcEJvdW5kaW5nQm94ID0ge1xuICAgIHg6IDAsXG4gICAgeE1heDogMCxcbiAgICB5OiAwLFxuICAgIHlNYXg6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH07XG5cbiAgSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuZ2V0Qm91bmRzT2ZDdXJ2ZSA9IGZ1bmN0aW9uIChwMCwgcDEsIHAyLCBwMykge1xuICAgIHZhciBib3VuZHMgPSBbW3AwWzBdLCBwM1swXV0sIFtwMFsxXSwgcDNbMV1dXTtcblxuICAgIGZvciAodmFyIGEsIGIsIGMsIHQsIGIyYWMsIHQxLCB0MiwgaSA9IDA7IGkgPCAyOyArK2kpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGx1c3BsdXNcbiAgICAgIGIgPSA2ICogcDBbaV0gLSAxMiAqIHAxW2ldICsgNiAqIHAyW2ldO1xuICAgICAgYSA9IC0zICogcDBbaV0gKyA5ICogcDFbaV0gLSA5ICogcDJbaV0gKyAzICogcDNbaV07XG4gICAgICBjID0gMyAqIHAxW2ldIC0gMyAqIHAwW2ldO1xuICAgICAgYiB8PSAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWJpdHdpc2VcblxuICAgICAgYSB8PSAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWJpdHdpc2VcblxuICAgICAgYyB8PSAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWJpdHdpc2VcblxuICAgICAgaWYgKGEgPT09IDAgJiYgYiA9PT0gMCkgey8vXG4gICAgICB9IGVsc2UgaWYgKGEgPT09IDApIHtcbiAgICAgICAgdCA9IC1jIC8gYjtcblxuICAgICAgICBpZiAodCA+IDAgJiYgdCA8IDEpIHtcbiAgICAgICAgICBib3VuZHNbaV0ucHVzaCh0aGlzLmNhbGN1bGF0ZUYodCwgcDAsIHAxLCBwMiwgcDMsIGkpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYjJhYyA9IGIgKiBiIC0gNCAqIGMgKiBhO1xuXG4gICAgICAgIGlmIChiMmFjID49IDApIHtcbiAgICAgICAgICB0MSA9ICgtYiArIGJtU3FydChiMmFjKSkgLyAoMiAqIGEpO1xuICAgICAgICAgIGlmICh0MSA+IDAgJiYgdDEgPCAxKSBib3VuZHNbaV0ucHVzaCh0aGlzLmNhbGN1bGF0ZUYodDEsIHAwLCBwMSwgcDIsIHAzLCBpKSk7XG4gICAgICAgICAgdDIgPSAoLWIgLSBibVNxcnQoYjJhYykpIC8gKDIgKiBhKTtcbiAgICAgICAgICBpZiAodDIgPiAwICYmIHQyIDwgMSkgYm91bmRzW2ldLnB1c2godGhpcy5jYWxjdWxhdGVGKHQyLCBwMCwgcDEsIHAyLCBwMywgaSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zaGFwZUJvdW5kaW5nQm94LmxlZnQgPSBibU1pbi5hcHBseShudWxsLCBib3VuZHNbMF0pO1xuICAgIHRoaXMuc2hhcGVCb3VuZGluZ0JveC50b3AgPSBibU1pbi5hcHBseShudWxsLCBib3VuZHNbMV0pO1xuICAgIHRoaXMuc2hhcGVCb3VuZGluZ0JveC5yaWdodCA9IGJtTWF4LmFwcGx5KG51bGwsIGJvdW5kc1swXSk7XG4gICAgdGhpcy5zaGFwZUJvdW5kaW5nQm94LmJvdHRvbSA9IGJtTWF4LmFwcGx5KG51bGwsIGJvdW5kc1sxXSk7XG4gIH07XG5cbiAgSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuY2FsY3VsYXRlRiA9IGZ1bmN0aW9uICh0LCBwMCwgcDEsIHAyLCBwMywgaSkge1xuICAgIHJldHVybiBibVBvdygxIC0gdCwgMykgKiBwMFtpXSArIDMgKiBibVBvdygxIC0gdCwgMikgKiB0ICogcDFbaV0gKyAzICogKDEgLSB0KSAqIGJtUG93KHQsIDIpICogcDJbaV0gKyBibVBvdyh0LCAzKSAqIHAzW2ldO1xuICB9O1xuXG4gIEhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNhbGN1bGF0ZUJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKGl0ZW1zRGF0YSwgYm91bmRpbmdCb3gpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gaXRlbXNEYXRhLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKGl0ZW1zRGF0YVtpXSAmJiBpdGVtc0RhdGFbaV0uc2gpIHtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVTaGFwZUJvdW5kaW5nQm94KGl0ZW1zRGF0YVtpXSwgYm91bmRpbmdCb3gpO1xuICAgICAgfSBlbHNlIGlmIChpdGVtc0RhdGFbaV0gJiYgaXRlbXNEYXRhW2ldLml0KSB7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQm91bmRpbmdCb3goaXRlbXNEYXRhW2ldLml0LCBib3VuZGluZ0JveCk7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW1zRGF0YVtpXSAmJiBpdGVtc0RhdGFbaV0uc3R5bGUgJiYgaXRlbXNEYXRhW2ldLncpIHtcbiAgICAgICAgdGhpcy5leHBhbmRTdHJva2VCb3VuZGluZ0JveChpdGVtc0RhdGFbaV0udywgYm91bmRpbmdCb3gpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBIU2hhcGVFbGVtZW50LnByb3RvdHlwZS5leHBhbmRTdHJva2VCb3VuZGluZ0JveCA9IGZ1bmN0aW9uICh3aWR0aFByb3BlcnR5LCBib3VuZGluZ0JveCkge1xuICAgIHZhciB3aWR0aCA9IDA7XG5cbiAgICBpZiAod2lkdGhQcm9wZXJ0eS5rZXlmcmFtZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd2lkdGhQcm9wZXJ0eS5rZXlmcmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGtmdyA9IHdpZHRoUHJvcGVydHkua2V5ZnJhbWVzW2ldLnM7XG5cbiAgICAgICAgaWYgKGtmdyA+IHdpZHRoKSB7XG4gICAgICAgICAgd2lkdGggPSBrZnc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2lkdGggKj0gd2lkdGhQcm9wZXJ0eS5tdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aCA9IHdpZHRoUHJvcGVydHkudiAqIHdpZHRoUHJvcGVydHkubXVsdDtcbiAgICB9XG5cbiAgICBib3VuZGluZ0JveC54IC09IHdpZHRoO1xuICAgIGJvdW5kaW5nQm94LnhNYXggKz0gd2lkdGg7XG4gICAgYm91bmRpbmdCb3gueSAtPSB3aWR0aDtcbiAgICBib3VuZGluZ0JveC55TWF4ICs9IHdpZHRoO1xuICB9O1xuXG4gIEhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmN1cnJlbnRCb3hDb250YWlucyA9IGZ1bmN0aW9uIChib3gpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50QkJveC54IDw9IGJveC54ICYmIHRoaXMuY3VycmVudEJCb3gueSA8PSBib3gueSAmJiB0aGlzLmN1cnJlbnRCQm94LndpZHRoICsgdGhpcy5jdXJyZW50QkJveC54ID49IGJveC54ICsgYm94LndpZHRoICYmIHRoaXMuY3VycmVudEJCb3guaGVpZ2h0ICsgdGhpcy5jdXJyZW50QkJveC55ID49IGJveC55ICsgYm94LmhlaWdodDtcbiAgfTtcblxuICBIU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcmVuZGVyU2hhcGVGcmFtZSgpO1xuXG4gICAgaWYgKCF0aGlzLmhpZGRlbiAmJiAodGhpcy5faXNGaXJzdEZyYW1lIHx8IHRoaXMuX21kZikpIHtcbiAgICAgIHZhciB0ZW1wQm91bmRpbmdCb3ggPSB0aGlzLnRlbXBCb3VuZGluZ0JveDtcbiAgICAgIHZhciBtYXggPSA5OTk5OTk7XG4gICAgICB0ZW1wQm91bmRpbmdCb3gueCA9IG1heDtcbiAgICAgIHRlbXBCb3VuZGluZ0JveC54TWF4ID0gLW1heDtcbiAgICAgIHRlbXBCb3VuZGluZ0JveC55ID0gbWF4O1xuICAgICAgdGVtcEJvdW5kaW5nQm94LnlNYXggPSAtbWF4O1xuICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZGluZ0JveCh0aGlzLml0ZW1zRGF0YSwgdGVtcEJvdW5kaW5nQm94KTtcbiAgICAgIHRlbXBCb3VuZGluZ0JveC53aWR0aCA9IHRlbXBCb3VuZGluZ0JveC54TWF4IDwgdGVtcEJvdW5kaW5nQm94LnggPyAwIDogdGVtcEJvdW5kaW5nQm94LnhNYXggLSB0ZW1wQm91bmRpbmdCb3gueDtcbiAgICAgIHRlbXBCb3VuZGluZ0JveC5oZWlnaHQgPSB0ZW1wQm91bmRpbmdCb3gueU1heCA8IHRlbXBCb3VuZGluZ0JveC55ID8gMCA6IHRlbXBCb3VuZGluZ0JveC55TWF4IC0gdGVtcEJvdW5kaW5nQm94Lnk7IC8vIHZhciB0ZW1wQm91bmRpbmdCb3ggPSB0aGlzLnNoYXBlQ29udC5nZXRCQm94KCk7XG5cbiAgICAgIGlmICh0aGlzLmN1cnJlbnRCb3hDb250YWlucyh0ZW1wQm91bmRpbmdCb3gpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMuY3VycmVudEJCb3gudyAhPT0gdGVtcEJvdW5kaW5nQm94LndpZHRoKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3gudyA9IHRlbXBCb3VuZGluZ0JveC53aWR0aDtcbiAgICAgICAgdGhpcy5zaGFwZUNvbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRlbXBCb3VuZGluZ0JveC53aWR0aCk7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jdXJyZW50QkJveC5oICE9PSB0ZW1wQm91bmRpbmdCb3guaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3guaCA9IHRlbXBCb3VuZGluZ0JveC5oZWlnaHQ7XG4gICAgICAgIHRoaXMuc2hhcGVDb250LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGVtcEJvdW5kaW5nQm94LmhlaWdodCk7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlZCB8fCB0aGlzLmN1cnJlbnRCQm94LnggIT09IHRlbXBCb3VuZGluZ0JveC54IHx8IHRoaXMuY3VycmVudEJCb3gueSAhPT0gdGVtcEJvdW5kaW5nQm94LnkpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50QkJveC53ID0gdGVtcEJvdW5kaW5nQm94LndpZHRoO1xuICAgICAgICB0aGlzLmN1cnJlbnRCQm94LmggPSB0ZW1wQm91bmRpbmdCb3guaGVpZ2h0O1xuICAgICAgICB0aGlzLmN1cnJlbnRCQm94LnggPSB0ZW1wQm91bmRpbmdCb3gueDtcbiAgICAgICAgdGhpcy5jdXJyZW50QkJveC55ID0gdGVtcEJvdW5kaW5nQm94Lnk7XG4gICAgICAgIHRoaXMuc2hhcGVDb250LnNldEF0dHJpYnV0ZSgndmlld0JveCcsIHRoaXMuY3VycmVudEJCb3gueCArICcgJyArIHRoaXMuY3VycmVudEJCb3gueSArICcgJyArIHRoaXMuY3VycmVudEJCb3gudyArICcgJyArIHRoaXMuY3VycmVudEJCb3guaCk7XG4gICAgICAgIHZhciBzaGFwZVN0eWxlID0gdGhpcy5zaGFwZUNvbnQuc3R5bGU7XG4gICAgICAgIHZhciBzaGFwZVRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJyArIHRoaXMuY3VycmVudEJCb3gueCArICdweCwnICsgdGhpcy5jdXJyZW50QkJveC55ICsgJ3B4KSc7XG4gICAgICAgIHNoYXBlU3R5bGUudHJhbnNmb3JtID0gc2hhcGVUcmFuc2Zvcm07XG4gICAgICAgIHNoYXBlU3R5bGUud2Via2l0VHJhbnNmb3JtID0gc2hhcGVUcmFuc2Zvcm07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIEhUZXh0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy50ZXh0U3BhbnMgPSBbXTtcbiAgICB0aGlzLnRleHRQYXRocyA9IFtdO1xuICAgIHRoaXMuY3VycmVudEJCb3ggPSB7XG4gICAgICB4OiA5OTk5OTksXG4gICAgICB5OiAtOTk5OTk5LFxuICAgICAgaDogMCxcbiAgICAgIHc6IDBcbiAgICB9O1xuICAgIHRoaXMucmVuZGVyVHlwZSA9ICdzdmcnO1xuICAgIHRoaXMuaXNNYXNrZWQgPSBmYWxzZTtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgSEJhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVET01FbGVtZW50LCBJVGV4dEVsZW1lbnRdLCBIVGV4dEVsZW1lbnQpO1xuXG4gIEhUZXh0RWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzTWFza2VkID0gdGhpcy5jaGVja01hc2tzKCk7XG5cbiAgICBpZiAodGhpcy5pc01hc2tlZCkge1xuICAgICAgdGhpcy5yZW5kZXJUeXBlID0gJ3N2Zyc7XG4gICAgICB0aGlzLmNvbXBXID0gdGhpcy5jb21wLmRhdGEudztcbiAgICAgIHRoaXMuY29tcEggPSB0aGlzLmNvbXAuZGF0YS5oO1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLmNvbXBXKTtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuY29tcEgpO1xuICAgICAgdmFyIGcgPSBjcmVhdGVOUygnZycpO1xuICAgICAgdGhpcy5tYXNrZWRFbGVtZW50LmFwcGVuZENoaWxkKGcpO1xuICAgICAgdGhpcy5pbm5lckVsZW0gPSBnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbmRlclR5cGUgPSAnaHRtbCc7XG4gICAgICB0aGlzLmlubmVyRWxlbSA9IHRoaXMubGF5ZXJFbGVtZW50O1xuICAgIH1cblxuICAgIHRoaXMuY2hlY2tQYXJlbnRpbmcoKTtcbiAgfTtcblxuICBIVGV4dEVsZW1lbnQucHJvdG90eXBlLmJ1aWxkTmV3VGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZG9jdW1lbnREYXRhID0gdGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGE7XG4gICAgdGhpcy5yZW5kZXJlZExldHRlcnMgPSBjcmVhdGVTaXplZEFycmF5KGRvY3VtZW50RGF0YS5sID8gZG9jdW1lbnREYXRhLmwubGVuZ3RoIDogMCk7XG4gICAgdmFyIGlubmVyRWxlbVN0eWxlID0gdGhpcy5pbm5lckVsZW0uc3R5bGU7XG4gICAgdmFyIHRleHRDb2xvciA9IGRvY3VtZW50RGF0YS5mYyA/IHRoaXMuYnVpbGRDb2xvcihkb2N1bWVudERhdGEuZmMpIDogJ3JnYmEoMCwwLDAsMCknO1xuICAgIGlubmVyRWxlbVN0eWxlLmZpbGwgPSB0ZXh0Q29sb3I7XG4gICAgaW5uZXJFbGVtU3R5bGUuY29sb3IgPSB0ZXh0Q29sb3I7XG5cbiAgICBpZiAoZG9jdW1lbnREYXRhLnNjKSB7XG4gICAgICBpbm5lckVsZW1TdHlsZS5zdHJva2UgPSB0aGlzLmJ1aWxkQ29sb3IoZG9jdW1lbnREYXRhLnNjKTtcbiAgICAgIGlubmVyRWxlbVN0eWxlLnN0cm9rZVdpZHRoID0gZG9jdW1lbnREYXRhLnN3ICsgJ3B4JztcbiAgICB9XG5cbiAgICB2YXIgZm9udERhdGEgPSB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuZ2V0Rm9udEJ5TmFtZShkb2N1bWVudERhdGEuZik7XG5cbiAgICBpZiAoIXRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5jaGFycykge1xuICAgICAgaW5uZXJFbGVtU3R5bGUuZm9udFNpemUgPSBkb2N1bWVudERhdGEuZmluYWxTaXplICsgJ3B4JztcbiAgICAgIGlubmVyRWxlbVN0eWxlLmxpbmVIZWlnaHQgPSBkb2N1bWVudERhdGEuZmluYWxTaXplICsgJ3B4JztcblxuICAgICAgaWYgKGZvbnREYXRhLmZDbGFzcykge1xuICAgICAgICB0aGlzLmlubmVyRWxlbS5jbGFzc05hbWUgPSBmb250RGF0YS5mQ2xhc3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbm5lckVsZW1TdHlsZS5mb250RmFtaWx5ID0gZm9udERhdGEuZkZhbWlseTtcbiAgICAgICAgdmFyIGZXZWlnaHQgPSBkb2N1bWVudERhdGEuZldlaWdodDtcbiAgICAgICAgdmFyIGZTdHlsZSA9IGRvY3VtZW50RGF0YS5mU3R5bGU7XG4gICAgICAgIGlubmVyRWxlbVN0eWxlLmZvbnRTdHlsZSA9IGZTdHlsZTtcbiAgICAgICAgaW5uZXJFbGVtU3R5bGUuZm9udFdlaWdodCA9IGZXZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcbiAgICB2YXIgbGV0dGVycyA9IGRvY3VtZW50RGF0YS5sO1xuICAgIGxlbiA9IGxldHRlcnMubGVuZ3RoO1xuICAgIHZhciB0U3BhbjtcbiAgICB2YXIgdFBhcmVudDtcbiAgICB2YXIgdENvbnQ7XG4gICAgdmFyIG1hdHJpeEhlbHBlciA9IHRoaXMubUhlbHBlcjtcbiAgICB2YXIgc2hhcGVzO1xuICAgIHZhciBzaGFwZVN0ciA9ICcnO1xuICAgIHZhciBjbnQgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAodGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmNoYXJzKSB7XG4gICAgICAgIGlmICghdGhpcy50ZXh0UGF0aHNbY250XSkge1xuICAgICAgICAgIHRTcGFuID0gY3JlYXRlTlMoJ3BhdGgnKTtcbiAgICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgbGluZUNhcEVudW1bMV0pO1xuICAgICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgbGluZUpvaW5FbnVtWzJdKTtcbiAgICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1taXRlcmxpbWl0JywgJzQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0U3BhbiA9IHRoaXMudGV4dFBhdGhzW2NudF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuaXNNYXNrZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy50ZXh0U3BhbnNbY250XSkge1xuICAgICAgICAgICAgdFBhcmVudCA9IHRoaXMudGV4dFNwYW5zW2NudF07XG4gICAgICAgICAgICB0Q29udCA9IHRQYXJlbnQuY2hpbGRyZW5bMF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRQYXJlbnQgPSBjcmVhdGVUYWcoJ2RpdicpO1xuICAgICAgICAgICAgdFBhcmVudC5zdHlsZS5saW5lSGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIHRDb250ID0gY3JlYXRlTlMoJ3N2ZycpO1xuICAgICAgICAgICAgdENvbnQuYXBwZW5kQ2hpbGQodFNwYW4pO1xuICAgICAgICAgICAgc3R5bGVEaXYodFBhcmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLmlzTWFza2VkKSB7XG4gICAgICAgIGlmICh0aGlzLnRleHRTcGFuc1tjbnRdKSB7XG4gICAgICAgICAgdFBhcmVudCA9IHRoaXMudGV4dFNwYW5zW2NudF07XG4gICAgICAgICAgdFNwYW4gPSB0aGlzLnRleHRQYXRoc1tjbnRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRQYXJlbnQgPSBjcmVhdGVUYWcoJ3NwYW4nKTtcbiAgICAgICAgICBzdHlsZURpdih0UGFyZW50KTtcbiAgICAgICAgICB0U3BhbiA9IGNyZWF0ZVRhZygnc3BhbicpO1xuICAgICAgICAgIHN0eWxlRGl2KHRTcGFuKTtcbiAgICAgICAgICB0UGFyZW50LmFwcGVuZENoaWxkKHRTcGFuKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdFNwYW4gPSB0aGlzLnRleHRQYXRoc1tjbnRdID8gdGhpcy50ZXh0UGF0aHNbY250XSA6IGNyZWF0ZU5TKCd0ZXh0Jyk7XG4gICAgICB9IC8vIHRTcGFuLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcblxuXG4gICAgICBpZiAodGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmNoYXJzKSB7XG4gICAgICAgIHZhciBjaGFyRGF0YSA9IHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRDaGFyRGF0YShkb2N1bWVudERhdGEuZmluYWxUZXh0W2ldLCBmb250RGF0YS5mU3R5bGUsIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKS5mRmFtaWx5KTtcbiAgICAgICAgdmFyIHNoYXBlRGF0YTtcblxuICAgICAgICBpZiAoY2hhckRhdGEpIHtcbiAgICAgICAgICBzaGFwZURhdGEgPSBjaGFyRGF0YS5kYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNoYXBlRGF0YSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBtYXRyaXhIZWxwZXIucmVzZXQoKTtcblxuICAgICAgICBpZiAoc2hhcGVEYXRhICYmIHNoYXBlRGF0YS5zaGFwZXMgJiYgc2hhcGVEYXRhLnNoYXBlcy5sZW5ndGgpIHtcbiAgICAgICAgICBzaGFwZXMgPSBzaGFwZURhdGEuc2hhcGVzWzBdLml0O1xuICAgICAgICAgIG1hdHJpeEhlbHBlci5zY2FsZShkb2N1bWVudERhdGEuZmluYWxTaXplIC8gMTAwLCBkb2N1bWVudERhdGEuZmluYWxTaXplIC8gMTAwKTtcbiAgICAgICAgICBzaGFwZVN0ciA9IHRoaXMuY3JlYXRlUGF0aFNoYXBlKG1hdHJpeEhlbHBlciwgc2hhcGVzKTtcbiAgICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ2QnLCBzaGFwZVN0cik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuaXNNYXNrZWQpIHtcbiAgICAgICAgICB0aGlzLmlubmVyRWxlbS5hcHBlbmRDaGlsZCh0UGFyZW50KTtcblxuICAgICAgICAgIGlmIChzaGFwZURhdGEgJiYgc2hhcGVEYXRhLnNoYXBlcykge1xuICAgICAgICAgICAgLy8gZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCBpcyBuZWVkZWQgdG8gZ2V0IGV4YWN0IG1lYXN1cmUgb2Ygc2hhcGVcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodENvbnQpO1xuICAgICAgICAgICAgdmFyIGJvdW5kaW5nQm94ID0gdENvbnQuZ2V0QkJveCgpO1xuICAgICAgICAgICAgdENvbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGJvdW5kaW5nQm94LndpZHRoICsgMik7XG4gICAgICAgICAgICB0Q29udC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGJvdW5kaW5nQm94LmhlaWdodCArIDIpO1xuICAgICAgICAgICAgdENvbnQuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgYm91bmRpbmdCb3gueCAtIDEgKyAnICcgKyAoYm91bmRpbmdCb3gueSAtIDEpICsgJyAnICsgKGJvdW5kaW5nQm94LndpZHRoICsgMikgKyAnICcgKyAoYm91bmRpbmdCb3guaGVpZ2h0ICsgMikpO1xuICAgICAgICAgICAgdmFyIHRDb250U3R5bGUgPSB0Q29udC5zdHlsZTtcbiAgICAgICAgICAgIHZhciB0Q29udFRyYW5zbGF0aW9uID0gJ3RyYW5zbGF0ZSgnICsgKGJvdW5kaW5nQm94LnggLSAxKSArICdweCwnICsgKGJvdW5kaW5nQm94LnkgLSAxKSArICdweCknO1xuICAgICAgICAgICAgdENvbnRTdHlsZS50cmFuc2Zvcm0gPSB0Q29udFRyYW5zbGF0aW9uO1xuICAgICAgICAgICAgdENvbnRTdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSB0Q29udFRyYW5zbGF0aW9uO1xuICAgICAgICAgICAgbGV0dGVyc1tpXS55T2Zmc2V0ID0gYm91bmRpbmdCb3gueSAtIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRDb250LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAxKTtcbiAgICAgICAgICAgIHRDb250LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdFBhcmVudC5hcHBlbmRDaGlsZCh0Q29udCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5pbm5lckVsZW0uYXBwZW5kQ2hpbGQodFNwYW4pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0U3Bhbi50ZXh0Q29udGVudCA9IGxldHRlcnNbaV0udmFsO1xuICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJywgJ3htbDpzcGFjZScsICdwcmVzZXJ2ZScpO1xuXG4gICAgICAgIGlmICghdGhpcy5pc01hc2tlZCkge1xuICAgICAgICAgIHRoaXMuaW5uZXJFbGVtLmFwcGVuZENoaWxkKHRQYXJlbnQpOyAvL1xuXG4gICAgICAgICAgdmFyIHRTdHlsZSA9IHRTcGFuLnN0eWxlO1xuICAgICAgICAgIHZhciB0U3BhblRyYW5zbGF0aW9uID0gJ3RyYW5zbGF0ZTNkKDAsJyArIC1kb2N1bWVudERhdGEuZmluYWxTaXplIC8gMS4yICsgJ3B4LDApJztcbiAgICAgICAgICB0U3R5bGUudHJhbnNmb3JtID0gdFNwYW5UcmFuc2xhdGlvbjtcbiAgICAgICAgICB0U3R5bGUud2Via2l0VHJhbnNmb3JtID0gdFNwYW5UcmFuc2xhdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmlubmVyRWxlbS5hcHBlbmRDaGlsZCh0U3Bhbik7XG4gICAgICAgIH1cbiAgICAgIH0gLy9cblxuXG4gICAgICBpZiAoIXRoaXMuaXNNYXNrZWQpIHtcbiAgICAgICAgdGhpcy50ZXh0U3BhbnNbY250XSA9IHRQYXJlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRleHRTcGFuc1tjbnRdID0gdFNwYW47XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGV4dFNwYW5zW2NudF0uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLnRleHRQYXRoc1tjbnRdID0gdFNwYW47XG4gICAgICBjbnQgKz0gMTtcbiAgICB9XG5cbiAgICB3aGlsZSAoY250IDwgdGhpcy50ZXh0U3BhbnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnRleHRTcGFuc1tjbnRdLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICBjbnQgKz0gMTtcbiAgICB9XG4gIH07XG5cbiAgSFRleHRFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy52YWxpZGF0ZVRleHQoKTtcbiAgICB2YXIgc3ZnU3R5bGU7XG5cbiAgICBpZiAodGhpcy5kYXRhLnNpbmdsZVNoYXBlKSB7XG4gICAgICBpZiAoIXRoaXMuX2lzRmlyc3RGcmFtZSAmJiAhdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc01hc2tlZCAmJiB0aGlzLmZpbmFsVHJhbnNmb3JtLl9tYXRNZGYpIHtcbiAgICAgICAgLy8gVG9kbyBCZW5jaG1hcmsgaWYgdXNpbmcgdGhpcyBpcyBiZXR0ZXIgdGhhbiBnZXRCQm94XG4gICAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCAtdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5wLnZbMF0gKyAnICcgKyAtdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5wLnZbMV0gKyAnICcgKyB0aGlzLmNvbXBXICsgJyAnICsgdGhpcy5jb21wSCk7XG4gICAgICAgIHN2Z1N0eWxlID0gdGhpcy5zdmdFbGVtZW50LnN0eWxlO1xuICAgICAgICB2YXIgdHJhbnNsYXRpb24gPSAndHJhbnNsYXRlKCcgKyAtdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5wLnZbMF0gKyAncHgsJyArIC10aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLnAudlsxXSArICdweCknO1xuICAgICAgICBzdmdTdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2xhdGlvbjtcbiAgICAgICAgc3ZnU3R5bGUud2Via2l0VHJhbnNmb3JtID0gdHJhbnNsYXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0QW5pbWF0b3IuZ2V0TWVhc3VyZXModGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGEsIHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnKTtcblxuICAgIGlmICghdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcgJiYgIXRoaXMudGV4dEFuaW1hdG9yLmxldHRlcnNDaGFuZ2VkRmxhZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgcmVuZGVyZWRMZXR0ZXJzID0gdGhpcy50ZXh0QW5pbWF0b3IucmVuZGVyZWRMZXR0ZXJzO1xuICAgIHZhciBsZXR0ZXJzID0gdGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGEubDtcbiAgICBsZW4gPSBsZXR0ZXJzLmxlbmd0aDtcbiAgICB2YXIgcmVuZGVyZWRMZXR0ZXI7XG4gICAgdmFyIHRleHRTcGFuO1xuICAgIHZhciB0ZXh0UGF0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKGxldHRlcnNbaV0ubikge1xuICAgICAgICBjb3VudCArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dFNwYW4gPSB0aGlzLnRleHRTcGFuc1tpXTtcbiAgICAgICAgdGV4dFBhdGggPSB0aGlzLnRleHRQYXRoc1tpXTtcbiAgICAgICAgcmVuZGVyZWRMZXR0ZXIgPSByZW5kZXJlZExldHRlcnNbY291bnRdO1xuICAgICAgICBjb3VudCArPSAxO1xuXG4gICAgICAgIGlmIChyZW5kZXJlZExldHRlci5fbWRmLm0pIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNNYXNrZWQpIHtcbiAgICAgICAgICAgIHRleHRTcGFuLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHJlbmRlcmVkTGV0dGVyLm07XG4gICAgICAgICAgICB0ZXh0U3Bhbi5zdHlsZS50cmFuc2Zvcm0gPSByZW5kZXJlZExldHRlci5tO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIHJlbmRlcmVkTGV0dGVyLm0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLy8gL3RleHRTcGFuLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScscmVuZGVyZWRMZXR0ZXIubyk7XG5cblxuICAgICAgICB0ZXh0U3Bhbi5zdHlsZS5vcGFjaXR5ID0gcmVuZGVyZWRMZXR0ZXIubztcblxuICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIuc3cgJiYgcmVuZGVyZWRMZXR0ZXIuX21kZi5zdykge1xuICAgICAgICAgIHRleHRQYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgcmVuZGVyZWRMZXR0ZXIuc3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyLnNjICYmIHJlbmRlcmVkTGV0dGVyLl9tZGYuc2MpIHtcbiAgICAgICAgICB0ZXh0UGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIHJlbmRlcmVkTGV0dGVyLnNjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW5kZXJlZExldHRlci5mYyAmJiByZW5kZXJlZExldHRlci5fbWRmLmZjKSB7XG4gICAgICAgICAgdGV4dFBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgcmVuZGVyZWRMZXR0ZXIuZmMpO1xuICAgICAgICAgIHRleHRQYXRoLnN0eWxlLmNvbG9yID0gcmVuZGVyZWRMZXR0ZXIuZmM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5pbm5lckVsZW0uZ2V0QkJveCAmJiAhdGhpcy5oaWRkZW4gJiYgKHRoaXMuX2lzRmlyc3RGcmFtZSB8fCB0aGlzLl9tZGYpKSB7XG4gICAgICB2YXIgYm91bmRpbmdCb3ggPSB0aGlzLmlubmVyRWxlbS5nZXRCQm94KCk7XG5cbiAgICAgIGlmICh0aGlzLmN1cnJlbnRCQm94LncgIT09IGJvdW5kaW5nQm94LndpZHRoKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3gudyA9IGJvdW5kaW5nQm94LndpZHRoO1xuICAgICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGJvdW5kaW5nQm94LndpZHRoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY3VycmVudEJCb3guaCAhPT0gYm91bmRpbmdCb3guaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3guaCA9IGJvdW5kaW5nQm94LmhlaWdodDtcbiAgICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgYm91bmRpbmdCb3guaGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hcmdpbiA9IDE7XG5cbiAgICAgIGlmICh0aGlzLmN1cnJlbnRCQm94LncgIT09IGJvdW5kaW5nQm94LndpZHRoICsgbWFyZ2luICogMiB8fCB0aGlzLmN1cnJlbnRCQm94LmggIT09IGJvdW5kaW5nQm94LmhlaWdodCArIG1hcmdpbiAqIDIgfHwgdGhpcy5jdXJyZW50QkJveC54ICE9PSBib3VuZGluZ0JveC54IC0gbWFyZ2luIHx8IHRoaXMuY3VycmVudEJCb3gueSAhPT0gYm91bmRpbmdCb3gueSAtIG1hcmdpbikge1xuICAgICAgICB0aGlzLmN1cnJlbnRCQm94LncgPSBib3VuZGluZ0JveC53aWR0aCArIG1hcmdpbiAqIDI7XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3guaCA9IGJvdW5kaW5nQm94LmhlaWdodCArIG1hcmdpbiAqIDI7XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3gueCA9IGJvdW5kaW5nQm94LnggLSBtYXJnaW47XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3gueSA9IGJvdW5kaW5nQm94LnkgLSBtYXJnaW47XG4gICAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCB0aGlzLmN1cnJlbnRCQm94LnggKyAnICcgKyB0aGlzLmN1cnJlbnRCQm94LnkgKyAnICcgKyB0aGlzLmN1cnJlbnRCQm94LncgKyAnICcgKyB0aGlzLmN1cnJlbnRCQm94LmgpO1xuICAgICAgICBzdmdTdHlsZSA9IHRoaXMuc3ZnRWxlbWVudC5zdHlsZTtcbiAgICAgICAgdmFyIHN2Z1RyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJyArIHRoaXMuY3VycmVudEJCb3gueCArICdweCwnICsgdGhpcy5jdXJyZW50QkJveC55ICsgJ3B4KSc7XG4gICAgICAgIHN2Z1N0eWxlLnRyYW5zZm9ybSA9IHN2Z1RyYW5zZm9ybTtcbiAgICAgICAgc3ZnU3R5bGUud2Via2l0VHJhbnNmb3JtID0gc3ZnVHJhbnNmb3JtO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBIQ2FtZXJhRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy5pbml0RnJhbWUoKTtcbiAgICB0aGlzLmluaXRCYXNlRGF0YShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgICB0aGlzLmluaXRIaWVyYXJjaHkoKTtcbiAgICB2YXIgZ2V0UHJvcCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wO1xuICAgIHRoaXMucGUgPSBnZXRQcm9wKHRoaXMsIGRhdGEucGUsIDAsIDAsIHRoaXMpO1xuXG4gICAgaWYgKGRhdGEua3MucC5zKSB7XG4gICAgICB0aGlzLnB4ID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLnAueCwgMSwgMCwgdGhpcyk7XG4gICAgICB0aGlzLnB5ID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLnAueSwgMSwgMCwgdGhpcyk7XG4gICAgICB0aGlzLnB6ID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLnAueiwgMSwgMCwgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucCA9IGdldFByb3AodGhpcywgZGF0YS5rcy5wLCAxLCAwLCB0aGlzKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5rcy5hKSB7XG4gICAgICB0aGlzLmEgPSBnZXRQcm9wKHRoaXMsIGRhdGEua3MuYSwgMSwgMCwgdGhpcyk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEua3Mub3Iuay5sZW5ndGggJiYgZGF0YS5rcy5vci5rWzBdLnRvKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBkYXRhLmtzLm9yLmsubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgZGF0YS5rcy5vci5rW2ldLnRvID0gbnVsbDtcbiAgICAgICAgZGF0YS5rcy5vci5rW2ldLnRpID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm9yID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLm9yLCAxLCBkZWdUb1JhZHMsIHRoaXMpO1xuICAgIHRoaXMub3Iuc2ggPSB0cnVlO1xuICAgIHRoaXMucnggPSBnZXRQcm9wKHRoaXMsIGRhdGEua3MucngsIDAsIGRlZ1RvUmFkcywgdGhpcyk7XG4gICAgdGhpcy5yeSA9IGdldFByb3AodGhpcywgZGF0YS5rcy5yeSwgMCwgZGVnVG9SYWRzLCB0aGlzKTtcbiAgICB0aGlzLnJ6ID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLnJ6LCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xuICAgIHRoaXMubWF0ID0gbmV3IE1hdHJpeCgpO1xuICAgIHRoaXMuX3ByZXZNYXQgPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTsgLy8gVE9ETzogZmluZCBhIGJldHRlciB3YXkgdG8gbWFrZSB0aGUgSENhbWVyYSBlbGVtZW50IHRvIGJlIGNvbXBhdGlibGUgd2l0aCB0aGUgTGF5ZXJJbnRlcmZhY2UgYW5kIFRyYW5zZm9ybUludGVyZmFjZS5cblxuICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0gPSB7XG4gICAgICBtUHJvcDogdGhpc1xuICAgIH07XG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBGcmFtZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnRdLCBIQ2FtZXJhRWxlbWVudCk7XG5cbiAgSENhbWVyYUVsZW1lbnQucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmNvbXAudGhyZWVERWxlbWVudHMubGVuZ3RoO1xuICAgIHZhciBjb21wO1xuICAgIHZhciBwZXJzcGVjdGl2ZVN0eWxlO1xuICAgIHZhciBjb250YWluZXJTdHlsZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgLy8gW3BlcnNwZWN0aXZlRWxlbSxjb250YWluZXJdXG4gICAgICBjb21wID0gdGhpcy5jb21wLnRocmVlREVsZW1lbnRzW2ldO1xuXG4gICAgICBpZiAoY29tcC50eXBlID09PSAnM2QnKSB7XG4gICAgICAgIHBlcnNwZWN0aXZlU3R5bGUgPSBjb21wLnBlcnNwZWN0aXZlRWxlbS5zdHlsZTtcbiAgICAgICAgY29udGFpbmVyU3R5bGUgPSBjb21wLmNvbnRhaW5lci5zdHlsZTtcbiAgICAgICAgdmFyIHBlcnNwZWN0aXZlID0gdGhpcy5wZS52ICsgJ3B4JztcbiAgICAgICAgdmFyIG9yaWdpbiA9ICcwcHggMHB4IDBweCc7XG4gICAgICAgIHZhciBtYXRyaXggPSAnbWF0cml4M2QoMSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsMCwwLDAsMSknO1xuICAgICAgICBwZXJzcGVjdGl2ZVN0eWxlLnBlcnNwZWN0aXZlID0gcGVyc3BlY3RpdmU7XG4gICAgICAgIHBlcnNwZWN0aXZlU3R5bGUud2Via2l0UGVyc3BlY3RpdmUgPSBwZXJzcGVjdGl2ZTtcbiAgICAgICAgY29udGFpbmVyU3R5bGUudHJhbnNmb3JtT3JpZ2luID0gb3JpZ2luO1xuICAgICAgICBjb250YWluZXJTdHlsZS5tb3pUcmFuc2Zvcm1PcmlnaW4gPSBvcmlnaW47XG4gICAgICAgIGNvbnRhaW5lclN0eWxlLndlYmtpdFRyYW5zZm9ybU9yaWdpbiA9IG9yaWdpbjtcbiAgICAgICAgcGVyc3BlY3RpdmVTdHlsZS50cmFuc2Zvcm0gPSBtYXRyaXg7XG4gICAgICAgIHBlcnNwZWN0aXZlU3R5bGUud2Via2l0VHJhbnNmb3JtID0gbWF0cml4O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBIQ2FtZXJhRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBIQ2FtZXJhRWxlbWVudC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIEhDYW1lcmFFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX21kZiA9IHRoaXMuX2lzRmlyc3RGcmFtZTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuXG4gICAgaWYgKHRoaXMuaGllcmFyY2h5KSB7XG4gICAgICBsZW4gPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBfbWRmID0gdGhpcy5oaWVyYXJjaHlbaV0uZmluYWxUcmFuc2Zvcm0ubVByb3AuX21kZiB8fCBfbWRmO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChfbWRmIHx8IHRoaXMucGUuX21kZiB8fCB0aGlzLnAgJiYgdGhpcy5wLl9tZGYgfHwgdGhpcy5weCAmJiAodGhpcy5weC5fbWRmIHx8IHRoaXMucHkuX21kZiB8fCB0aGlzLnB6Ll9tZGYpIHx8IHRoaXMucnguX21kZiB8fCB0aGlzLnJ5Ll9tZGYgfHwgdGhpcy5yei5fbWRmIHx8IHRoaXMub3IuX21kZiB8fCB0aGlzLmEgJiYgdGhpcy5hLl9tZGYpIHtcbiAgICAgIHRoaXMubWF0LnJlc2V0KCk7XG5cbiAgICAgIGlmICh0aGlzLmhpZXJhcmNoeSkge1xuICAgICAgICBsZW4gPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGggLSAxO1xuXG4gICAgICAgIGZvciAoaSA9IGxlbjsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICB2YXIgbVRyYW5zZiA9IHRoaXMuaGllcmFyY2h5W2ldLmZpbmFsVHJhbnNmb3JtLm1Qcm9wO1xuICAgICAgICAgIHRoaXMubWF0LnRyYW5zbGF0ZSgtbVRyYW5zZi5wLnZbMF0sIC1tVHJhbnNmLnAudlsxXSwgbVRyYW5zZi5wLnZbMl0pO1xuICAgICAgICAgIHRoaXMubWF0LnJvdGF0ZVgoLW1UcmFuc2Yub3IudlswXSkucm90YXRlWSgtbVRyYW5zZi5vci52WzFdKS5yb3RhdGVaKG1UcmFuc2Yub3IudlsyXSk7XG4gICAgICAgICAgdGhpcy5tYXQucm90YXRlWCgtbVRyYW5zZi5yeC52KS5yb3RhdGVZKC1tVHJhbnNmLnJ5LnYpLnJvdGF0ZVoobVRyYW5zZi5yei52KTtcbiAgICAgICAgICB0aGlzLm1hdC5zY2FsZSgxIC8gbVRyYW5zZi5zLnZbMF0sIDEgLyBtVHJhbnNmLnMudlsxXSwgMSAvIG1UcmFuc2Yucy52WzJdKTtcbiAgICAgICAgICB0aGlzLm1hdC50cmFuc2xhdGUobVRyYW5zZi5hLnZbMF0sIG1UcmFuc2YuYS52WzFdLCBtVHJhbnNmLmEudlsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucCkge1xuICAgICAgICB0aGlzLm1hdC50cmFuc2xhdGUoLXRoaXMucC52WzBdLCAtdGhpcy5wLnZbMV0sIHRoaXMucC52WzJdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWF0LnRyYW5zbGF0ZSgtdGhpcy5weC52LCAtdGhpcy5weS52LCB0aGlzLnB6LnYpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5hKSB7XG4gICAgICAgIHZhciBkaWZmVmVjdG9yO1xuXG4gICAgICAgIGlmICh0aGlzLnApIHtcbiAgICAgICAgICBkaWZmVmVjdG9yID0gW3RoaXMucC52WzBdIC0gdGhpcy5hLnZbMF0sIHRoaXMucC52WzFdIC0gdGhpcy5hLnZbMV0sIHRoaXMucC52WzJdIC0gdGhpcy5hLnZbMl1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpZmZWZWN0b3IgPSBbdGhpcy5weC52IC0gdGhpcy5hLnZbMF0sIHRoaXMucHkudiAtIHRoaXMuYS52WzFdLCB0aGlzLnB6LnYgLSB0aGlzLmEudlsyXV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWFnID0gTWF0aC5zcXJ0KE1hdGgucG93KGRpZmZWZWN0b3JbMF0sIDIpICsgTWF0aC5wb3coZGlmZlZlY3RvclsxXSwgMikgKyBNYXRoLnBvdyhkaWZmVmVjdG9yWzJdLCAyKSk7IC8vIHZhciBsb29rRGlyID0gZ2V0Tm9ybWFsaXplZFBvaW50KGdldERpZmZWZWN0b3IodGhpcy5hLnYsdGhpcy5wLnYpKTtcblxuICAgICAgICB2YXIgbG9va0RpciA9IFtkaWZmVmVjdG9yWzBdIC8gbWFnLCBkaWZmVmVjdG9yWzFdIC8gbWFnLCBkaWZmVmVjdG9yWzJdIC8gbWFnXTtcbiAgICAgICAgdmFyIGxvb2tMZW5ndGhPblhaID0gTWF0aC5zcXJ0KGxvb2tEaXJbMl0gKiBsb29rRGlyWzJdICsgbG9va0RpclswXSAqIGxvb2tEaXJbMF0pO1xuICAgICAgICB2YXIgbVJvdGF0aW9uWCA9IE1hdGguYXRhbjIobG9va0RpclsxXSwgbG9va0xlbmd0aE9uWFopO1xuICAgICAgICB2YXIgbVJvdGF0aW9uWSA9IE1hdGguYXRhbjIobG9va0RpclswXSwgLWxvb2tEaXJbMl0pO1xuICAgICAgICB0aGlzLm1hdC5yb3RhdGVZKG1Sb3RhdGlvblkpLnJvdGF0ZVgoLW1Sb3RhdGlvblgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1hdC5yb3RhdGVYKC10aGlzLnJ4LnYpLnJvdGF0ZVkoLXRoaXMucnkudikucm90YXRlWih0aGlzLnJ6LnYpO1xuICAgICAgdGhpcy5tYXQucm90YXRlWCgtdGhpcy5vci52WzBdKS5yb3RhdGVZKC10aGlzLm9yLnZbMV0pLnJvdGF0ZVoodGhpcy5vci52WzJdKTtcbiAgICAgIHRoaXMubWF0LnRyYW5zbGF0ZSh0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudyAvIDIsIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oIC8gMiwgMCk7XG4gICAgICB0aGlzLm1hdC50cmFuc2xhdGUoMCwgMCwgdGhpcy5wZS52KTtcbiAgICAgIHZhciBoYXNNYXRyaXhDaGFuZ2VkID0gIXRoaXMuX3ByZXZNYXQuZXF1YWxzKHRoaXMubWF0KTtcblxuICAgICAgaWYgKChoYXNNYXRyaXhDaGFuZ2VkIHx8IHRoaXMucGUuX21kZikgJiYgdGhpcy5jb21wLnRocmVlREVsZW1lbnRzKSB7XG4gICAgICAgIGxlbiA9IHRoaXMuY29tcC50aHJlZURFbGVtZW50cy5sZW5ndGg7XG4gICAgICAgIHZhciBjb21wO1xuICAgICAgICB2YXIgcGVyc3BlY3RpdmVTdHlsZTtcbiAgICAgICAgdmFyIGNvbnRhaW5lclN0eWxlO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGNvbXAgPSB0aGlzLmNvbXAudGhyZWVERWxlbWVudHNbaV07XG5cbiAgICAgICAgICBpZiAoY29tcC50eXBlID09PSAnM2QnKSB7XG4gICAgICAgICAgICBpZiAoaGFzTWF0cml4Q2hhbmdlZCkge1xuICAgICAgICAgICAgICB2YXIgbWF0VmFsdWUgPSB0aGlzLm1hdC50b0NTUygpO1xuICAgICAgICAgICAgICBjb250YWluZXJTdHlsZSA9IGNvbXAuY29udGFpbmVyLnN0eWxlO1xuICAgICAgICAgICAgICBjb250YWluZXJTdHlsZS50cmFuc2Zvcm0gPSBtYXRWYWx1ZTtcbiAgICAgICAgICAgICAgY29udGFpbmVyU3R5bGUud2Via2l0VHJhbnNmb3JtID0gbWF0VmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnBlLl9tZGYpIHtcbiAgICAgICAgICAgICAgcGVyc3BlY3RpdmVTdHlsZSA9IGNvbXAucGVyc3BlY3RpdmVFbGVtLnN0eWxlO1xuICAgICAgICAgICAgICBwZXJzcGVjdGl2ZVN0eWxlLnBlcnNwZWN0aXZlID0gdGhpcy5wZS52ICsgJ3B4JztcbiAgICAgICAgICAgICAgcGVyc3BlY3RpdmVTdHlsZS53ZWJraXRQZXJzcGVjdGl2ZSA9IHRoaXMucGUudiArICdweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYXQuY2xvbmUodGhpcy5fcHJldk1hdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gZmFsc2U7XG4gIH07XG5cbiAgSENhbWVyYUVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdHJ1ZSk7XG4gIH07XG5cbiAgSENhbWVyYUVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBIQ2FtZXJhRWxlbWVudC5wcm90b3R5cGUuZ2V0QmFzZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgZnVuY3Rpb24gSEltYWdlRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy5hc3NldERhdGEgPSBnbG9iYWxEYXRhLmdldEFzc2V0RGF0YShkYXRhLnJlZklkKTtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgSEJhc2VFbGVtZW50LCBIU29saWRFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVFbGVtZW50XSwgSEltYWdlRWxlbWVudCk7XG5cbiAgSEltYWdlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXNzZXRQYXRoID0gdGhpcy5nbG9iYWxEYXRhLmdldEFzc2V0c1BhdGgodGhpcy5hc3NldERhdGEpO1xuICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcblxuICAgIGlmICh0aGlzLmRhdGEuaGFzTWFzaykge1xuICAgICAgdGhpcy5pbWFnZUVsZW0gPSBjcmVhdGVOUygnaW1hZ2UnKTtcbiAgICAgIHRoaXMuaW1hZ2VFbGVtLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLmFzc2V0RGF0YS53ICsgJ3B4Jyk7XG4gICAgICB0aGlzLmltYWdlRWxlbS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuYXNzZXREYXRhLmggKyAncHgnKTtcbiAgICAgIHRoaXMuaW1hZ2VFbGVtLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgJ2hyZWYnLCBhc3NldFBhdGgpO1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5pbWFnZUVsZW0pO1xuICAgICAgdGhpcy5iYXNlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5hc3NldERhdGEudyk7XG4gICAgICB0aGlzLmJhc2VFbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5hc3NldERhdGEuaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKGltZyk7XG4gICAgfVxuXG4gICAgaW1nLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XG4gICAgaW1nLnNyYyA9IGFzc2V0UGF0aDtcblxuICAgIGlmICh0aGlzLmRhdGEubG4pIHtcbiAgICAgIHRoaXMuYmFzZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuZGF0YS5sbik7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIEh5YnJpZFJlbmRlcmVyQmFzZShhbmltYXRpb25JdGVtLCBjb25maWcpIHtcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0gPSBhbmltYXRpb25JdGVtO1xuICAgIHRoaXMubGF5ZXJzID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlcmVkRnJhbWUgPSAtMTtcbiAgICB0aGlzLnJlbmRlckNvbmZpZyA9IHtcbiAgICAgIGNsYXNzTmFtZTogY29uZmlnICYmIGNvbmZpZy5jbGFzc05hbWUgfHwgJycsXG4gICAgICBpbWFnZVByZXNlcnZlQXNwZWN0UmF0aW86IGNvbmZpZyAmJiBjb25maWcuaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvIHx8ICd4TWlkWU1pZCBzbGljZScsXG4gICAgICBoaWRlT25UcmFuc3BhcmVudDogIShjb25maWcgJiYgY29uZmlnLmhpZGVPblRyYW5zcGFyZW50ID09PSBmYWxzZSksXG4gICAgICBmaWx0ZXJTaXplOiB7XG4gICAgICAgIHdpZHRoOiBjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUud2lkdGggfHwgJzQwMCUnLFxuICAgICAgICBoZWlnaHQ6IGNvbmZpZyAmJiBjb25maWcuZmlsdGVyU2l6ZSAmJiBjb25maWcuZmlsdGVyU2l6ZS5oZWlnaHQgfHwgJzQwMCUnLFxuICAgICAgICB4OiBjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUueCB8fCAnLTEwMCUnLFxuICAgICAgICB5OiBjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUueSB8fCAnLTEwMCUnXG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmdsb2JhbERhdGEgPSB7XG4gICAgICBfbWRmOiBmYWxzZSxcbiAgICAgIGZyYW1lTnVtOiAtMSxcbiAgICAgIHJlbmRlckNvbmZpZzogdGhpcy5yZW5kZXJDb25maWdcbiAgICB9O1xuICAgIHRoaXMucGVuZGluZ0VsZW1lbnRzID0gW107XG4gICAgdGhpcy5lbGVtZW50cyA9IFtdO1xuICAgIHRoaXMudGhyZWVERWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FtZXJhID0gbnVsbDtcbiAgICB0aGlzLnN1cHBvcnRzM2QgPSB0cnVlO1xuICAgIHRoaXMucmVuZGVyZXJUeXBlID0gJ2h0bWwnO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlUmVuZGVyZXJdLCBIeWJyaWRSZW5kZXJlckJhc2UpO1xuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLmJ1aWxkSXRlbSA9IFNWR1JlbmRlcmVyLnByb3RvdHlwZS5idWlsZEl0ZW07XG5cbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jaGVja1BlbmRpbmdFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB3aGlsZSAodGhpcy5wZW5kaW5nRWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGVuZGluZ0VsZW1lbnRzLnBvcCgpO1xuICAgICAgZWxlbWVudC5jaGVja1BhcmVudGluZygpO1xuICAgIH1cbiAgfTtcblxuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLmFwcGVuZEVsZW1lbnRJblBvcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBwb3MpIHtcbiAgICB2YXIgbmV3RE9NRWxlbWVudCA9IGVsZW1lbnQuZ2V0QmFzZUVsZW1lbnQoKTtcblxuICAgIGlmICghbmV3RE9NRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsYXllciA9IHRoaXMubGF5ZXJzW3Bvc107XG5cbiAgICBpZiAoIWxheWVyLmRkZCB8fCAhdGhpcy5zdXBwb3J0czNkKSB7XG4gICAgICBpZiAodGhpcy50aHJlZURFbGVtZW50cykge1xuICAgICAgICB0aGlzLmFkZFRvM2RDb250YWluZXIobmV3RE9NRWxlbWVudCwgcG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIG5leHRET01FbGVtZW50O1xuICAgICAgICB2YXIgbmV4dExheWVyO1xuICAgICAgICB2YXIgdG1wRE9NRWxlbWVudDtcblxuICAgICAgICB3aGlsZSAoaSA8IHBvcykge1xuICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldICYmIHRoaXMuZWxlbWVudHNbaV0gIT09IHRydWUgJiYgdGhpcy5lbGVtZW50c1tpXS5nZXRCYXNlRWxlbWVudCkge1xuICAgICAgICAgICAgbmV4dExheWVyID0gdGhpcy5lbGVtZW50c1tpXTtcbiAgICAgICAgICAgIHRtcERPTUVsZW1lbnQgPSB0aGlzLmxheWVyc1tpXS5kZGQgPyB0aGlzLmdldFRocmVlRENvbnRhaW5lckJ5UG9zKGkpIDogbmV4dExheWVyLmdldEJhc2VFbGVtZW50KCk7XG4gICAgICAgICAgICBuZXh0RE9NRWxlbWVudCA9IHRtcERPTUVsZW1lbnQgfHwgbmV4dERPTUVsZW1lbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRET01FbGVtZW50KSB7XG4gICAgICAgICAgaWYgKCFsYXllci5kZGQgfHwgIXRoaXMuc3VwcG9ydHMzZCkge1xuICAgICAgICAgICAgdGhpcy5sYXllckVsZW1lbnQuaW5zZXJ0QmVmb3JlKG5ld0RPTUVsZW1lbnQsIG5leHRET01FbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWxheWVyLmRkZCB8fCAhdGhpcy5zdXBwb3J0czNkKSB7XG4gICAgICAgICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQobmV3RE9NRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRUbzNkQ29udGFpbmVyKG5ld0RPTUVsZW1lbnQsIHBvcyk7XG4gICAgfVxuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlU2hhcGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmICghdGhpcy5zdXBwb3J0czNkKSB7XG4gICAgICByZXR1cm4gbmV3IFNWR1NoYXBlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSFNoYXBlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlVGV4dCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKCF0aGlzLnN1cHBvcnRzM2QpIHtcbiAgICAgIHJldHVybiBuZXcgU1ZHVGV4dExvdHRpZUVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEhUZXh0RWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlQ2FtZXJhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB0aGlzLmNhbWVyYSA9IG5ldyBIQ2FtZXJhRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzLmNhbWVyYTtcbiAgfTtcblxuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLmNyZWF0ZUltYWdlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuc3VwcG9ydHMzZCkge1xuICAgICAgcmV0dXJuIG5ldyBJSW1hZ2VFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBISW1hZ2VFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jcmVhdGVTb2xpZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKCF0aGlzLnN1cHBvcnRzM2QpIHtcbiAgICAgIHJldHVybiBuZXcgSVNvbGlkRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSFNvbGlkRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlTnVsbCA9IFNWR1JlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVOdWxsO1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuZ2V0VGhyZWVEQ29udGFpbmVyQnlQb3MgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSB0aGlzLnRocmVlREVsZW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAodGhpcy50aHJlZURFbGVtZW50c1tpXS5zdGFydFBvcyA8PSBwb3MgJiYgdGhpcy50aHJlZURFbGVtZW50c1tpXS5lbmRQb3MgPj0gcG9zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRocmVlREVsZW1lbnRzW2ldLnBlcnNwZWN0aXZlRWxlbTtcbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlVGhyZWVEQ29udGFpbmVyID0gZnVuY3Rpb24gKHBvcywgdHlwZSkge1xuICAgIHZhciBwZXJzcGVjdGl2ZUVsZW0gPSBjcmVhdGVUYWcoJ2RpdicpO1xuICAgIHZhciBzdHlsZTtcbiAgICB2YXIgY29udGFpbmVyU3R5bGU7XG4gICAgc3R5bGVEaXYocGVyc3BlY3RpdmVFbGVtKTtcbiAgICB2YXIgY29udGFpbmVyID0gY3JlYXRlVGFnKCdkaXYnKTtcbiAgICBzdHlsZURpdihjb250YWluZXIpO1xuXG4gICAgaWYgKHR5cGUgPT09ICczZCcpIHtcbiAgICAgIHN0eWxlID0gcGVyc3BlY3RpdmVFbGVtLnN0eWxlO1xuICAgICAgc3R5bGUud2lkdGggPSB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudyArICdweCc7XG4gICAgICBzdHlsZS5oZWlnaHQgPSB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaCArICdweCc7XG4gICAgICB2YXIgY2VudGVyID0gJzUwJSA1MCUnO1xuICAgICAgc3R5bGUud2Via2l0VHJhbnNmb3JtT3JpZ2luID0gY2VudGVyO1xuICAgICAgc3R5bGUubW96VHJhbnNmb3JtT3JpZ2luID0gY2VudGVyO1xuICAgICAgc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gY2VudGVyO1xuICAgICAgY29udGFpbmVyU3R5bGUgPSBjb250YWluZXIuc3R5bGU7XG4gICAgICB2YXIgbWF0cml4ID0gJ21hdHJpeDNkKDEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLDAsMCwwLDEpJztcbiAgICAgIGNvbnRhaW5lclN0eWxlLnRyYW5zZm9ybSA9IG1hdHJpeDtcbiAgICAgIGNvbnRhaW5lclN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IG1hdHJpeDtcbiAgICB9XG5cbiAgICBwZXJzcGVjdGl2ZUVsZW0uYXBwZW5kQ2hpbGQoY29udGFpbmVyKTsgLy8gdGhpcy5yZXNpemVyRWxlbS5hcHBlbmRDaGlsZChwZXJzcGVjdGl2ZUVsZW0pO1xuXG4gICAgdmFyIHRocmVlRENvbnRhaW5lckRhdGEgPSB7XG4gICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgIHBlcnNwZWN0aXZlRWxlbTogcGVyc3BlY3RpdmVFbGVtLFxuICAgICAgc3RhcnRQb3M6IHBvcyxcbiAgICAgIGVuZFBvczogcG9zLFxuICAgICAgdHlwZTogdHlwZVxuICAgIH07XG4gICAgdGhpcy50aHJlZURFbGVtZW50cy5wdXNoKHRocmVlRENvbnRhaW5lckRhdGEpO1xuICAgIHJldHVybiB0aHJlZURDb250YWluZXJEYXRhO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuYnVpbGQzZENvbnRhaW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMubGF5ZXJzLmxlbmd0aDtcbiAgICB2YXIgbGFzdFRocmVlRENvbnRhaW5lckRhdGE7XG4gICAgdmFyIGN1cnJlbnRDb250YWluZXIgPSAnJztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMubGF5ZXJzW2ldLmRkZCAmJiB0aGlzLmxheWVyc1tpXS50eSAhPT0gMykge1xuICAgICAgICBpZiAoY3VycmVudENvbnRhaW5lciAhPT0gJzNkJykge1xuICAgICAgICAgIGN1cnJlbnRDb250YWluZXIgPSAnM2QnO1xuICAgICAgICAgIGxhc3RUaHJlZURDb250YWluZXJEYXRhID0gdGhpcy5jcmVhdGVUaHJlZURDb250YWluZXIoaSwgJzNkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0VGhyZWVEQ29udGFpbmVyRGF0YS5lbmRQb3MgPSBNYXRoLm1heChsYXN0VGhyZWVEQ29udGFpbmVyRGF0YS5lbmRQb3MsIGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGN1cnJlbnRDb250YWluZXIgIT09ICcyZCcpIHtcbiAgICAgICAgICBjdXJyZW50Q29udGFpbmVyID0gJzJkJztcbiAgICAgICAgICBsYXN0VGhyZWVEQ29udGFpbmVyRGF0YSA9IHRoaXMuY3JlYXRlVGhyZWVEQ29udGFpbmVyKGksICcyZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFRocmVlRENvbnRhaW5lckRhdGEuZW5kUG9zID0gTWF0aC5tYXgobGFzdFRocmVlRENvbnRhaW5lckRhdGEuZW5kUG9zLCBpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZW4gPSB0aGlzLnRocmVlREVsZW1lbnRzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICB0aGlzLnJlc2l6ZXJFbGVtLmFwcGVuZENoaWxkKHRoaXMudGhyZWVERWxlbWVudHNbaV0ucGVyc3BlY3RpdmVFbGVtKTtcbiAgICB9XG4gIH07XG5cbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5hZGRUbzNkQ29udGFpbmVyID0gZnVuY3Rpb24gKGVsZW0sIHBvcykge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdGhpcy50aHJlZURFbGVtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgaWYgKHBvcyA8PSB0aGlzLnRocmVlREVsZW1lbnRzW2ldLmVuZFBvcykge1xuICAgICAgICB2YXIgaiA9IHRoaXMudGhyZWVERWxlbWVudHNbaV0uc3RhcnRQb3M7XG4gICAgICAgIHZhciBuZXh0RWxlbWVudDtcblxuICAgICAgICB3aGlsZSAoaiA8IHBvcykge1xuICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2pdICYmIHRoaXMuZWxlbWVudHNbal0uZ2V0QmFzZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIG5leHRFbGVtZW50ID0gdGhpcy5lbGVtZW50c1tqXS5nZXRCYXNlRWxlbWVudCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0RWxlbWVudCkge1xuICAgICAgICAgIHRoaXMudGhyZWVERWxlbWVudHNbaV0uY29udGFpbmVyLmluc2VydEJlZm9yZShlbGVtLCBuZXh0RWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50aHJlZURFbGVtZW50c1tpXS5jb250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgIH1cbiAgfTtcblxuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLmNvbmZpZ0FuaW1hdGlvbiA9IGZ1bmN0aW9uIChhbmltRGF0YSkge1xuICAgIHZhciByZXNpemVyRWxlbSA9IGNyZWF0ZVRhZygnZGl2Jyk7XG4gICAgdmFyIHdyYXBwZXIgPSB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlcjtcbiAgICB2YXIgc3R5bGUgPSByZXNpemVyRWxlbS5zdHlsZTtcbiAgICBzdHlsZS53aWR0aCA9IGFuaW1EYXRhLncgKyAncHgnO1xuICAgIHN0eWxlLmhlaWdodCA9IGFuaW1EYXRhLmggKyAncHgnO1xuICAgIHRoaXMucmVzaXplckVsZW0gPSByZXNpemVyRWxlbTtcbiAgICBzdHlsZURpdihyZXNpemVyRWxlbSk7XG4gICAgc3R5bGUudHJhbnNmb3JtU3R5bGUgPSAnZmxhdCc7XG4gICAgc3R5bGUubW96VHJhbnNmb3JtU3R5bGUgPSAnZmxhdCc7XG4gICAgc3R5bGUud2Via2l0VHJhbnNmb3JtU3R5bGUgPSAnZmxhdCc7XG5cbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcuY2xhc3NOYW1lKSB7XG4gICAgICByZXNpemVyRWxlbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdGhpcy5yZW5kZXJDb25maWcuY2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHJlc2l6ZXJFbGVtKTtcbiAgICBzdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgIHZhciBzdmcgPSBjcmVhdGVOUygnc3ZnJyk7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMScpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcxJyk7XG4gICAgc3R5bGVEaXYoc3ZnKTtcbiAgICB0aGlzLnJlc2l6ZXJFbGVtLmFwcGVuZENoaWxkKHN2Zyk7XG4gICAgdmFyIGRlZnMgPSBjcmVhdGVOUygnZGVmcycpO1xuICAgIHN2Zy5hcHBlbmRDaGlsZChkZWZzKTtcbiAgICB0aGlzLmRhdGEgPSBhbmltRGF0YTsgLy8gTWFzayBhbmltYXRpb25cblxuICAgIHRoaXMuc2V0dXBHbG9iYWxEYXRhKGFuaW1EYXRhLCBzdmcpO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzID0gZGVmcztcbiAgICB0aGlzLmxheWVycyA9IGFuaW1EYXRhLmxheWVycztcbiAgICB0aGlzLmxheWVyRWxlbWVudCA9IHRoaXMucmVzaXplckVsZW07XG4gICAgdGhpcy5idWlsZDNkQ29udGFpbmVycygpO1xuICAgIHRoaXMudXBkYXRlQ29udGFpbmVyU2l6ZSgpO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyLmlubmVyVGV4dCA9ICcnO1xuICAgIH1cblxuICAgIHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIgPSBudWxsO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzID0gbnVsbDtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5sYXllcnMgPyB0aGlzLmxheWVycy5sZW5ndGggOiAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAodGhpcy5lbGVtZW50c1tpXSAmJiB0aGlzLmVsZW1lbnRzW2ldLmRlc3Ryb3kpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0gPSBudWxsO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUudXBkYXRlQ29udGFpbmVyU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlbWVudFdpZHRoID0gdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIub2Zmc2V0V2lkdGg7XG4gICAgdmFyIGVsZW1lbnRIZWlnaHQgPSB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlci5vZmZzZXRIZWlnaHQ7XG4gICAgdmFyIGVsZW1lbnRSZWwgPSBlbGVtZW50V2lkdGggLyBlbGVtZW50SGVpZ2h0O1xuICAgIHZhciBhbmltYXRpb25SZWwgPSB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudyAvIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oO1xuICAgIHZhciBzeDtcbiAgICB2YXIgc3k7XG4gICAgdmFyIHR4O1xuICAgIHZhciB0eTtcblxuICAgIGlmIChhbmltYXRpb25SZWwgPiBlbGVtZW50UmVsKSB7XG4gICAgICBzeCA9IGVsZW1lbnRXaWR0aCAvIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53O1xuICAgICAgc3kgPSBlbGVtZW50V2lkdGggLyB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudztcbiAgICAgIHR4ID0gMDtcbiAgICAgIHR5ID0gKGVsZW1lbnRIZWlnaHQgLSB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaCAqIChlbGVtZW50V2lkdGggLyB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudykpIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3ggPSBlbGVtZW50SGVpZ2h0IC8gdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLmg7XG4gICAgICBzeSA9IGVsZW1lbnRIZWlnaHQgLyB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaDtcbiAgICAgIHR4ID0gKGVsZW1lbnRXaWR0aCAtIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53ICogKGVsZW1lbnRIZWlnaHQgLyB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaCkpIC8gMjtcbiAgICAgIHR5ID0gMDtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSB0aGlzLnJlc2l6ZXJFbGVtLnN0eWxlO1xuICAgIHN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdtYXRyaXgzZCgnICsgc3ggKyAnLDAsMCwwLDAsJyArIHN5ICsgJywwLDAsMCwwLDEsMCwnICsgdHggKyAnLCcgKyB0eSArICcsMCwxKSc7XG4gICAgc3R5bGUudHJhbnNmb3JtID0gc3R5bGUud2Via2l0VHJhbnNmb3JtO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBTVkdSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRnJhbWU7XG5cbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVzaXplckVsZW0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfTtcblxuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZXNpemVyRWxlbS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgfTtcblxuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLmluaXRJdGVtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmJ1aWxkQWxsSXRlbXMoKTtcblxuICAgIGlmICh0aGlzLmNhbWVyYSkge1xuICAgICAgdGhpcy5jYW1lcmEuc2V0dXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNXaWR0aCA9IHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53O1xuICAgICAgdmFyIGNIZWlnaHQgPSB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaDtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMudGhyZWVERWxlbWVudHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy50aHJlZURFbGVtZW50c1tpXS5wZXJzcGVjdGl2ZUVsZW0uc3R5bGU7XG4gICAgICAgIHN0eWxlLndlYmtpdFBlcnNwZWN0aXZlID0gTWF0aC5zcXJ0KE1hdGgucG93KGNXaWR0aCwgMikgKyBNYXRoLnBvdyhjSGVpZ2h0LCAyKSkgKyAncHgnO1xuICAgICAgICBzdHlsZS5wZXJzcGVjdGl2ZSA9IHN0eWxlLndlYmtpdFBlcnNwZWN0aXZlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLnNlYXJjaEV4dHJhQ29tcG9zaXRpb25zID0gZnVuY3Rpb24gKGFzc2V0cykge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBhc3NldHMubGVuZ3RoO1xuICAgIHZhciBmbG9hdGluZ0NvbnRhaW5lciA9IGNyZWF0ZVRhZygnZGl2Jyk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmIChhc3NldHNbaV0ueHQpIHtcbiAgICAgICAgdmFyIGNvbXAgPSB0aGlzLmNyZWF0ZUNvbXAoYXNzZXRzW2ldLCBmbG9hdGluZ0NvbnRhaW5lciwgdGhpcy5nbG9iYWxEYXRhLmNvbXAsIG51bGwpO1xuICAgICAgICBjb21wLmluaXRFeHByZXNzaW9ucygpO1xuICAgICAgICB0aGlzLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5yZWdpc3RlckNvbXBvc2l0aW9uKGNvbXApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBIQ29tcEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgIHRoaXMubGF5ZXJzID0gZGF0YS5sYXllcnM7XG4gICAgdGhpcy5zdXBwb3J0czNkID0gIWRhdGEuaGFzTWFzaztcbiAgICB0aGlzLmNvbXBsZXRlTGF5ZXJzID0gZmFsc2U7XG4gICAgdGhpcy5wZW5kaW5nRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLmVsZW1lbnRzID0gdGhpcy5sYXllcnMgPyBjcmVhdGVTaXplZEFycmF5KHRoaXMubGF5ZXJzLmxlbmd0aCkgOiBbXTtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICAgIHRoaXMudG0gPSBkYXRhLnRtID8gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS50bSwgMCwgZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIHRoaXMpIDoge1xuICAgICAgX3BsYWNlaG9sZGVyOiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbSHlicmlkUmVuZGVyZXJCYXNlLCBJQ29tcEVsZW1lbnQsIEhCYXNlRWxlbWVudF0sIEhDb21wRWxlbWVudCk7XG4gIEhDb21wRWxlbWVudC5wcm90b3R5cGUuX2NyZWF0ZUJhc2VDb250YWluZXJFbGVtZW50cyA9IEhDb21wRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGFpbmVyRWxlbWVudHM7XG5cbiAgSENvbXBFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250YWluZXJFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jcmVhdGVCYXNlQ29udGFpbmVyRWxlbWVudHMoKTsgLy8gZGl2RWxlbWVudC5zdHlsZS5jbGlwID0gJ3JlY3QoMHB4LCAnK3RoaXMuZGF0YS53KydweCwgJyt0aGlzLmRhdGEuaCsncHgsIDBweCknO1xuXG5cbiAgICBpZiAodGhpcy5kYXRhLmhhc01hc2spIHtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5kYXRhLncpO1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5kYXRhLmgpO1xuICAgICAgdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQgPSB0aGlzLmJhc2VFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudCA9IHRoaXMubGF5ZXJFbGVtZW50O1xuICAgIH1cbiAgfTtcblxuICBIQ29tcEVsZW1lbnQucHJvdG90eXBlLmFkZFRvM2RDb250YWluZXIgPSBmdW5jdGlvbiAoZWxlbSwgcG9zKSB7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBuZXh0RWxlbWVudDtcblxuICAgIHdoaWxlIChqIDwgcG9zKSB7XG4gICAgICBpZiAodGhpcy5lbGVtZW50c1tqXSAmJiB0aGlzLmVsZW1lbnRzW2pdLmdldEJhc2VFbGVtZW50KSB7XG4gICAgICAgIG5leHRFbGVtZW50ID0gdGhpcy5lbGVtZW50c1tqXS5nZXRCYXNlRWxlbWVudCgpO1xuICAgICAgfVxuXG4gICAgICBqICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKG5leHRFbGVtZW50KSB7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudC5pbnNlcnRCZWZvcmUoZWxlbSwgbmV4dEVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZChlbGVtKTtcbiAgICB9XG4gIH07XG5cbiAgSENvbXBFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb21wID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuc3VwcG9ydHMzZCkge1xuICAgICAgcmV0dXJuIG5ldyBTVkdDb21wRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSENvbXBFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gSHlicmlkUmVuZGVyZXIoYW5pbWF0aW9uSXRlbSwgY29uZmlnKSB7XG4gICAgdGhpcy5hbmltYXRpb25JdGVtID0gYW5pbWF0aW9uSXRlbTtcbiAgICB0aGlzLmxheWVycyA9IG51bGw7XG4gICAgdGhpcy5yZW5kZXJlZEZyYW1lID0gLTE7XG4gICAgdGhpcy5yZW5kZXJDb25maWcgPSB7XG4gICAgICBjbGFzc05hbWU6IGNvbmZpZyAmJiBjb25maWcuY2xhc3NOYW1lIHx8ICcnLFxuICAgICAgaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvOiBjb25maWcgJiYgY29uZmlnLmltYWdlUHJlc2VydmVBc3BlY3RSYXRpbyB8fCAneE1pZFlNaWQgc2xpY2UnLFxuICAgICAgaGlkZU9uVHJhbnNwYXJlbnQ6ICEoY29uZmlnICYmIGNvbmZpZy5oaWRlT25UcmFuc3BhcmVudCA9PT0gZmFsc2UpLFxuICAgICAgZmlsdGVyU2l6ZToge1xuICAgICAgICB3aWR0aDogY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLndpZHRoIHx8ICc0MDAlJyxcbiAgICAgICAgaGVpZ2h0OiBjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUuaGVpZ2h0IHx8ICc0MDAlJyxcbiAgICAgICAgeDogY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLnggfHwgJy0xMDAlJyxcbiAgICAgICAgeTogY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLnkgfHwgJy0xMDAlJ1xuICAgICAgfSxcbiAgICAgIHJ1bkV4cHJlc3Npb25zOiAhY29uZmlnIHx8IGNvbmZpZy5ydW5FeHByZXNzaW9ucyA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5ydW5FeHByZXNzaW9uc1xuICAgIH07XG4gICAgdGhpcy5nbG9iYWxEYXRhID0ge1xuICAgICAgX21kZjogZmFsc2UsXG4gICAgICBmcmFtZU51bTogLTEsXG4gICAgICByZW5kZXJDb25maWc6IHRoaXMucmVuZGVyQ29uZmlnXG4gICAgfTtcbiAgICB0aGlzLnBlbmRpbmdFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLnRocmVlREVsZW1lbnRzID0gW107XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhbWVyYSA9IG51bGw7XG4gICAgdGhpcy5zdXBwb3J0czNkID0gdHJ1ZTtcbiAgICB0aGlzLnJlbmRlcmVyVHlwZSA9ICdodG1sJztcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbSHlicmlkUmVuZGVyZXJCYXNlXSwgSHlicmlkUmVuZGVyZXIpO1xuXG4gIEh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVDb21wID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuc3VwcG9ydHMzZCkge1xuICAgICAgcmV0dXJuIG5ldyBTVkdDb21wRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSENvbXBFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgdmFyIENvbXBFeHByZXNzaW9uSW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY29tcCkge1xuICAgICAgZnVuY3Rpb24gX3RoaXNMYXllckZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gY29tcC5sYXllcnMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgaWYgKGNvbXAubGF5ZXJzW2ldLm5tID09PSBuYW1lIHx8IGNvbXAubGF5ZXJzW2ldLmluZCA9PT0gbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXAuZWxlbWVudHNbaV0ubGF5ZXJJbnRlcmZhY2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIHJldHVybiB7YWN0aXZlOmZhbHNlfTtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzTGF5ZXJGdW5jdGlvbiwgJ19uYW1lJywge1xuICAgICAgICB2YWx1ZTogY29tcC5kYXRhLm5tXG4gICAgICB9KTtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5sYXllciA9IF90aGlzTGF5ZXJGdW5jdGlvbjtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5waXhlbEFzcGVjdCA9IDE7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uaGVpZ2h0ID0gY29tcC5kYXRhLmggfHwgY29tcC5nbG9iYWxEYXRhLmNvbXBTaXplLmg7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24ud2lkdGggPSBjb21wLmRhdGEudyB8fCBjb21wLmdsb2JhbERhdGEuY29tcFNpemUudztcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5waXhlbEFzcGVjdCA9IDE7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uZnJhbWVEdXJhdGlvbiA9IDEgLyBjb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLmRpc3BsYXlTdGFydFRpbWUgPSAwO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLm51bUxheWVycyA9IGNvbXAubGF5ZXJzLmxlbmd0aDtcbiAgICAgIHJldHVybiBfdGhpc0xheWVyRnVuY3Rpb247XG4gICAgfTtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIF90eXBlb2YkMihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiQyID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YkMiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mJDIob2JqKTsgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlICovXG5cbiAgLypcclxuICAgQ29weXJpZ2h0IDIwMTQgRGF2aWQgQmF1LlxyXG5cclxuICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXHJcbiAgIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4gICBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuICAgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4gICBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cclxuICAgcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXHJcbiAgIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbiAgIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbiAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cclxuICAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcclxuICAgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCxcclxuICAgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEVcclxuICAgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcblxyXG4gICAqL1xuICBmdW5jdGlvbiBzZWVkUmFuZG9tKHBvb2wsIG1hdGgpIHtcbiAgICAvL1xuICAgIC8vIFRoZSBmb2xsb3dpbmcgY29uc3RhbnRzIGFyZSByZWxhdGVkIHRvIElFRUUgNzU0IGxpbWl0cy5cbiAgICAvL1xuICAgIHZhciBnbG9iYWwgPSB0aGlzLFxuICAgICAgICB3aWR0aCA9IDI1NixcbiAgICAgICAgLy8gZWFjaCBSQzQgb3V0cHV0IGlzIDAgPD0geCA8IDI1NlxuICAgIGNodW5rcyA9IDYsXG4gICAgICAgIC8vIGF0IGxlYXN0IHNpeCBSQzQgb3V0cHV0cyBmb3IgZWFjaCBkb3VibGVcbiAgICBkaWdpdHMgPSA1MixcbiAgICAgICAgLy8gdGhlcmUgYXJlIDUyIHNpZ25pZmljYW50IGRpZ2l0cyBpbiBhIGRvdWJsZVxuICAgIHJuZ25hbWUgPSAncmFuZG9tJyxcbiAgICAgICAgLy8gcm5nbmFtZTogbmFtZSBmb3IgTWF0aC5yYW5kb20gYW5kIE1hdGguc2VlZHJhbmRvbVxuICAgIHN0YXJ0ZGVub20gPSBtYXRoLnBvdyh3aWR0aCwgY2h1bmtzKSxcbiAgICAgICAgc2lnbmlmaWNhbmNlID0gbWF0aC5wb3coMiwgZGlnaXRzKSxcbiAgICAgICAgb3ZlcmZsb3cgPSBzaWduaWZpY2FuY2UgKiAyLFxuICAgICAgICBtYXNrID0gd2lkdGggLSAxLFxuICAgICAgICBub2RlY3J5cHRvOyAvLyBub2RlLmpzIGNyeXB0byBtb2R1bGUsIGluaXRpYWxpemVkIGF0IHRoZSBib3R0b20uXG4gICAgLy9cbiAgICAvLyBzZWVkcmFuZG9tKClcbiAgICAvLyBUaGlzIGlzIHRoZSBzZWVkcmFuZG9tIGZ1bmN0aW9uIGRlc2NyaWJlZCBhYm92ZS5cbiAgICAvL1xuXG4gICAgZnVuY3Rpb24gc2VlZHJhbmRvbShzZWVkLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGtleSA9IFtdO1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPT09IHRydWUgPyB7XG4gICAgICAgIGVudHJvcHk6IHRydWVcbiAgICAgIH0gOiBvcHRpb25zIHx8IHt9OyAvLyBGbGF0dGVuIHRoZSBzZWVkIHN0cmluZyBvciBidWlsZCBvbmUgZnJvbSBsb2NhbCBlbnRyb3B5IGlmIG5lZWRlZC5cblxuICAgICAgdmFyIHNob3J0c2VlZCA9IG1peGtleShmbGF0dGVuKG9wdGlvbnMuZW50cm9weSA/IFtzZWVkLCB0b3N0cmluZyhwb29sKV0gOiBzZWVkID09PSBudWxsID8gYXV0b3NlZWQoKSA6IHNlZWQsIDMpLCBrZXkpOyAvLyBVc2UgdGhlIHNlZWQgdG8gaW5pdGlhbGl6ZSBhbiBBUkM0IGdlbmVyYXRvci5cblxuICAgICAgdmFyIGFyYzQgPSBuZXcgQVJDNChrZXkpOyAvLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSByYW5kb20gZG91YmxlIGluIFswLCAxKSB0aGF0IGNvbnRhaW5zXG4gICAgICAvLyByYW5kb21uZXNzIGluIGV2ZXJ5IGJpdCBvZiB0aGUgbWFudGlzc2Egb2YgdGhlIElFRUUgNzU0IHZhbHVlLlxuXG4gICAgICB2YXIgcHJuZyA9IGZ1bmN0aW9uIHBybmcoKSB7XG4gICAgICAgIHZhciBuID0gYXJjNC5nKGNodW5rcyksXG4gICAgICAgICAgICAvLyBTdGFydCB3aXRoIGEgbnVtZXJhdG9yIG4gPCAyIF4gNDhcbiAgICAgICAgZCA9IHN0YXJ0ZGVub20sXG4gICAgICAgICAgICAvLyAgIGFuZCBkZW5vbWluYXRvciBkID0gMiBeIDQ4LlxuICAgICAgICB4ID0gMDsgLy8gICBhbmQgbm8gJ2V4dHJhIGxhc3QgYnl0ZScuXG5cbiAgICAgICAgd2hpbGUgKG4gPCBzaWduaWZpY2FuY2UpIHtcbiAgICAgICAgICAvLyBGaWxsIHVwIGFsbCBzaWduaWZpY2FudCBkaWdpdHMgYnlcbiAgICAgICAgICBuID0gKG4gKyB4KSAqIHdpZHRoOyAvLyAgIHNoaWZ0aW5nIG51bWVyYXRvciBhbmRcblxuICAgICAgICAgIGQgKj0gd2lkdGg7IC8vICAgZGVub21pbmF0b3IgYW5kIGdlbmVyYXRpbmcgYVxuXG4gICAgICAgICAgeCA9IGFyYzQuZygxKTsgLy8gICBuZXcgbGVhc3Qtc2lnbmlmaWNhbnQtYnl0ZS5cbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChuID49IG92ZXJmbG93KSB7XG4gICAgICAgICAgLy8gVG8gYXZvaWQgcm91bmRpbmcgdXAsIGJlZm9yZSBhZGRpbmdcbiAgICAgICAgICBuIC89IDI7IC8vICAgbGFzdCBieXRlLCBzaGlmdCBldmVyeXRoaW5nXG5cbiAgICAgICAgICBkIC89IDI7IC8vICAgcmlnaHQgdXNpbmcgaW50ZWdlciBtYXRoIHVudGlsXG5cbiAgICAgICAgICB4ID4+Pj0gMTsgLy8gICB3ZSBoYXZlIGV4YWN0bHkgdGhlIGRlc2lyZWQgYml0cy5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobiArIHgpIC8gZDsgLy8gRm9ybSB0aGUgbnVtYmVyIHdpdGhpbiBbMCwgMSkuXG4gICAgICB9O1xuXG4gICAgICBwcm5nLmludDMyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJjNC5nKDQpIHwgMDtcbiAgICAgIH07XG5cbiAgICAgIHBybmcucXVpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmM0LmcoNCkgLyAweDEwMDAwMDAwMDtcbiAgICAgIH07XG5cbiAgICAgIHBybmdbXCJkb3VibGVcIl0gPSBwcm5nOyAvLyBNaXggdGhlIHJhbmRvbW5lc3MgaW50byBhY2N1bXVsYXRlZCBlbnRyb3B5LlxuXG4gICAgICBtaXhrZXkodG9zdHJpbmcoYXJjNC5TKSwgcG9vbCk7IC8vIENhbGxpbmcgY29udmVudGlvbjogd2hhdCB0byByZXR1cm4gYXMgYSBmdW5jdGlvbiBvZiBwcm5nLCBzZWVkLCBpc19tYXRoLlxuXG4gICAgICByZXR1cm4gKG9wdGlvbnMucGFzcyB8fCBjYWxsYmFjayB8fCBmdW5jdGlvbiAocHJuZywgc2VlZCwgaXNfbWF0aF9jYWxsLCBzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAvLyBMb2FkIHRoZSBhcmM0IHN0YXRlIGZyb20gdGhlIGdpdmVuIHN0YXRlIGlmIGl0IGhhcyBhbiBTIGFycmF5LlxuICAgICAgICAgIGlmIChzdGF0ZS5TKSB7XG4gICAgICAgICAgICBjb3B5KHN0YXRlLCBhcmM0KTtcbiAgICAgICAgICB9IC8vIE9ubHkgcHJvdmlkZSB0aGUgLnN0YXRlIG1ldGhvZCBpZiByZXF1ZXN0ZWQgdmlhIG9wdGlvbnMuc3RhdGUuXG5cblxuICAgICAgICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29weShhcmM0LCB7fSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSAvLyBJZiBjYWxsZWQgYXMgYSBtZXRob2Qgb2YgTWF0aCAoTWF0aC5zZWVkcmFuZG9tKCkpLCBtdXRhdGVcbiAgICAgICAgLy8gTWF0aC5yYW5kb20gYmVjYXVzZSB0aGF0IGlzIGhvdyBzZWVkcmFuZG9tLmpzIGhhcyB3b3JrZWQgc2luY2UgdjEuMC5cblxuXG4gICAgICAgIGlmIChpc19tYXRoX2NhbGwpIHtcbiAgICAgICAgICBtYXRoW3JuZ25hbWVdID0gcHJuZztcbiAgICAgICAgICByZXR1cm4gc2VlZDtcbiAgICAgICAgfSAvLyBPdGhlcndpc2UsIGl0IGlzIGEgbmV3ZXIgY2FsbGluZyBjb252ZW50aW9uLCBzbyByZXR1cm4gdGhlXG4gICAgICAgIC8vIHBybmcgZGlyZWN0bHkuXG4gICAgICAgIGVsc2UgcmV0dXJuIHBybmc7XG4gICAgICB9KShwcm5nLCBzaG9ydHNlZWQsICdnbG9iYWwnIGluIG9wdGlvbnMgPyBvcHRpb25zLmdsb2JhbCA6IHRoaXMgPT0gbWF0aCwgb3B0aW9ucy5zdGF0ZSk7XG4gICAgfVxuXG4gICAgbWF0aFsnc2VlZCcgKyBybmduYW1lXSA9IHNlZWRyYW5kb207IC8vXG4gICAgLy8gQVJDNFxuICAgIC8vXG4gICAgLy8gQW4gQVJDNCBpbXBsZW1lbnRhdGlvbi4gIFRoZSBjb25zdHJ1Y3RvciB0YWtlcyBhIGtleSBpbiB0aGUgZm9ybSBvZlxuICAgIC8vIGFuIGFycmF5IG9mIGF0IG1vc3QgKHdpZHRoKSBpbnRlZ2VycyB0aGF0IHNob3VsZCBiZSAwIDw9IHggPCAod2lkdGgpLlxuICAgIC8vXG4gICAgLy8gVGhlIGcoY291bnQpIG1ldGhvZCByZXR1cm5zIGEgcHNldWRvcmFuZG9tIGludGVnZXIgdGhhdCBjb25jYXRlbmF0ZXNcbiAgICAvLyB0aGUgbmV4dCAoY291bnQpIG91dHB1dHMgZnJvbSBBUkM0LiAgSXRzIHJldHVybiB2YWx1ZSBpcyBhIG51bWJlciB4XG4gICAgLy8gdGhhdCBpcyBpbiB0aGUgcmFuZ2UgMCA8PSB4IDwgKHdpZHRoIF4gY291bnQpLlxuICAgIC8vXG5cbiAgICBmdW5jdGlvbiBBUkM0KGtleSkge1xuICAgICAgdmFyIHQsXG4gICAgICAgICAga2V5bGVuID0ga2V5Lmxlbmd0aCxcbiAgICAgICAgICBtZSA9IHRoaXMsXG4gICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgaiA9IG1lLmkgPSBtZS5qID0gMCxcbiAgICAgICAgICBzID0gbWUuUyA9IFtdOyAvLyBUaGUgZW1wdHkga2V5IFtdIGlzIHRyZWF0ZWQgYXMgWzBdLlxuXG4gICAgICBpZiAoIWtleWxlbikge1xuICAgICAgICBrZXkgPSBba2V5bGVuKytdO1xuICAgICAgfSAvLyBTZXQgdXAgUyB1c2luZyB0aGUgc3RhbmRhcmQga2V5IHNjaGVkdWxpbmcgYWxnb3JpdGhtLlxuXG5cbiAgICAgIHdoaWxlIChpIDwgd2lkdGgpIHtcbiAgICAgICAgc1tpXSA9IGkrKztcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICAgICAgc1tpXSA9IHNbaiA9IG1hc2sgJiBqICsga2V5W2kgJSBrZXlsZW5dICsgKHQgPSBzW2ldKV07XG4gICAgICAgIHNbal0gPSB0O1xuICAgICAgfSAvLyBUaGUgXCJnXCIgbWV0aG9kIHJldHVybnMgdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGFzIG9uZSBudW1iZXIuXG5cblxuICAgICAgbWUuZyA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgICAgICAvLyBVc2luZyBpbnN0YW5jZSBtZW1iZXJzIGluc3RlYWQgb2YgY2xvc3VyZSBzdGF0ZSBuZWFybHkgZG91YmxlcyBzcGVlZC5cbiAgICAgICAgdmFyIHQsXG4gICAgICAgICAgICByID0gMCxcbiAgICAgICAgICAgIGkgPSBtZS5pLFxuICAgICAgICAgICAgaiA9IG1lLmosXG4gICAgICAgICAgICBzID0gbWUuUztcblxuICAgICAgICB3aGlsZSAoY291bnQtLSkge1xuICAgICAgICAgIHQgPSBzW2kgPSBtYXNrICYgaSArIDFdO1xuICAgICAgICAgIHIgPSByICogd2lkdGggKyBzW21hc2sgJiAoc1tpXSA9IHNbaiA9IG1hc2sgJiBqICsgdF0pICsgKHNbal0gPSB0KV07XG4gICAgICAgIH1cblxuICAgICAgICBtZS5pID0gaTtcbiAgICAgICAgbWUuaiA9IGo7XG4gICAgICAgIHJldHVybiByOyAvLyBGb3Igcm9idXN0IHVucHJlZGljdGFiaWxpdHksIHRoZSBmdW5jdGlvbiBjYWxsIGJlbG93IGF1dG9tYXRpY2FsbHlcbiAgICAgICAgLy8gZGlzY2FyZHMgYW4gaW5pdGlhbCBiYXRjaCBvZiB2YWx1ZXMuICBUaGlzIGlzIGNhbGxlZCBSQzQtZHJvcFsyNTZdLlxuICAgICAgICAvLyBTZWUgaHR0cDovL2dvb2dsZS5jb20vc2VhcmNoP3E9cnNhK2ZsdWhyZXIrcmVzcG9uc2UmYnRuSVxuICAgICAgfTtcbiAgICB9IC8vXG4gICAgLy8gY29weSgpXG4gICAgLy8gQ29waWVzIGludGVybmFsIHN0YXRlIG9mIEFSQzQgdG8gb3IgZnJvbSBhIHBsYWluIG9iamVjdC5cbiAgICAvL1xuXG5cbiAgICBmdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgICAgIHQuaSA9IGYuaTtcbiAgICAgIHQuaiA9IGYuajtcbiAgICAgIHQuUyA9IGYuUy5zbGljZSgpO1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfSAvL1xuICAgIC8vIGZsYXR0ZW4oKVxuICAgIC8vIENvbnZlcnRzIGFuIG9iamVjdCB0cmVlIHRvIG5lc3RlZCBhcnJheXMgb2Ygc3RyaW5ncy5cbiAgICAvL1xuXG5cbiAgICBmdW5jdGlvbiBmbGF0dGVuKG9iaiwgZGVwdGgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICB0eXAgPSBfdHlwZW9mJDIob2JqKSxcbiAgICAgICAgICBwcm9wO1xuXG4gICAgICBpZiAoZGVwdGggJiYgdHlwID09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZmxhdHRlbihvYmpbcHJvcF0sIGRlcHRoIC0gMSkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPyByZXN1bHQgOiB0eXAgPT0gJ3N0cmluZycgPyBvYmogOiBvYmogKyAnXFwwJztcbiAgICB9IC8vXG4gICAgLy8gbWl4a2V5KClcbiAgICAvLyBNaXhlcyBhIHN0cmluZyBzZWVkIGludG8gYSBrZXkgdGhhdCBpcyBhbiBhcnJheSBvZiBpbnRlZ2VycywgYW5kXG4gICAgLy8gcmV0dXJucyBhIHNob3J0ZW5lZCBzdHJpbmcgc2VlZCB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gdGhlIHJlc3VsdCBrZXkuXG4gICAgLy9cblxuXG4gICAgZnVuY3Rpb24gbWl4a2V5KHNlZWQsIGtleSkge1xuICAgICAgdmFyIHN0cmluZ3NlZWQgPSBzZWVkICsgJycsXG4gICAgICAgICAgc21lYXIsXG4gICAgICAgICAgaiA9IDA7XG5cbiAgICAgIHdoaWxlIChqIDwgc3RyaW5nc2VlZC5sZW5ndGgpIHtcbiAgICAgICAga2V5W21hc2sgJiBqXSA9IG1hc2sgJiAoc21lYXIgXj0ga2V5W21hc2sgJiBqXSAqIDE5KSArIHN0cmluZ3NlZWQuY2hhckNvZGVBdChqKyspO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG9zdHJpbmcoa2V5KTtcbiAgICB9IC8vXG4gICAgLy8gYXV0b3NlZWQoKVxuICAgIC8vIFJldHVybnMgYW4gb2JqZWN0IGZvciBhdXRvc2VlZGluZywgdXNpbmcgd2luZG93LmNyeXB0byBhbmQgTm9kZSBjcnlwdG9cbiAgICAvLyBtb2R1bGUgaWYgYXZhaWxhYmxlLlxuICAgIC8vXG5cblxuICAgIGZ1bmN0aW9uIGF1dG9zZWVkKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG5vZGVjcnlwdG8pIHtcbiAgICAgICAgICByZXR1cm4gdG9zdHJpbmcobm9kZWNyeXB0by5yYW5kb21CeXRlcyh3aWR0aCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dCA9IG5ldyBVaW50OEFycmF5KHdpZHRoKTtcbiAgICAgICAgKGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvKS5nZXRSYW5kb21WYWx1ZXMob3V0KTtcbiAgICAgICAgcmV0dXJuIHRvc3RyaW5nKG91dCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHZhciBicm93c2VyID0gZ2xvYmFsLm5hdmlnYXRvcixcbiAgICAgICAgICAgIHBsdWdpbnMgPSBicm93c2VyICYmIGJyb3dzZXIucGx1Z2lucztcbiAgICAgICAgcmV0dXJuIFsrbmV3IERhdGUoKSwgZ2xvYmFsLCBwbHVnaW5zLCBnbG9iYWwuc2NyZWVuLCB0b3N0cmluZyhwb29sKV07XG4gICAgICB9XG4gICAgfSAvL1xuICAgIC8vIHRvc3RyaW5nKClcbiAgICAvLyBDb252ZXJ0cyBhbiBhcnJheSBvZiBjaGFyY29kZXMgdG8gYSBzdHJpbmdcbiAgICAvL1xuXG5cbiAgICBmdW5jdGlvbiB0b3N0cmluZyhhKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSgwLCBhKTtcbiAgICB9IC8vXG4gICAgLy8gV2hlbiBzZWVkcmFuZG9tLmpzIGlzIGxvYWRlZCwgd2UgaW1tZWRpYXRlbHkgbWl4IGEgZmV3IGJpdHNcbiAgICAvLyBmcm9tIHRoZSBidWlsdC1pbiBSTkcgaW50byB0aGUgZW50cm9weSBwb29sLiAgQmVjYXVzZSB3ZSBkb1xuICAgIC8vIG5vdCB3YW50IHRvIGludGVyZmVyZSB3aXRoIGRldGVybWluaXN0aWMgUFJORyBzdGF0ZSBsYXRlcixcbiAgICAvLyBzZWVkcmFuZG9tIHdpbGwgbm90IGNhbGwgbWF0aC5yYW5kb20gb24gaXRzIG93biBhZ2FpbiBhZnRlclxuICAgIC8vIGluaXRpYWxpemF0aW9uLlxuICAgIC8vXG5cblxuICAgIG1peGtleShtYXRoLnJhbmRvbSgpLCBwb29sKTsgLy9cbiAgICAvLyBOb2RlanMgYW5kIEFNRCBzdXBwb3J0OiBleHBvcnQgdGhlIGltcGxlbWVudGF0aW9uIGFzIGEgbW9kdWxlIHVzaW5nXG4gICAgLy8gZWl0aGVyIGNvbnZlbnRpb24uXG4gICAgLy9cbiAgICAvLyBFbmQgYW5vbnltb3VzIHNjb3BlLCBhbmQgcGFzcyBpbml0aWFsIHZhbHVlcy5cbiAgfVxuXG4gIDtcblxuICBmdW5jdGlvbiBpbml0aWFsaXplJDIoQk1NYXRoKSB7XG4gICAgc2VlZFJhbmRvbShbXSwgQk1NYXRoKTtcbiAgfVxuXG4gIHZhciBwcm9wVHlwZXMgPSB7XG4gICAgU0hBUEU6ICdzaGFwZSdcbiAgfTtcblxuICBmdW5jdGlvbiBfdHlwZW9mJDEob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YkMSA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mJDEgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZiQxKG9iaik7IH1cblxuICB2YXIgRXhwcmVzc2lvbk1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG9iID0ge307XG4gICAgdmFyIE1hdGggPSBCTU1hdGg7XG4gICAgdmFyIHdpbmRvdyA9IG51bGw7XG4gICAgdmFyIGRvY3VtZW50ID0gbnVsbDtcbiAgICB2YXIgWE1MSHR0cFJlcXVlc3QgPSBudWxsO1xuICAgIHZhciBmZXRjaCA9IG51bGw7XG4gICAgdmFyIGZyYW1lcyA9IG51bGw7XG4gICAgdmFyIF9sb3R0aWVHbG9iYWwgPSB7fTtcbiAgICBpbml0aWFsaXplJDIoQk1NYXRoKTtcblxuICAgIGZ1bmN0aW9uIHJlc2V0RnJhbWUoKSB7XG4gICAgICBfbG90dGllR2xvYmFsID0ge307XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJGJtX2lzSW5zdGFuY2VPZkFycmF5KGFycikge1xuICAgICAgcmV0dXJuIGFyci5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgfHwgYXJyLmNvbnN0cnVjdG9yID09PSBGbG9hdDMyQXJyYXk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOdW1lcmFibGUodE9mViwgdikge1xuICAgICAgcmV0dXJuIHRPZlYgPT09ICdudW1iZXInIHx8IHYgaW5zdGFuY2VvZiBOdW1iZXIgfHwgdE9mViA9PT0gJ2Jvb2xlYW4nIHx8IHRPZlYgPT09ICdzdHJpbmcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICRibV9uZWcoYSkge1xuICAgICAgdmFyIHRPZkEgPSBfdHlwZW9mJDEoYSk7XG5cbiAgICAgIGlmICh0T2ZBID09PSAnbnVtYmVyJyB8fCBhIGluc3RhbmNlb2YgTnVtYmVyIHx8IHRPZkEgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gLWE7XG4gICAgICB9XG5cbiAgICAgIGlmICgkYm1faXNJbnN0YW5jZU9mQXJyYXkoYSkpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW5BID0gYS5sZW5ndGg7XG4gICAgICAgIHZhciByZXRBcnIgPSBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuQTsgaSArPSAxKSB7XG4gICAgICAgICAgcmV0QXJyW2ldID0gLWFbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgfVxuXG4gICAgICBpZiAoYS5wcm9wVHlwZSkge1xuICAgICAgICByZXR1cm4gYS52O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLWE7XG4gICAgfVxuXG4gICAgdmFyIGVhc2VJbkJleiA9IEJlemllckZhY3RvcnkuZ2V0QmV6aWVyRWFzaW5nKDAuMzMzLCAwLCAwLjgzMywgMC44MzMsICdlYXNlSW4nKS5nZXQ7XG4gICAgdmFyIGVhc2VPdXRCZXogPSBCZXppZXJGYWN0b3J5LmdldEJlemllckVhc2luZygwLjE2NywgMC4xNjcsIDAuNjY3LCAxLCAnZWFzZU91dCcpLmdldDtcbiAgICB2YXIgZWFzZUluT3V0QmV6ID0gQmV6aWVyRmFjdG9yeS5nZXRCZXppZXJFYXNpbmcoMC4zMywgMCwgMC42NjcsIDEsICdlYXNlSW5PdXQnKS5nZXQ7XG5cbiAgICBmdW5jdGlvbiBzdW0oYSwgYikge1xuICAgICAgdmFyIHRPZkEgPSBfdHlwZW9mJDEoYSk7XG5cbiAgICAgIHZhciB0T2ZCID0gX3R5cGVvZiQxKGIpO1xuXG4gICAgICBpZiAoaXNOdW1lcmFibGUodE9mQSwgYSkgJiYgaXNOdW1lcmFibGUodE9mQiwgYikgfHwgdE9mQSA9PT0gJ3N0cmluZycgfHwgdE9mQiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGEgKyBiO1xuICAgICAgfVxuXG4gICAgICBpZiAoJGJtX2lzSW5zdGFuY2VPZkFycmF5KGEpICYmIGlzTnVtZXJhYmxlKHRPZkIsIGIpKSB7XG4gICAgICAgIGEgPSBhLnNsaWNlKDApO1xuICAgICAgICBhWzBdICs9IGI7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOdW1lcmFibGUodE9mQSwgYSkgJiYgJGJtX2lzSW5zdGFuY2VPZkFycmF5KGIpKSB7XG4gICAgICAgIGIgPSBiLnNsaWNlKDApO1xuICAgICAgICBiWzBdID0gYSArIGJbMF07XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfVxuXG4gICAgICBpZiAoJGJtX2lzSW5zdGFuY2VPZkFycmF5KGEpICYmICRibV9pc0luc3RhbmNlT2ZBcnJheShiKSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW5BID0gYS5sZW5ndGg7XG4gICAgICAgIHZhciBsZW5CID0gYi5sZW5ndGg7XG4gICAgICAgIHZhciByZXRBcnIgPSBbXTtcblxuICAgICAgICB3aGlsZSAoaSA8IGxlbkEgfHwgaSA8IGxlbkIpIHtcbiAgICAgICAgICBpZiAoKHR5cGVvZiBhW2ldID09PSAnbnVtYmVyJyB8fCBhW2ldIGluc3RhbmNlb2YgTnVtYmVyKSAmJiAodHlwZW9mIGJbaV0gPT09ICdudW1iZXInIHx8IGJbaV0gaW5zdGFuY2VvZiBOdW1iZXIpKSB7XG4gICAgICAgICAgICByZXRBcnJbaV0gPSBhW2ldICsgYltpXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0QXJyW2ldID0gYltpXSA9PT0gdW5kZWZpbmVkID8gYVtpXSA6IGFbaV0gfHwgYltpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgYWRkID0gc3VtO1xuXG4gICAgZnVuY3Rpb24gc3ViKGEsIGIpIHtcbiAgICAgIHZhciB0T2ZBID0gX3R5cGVvZiQxKGEpO1xuXG4gICAgICB2YXIgdE9mQiA9IF90eXBlb2YkMShiKTtcblxuICAgICAgaWYgKGlzTnVtZXJhYmxlKHRPZkEsIGEpICYmIGlzTnVtZXJhYmxlKHRPZkIsIGIpKSB7XG4gICAgICAgIGlmICh0T2ZBID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGEgPSBwYXJzZUludChhLCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodE9mQiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBiID0gcGFyc2VJbnQoYiwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgfVxuXG4gICAgICBpZiAoJGJtX2lzSW5zdGFuY2VPZkFycmF5KGEpICYmIGlzTnVtZXJhYmxlKHRPZkIsIGIpKSB7XG4gICAgICAgIGEgPSBhLnNsaWNlKDApO1xuICAgICAgICBhWzBdIC09IGI7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOdW1lcmFibGUodE9mQSwgYSkgJiYgJGJtX2lzSW5zdGFuY2VPZkFycmF5KGIpKSB7XG4gICAgICAgIGIgPSBiLnNsaWNlKDApO1xuICAgICAgICBiWzBdID0gYSAtIGJbMF07XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfVxuXG4gICAgICBpZiAoJGJtX2lzSW5zdGFuY2VPZkFycmF5KGEpICYmICRibV9pc0luc3RhbmNlT2ZBcnJheShiKSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW5BID0gYS5sZW5ndGg7XG4gICAgICAgIHZhciBsZW5CID0gYi5sZW5ndGg7XG4gICAgICAgIHZhciByZXRBcnIgPSBbXTtcblxuICAgICAgICB3aGlsZSAoaSA8IGxlbkEgfHwgaSA8IGxlbkIpIHtcbiAgICAgICAgICBpZiAoKHR5cGVvZiBhW2ldID09PSAnbnVtYmVyJyB8fCBhW2ldIGluc3RhbmNlb2YgTnVtYmVyKSAmJiAodHlwZW9mIGJbaV0gPT09ICdudW1iZXInIHx8IGJbaV0gaW5zdGFuY2VvZiBOdW1iZXIpKSB7XG4gICAgICAgICAgICByZXRBcnJbaV0gPSBhW2ldIC0gYltpXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0QXJyW2ldID0gYltpXSA9PT0gdW5kZWZpbmVkID8gYVtpXSA6IGFbaV0gfHwgYltpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtdWwoYSwgYikge1xuICAgICAgdmFyIHRPZkEgPSBfdHlwZW9mJDEoYSk7XG5cbiAgICAgIHZhciB0T2ZCID0gX3R5cGVvZiQxKGIpO1xuXG4gICAgICB2YXIgYXJyO1xuXG4gICAgICBpZiAoaXNOdW1lcmFibGUodE9mQSwgYSkgJiYgaXNOdW1lcmFibGUodE9mQiwgYikpIHtcbiAgICAgICAgcmV0dXJuIGEgKiBiO1xuICAgICAgfVxuXG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW47XG5cbiAgICAgIGlmICgkYm1faXNJbnN0YW5jZU9mQXJyYXkoYSkgJiYgaXNOdW1lcmFibGUodE9mQiwgYikpIHtcbiAgICAgICAgbGVuID0gYS5sZW5ndGg7XG4gICAgICAgIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGFycltpXSA9IGFbaV0gKiBiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTnVtZXJhYmxlKHRPZkEsIGEpICYmICRibV9pc0luc3RhbmNlT2ZBcnJheShiKSkge1xuICAgICAgICBsZW4gPSBiLmxlbmd0aDtcbiAgICAgICAgYXJyID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgYXJyW2ldID0gYSAqIGJbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaXYoYSwgYikge1xuICAgICAgdmFyIHRPZkEgPSBfdHlwZW9mJDEoYSk7XG5cbiAgICAgIHZhciB0T2ZCID0gX3R5cGVvZiQxKGIpO1xuXG4gICAgICB2YXIgYXJyO1xuXG4gICAgICBpZiAoaXNOdW1lcmFibGUodE9mQSwgYSkgJiYgaXNOdW1lcmFibGUodE9mQiwgYikpIHtcbiAgICAgICAgcmV0dXJuIGEgLyBiO1xuICAgICAgfVxuXG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW47XG5cbiAgICAgIGlmICgkYm1faXNJbnN0YW5jZU9mQXJyYXkoYSkgJiYgaXNOdW1lcmFibGUodE9mQiwgYikpIHtcbiAgICAgICAgbGVuID0gYS5sZW5ndGg7XG4gICAgICAgIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGFycltpXSA9IGFbaV0gLyBiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTnVtZXJhYmxlKHRPZkEsIGEpICYmICRibV9pc0luc3RhbmNlT2ZBcnJheShiKSkge1xuICAgICAgICBsZW4gPSBiLmxlbmd0aDtcbiAgICAgICAgYXJyID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgYXJyW2ldID0gYSAvIGJbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb2QoYSwgYikge1xuICAgICAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJykge1xuICAgICAgICBhID0gcGFyc2VJbnQoYSwgMTApO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGIgPSBwYXJzZUludChiLCAxMCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhICUgYjtcbiAgICB9XG5cbiAgICB2YXIgJGJtX3N1bSA9IHN1bTtcbiAgICB2YXIgJGJtX3N1YiA9IHN1YjtcbiAgICB2YXIgJGJtX211bCA9IG11bDtcbiAgICB2YXIgJGJtX2RpdiA9IGRpdjtcbiAgICB2YXIgJGJtX21vZCA9IG1vZDtcblxuICAgIGZ1bmN0aW9uIGNsYW1wKG51bSwgbWluLCBtYXgpIHtcbiAgICAgIGlmIChtaW4gPiBtYXgpIHtcbiAgICAgICAgdmFyIG1tID0gbWF4O1xuICAgICAgICBtYXggPSBtaW47XG4gICAgICAgIG1pbiA9IG1tO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobnVtLCBtaW4pLCBtYXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJhZGlhbnNUb0RlZ3JlZXModmFsKSB7XG4gICAgICByZXR1cm4gdmFsIC8gZGVnVG9SYWRzO1xuICAgIH1cblxuICAgIHZhciByYWRpYW5zX3RvX2RlZ3JlZXMgPSByYWRpYW5zVG9EZWdyZWVzO1xuXG4gICAgZnVuY3Rpb24gZGVncmVlc1RvUmFkaWFucyh2YWwpIHtcbiAgICAgIHJldHVybiB2YWwgKiBkZWdUb1JhZHM7XG4gICAgfVxuXG4gICAgdmFyIGRlZ3JlZXNfdG9fcmFkaWFucyA9IHJhZGlhbnNUb0RlZ3JlZXM7XG4gICAgdmFyIGhlbHBlckxlbmd0aEFycmF5ID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xuXG4gICAgZnVuY3Rpb24gbGVuZ3RoKGFycjEsIGFycjIpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJyMSA9PT0gJ251bWJlcicgfHwgYXJyMSBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgICAgICBhcnIyID0gYXJyMiB8fCAwO1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoYXJyMSAtIGFycjIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFycjIpIHtcbiAgICAgICAgYXJyMiA9IGhlbHBlckxlbmd0aEFycmF5O1xuICAgICAgfVxuXG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcnIxLmxlbmd0aCwgYXJyMi5sZW5ndGgpO1xuICAgICAgdmFyIGFkZGVkTGVuZ3RoID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGFkZGVkTGVuZ3RoICs9IE1hdGgucG93KGFycjJbaV0gLSBhcnIxW2ldLCAyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE1hdGguc3FydChhZGRlZExlbmd0aCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKHZlYykge1xuICAgICAgcmV0dXJuIGRpdih2ZWMsIGxlbmd0aCh2ZWMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZ2JUb0hzbCh2YWwpIHtcbiAgICAgIHZhciByID0gdmFsWzBdO1xuICAgICAgdmFyIGcgPSB2YWxbMV07XG4gICAgICB2YXIgYiA9IHZhbFsyXTtcbiAgICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICAgIHZhciBoO1xuICAgICAgdmFyIHM7XG4gICAgICB2YXIgbCA9IChtYXggKyBtaW4pIC8gMjtcblxuICAgICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICAgIGggPSAwOyAvLyBhY2hyb21hdGljXG5cbiAgICAgICAgcyA9IDA7IC8vIGFjaHJvbWF0aWNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkID0gbWF4IC0gbWluO1xuICAgICAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG5cbiAgICAgICAgc3dpdGNoIChtYXgpIHtcbiAgICAgICAgICBjYXNlIHI6XG4gICAgICAgICAgICBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgZzpcbiAgICAgICAgICAgIGggPSAoYiAtIHIpIC8gZCArIDI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgYjpcbiAgICAgICAgICAgIGggPSAociAtIGcpIC8gZCArIDQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGggLz0gNjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtoLCBzLCBsLCB2YWxbM11dO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xuICAgICAgaWYgKHQgPCAwKSB0ICs9IDE7XG4gICAgICBpZiAodCA+IDEpIHQgLT0gMTtcbiAgICAgIGlmICh0IDwgMSAvIDYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICAgICAgaWYgKHQgPCAxIC8gMikgcmV0dXJuIHE7XG4gICAgICBpZiAodCA8IDIgLyAzKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoc2xUb1JnYih2YWwpIHtcbiAgICAgIHZhciBoID0gdmFsWzBdO1xuICAgICAgdmFyIHMgPSB2YWxbMV07XG4gICAgICB2YXIgbCA9IHZhbFsyXTtcbiAgICAgIHZhciByO1xuICAgICAgdmFyIGc7XG4gICAgICB2YXIgYjtcblxuICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgciA9IGw7IC8vIGFjaHJvbWF0aWNcblxuICAgICAgICBiID0gbDsgLy8gYWNocm9tYXRpY1xuXG4gICAgICAgIGcgPSBsOyAvLyBhY2hyb21hdGljXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgIHZhciBwID0gMiAqIGwgLSBxO1xuICAgICAgICByID0gaHVlMnJnYihwLCBxLCBoICsgMSAvIDMpO1xuICAgICAgICBnID0gaHVlMnJnYihwLCBxLCBoKTtcbiAgICAgICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtyLCBnLCBiLCB2YWxbM11dO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVhcih0LCB0TWluLCB0TWF4LCB2YWx1ZTEsIHZhbHVlMikge1xuICAgICAgaWYgKHZhbHVlMSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlMSA9IHRNaW47XG4gICAgICAgIHZhbHVlMiA9IHRNYXg7XG4gICAgICAgIHRNaW4gPSAwO1xuICAgICAgICB0TWF4ID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRNYXggPCB0TWluKSB7XG4gICAgICAgIHZhciBfdE1pbiA9IHRNYXg7XG4gICAgICAgIHRNYXggPSB0TWluO1xuICAgICAgICB0TWluID0gX3RNaW47XG4gICAgICB9XG5cbiAgICAgIGlmICh0IDw9IHRNaW4pIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHQgPj0gdE1heCkge1xuICAgICAgICByZXR1cm4gdmFsdWUyO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGVyYyA9IHRNYXggPT09IHRNaW4gPyAwIDogKHQgLSB0TWluKSAvICh0TWF4IC0gdE1pbik7XG5cbiAgICAgIGlmICghdmFsdWUxLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdmFsdWUxICsgKHZhbHVlMiAtIHZhbHVlMSkgKiBwZXJjO1xuICAgICAgfVxuXG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSB2YWx1ZTEubGVuZ3RoO1xuICAgICAgdmFyIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYXJyW2ldID0gdmFsdWUxW2ldICsgKHZhbHVlMltpXSAtIHZhbHVlMVtpXSkgKiBwZXJjO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJhbmRvbShtaW4sIG1heCkge1xuICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChtaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG1pbiA9IDA7XG4gICAgICAgICAgbWF4ID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXggPSBtaW47XG4gICAgICAgICAgbWluID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXgubGVuZ3RoKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbGVuID0gbWF4Lmxlbmd0aDtcblxuICAgICAgICBpZiAoIW1pbikge1xuICAgICAgICAgIG1pbiA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuICAgICAgICB2YXIgcm5kID0gQk1NYXRoLnJhbmRvbSgpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGFycltpXSA9IG1pbltpXSArIHJuZCAqIChtYXhbaV0gLSBtaW5baV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBybmRtID0gQk1NYXRoLnJhbmRvbSgpO1xuICAgICAgcmV0dXJuIG1pbiArIHJuZG0gKiAobWF4IC0gbWluKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXRoKHBvaW50cywgaW5UYW5nZW50cywgb3V0VGFuZ2VudHMsIGNsb3NlZCkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgIHZhciBwYXRoID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcbiAgICAgIHBhdGguc2V0UGF0aERhdGEoISFjbG9zZWQsIGxlbik7XG4gICAgICB2YXIgYXJyUGxhY2Vob2xkZXIgPSBbMCwgMF07XG4gICAgICB2YXIgaW5WZXJ0ZXhQb2ludDtcbiAgICAgIHZhciBvdXRWZXJ0ZXhQb2ludDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGluVmVydGV4UG9pbnQgPSBpblRhbmdlbnRzICYmIGluVGFuZ2VudHNbaV0gPyBpblRhbmdlbnRzW2ldIDogYXJyUGxhY2Vob2xkZXI7XG4gICAgICAgIG91dFZlcnRleFBvaW50ID0gb3V0VGFuZ2VudHMgJiYgb3V0VGFuZ2VudHNbaV0gPyBvdXRUYW5nZW50c1tpXSA6IGFyclBsYWNlaG9sZGVyO1xuICAgICAgICBwYXRoLnNldFRyaXBsZUF0KHBvaW50c1tpXVswXSwgcG9pbnRzW2ldWzFdLCBvdXRWZXJ0ZXhQb2ludFswXSArIHBvaW50c1tpXVswXSwgb3V0VmVydGV4UG9pbnRbMV0gKyBwb2ludHNbaV1bMV0sIGluVmVydGV4UG9pbnRbMF0gKyBwb2ludHNbaV1bMF0sIGluVmVydGV4UG9pbnRbMV0gKyBwb2ludHNbaV1bMV0sIGksIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0aWF0ZUV4cHJlc3Npb24oZWxlbSwgZGF0YSwgcHJvcGVydHkpIHtcbiAgICAgIC8vIEJhaWwgb3V0IGlmIHdlIGRvbid0IHdhbnQgZXhwcmVzc2lvbnNcbiAgICAgIGZ1bmN0aW9uIG5vT3AoX3ZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghZWxlbS5nbG9iYWxEYXRhLnJlbmRlckNvbmZpZy5ydW5FeHByZXNzaW9ucykge1xuICAgICAgICByZXR1cm4gbm9PcDtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbCA9IGRhdGEueDtcbiAgICAgIHZhciBuZWVkc1ZlbG9jaXR5ID0gL3ZlbG9jaXR5KD8hW1xcd1xcZF0pLy50ZXN0KHZhbCk7XG5cbiAgICAgIHZhciBfbmVlZHNSYW5kb20gPSB2YWwuaW5kZXhPZigncmFuZG9tJykgIT09IC0xO1xuXG4gICAgICB2YXIgZWxlbVR5cGUgPSBlbGVtLmRhdGEudHk7XG4gICAgICB2YXIgdHJhbnNmb3JtO1xuICAgICAgdmFyICRibV90cmFuc2Zvcm07XG4gICAgICB2YXIgY29udGVudDtcbiAgICAgIHZhciBlZmZlY3Q7XG4gICAgICB2YXIgdGhpc1Byb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgICB0aGlzUHJvcGVydHkudmFsdWVBdFRpbWUgPSB0aGlzUHJvcGVydHkuZ2V0VmFsdWVBdFRpbWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpc1Byb3BlcnR5LCAndmFsdWUnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzUHJvcGVydHkudjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlbGVtLmNvbXAuZnJhbWVEdXJhdGlvbiA9IDEgLyBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XG4gICAgICBlbGVtLmNvbXAuZGlzcGxheVN0YXJ0VGltZSA9IDA7XG4gICAgICB2YXIgaW5Qb2ludCA9IGVsZW0uZGF0YS5pcCAvIGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcbiAgICAgIHZhciBvdXRQb2ludCA9IGVsZW0uZGF0YS5vcCAvIGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcbiAgICAgIHZhciB3aWR0aCA9IGVsZW0uZGF0YS5zdyA/IGVsZW0uZGF0YS5zdyA6IDA7XG4gICAgICB2YXIgaGVpZ2h0ID0gZWxlbS5kYXRhLnNoID8gZWxlbS5kYXRhLnNoIDogMDtcbiAgICAgIHZhciBuYW1lID0gZWxlbS5kYXRhLm5tO1xuICAgICAgdmFyIGxvb3BJbjtcbiAgICAgIHZhciBsb29wX2luO1xuICAgICAgdmFyIGxvb3BPdXQ7XG4gICAgICB2YXIgbG9vcF9vdXQ7XG4gICAgICB2YXIgc21vb3RoO1xuICAgICAgdmFyIHRvV29ybGQ7XG4gICAgICB2YXIgZnJvbVdvcmxkO1xuICAgICAgdmFyIGZyb21Db21wO1xuICAgICAgdmFyIHRvQ29tcDtcbiAgICAgIHZhciBmcm9tQ29tcFRvU3VyZmFjZTtcbiAgICAgIHZhciBwb3NpdGlvbjtcbiAgICAgIHZhciByb3RhdGlvbjtcbiAgICAgIHZhciBhbmNob3JQb2ludDtcbiAgICAgIHZhciBzY2FsZTtcbiAgICAgIHZhciB0aGlzTGF5ZXI7XG4gICAgICB2YXIgdGhpc0NvbXA7XG4gICAgICB2YXIgbWFzaztcbiAgICAgIHZhciB2YWx1ZUF0VGltZTtcbiAgICAgIHZhciB2ZWxvY2l0eUF0VGltZTtcbiAgICAgIHZhciBzY29wZWRfYm1fcnQ7IC8vIHZhbCA9IHZhbC5yZXBsYWNlKC8oXFxcXD9cInwnKSgoaHR0cCkocyk/KDpcXC8pKT9cXC8uKj8oXFxcXD9cInwnKS9nLCBcIlxcXCJcXFwiXCIpOyAvLyBkZXRlciBwb3RlbnRpYWwgbmV0d29yayBjYWxsc1xuXG4gICAgICB2YXIgZXhwcmVzc2lvbl9mdW5jdGlvbiA9IGV2YWwoJ1tmdW5jdGlvbiBfZXhwcmVzc2lvbl9mdW5jdGlvbigpeycgKyB2YWwgKyAnO3Njb3BlZF9ibV9ydD0kYm1fcnR9XScpWzBdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcblxuICAgICAgdmFyIG51bUtleXMgPSBwcm9wZXJ0eS5rZiA/IGRhdGEuay5sZW5ndGggOiAwO1xuICAgICAgdmFyIGFjdGl2ZSA9ICF0aGlzLmRhdGEgfHwgdGhpcy5kYXRhLmhkICE9PSB0cnVlO1xuXG4gICAgICB2YXIgd2lnZ2xlID0gZnVuY3Rpb24gd2lnZ2xlKGZyZXEsIGFtcCkge1xuICAgICAgICB2YXIgaVdpZ2dsZTtcbiAgICAgICAgdmFyIGo7XG4gICAgICAgIHZhciBsZW5XaWdnbGUgPSB0aGlzLnB2Lmxlbmd0aCA/IHRoaXMucHYubGVuZ3RoIDogMTtcbiAgICAgICAgdmFyIGFkZGVkQW1wcyA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW5XaWdnbGUpO1xuICAgICAgICBmcmVxID0gNTtcbiAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBNYXRoLmZsb29yKHRpbWUgKiBmcmVxKTtcbiAgICAgICAgaVdpZ2dsZSA9IDA7XG4gICAgICAgIGogPSAwO1xuXG4gICAgICAgIHdoaWxlIChpV2lnZ2xlIDwgaXRlcmF0aW9ucykge1xuICAgICAgICAgIC8vIHZhciBybmQgPSBCTU1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxlbldpZ2dsZTsgaiArPSAxKSB7XG4gICAgICAgICAgICBhZGRlZEFtcHNbal0gKz0gLWFtcCArIGFtcCAqIDIgKiBCTU1hdGgucmFuZG9tKCk7IC8vIGFkZGVkQW1wc1tqXSArPSAtYW1wICsgYW1wKjIqcm5kO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlXaWdnbGUgKz0gMTtcbiAgICAgICAgfSAvLyB2YXIgcm5kMiA9IEJNTWF0aC5yYW5kb20oKTtcblxuXG4gICAgICAgIHZhciBwZXJpb2RzID0gdGltZSAqIGZyZXE7XG4gICAgICAgIHZhciBwZXJjID0gcGVyaW9kcyAtIE1hdGguZmxvb3IocGVyaW9kcyk7XG4gICAgICAgIHZhciBhcnIgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuV2lnZ2xlKTtcblxuICAgICAgICBpZiAobGVuV2lnZ2xlID4gMSkge1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsZW5XaWdnbGU7IGogKz0gMSkge1xuICAgICAgICAgICAgYXJyW2pdID0gdGhpcy5wdltqXSArIGFkZGVkQW1wc1tqXSArICgtYW1wICsgYW1wICogMiAqIEJNTWF0aC5yYW5kb20oKSkgKiBwZXJjOyAvLyBhcnJbal0gPSB0aGlzLnB2W2pdICsgYWRkZWRBbXBzW2pdICsgKC1hbXAgKyBhbXAqMipybmQpKnBlcmM7XG4gICAgICAgICAgICAvLyBhcnJbaV0gPSB0aGlzLnB2W2ldICsgYWRkZWRBbXAgKyBhbXAxKnBlcmMgKyBhbXAyKigxLXBlcmMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5wdiArIGFkZGVkQW1wc1swXSArICgtYW1wICsgYW1wICogMiAqIEJNTWF0aC5yYW5kb20oKSkgKiBwZXJjO1xuICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICBpZiAodGhpc1Byb3BlcnR5Lmxvb3BJbikge1xuICAgICAgICBsb29wSW4gPSB0aGlzUHJvcGVydHkubG9vcEluLmJpbmQodGhpc1Byb3BlcnR5KTtcbiAgICAgICAgbG9vcF9pbiA9IGxvb3BJbjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNQcm9wZXJ0eS5sb29wT3V0KSB7XG4gICAgICAgIGxvb3BPdXQgPSB0aGlzUHJvcGVydHkubG9vcE91dC5iaW5kKHRoaXNQcm9wZXJ0eSk7XG4gICAgICAgIGxvb3Bfb3V0ID0gbG9vcE91dDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNQcm9wZXJ0eS5zbW9vdGgpIHtcbiAgICAgICAgc21vb3RoID0gdGhpc1Byb3BlcnR5LnNtb290aC5iaW5kKHRoaXNQcm9wZXJ0eSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxvb3BJbkR1cmF0aW9uKHR5cGUsIGR1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBsb29wSW4odHlwZSwgZHVyYXRpb24sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsb29wT3V0RHVyYXRpb24odHlwZSwgZHVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGxvb3BPdXQodHlwZSwgZHVyYXRpb24sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5nZXRWYWx1ZUF0VGltZSkge1xuICAgICAgICB2YWx1ZUF0VGltZSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUuYmluZCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZ2V0VmVsb2NpdHlBdFRpbWUpIHtcbiAgICAgICAgdmVsb2NpdHlBdFRpbWUgPSB0aGlzLmdldFZlbG9jaXR5QXRUaW1lLmJpbmQodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21wID0gZWxlbS5jb21wLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5iaW5kKGVsZW0uY29tcC5nbG9iYWxEYXRhLnByb2plY3RJbnRlcmZhY2UpO1xuXG4gICAgICBmdW5jdGlvbiBsb29rQXQoZWxlbTEsIGVsZW0yKSB7XG4gICAgICAgIHZhciBmVmVjID0gW2VsZW0yWzBdIC0gZWxlbTFbMF0sIGVsZW0yWzFdIC0gZWxlbTFbMV0sIGVsZW0yWzJdIC0gZWxlbTFbMl1dO1xuICAgICAgICB2YXIgcGl0Y2ggPSBNYXRoLmF0YW4yKGZWZWNbMF0sIE1hdGguc3FydChmVmVjWzFdICogZlZlY1sxXSArIGZWZWNbMl0gKiBmVmVjWzJdKSkgLyBkZWdUb1JhZHM7XG4gICAgICAgIHZhciB5YXcgPSAtTWF0aC5hdGFuMihmVmVjWzFdLCBmVmVjWzJdKSAvIGRlZ1RvUmFkcztcbiAgICAgICAgcmV0dXJuIFt5YXcsIHBpdGNoLCAwXTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZWFzZU91dCh0LCB0TWluLCB0TWF4LCB2YWwxLCB2YWwyKSB7XG4gICAgICAgIHJldHVybiBhcHBseUVhc2UoZWFzZU91dEJleiwgdCwgdE1pbiwgdE1heCwgdmFsMSwgdmFsMik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGVhc2VJbih0LCB0TWluLCB0TWF4LCB2YWwxLCB2YWwyKSB7XG4gICAgICAgIHJldHVybiBhcHBseUVhc2UoZWFzZUluQmV6LCB0LCB0TWluLCB0TWF4LCB2YWwxLCB2YWwyKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZWFzZSh0LCB0TWluLCB0TWF4LCB2YWwxLCB2YWwyKSB7XG4gICAgICAgIHJldHVybiBhcHBseUVhc2UoZWFzZUluT3V0QmV6LCB0LCB0TWluLCB0TWF4LCB2YWwxLCB2YWwyKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYXBwbHlFYXNlKGZuLCB0LCB0TWluLCB0TWF4LCB2YWwxLCB2YWwyKSB7XG4gICAgICAgIGlmICh2YWwxID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YWwxID0gdE1pbjtcbiAgICAgICAgICB2YWwyID0gdE1heDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ID0gKHQgLSB0TWluKSAvICh0TWF4IC0gdE1pbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodCA+IDEpIHtcbiAgICAgICAgICB0ID0gMTtcbiAgICAgICAgfSBlbHNlIGlmICh0IDwgMCkge1xuICAgICAgICAgIHQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG11bHQgPSBmbih0KTtcblxuICAgICAgICBpZiAoJGJtX2lzSW5zdGFuY2VPZkFycmF5KHZhbDEpKSB7XG4gICAgICAgICAgdmFyIGlLZXk7XG4gICAgICAgICAgdmFyIGxlbktleSA9IHZhbDEubGVuZ3RoO1xuICAgICAgICAgIHZhciBhcnIgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuS2V5KTtcblxuICAgICAgICAgIGZvciAoaUtleSA9IDA7IGlLZXkgPCBsZW5LZXk7IGlLZXkgKz0gMSkge1xuICAgICAgICAgICAgYXJyW2lLZXldID0gKHZhbDJbaUtleV0gLSB2YWwxW2lLZXldKSAqIG11bHQgKyB2YWwxW2lLZXldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHZhbDIgLSB2YWwxKSAqIG11bHQgKyB2YWwxO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBuZWFyZXN0S2V5KHRpbWUpIHtcbiAgICAgICAgdmFyIGlLZXk7XG4gICAgICAgIHZhciBsZW5LZXkgPSBkYXRhLmsubGVuZ3RoO1xuICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgIHZhciBrZXlUaW1lO1xuXG4gICAgICAgIGlmICghZGF0YS5rLmxlbmd0aCB8fCB0eXBlb2YgZGF0YS5rWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICBrZXlUaW1lID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgIHRpbWUgKj0gZWxlbS5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuXG4gICAgICAgICAgaWYgKHRpbWUgPCBkYXRhLmtbMF0udCkge1xuICAgICAgICAgICAgaW5kZXggPSAxO1xuICAgICAgICAgICAga2V5VGltZSA9IGRhdGEua1swXS50O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGlLZXkgPSAwOyBpS2V5IDwgbGVuS2V5IC0gMTsgaUtleSArPSAxKSB7XG4gICAgICAgICAgICAgIGlmICh0aW1lID09PSBkYXRhLmtbaUtleV0udCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaUtleSArIDE7XG4gICAgICAgICAgICAgICAga2V5VGltZSA9IGRhdGEua1tpS2V5XS50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRpbWUgPiBkYXRhLmtbaUtleV0udCAmJiB0aW1lIDwgZGF0YS5rW2lLZXkgKyAxXS50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgLSBkYXRhLmtbaUtleV0udCA+IGRhdGEua1tpS2V5ICsgMV0udCAtIHRpbWUpIHtcbiAgICAgICAgICAgICAgICAgIGluZGV4ID0gaUtleSArIDI7XG4gICAgICAgICAgICAgICAgICBrZXlUaW1lID0gZGF0YS5rW2lLZXkgKyAxXS50O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpbmRleCA9IGlLZXkgKyAxO1xuICAgICAgICAgICAgICAgICAga2V5VGltZSA9IGRhdGEua1tpS2V5XS50O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgaW5kZXggPSBpS2V5ICsgMTtcbiAgICAgICAgICAgICAga2V5VGltZSA9IGRhdGEua1tpS2V5XS50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvYktleSA9IHt9O1xuICAgICAgICBvYktleS5pbmRleCA9IGluZGV4O1xuICAgICAgICBvYktleS50aW1lID0ga2V5VGltZSAvIGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcbiAgICAgICAgcmV0dXJuIG9iS2V5O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBrZXkoaW5kKSB7XG4gICAgICAgIHZhciBvYktleTtcbiAgICAgICAgdmFyIGlLZXk7XG4gICAgICAgIHZhciBsZW5LZXk7XG5cbiAgICAgICAgaWYgKCFkYXRhLmsubGVuZ3RoIHx8IHR5cGVvZiBkYXRhLmtbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvcGVydHkgaGFzIG5vIGtleWZyYW1lIGF0IGluZGV4ICcgKyBpbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kIC09IDE7XG4gICAgICAgIG9iS2V5ID0ge1xuICAgICAgICAgIHRpbWU6IGRhdGEua1tpbmRdLnQgLyBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsXG4gICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHZhciBhcnIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YS5rW2luZF0sICdzJykgPyBkYXRhLmtbaW5kXS5zIDogZGF0YS5rW2luZCAtIDFdLmU7XG4gICAgICAgIGxlbktleSA9IGFyci5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpS2V5ID0gMDsgaUtleSA8IGxlbktleTsgaUtleSArPSAxKSB7XG4gICAgICAgICAgb2JLZXlbaUtleV0gPSBhcnJbaUtleV07XG4gICAgICAgICAgb2JLZXkudmFsdWVbaUtleV0gPSBhcnJbaUtleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JLZXk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZyYW1lc1RvVGltZShmciwgZnBzKSB7XG4gICAgICAgIGlmICghZnBzKSB7XG4gICAgICAgICAgZnBzID0gZWxlbS5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZyIC8gZnBzO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0aW1lVG9GcmFtZXModCwgZnBzKSB7XG4gICAgICAgIGlmICghdCAmJiB0ICE9PSAwKSB7XG4gICAgICAgICAgdCA9IHRpbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZwcykge1xuICAgICAgICAgIGZwcyA9IGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ICogZnBzO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzZWVkUmFuZG9tKHNlZWQpIHtcbiAgICAgICAgQk1NYXRoLnNlZWRyYW5kb20ocmFuZFNlZWQgKyBzZWVkKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc291cmNlUmVjdEF0VGltZSgpIHtcbiAgICAgICAgcmV0dXJuIGVsZW0uc291cmNlUmVjdEF0VGltZSgpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzdWJzdHJpbmcoaW5pdCwgZW5kKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKGluaXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB2YWx1ZS5zdWJzdHJpbmcoaW5pdCwgZW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc3Vic3RyKGluaXQsIGVuZCkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnN1YnN0cihpbml0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyKGluaXQsIGVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBvc3Rlcml6ZVRpbWUoZnJhbWVzUGVyU2Vjb25kKSB7XG4gICAgICAgIHRpbWUgPSBmcmFtZXNQZXJTZWNvbmQgPT09IDAgPyAwIDogTWF0aC5mbG9vcih0aW1lICogZnJhbWVzUGVyU2Vjb25kKSAvIGZyYW1lc1BlclNlY29uZDtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZUF0VGltZSh0aW1lKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpbWU7XG4gICAgICB2YXIgdmVsb2NpdHk7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICB2YXIgdGV4dDtcbiAgICAgIHZhciB0ZXh0SW5kZXg7XG4gICAgICB2YXIgdGV4dFRvdGFsO1xuICAgICAgdmFyIHNlbGVjdG9yVmFsdWU7XG4gICAgICB2YXIgaW5kZXggPSBlbGVtLmRhdGEuaW5kO1xuICAgICAgdmFyIGhhc1BhcmVudCA9ICEhKGVsZW0uaGllcmFyY2h5ICYmIGVsZW0uaGllcmFyY2h5Lmxlbmd0aCk7XG4gICAgICB2YXIgcGFyZW50O1xuICAgICAgdmFyIHJhbmRTZWVkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMCk7XG4gICAgICB2YXIgZ2xvYmFsRGF0YSA9IGVsZW0uZ2xvYmFsRGF0YTtcblxuICAgICAgZnVuY3Rpb24gZXhlY3V0ZUV4cHJlc3Npb24oX3ZhbHVlKSB7XG4gICAgICAgIC8vIGdsb2JhbERhdGEucHVzaEV4cHJlc3Npb24oKTtcbiAgICAgICAgdmFsdWUgPSBfdmFsdWU7XG5cbiAgICAgICAgaWYgKHRoaXMuZnJhbWVFeHByZXNzaW9uSWQgPT09IGVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkICYmIHRoaXMucHJvcFR5cGUgIT09ICd0ZXh0U2VsZWN0b3InKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcFR5cGUgPT09ICd0ZXh0U2VsZWN0b3InKSB7XG4gICAgICAgICAgdGV4dEluZGV4ID0gdGhpcy50ZXh0SW5kZXg7XG4gICAgICAgICAgdGV4dFRvdGFsID0gdGhpcy50ZXh0VG90YWw7XG4gICAgICAgICAgc2VsZWN0b3JWYWx1ZSA9IHRoaXMuc2VsZWN0b3JWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpc0xheWVyKSB7XG4gICAgICAgICAgdGV4dCA9IGVsZW0ubGF5ZXJJbnRlcmZhY2UudGV4dDtcbiAgICAgICAgICB0aGlzTGF5ZXIgPSBlbGVtLmxheWVySW50ZXJmYWNlO1xuICAgICAgICAgIHRoaXNDb21wID0gZWxlbS5jb21wLmNvbXBJbnRlcmZhY2U7XG4gICAgICAgICAgdG9Xb3JsZCA9IHRoaXNMYXllci50b1dvcmxkLmJpbmQodGhpc0xheWVyKTtcbiAgICAgICAgICBmcm9tV29ybGQgPSB0aGlzTGF5ZXIuZnJvbVdvcmxkLmJpbmQodGhpc0xheWVyKTtcbiAgICAgICAgICBmcm9tQ29tcCA9IHRoaXNMYXllci5mcm9tQ29tcC5iaW5kKHRoaXNMYXllcik7XG4gICAgICAgICAgdG9Db21wID0gdGhpc0xheWVyLnRvQ29tcC5iaW5kKHRoaXNMYXllcik7XG4gICAgICAgICAgbWFzayA9IHRoaXNMYXllci5tYXNrID8gdGhpc0xheWVyLm1hc2suYmluZCh0aGlzTGF5ZXIpIDogbnVsbDtcbiAgICAgICAgICBmcm9tQ29tcFRvU3VyZmFjZSA9IGZyb21Db21wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgICAgICB0cmFuc2Zvcm0gPSBlbGVtLmxheWVySW50ZXJmYWNlKCdBREJFIFRyYW5zZm9ybSBHcm91cCcpO1xuICAgICAgICAgICRibV90cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5cbiAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBhbmNob3JQb2ludCA9IHRyYW5zZm9ybS5hbmNob3JQb2ludDtcbiAgICAgICAgICAgIC8qIHBvc2l0aW9uID0gdHJhbnNmb3JtLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgcm90YXRpb24gPSB0cmFuc2Zvcm0ucm90YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICBzY2FsZSA9IHRyYW5zZm9ybS5zY2FsZTsgKi9cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxlbVR5cGUgPT09IDQgJiYgIWNvbnRlbnQpIHtcbiAgICAgICAgICBjb250ZW50ID0gdGhpc0xheWVyKCdBREJFIFJvb3QgVmVjdG9ycyBHcm91cCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFlZmZlY3QpIHtcbiAgICAgICAgICBlZmZlY3QgPSB0aGlzTGF5ZXIoNCk7XG4gICAgICAgIH1cblxuICAgICAgICBoYXNQYXJlbnQgPSAhIShlbGVtLmhpZXJhcmNoeSAmJiBlbGVtLmhpZXJhcmNoeS5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChoYXNQYXJlbnQgJiYgIXBhcmVudCkge1xuICAgICAgICAgIHBhcmVudCA9IGVsZW0uaGllcmFyY2h5WzBdLmxheWVySW50ZXJmYWNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGltZSA9IHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuXG4gICAgICAgIGlmIChfbmVlZHNSYW5kb20pIHtcbiAgICAgICAgICBzZWVkUmFuZG9tKHJhbmRTZWVkICsgdGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmVlZHNWZWxvY2l0eSkge1xuICAgICAgICAgIHZlbG9jaXR5ID0gdmVsb2NpdHlBdFRpbWUodGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICBleHByZXNzaW9uX2Z1bmN0aW9uKCk7XG4gICAgICAgIHRoaXMuZnJhbWVFeHByZXNzaW9uSWQgPSBlbGVtLmdsb2JhbERhdGEuZnJhbWVJZDsgLy8gVE9ETzogQ2hlY2sgaWYgaXQncyBwb3NzaWJsZSB0byByZXR1cm4gb24gU2hhcGVJbnRlcmZhY2UgdGhlIC52IHZhbHVlXG4gICAgICAgIC8vIENoYW5nZWQgdGhpcyB0byBhIHRlcm5hcnkgb3BlcmF0aW9uIGJlY2F1c2UgUm9sbHVwIGZhaWxlZCBjb21waWxpbmcgaXQgY29ycmVjdGx5XG5cbiAgICAgICAgc2NvcGVkX2JtX3J0ID0gc2NvcGVkX2JtX3J0LnByb3BUeXBlID09PSBwcm9wVHlwZXMuU0hBUEUgPyBzY29wZWRfYm1fcnQudiA6IHNjb3BlZF9ibV9ydDtcbiAgICAgICAgcmV0dXJuIHNjb3BlZF9ibV9ydDtcbiAgICAgIH0gLy8gQnVuZGxlcnMgd2lsbCBzZWUgdGhlc2UgYXMgZGVhZCBjb2RlIGFuZCB1bmxlc3Mgd2UgcmVmZXJlbmNlIHRoZW1cblxuXG4gICAgICBleGVjdXRlRXhwcmVzc2lvbi5fX3ByZXZlbnREZWFkQ29kZVJlbW92YWwgPSBbJGJtX3RyYW5zZm9ybSwgYW5jaG9yUG9pbnQsIHRpbWUsIHZlbG9jaXR5LCBpblBvaW50LCBvdXRQb2ludCwgd2lkdGgsIGhlaWdodCwgbmFtZSwgbG9vcF9pbiwgbG9vcF9vdXQsIHNtb290aCwgdG9Db21wLCBmcm9tQ29tcFRvU3VyZmFjZSwgdG9Xb3JsZCwgZnJvbVdvcmxkLCBtYXNrLCBwb3NpdGlvbiwgcm90YXRpb24sIHNjYWxlLCB0aGlzQ29tcCwgbnVtS2V5cywgYWN0aXZlLCB3aWdnbGUsIGxvb3BJbkR1cmF0aW9uLCBsb29wT3V0RHVyYXRpb24sIGNvbXAsIGxvb2tBdCwgZWFzZU91dCwgZWFzZUluLCBlYXNlLCBuZWFyZXN0S2V5LCBrZXksIHRleHQsIHRleHRJbmRleCwgdGV4dFRvdGFsLCBzZWxlY3RvclZhbHVlLCBmcmFtZXNUb1RpbWUsIHRpbWVUb0ZyYW1lcywgc291cmNlUmVjdEF0VGltZSwgc3Vic3RyaW5nLCBzdWJzdHIsIHBvc3Rlcml6ZVRpbWUsIGluZGV4LCBnbG9iYWxEYXRhXTtcbiAgICAgIHJldHVybiBleGVjdXRlRXhwcmVzc2lvbjtcbiAgICB9XG5cbiAgICBvYi5pbml0aWF0ZUV4cHJlc3Npb24gPSBpbml0aWF0ZUV4cHJlc3Npb247XG4gICAgb2IuX19wcmV2ZW50RGVhZENvZGVSZW1vdmFsID0gW3dpbmRvdywgZG9jdW1lbnQsIFhNTEh0dHBSZXF1ZXN0LCBmZXRjaCwgZnJhbWVzLCAkYm1fbmVnLCBhZGQsICRibV9zdW0sICRibV9zdWIsICRibV9tdWwsICRibV9kaXYsICRibV9tb2QsIGNsYW1wLCByYWRpYW5zX3RvX2RlZ3JlZXMsIGRlZ3JlZXNUb1JhZGlhbnMsIGRlZ3JlZXNfdG9fcmFkaWFucywgbm9ybWFsaXplLCByZ2JUb0hzbCwgaHNsVG9SZ2IsIGxpbmVhciwgcmFuZG9tLCBjcmVhdGVQYXRoLCBfbG90dGllR2xvYmFsXTtcbiAgICBvYi5yZXNldEZyYW1lID0gcmVzZXRGcmFtZTtcbiAgICByZXR1cm4gb2I7XG4gIH0oKTtcblxuICB2YXIgRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iID0ge307XG4gICAgb2IuaW5pdEV4cHJlc3Npb25zID0gaW5pdEV4cHJlc3Npb25zO1xuICAgIG9iLnJlc2V0RnJhbWUgPSBFeHByZXNzaW9uTWFuYWdlci5yZXNldEZyYW1lO1xuXG4gICAgZnVuY3Rpb24gaW5pdEV4cHJlc3Npb25zKGFuaW1hdGlvbikge1xuICAgICAgdmFyIHN0YWNrQ291bnQgPSAwO1xuICAgICAgdmFyIHJlZ2lzdGVycyA9IFtdO1xuXG4gICAgICBmdW5jdGlvbiBwdXNoRXhwcmVzc2lvbigpIHtcbiAgICAgICAgc3RhY2tDb3VudCArPSAxO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwb3BFeHByZXNzaW9uKCkge1xuICAgICAgICBzdGFja0NvdW50IC09IDE7XG5cbiAgICAgICAgaWYgKHN0YWNrQ291bnQgPT09IDApIHtcbiAgICAgICAgICByZWxlYXNlSW5zdGFuY2VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVnaXN0ZXJFeHByZXNzaW9uUHJvcGVydHkoZXhwcmVzc2lvbikge1xuICAgICAgICBpZiAocmVnaXN0ZXJzLmluZGV4T2YoZXhwcmVzc2lvbikgPT09IC0xKSB7XG4gICAgICAgICAgcmVnaXN0ZXJzLnB1c2goZXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVsZWFzZUluc3RhbmNlcygpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW4gPSByZWdpc3RlcnMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIHJlZ2lzdGVyc1tpXS5yZWxlYXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlcnMubGVuZ3RoID0gMDtcbiAgICAgIH1cblxuICAgICAgYW5pbWF0aW9uLnJlbmRlcmVyLmNvbXBJbnRlcmZhY2UgPSBDb21wRXhwcmVzc2lvbkludGVyZmFjZShhbmltYXRpb24ucmVuZGVyZXIpO1xuICAgICAgYW5pbWF0aW9uLnJlbmRlcmVyLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5yZWdpc3RlckNvbXBvc2l0aW9uKGFuaW1hdGlvbi5yZW5kZXJlcik7XG4gICAgICBhbmltYXRpb24ucmVuZGVyZXIuZ2xvYmFsRGF0YS5wdXNoRXhwcmVzc2lvbiA9IHB1c2hFeHByZXNzaW9uO1xuICAgICAgYW5pbWF0aW9uLnJlbmRlcmVyLmdsb2JhbERhdGEucG9wRXhwcmVzc2lvbiA9IHBvcEV4cHJlc3Npb247XG4gICAgICBhbmltYXRpb24ucmVuZGVyZXIuZ2xvYmFsRGF0YS5yZWdpc3RlckV4cHJlc3Npb25Qcm9wZXJ0eSA9IHJlZ2lzdGVyRXhwcmVzc2lvblByb3BlcnR5O1xuICAgIH1cblxuICAgIHJldHVybiBvYjtcbiAgfSgpO1xuXG4gIHZhciBNYXNrTWFuYWdlckludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXNrSW50ZXJmYWNlKG1hc2ssIGRhdGEpIHtcbiAgICAgIHRoaXMuX21hc2sgPSBtYXNrO1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hc2tJbnRlcmZhY2UucHJvdG90eXBlLCAnbWFza1BhdGgnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX21hc2sucHJvcC5rKSB7XG4gICAgICAgICAgdGhpcy5fbWFzay5wcm9wLmdldFZhbHVlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fbWFzay5wcm9wO1xuICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXNrSW50ZXJmYWNlLnByb3RvdHlwZSwgJ21hc2tPcGFjaXR5Jywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9tYXNrLm9wLmspIHtcbiAgICAgICAgICB0aGlzLl9tYXNrLm9wLmdldFZhbHVlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fbWFzay5vcC52ICogMTAwO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIE1hc2tNYW5hZ2VyID0gZnVuY3Rpb24gTWFza01hbmFnZXIobWFza01hbmFnZXIpIHtcbiAgICAgIHZhciBfbWFza3NJbnRlcmZhY2VzID0gY3JlYXRlU2l6ZWRBcnJheShtYXNrTWFuYWdlci52aWV3RGF0YS5sZW5ndGgpO1xuXG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBtYXNrTWFuYWdlci52aWV3RGF0YS5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBfbWFza3NJbnRlcmZhY2VzW2ldID0gbmV3IE1hc2tJbnRlcmZhY2UobWFza01hbmFnZXIudmlld0RhdGFbaV0sIG1hc2tNYW5hZ2VyLm1hc2tzUHJvcGVydGllc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXNrRnVuY3Rpb24gPSBmdW5jdGlvbiBtYXNrRnVuY3Rpb24obmFtZSkge1xuICAgICAgICBpID0gMDtcblxuICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgIGlmIChtYXNrTWFuYWdlci5tYXNrc1Byb3BlcnRpZXNbaV0ubm0gPT09IG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfbWFza3NJbnRlcmZhY2VzW2ldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG1hc2tGdW5jdGlvbjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1hc2tNYW5hZ2VyO1xuICB9KCk7XG5cbiAgdmFyIEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGVmYXVsdFVuaWRpbWVuc2lvbmFsVmFsdWUgPSB7XG4gICAgICBwdjogMCxcbiAgICAgIHY6IDAsXG4gICAgICBtdWx0OiAxXG4gICAgfTtcbiAgICB2YXIgZGVmYXVsdE11bHRpZGltZW5zaW9uYWxWYWx1ZSA9IHtcbiAgICAgIHB2OiBbMCwgMCwgMF0sXG4gICAgICB2OiBbMCwgMCwgMF0sXG4gICAgICBtdWx0OiAxXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlUHJvcGVydHkoZXhwcmVzc2lvblZhbHVlLCBwcm9wZXJ0eSwgdHlwZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cHJlc3Npb25WYWx1ZSwgJ3ZlbG9jaXR5Jywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcGVydHkuZ2V0VmVsb2NpdHlBdFRpbWUocHJvcGVydHkuY29tcC5jdXJyZW50RnJhbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGV4cHJlc3Npb25WYWx1ZS5udW1LZXlzID0gcHJvcGVydHkua2V5ZnJhbWVzID8gcHJvcGVydHkua2V5ZnJhbWVzLmxlbmd0aCA6IDA7XG5cbiAgICAgIGV4cHJlc3Npb25WYWx1ZS5rZXkgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIGlmICghZXhwcmVzc2lvblZhbHVlLm51bUtleXMpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZSA9ICcnO1xuXG4gICAgICAgIGlmICgncycgaW4gcHJvcGVydHkua2V5ZnJhbWVzW3BvcyAtIDFdKSB7XG4gICAgICAgICAgdmFsdWUgPSBwcm9wZXJ0eS5rZXlmcmFtZXNbcG9zIC0gMV0ucztcbiAgICAgICAgfSBlbHNlIGlmICgnZScgaW4gcHJvcGVydHkua2V5ZnJhbWVzW3BvcyAtIDJdKSB7XG4gICAgICAgICAgdmFsdWUgPSBwcm9wZXJ0eS5rZXlmcmFtZXNbcG9zIC0gMl0uZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IHByb3BlcnR5LmtleWZyYW1lc1twb3MgLSAyXS5zO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlUHJvcCA9IHR5cGUgPT09ICd1bmlkaW1lbnNpb25hbCcgPyBuZXcgTnVtYmVyKHZhbHVlKSA6IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblxuICAgICAgICB2YWx1ZVByb3AudGltZSA9IHByb3BlcnR5LmtleWZyYW1lc1twb3MgLSAxXS50IC8gcHJvcGVydHkuZWxlbS5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuICAgICAgICB2YWx1ZVByb3AudmFsdWUgPSB0eXBlID09PSAndW5pZGltZW5zaW9uYWwnID8gdmFsdWVbMF0gOiB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlUHJvcDtcbiAgICAgIH07XG5cbiAgICAgIGV4cHJlc3Npb25WYWx1ZS52YWx1ZUF0VGltZSA9IHByb3BlcnR5LmdldFZhbHVlQXRUaW1lO1xuICAgICAgZXhwcmVzc2lvblZhbHVlLnNwZWVkQXRUaW1lID0gcHJvcGVydHkuZ2V0U3BlZWRBdFRpbWU7XG4gICAgICBleHByZXNzaW9uVmFsdWUudmVsb2NpdHlBdFRpbWUgPSBwcm9wZXJ0eS5nZXRWZWxvY2l0eUF0VGltZTtcbiAgICAgIGV4cHJlc3Npb25WYWx1ZS5wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHkucHJvcGVydHlHcm91cDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBVbmlkaW1lbnNpb25hbFByb3BlcnR5SW50ZXJmYWNlKHByb3BlcnR5KSB7XG4gICAgICBpZiAoIXByb3BlcnR5IHx8ICEoJ3B2JyBpbiBwcm9wZXJ0eSkpIHtcbiAgICAgICAgcHJvcGVydHkgPSBkZWZhdWx0VW5pZGltZW5zaW9uYWxWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG11bHQgPSAxIC8gcHJvcGVydHkubXVsdDtcbiAgICAgIHZhciB2YWwgPSBwcm9wZXJ0eS5wdiAqIG11bHQ7XG4gICAgICB2YXIgZXhwcmVzc2lvblZhbHVlID0gbmV3IE51bWJlcih2YWwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXG4gICAgICBleHByZXNzaW9uVmFsdWUudmFsdWUgPSB2YWw7XG4gICAgICBjb21wbGV0ZVByb3BlcnR5KGV4cHJlc3Npb25WYWx1ZSwgcHJvcGVydHksICd1bmlkaW1lbnNpb25hbCcpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5LmspIHtcbiAgICAgICAgICBwcm9wZXJ0eS5nZXRWYWx1ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsID0gcHJvcGVydHkudiAqIG11bHQ7XG5cbiAgICAgICAgaWYgKGV4cHJlc3Npb25WYWx1ZS52YWx1ZSAhPT0gdmFsKSB7XG4gICAgICAgICAgZXhwcmVzc2lvblZhbHVlID0gbmV3IE51bWJlcih2YWwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXG4gICAgICAgICAgZXhwcmVzc2lvblZhbHVlLnZhbHVlID0gdmFsO1xuICAgICAgICAgIGNvbXBsZXRlUHJvcGVydHkoZXhwcmVzc2lvblZhbHVlLCBwcm9wZXJ0eSwgJ3VuaWRpbWVuc2lvbmFsJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcmVzc2lvblZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBNdWx0aWRpbWVuc2lvbmFsUHJvcGVydHlJbnRlcmZhY2UocHJvcGVydHkpIHtcbiAgICAgIGlmICghcHJvcGVydHkgfHwgISgncHYnIGluIHByb3BlcnR5KSkge1xuICAgICAgICBwcm9wZXJ0eSA9IGRlZmF1bHRNdWx0aWRpbWVuc2lvbmFsVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBtdWx0ID0gMSAvIHByb3BlcnR5Lm11bHQ7XG4gICAgICB2YXIgbGVuID0gcHJvcGVydHkuZGF0YSAmJiBwcm9wZXJ0eS5kYXRhLmwgfHwgcHJvcGVydHkucHYubGVuZ3RoO1xuICAgICAgdmFyIGV4cHJlc3Npb25WYWx1ZSA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuICAgICAgdmFyIGFyclZhbHVlID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XG4gICAgICBleHByZXNzaW9uVmFsdWUudmFsdWUgPSBhcnJWYWx1ZTtcbiAgICAgIGNvbXBsZXRlUHJvcGVydHkoZXhwcmVzc2lvblZhbHVlLCBwcm9wZXJ0eSwgJ211bHRpZGltZW5zaW9uYWwnKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eS5rKSB7XG4gICAgICAgICAgcHJvcGVydHkuZ2V0VmFsdWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBhcnJWYWx1ZVtpXSA9IHByb3BlcnR5LnZbaV0gKiBtdWx0O1xuICAgICAgICAgIGV4cHJlc3Npb25WYWx1ZVtpXSA9IGFyclZhbHVlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25WYWx1ZTtcbiAgICAgIH07XG4gICAgfSAvLyBUT0RPOiB0cnkgdG8gYXZvaWQgdXNpbmcgdGhpcyBnZXR0ZXJcblxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdEdldHRlcigpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VW5pZGltZW5zaW9uYWxWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICBpZiAoIXByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0R2V0dGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcGVydHkucHJvcFR5cGUgPT09ICd1bmlkaW1lbnNpb25hbCcpIHtcbiAgICAgICAgcmV0dXJuIFVuaWRpbWVuc2lvbmFsUHJvcGVydHlJbnRlcmZhY2UocHJvcGVydHkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTXVsdGlkaW1lbnNpb25hbFByb3BlcnR5SW50ZXJmYWNlKHByb3BlcnR5KTtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIFRyYW5zZm9ybUV4cHJlc3Npb25JbnRlcmZhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcbiAgICAgIGZ1bmN0aW9uIF90aGlzRnVuY3Rpb24obmFtZSkge1xuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICBjYXNlICdzY2FsZSc6XG4gICAgICAgICAgY2FzZSAnU2NhbGUnOlxuICAgICAgICAgIGNhc2UgJ0FEQkUgU2NhbGUnOlxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uLnNjYWxlO1xuXG4gICAgICAgICAgY2FzZSAncm90YXRpb24nOlxuICAgICAgICAgIGNhc2UgJ1JvdGF0aW9uJzpcbiAgICAgICAgICBjYXNlICdBREJFIFJvdGF0aW9uJzpcbiAgICAgICAgICBjYXNlICdBREJFIFJvdGF0ZSBaJzpcbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb24ucm90YXRpb247XG5cbiAgICAgICAgICBjYXNlICdBREJFIFJvdGF0ZSBYJzpcbiAgICAgICAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uLnhSb3RhdGlvbjtcblxuICAgICAgICAgIGNhc2UgJ0FEQkUgUm90YXRlIFknOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb24ueVJvdGF0aW9uO1xuXG4gICAgICAgICAgY2FzZSAncG9zaXRpb24nOlxuICAgICAgICAgIGNhc2UgJ1Bvc2l0aW9uJzpcbiAgICAgICAgICBjYXNlICdBREJFIFBvc2l0aW9uJzpcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi5wb3NpdGlvbjtcblxuICAgICAgICAgIGNhc2UgJ0FEQkUgUG9zaXRpb25fMCc6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi54UG9zaXRpb247XG5cbiAgICAgICAgICBjYXNlICdBREJFIFBvc2l0aW9uXzEnOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb24ueVBvc2l0aW9uO1xuXG4gICAgICAgICAgY2FzZSAnQURCRSBQb3NpdGlvbl8yJzpcbiAgICAgICAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uLnpQb3NpdGlvbjtcblxuICAgICAgICAgIGNhc2UgJ2FuY2hvclBvaW50JzpcbiAgICAgICAgICBjYXNlICdBbmNob3JQb2ludCc6XG4gICAgICAgICAgY2FzZSAnQW5jaG9yIFBvaW50JzpcbiAgICAgICAgICBjYXNlICdBREJFIEFuY2hvclBvaW50JzpcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi5hbmNob3JQb2ludDtcblxuICAgICAgICAgIGNhc2UgJ29wYWNpdHknOlxuICAgICAgICAgIGNhc2UgJ09wYWNpdHknOlxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi5vcGFjaXR5O1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAncm90YXRpb24nLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5yIHx8IHRyYW5zZm9ybS5yeilcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICd6Um90YXRpb24nLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5yeiB8fCB0cmFuc2Zvcm0ucilcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICd4Um90YXRpb24nLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5yeClcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICd5Um90YXRpb24nLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5yeSlcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICdzY2FsZScsIHtcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnMpXG4gICAgICB9KTtcblxuICAgICAgdmFyIF9weDtcblxuICAgICAgdmFyIF9weTtcblxuICAgICAgdmFyIF9wejtcblxuICAgICAgdmFyIF90cmFuc2Zvcm1GYWN0b3J5O1xuXG4gICAgICBpZiAodHJhbnNmb3JtLnApIHtcbiAgICAgICAgX3RyYW5zZm9ybUZhY3RvcnkgPSBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3B4ID0gRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5weCk7XG4gICAgICAgIF9weSA9IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucHkpO1xuXG4gICAgICAgIGlmICh0cmFuc2Zvcm0ucHopIHtcbiAgICAgICAgICBfcHogPSBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnB6KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ3Bvc2l0aW9uJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICBpZiAodHJhbnNmb3JtLnApIHtcbiAgICAgICAgICAgIHJldHVybiBfdHJhbnNmb3JtRmFjdG9yeSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBbX3B4KCksIF9weSgpLCBfcHogPyBfcHooKSA6IDBdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAneFBvc2l0aW9uJywge1xuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucHgpXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAneVBvc2l0aW9uJywge1xuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucHkpXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAnelBvc2l0aW9uJywge1xuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucHopXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAnYW5jaG9yUG9pbnQnLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5hKVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ29wYWNpdHknLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5vKVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ3NrZXcnLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5zaylcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICdza2V3QXhpcycsIHtcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnNhKVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ29yaWVudGF0aW9uJywge1xuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ub3IpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uO1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgTGF5ZXJFeHByZXNzaW9uSW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGdldE1hdHJpeCh0aW1lKSB7XG4gICAgICB2YXIgdG9Xb3JsZE1hdCA9IG5ldyBNYXRyaXgoKTtcblxuICAgICAgaWYgKHRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgcHJvcE1hdHJpeCA9IHRoaXMuX2VsZW0uZmluYWxUcmFuc2Zvcm0ubVByb3AuZ2V0VmFsdWVBdFRpbWUodGltZSk7XG5cbiAgICAgICAgcHJvcE1hdHJpeC5jbG9uZSh0b1dvcmxkTWF0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1NYXQgPSB0aGlzLl9lbGVtLmZpbmFsVHJhbnNmb3JtLm1Qcm9wO1xuICAgICAgICB0cmFuc2Zvcm1NYXQuYXBwbHlUb01hdHJpeCh0b1dvcmxkTWF0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRvV29ybGRNYXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Xb3JsZFZlYyhhcnIsIHRpbWUpIHtcbiAgICAgIHZhciB0b1dvcmxkTWF0ID0gdGhpcy5nZXRNYXRyaXgodGltZSk7XG4gICAgICB0b1dvcmxkTWF0LnByb3BzWzEyXSA9IDA7XG4gICAgICB0b1dvcmxkTWF0LnByb3BzWzEzXSA9IDA7XG4gICAgICB0b1dvcmxkTWF0LnByb3BzWzE0XSA9IDA7XG4gICAgICByZXR1cm4gdGhpcy5hcHBseVBvaW50KHRvV29ybGRNYXQsIGFycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Xb3JsZChhcnIsIHRpbWUpIHtcbiAgICAgIHZhciB0b1dvcmxkTWF0ID0gdGhpcy5nZXRNYXRyaXgodGltZSk7XG4gICAgICByZXR1cm4gdGhpcy5hcHBseVBvaW50KHRvV29ybGRNYXQsIGFycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbVdvcmxkVmVjKGFyciwgdGltZSkge1xuICAgICAgdmFyIHRvV29ybGRNYXQgPSB0aGlzLmdldE1hdHJpeCh0aW1lKTtcbiAgICAgIHRvV29ybGRNYXQucHJvcHNbMTJdID0gMDtcbiAgICAgIHRvV29ybGRNYXQucHJvcHNbMTNdID0gMDtcbiAgICAgIHRvV29ybGRNYXQucHJvcHNbMTRdID0gMDtcbiAgICAgIHJldHVybiB0aGlzLmludmVydFBvaW50KHRvV29ybGRNYXQsIGFycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbVdvcmxkKGFyciwgdGltZSkge1xuICAgICAgdmFyIHRvV29ybGRNYXQgPSB0aGlzLmdldE1hdHJpeCh0aW1lKTtcbiAgICAgIHJldHVybiB0aGlzLmludmVydFBvaW50KHRvV29ybGRNYXQsIGFycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlQb2ludChtYXRyaXgsIGFycikge1xuICAgICAgaWYgKHRoaXMuX2VsZW0uaGllcmFyY2h5ICYmIHRoaXMuX2VsZW0uaGllcmFyY2h5Lmxlbmd0aCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuX2VsZW0uaGllcmFyY2h5Lmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICB0aGlzLl9lbGVtLmhpZXJhcmNoeVtpXS5maW5hbFRyYW5zZm9ybS5tUHJvcC5hcHBseVRvTWF0cml4KG1hdHJpeCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hdHJpeC5hcHBseVRvUG9pbnRBcnJheShhcnJbMF0sIGFyclsxXSwgYXJyWzJdIHx8IDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmVydFBvaW50KG1hdHJpeCwgYXJyKSB7XG4gICAgICBpZiAodGhpcy5fZWxlbS5oaWVyYXJjaHkgJiYgdGhpcy5fZWxlbS5oaWVyYXJjaHkubGVuZ3RoKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5fZWxlbS5oaWVyYXJjaHkubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIHRoaXMuX2VsZW0uaGllcmFyY2h5W2ldLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLmFwcGx5VG9NYXRyaXgobWF0cml4KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF0cml4LmludmVyc2VQb2ludChhcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb21Db21wKGFycikge1xuICAgICAgdmFyIHRvV29ybGRNYXQgPSBuZXcgTWF0cml4KCk7XG4gICAgICB0b1dvcmxkTWF0LnJlc2V0KCk7XG5cbiAgICAgIHRoaXMuX2VsZW0uZmluYWxUcmFuc2Zvcm0ubVByb3AuYXBwbHlUb01hdHJpeCh0b1dvcmxkTWF0KTtcblxuICAgICAgaWYgKHRoaXMuX2VsZW0uaGllcmFyY2h5ICYmIHRoaXMuX2VsZW0uaGllcmFyY2h5Lmxlbmd0aCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuX2VsZW0uaGllcmFyY2h5Lmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICB0aGlzLl9lbGVtLmhpZXJhcmNoeVtpXS5maW5hbFRyYW5zZm9ybS5tUHJvcC5hcHBseVRvTWF0cml4KHRvV29ybGRNYXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvV29ybGRNYXQuaW52ZXJzZVBvaW50KGFycik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b1dvcmxkTWF0LmludmVyc2VQb2ludChhcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNhbXBsZUltYWdlKCkge1xuICAgICAgcmV0dXJuIFsxLCAxLCAxLCAxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1JbnRlcmZhY2U7XG5cbiAgICAgIGZ1bmN0aW9uIF9yZWdpc3Rlck1hc2tJbnRlcmZhY2UobWFza01hbmFnZXIpIHtcbiAgICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLm1hc2sgPSBuZXcgTWFza01hbmFnZXJJbnRlcmZhY2UobWFza01hbmFnZXIsIGVsZW0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfcmVnaXN0ZXJFZmZlY3RzSW50ZXJmYWNlKGVmZmVjdHMpIHtcbiAgICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLmVmZmVjdCA9IGVmZmVjdHM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aGlzTGF5ZXJGdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgIGNhc2UgJ0FEQkUgUm9vdCBWZWN0b3JzIEdyb3VwJzpcbiAgICAgICAgICBjYXNlICdDb250ZW50cyc6XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzTGF5ZXJGdW5jdGlvbi5zaGFwZUludGVyZmFjZTtcblxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgY2FzZSAnVHJhbnNmb3JtJzpcbiAgICAgICAgICBjYXNlICd0cmFuc2Zvcm0nOlxuICAgICAgICAgIGNhc2UgJ0FEQkUgVHJhbnNmb3JtIEdyb3VwJzpcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1JbnRlcmZhY2U7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY2FzZSAnQURCRSBFZmZlY3QgUGFyYWRlJzpcbiAgICAgICAgICBjYXNlICdlZmZlY3RzJzpcbiAgICAgICAgICBjYXNlICdFZmZlY3RzJzpcbiAgICAgICAgICAgIHJldHVybiBfdGhpc0xheWVyRnVuY3Rpb24uZWZmZWN0O1xuXG4gICAgICAgICAgY2FzZSAnQURCRSBUZXh0IFByb3BlcnRpZXMnOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzTGF5ZXJGdW5jdGlvbi50ZXh0SW50ZXJmYWNlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5nZXRNYXRyaXggPSBnZXRNYXRyaXg7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uaW52ZXJ0UG9pbnQgPSBpbnZlcnRQb2ludDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5hcHBseVBvaW50ID0gYXBwbHlQb2ludDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi50b1dvcmxkID0gdG9Xb3JsZDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi50b1dvcmxkVmVjID0gdG9Xb3JsZFZlYztcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5mcm9tV29ybGQgPSBmcm9tV29ybGQ7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uZnJvbVdvcmxkVmVjID0gZnJvbVdvcmxkVmVjO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnRvQ29tcCA9IHRvV29ybGQ7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uZnJvbUNvbXAgPSBmcm9tQ29tcDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5zYW1wbGVJbWFnZSA9IHNhbXBsZUltYWdlO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnNvdXJjZVJlY3RBdFRpbWUgPSBlbGVtLnNvdXJjZVJlY3RBdFRpbWUuYmluZChlbGVtKTtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5fZWxlbSA9IGVsZW07XG4gICAgICB0cmFuc2Zvcm1JbnRlcmZhY2UgPSBUcmFuc2Zvcm1FeHByZXNzaW9uSW50ZXJmYWNlKGVsZW0uZmluYWxUcmFuc2Zvcm0ubVByb3ApO1xuICAgICAgdmFyIGFuY2hvclBvaW50RGVzY3JpcHRvciA9IGdldERlc2NyaXB0b3IodHJhbnNmb3JtSW50ZXJmYWNlLCAnYW5jaG9yUG9pbnQnKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzTGF5ZXJGdW5jdGlvbiwge1xuICAgICAgICBoYXNQYXJlbnQ6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmhpZXJhcmNoeS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmhpZXJhcmNoeVswXS5sYXllckludGVyZmFjZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJvdGF0aW9uOiBnZXREZXNjcmlwdG9yKHRyYW5zZm9ybUludGVyZmFjZSwgJ3JvdGF0aW9uJyksXG4gICAgICAgIHNjYWxlOiBnZXREZXNjcmlwdG9yKHRyYW5zZm9ybUludGVyZmFjZSwgJ3NjYWxlJyksXG4gICAgICAgIHBvc2l0aW9uOiBnZXREZXNjcmlwdG9yKHRyYW5zZm9ybUludGVyZmFjZSwgJ3Bvc2l0aW9uJyksXG4gICAgICAgIG9wYWNpdHk6IGdldERlc2NyaXB0b3IodHJhbnNmb3JtSW50ZXJmYWNlLCAnb3BhY2l0eScpLFxuICAgICAgICBhbmNob3JQb2ludDogYW5jaG9yUG9pbnREZXNjcmlwdG9yLFxuICAgICAgICBhbmNob3JfcG9pbnQ6IGFuY2hvclBvaW50RGVzY3JpcHRvcixcbiAgICAgICAgdHJhbnNmb3JtOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtSW50ZXJmYWNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWN0aXZlOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS5pc0luUmFuZ2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5zdGFydFRpbWUgPSBlbGVtLmRhdGEuc3Q7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uaW5kZXggPSBlbGVtLmRhdGEuaW5kO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnNvdXJjZSA9IGVsZW0uZGF0YS5yZWZJZDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5oZWlnaHQgPSBlbGVtLmRhdGEudHkgPT09IDAgPyBlbGVtLmRhdGEuaCA6IDEwMDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi53aWR0aCA9IGVsZW0uZGF0YS50eSA9PT0gMCA/IGVsZW0uZGF0YS53IDogMTAwO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLmluUG9pbnQgPSBlbGVtLmRhdGEuaXAgLyBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24ub3V0UG9pbnQgPSBlbGVtLmRhdGEub3AgLyBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uX25hbWUgPSBlbGVtLmRhdGEubm07XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24ucmVnaXN0ZXJNYXNrSW50ZXJmYWNlID0gX3JlZ2lzdGVyTWFza0ludGVyZmFjZTtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5yZWdpc3RlckVmZmVjdHNJbnRlcmZhY2UgPSBfcmVnaXN0ZXJFZmZlY3RzSW50ZXJmYWNlO1xuICAgICAgcmV0dXJuIF90aGlzTGF5ZXJGdW5jdGlvbjtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIHByb3BlcnR5R3JvdXBGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW50ZXJmYWNlRnVuY3Rpb24sIHBhcmVudFByb3BlcnR5R3JvdXApIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhbCA9IHZhbCA9PT0gdW5kZWZpbmVkID8gMSA6IHZhbDtcblxuICAgICAgICBpZiAodmFsIDw9IDApIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyZW50UHJvcGVydHlHcm91cCh2YWwgLSAxKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBQcm9wZXJ0eUludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHByb3BlcnR5TmFtZSwgcHJvcGVydHlHcm91cCkge1xuICAgICAgdmFyIGludGVyZmFjZUZ1bmN0aW9uID0ge1xuICAgICAgICBfbmFtZTogcHJvcGVydHlOYW1lXG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBfcHJvcGVydHlHcm91cCh2YWwpIHtcbiAgICAgICAgdmFsID0gdmFsID09PSB1bmRlZmluZWQgPyAxIDogdmFsO1xuXG4gICAgICAgIGlmICh2YWwgPD0gMCkge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9wZXJ0eUdyb3VwKHZhbCAtIDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3Byb3BlcnR5R3JvdXA7XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBFZmZlY3RzRXhwcmVzc2lvbkludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2IgPSB7XG4gICAgICBjcmVhdGVFZmZlY3RzSW50ZXJmYWNlOiBjcmVhdGVFZmZlY3RzSW50ZXJmYWNlXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVmZmVjdHNJbnRlcmZhY2UoZWxlbSwgcHJvcGVydHlHcm91cCkge1xuICAgICAgaWYgKGVsZW0uZWZmZWN0c01hbmFnZXIpIHtcbiAgICAgICAgdmFyIGVmZmVjdEVsZW1lbnRzID0gW107XG4gICAgICAgIHZhciBlZmZlY3RzRGF0YSA9IGVsZW0uZGF0YS5lZjtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW4gPSBlbGVtLmVmZmVjdHNNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBlZmZlY3RFbGVtZW50cy5wdXNoKGNyZWF0ZUdyb3VwSW50ZXJmYWNlKGVmZmVjdHNEYXRhW2ldLCBlbGVtLmVmZmVjdHNNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzW2ldLCBwcm9wZXJ0eUdyb3VwLCBlbGVtKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWZmZWN0cyA9IGVsZW0uZGF0YS5lZiB8fCBbXTtcblxuICAgICAgICB2YXIgZ3JvdXBJbnRlcmZhY2UgPSBmdW5jdGlvbiBncm91cEludGVyZmFjZShuYW1lKSB7XG4gICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgbGVuID0gZWZmZWN0cy5sZW5ndGg7XG5cbiAgICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09IGVmZmVjdHNbaV0ubm0gfHwgbmFtZSA9PT0gZWZmZWN0c1tpXS5tbiB8fCBuYW1lID09PSBlZmZlY3RzW2ldLml4KSB7XG4gICAgICAgICAgICAgIHJldHVybiBlZmZlY3RFbGVtZW50c1tpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShncm91cEludGVyZmFjZSwgJ251bVByb3BlcnRpZXMnLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gZWZmZWN0cy5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdyb3VwSW50ZXJmYWNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVHcm91cEludGVyZmFjZShkYXRhLCBlbGVtZW50cywgcHJvcGVydHlHcm91cCwgZWxlbSkge1xuICAgICAgZnVuY3Rpb24gZ3JvdXBJbnRlcmZhY2UobmFtZSkge1xuICAgICAgICB2YXIgZWZmZWN0cyA9IGRhdGEuZWY7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IGVmZmVjdHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgaWYgKG5hbWUgPT09IGVmZmVjdHNbaV0ubm0gfHwgbmFtZSA9PT0gZWZmZWN0c1tpXS5tbiB8fCBuYW1lID09PSBlZmZlY3RzW2ldLml4KSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0c1tpXS50eSA9PT0gNSkge1xuICAgICAgICAgICAgICByZXR1cm4gZWZmZWN0RWxlbWVudHNbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlZmZlY3RFbGVtZW50c1tpXSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShncm91cEludGVyZmFjZSwgcHJvcGVydHlHcm91cCk7XG5cbiAgICAgIHZhciBlZmZlY3RFbGVtZW50cyA9IFtdO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gZGF0YS5lZi5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoZGF0YS5lZltpXS50eSA9PT0gNSkge1xuICAgICAgICAgIGVmZmVjdEVsZW1lbnRzLnB1c2goY3JlYXRlR3JvdXBJbnRlcmZhY2UoZGF0YS5lZltpXSwgZWxlbWVudHMuZWZmZWN0RWxlbWVudHNbaV0sIGVsZW1lbnRzLmVmZmVjdEVsZW1lbnRzW2ldLnByb3BlcnR5R3JvdXAsIGVsZW0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZmZlY3RFbGVtZW50cy5wdXNoKGNyZWF0ZVZhbHVlSW50ZXJmYWNlKGVsZW1lbnRzLmVmZmVjdEVsZW1lbnRzW2ldLCBkYXRhLmVmW2ldLnR5LCBlbGVtLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLm1uID09PSAnQURCRSBDb2xvciBDb250cm9sJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ3JvdXBJbnRlcmZhY2UsICdjb2xvcicsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBlZmZlY3RFbGVtZW50c1swXSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGdyb3VwSW50ZXJmYWNlLCB7XG4gICAgICAgIG51bVByb3BlcnRpZXM6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLm5wO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogZGF0YS5ubVxuICAgICAgICB9LFxuICAgICAgICBwcm9wZXJ0eUdyb3VwOiB7XG4gICAgICAgICAgdmFsdWU6IF9wcm9wZXJ0eUdyb3VwXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZ3JvdXBJbnRlcmZhY2UuZW5hYmxlZCA9IGRhdGEuZW4gIT09IDA7XG4gICAgICBncm91cEludGVyZmFjZS5hY3RpdmUgPSBncm91cEludGVyZmFjZS5lbmFibGVkO1xuICAgICAgcmV0dXJuIGdyb3VwSW50ZXJmYWNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVZhbHVlSW50ZXJmYWNlKGVsZW1lbnQsIHR5cGUsIGVsZW0sIHByb3BlcnR5R3JvdXApIHtcbiAgICAgIHZhciBleHByZXNzaW9uUHJvcGVydHkgPSBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UoZWxlbWVudC5wKTtcblxuICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAxMCkge1xuICAgICAgICAgIHJldHVybiBlbGVtLmNvbXAuY29tcEludGVyZmFjZShlbGVtZW50LnAudik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcmVzc2lvblByb3BlcnR5KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50LnAuc2V0R3JvdXBQcm9wZXJ0eSkge1xuICAgICAgICBlbGVtZW50LnAuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnJywgcHJvcGVydHlHcm91cCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iO1xuICB9KCk7XG5cbiAgdmFyIFNoYXBlUGF0aEludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcGF0aEludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcbiAgICAgIHZhciBwcm9wID0gdmlldy5zaDtcblxuICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGlmICh2YWwgPT09ICdTaGFwZScgfHwgdmFsID09PSAnc2hhcGUnIHx8IHZhbCA9PT0gJ1BhdGgnIHx8IHZhbCA9PT0gJ3BhdGgnIHx8IHZhbCA9PT0gJ0FEQkUgVmVjdG9yIFNoYXBlJyB8fCB2YWwgPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XG5cbiAgICAgIHByb3Auc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnUGF0aCcsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBpZiAocHJvcC5rKSB7XG4gICAgICAgICAgICAgIHByb3AuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgaWYgKHByb3Auaykge1xuICAgICAgICAgICAgICBwcm9wLmdldFZhbHVlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfSxcbiAgICAgICAgaXg6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUuaXhcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcGVydHlJbmRleDoge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5peFxuICAgICAgICB9LFxuICAgICAgICBtbjoge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5tblxuICAgICAgICB9LFxuICAgICAgICBwcm9wZXJ0eUdyb3VwOiB7XG4gICAgICAgICAgdmFsdWU6IHByb3BlcnR5R3JvdXBcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBTaGFwZUV4cHJlc3Npb25JbnRlcmZhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gaXRlcmF0ZUVsZW1lbnRzKHNoYXBlcywgdmlldywgcHJvcGVydHlHcm91cCkge1xuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gc2hhcGVzID8gc2hhcGVzLmxlbmd0aCA6IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoc2hhcGVzW2ldLnR5ID09PSAnZ3InKSB7XG4gICAgICAgICAgYXJyLnB1c2goZ3JvdXBJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ2ZsJykge1xuICAgICAgICAgIGFyci5wdXNoKGZpbGxJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ3N0Jykge1xuICAgICAgICAgIGFyci5wdXNoKHN0cm9rZUludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAndG0nKSB7XG4gICAgICAgICAgYXJyLnB1c2godHJpbUludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAndHInKSB7Ly8gYXJyLnB1c2godHJhbnNmb3JtSW50ZXJmYWNlRmFjdG9yeShzaGFwZXNbaV0sdmlld1tpXSxwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAnZWwnKSB7XG4gICAgICAgICAgYXJyLnB1c2goZWxsaXBzZUludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAnc3InKSB7XG4gICAgICAgICAgYXJyLnB1c2goc3RhckludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAnc2gnKSB7XG4gICAgICAgICAgYXJyLnB1c2goU2hhcGVQYXRoSW50ZXJmYWNlKHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ3JjJykge1xuICAgICAgICAgIGFyci5wdXNoKHJlY3RJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ3JkJykge1xuICAgICAgICAgIGFyci5wdXNoKHJvdW5kZWRJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ3JwJykge1xuICAgICAgICAgIGFyci5wdXNoKHJlcGVhdGVySW50ZXJmYWNlRmFjdG9yeShzaGFwZXNbaV0sIHZpZXdbaV0sIHByb3BlcnR5R3JvdXApKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZXNbaV0udHkgPT09ICdnZicpIHtcbiAgICAgICAgICBhcnIucHVzaChncmFkaWVudEZpbGxJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFyci5wdXNoKGRlZmF1bHRJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udGVudHNJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICB2YXIgaW50ZXJmYWNlcztcblxuICAgICAgdmFyIGludGVyZmFjZUZ1bmN0aW9uID0gZnVuY3Rpb24gX2ludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IGludGVyZmFjZXMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgaWYgKGludGVyZmFjZXNbaV0uX25hbWUgPT09IHZhbHVlIHx8IGludGVyZmFjZXNbaV0ubW4gPT09IHZhbHVlIHx8IGludGVyZmFjZXNbaV0ucHJvcGVydHlJbmRleCA9PT0gdmFsdWUgfHwgaW50ZXJmYWNlc1tpXS5peCA9PT0gdmFsdWUgfHwgaW50ZXJmYWNlc1tpXS5pbmQgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlc1tpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VzW3ZhbHVlIC0gMV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XG4gICAgICBpbnRlcmZhY2VzID0gaXRlcmF0ZUVsZW1lbnRzKHNoYXBlLml0LCB2aWV3Lml0LCBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwKTtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm51bVByb3BlcnRpZXMgPSBpbnRlcmZhY2VzLmxlbmd0aDtcbiAgICAgIHZhciB0cmFuc2Zvcm1JbnRlcmZhY2UgPSB0cmFuc2Zvcm1JbnRlcmZhY2VGYWN0b3J5KHNoYXBlLml0W3NoYXBlLml0Lmxlbmd0aCAtIDFdLCB2aWV3Lml0W3ZpZXcuaXQubGVuZ3RoIC0gMV0sIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5R3JvdXApO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24udHJhbnNmb3JtID0gdHJhbnNmb3JtSW50ZXJmYWNlO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLmNpeDtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLl9uYW1lID0gc2hhcGUubm07XG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ3JvdXBJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICB2YXIgaW50ZXJmYWNlRnVuY3Rpb24gPSBmdW5jdGlvbiBfaW50ZXJmYWNlRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ0FEQkUgVmVjdG9ycyBHcm91cCc6XG4gICAgICAgICAgY2FzZSAnQ29udGVudHMnOlxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5jb250ZW50O1xuICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnkgZm9yIG5vdy4gS2VlcGluZyB0aGVtIGhlcmUgaW4gY2FzZSBhIG5ldyBjYXNlIGFwcGVhcnNcbiAgICAgICAgICAvLyBjYXNlICdBREJFIFZlY3RvciBUcmFuc2Zvcm0gR3JvdXAnOlxuICAgICAgICAgIC8vIGNhc2UgMzpcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24udHJhbnNmb3JtO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoaW50ZXJmYWNlRnVuY3Rpb24sIHByb3BlcnR5R3JvdXApO1xuICAgICAgdmFyIGNvbnRlbnQgPSBjb250ZW50c0ludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5R3JvdXApO1xuICAgICAgdmFyIHRyYW5zZm9ybUludGVyZmFjZSA9IHRyYW5zZm9ybUludGVyZmFjZUZhY3Rvcnkoc2hhcGUuaXRbc2hhcGUuaXQubGVuZ3RoIC0gMV0sIHZpZXcuaXRbdmlldy5pdC5sZW5ndGggLSAxXSwgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlHcm91cCk7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5jb250ZW50ID0gY29udGVudDtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnRyYW5zZm9ybSA9IHRyYW5zZm9ybUludGVyZmFjZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnRlcmZhY2VGdW5jdGlvbiwgJ19uYW1lJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gc2hhcGUubm07XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBpbnRlcmZhY2VGdW5jdGlvbi5jb250ZW50ID0gaW50ZXJmYWNlRnVuY3Rpb247XG5cbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm51bVByb3BlcnRpZXMgPSBzaGFwZS5ucDtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5SW5kZXggPSBzaGFwZS5peDtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm5tID0gc2hhcGUubm07XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xuICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbGxJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PT0gJ0NvbG9yJyB8fCB2YWwgPT09ICdjb2xvcicpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uY29sb3I7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsID09PSAnT3BhY2l0eScgfHwgdmFsID09PSAnb3BhY2l0eScpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub3BhY2l0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcuYylcbiAgICAgICAgfSxcbiAgICAgICAgb3BhY2l0eToge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcubylcbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfSxcbiAgICAgICAgbW46IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubW5cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2aWV3LmMuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnQ29sb3InLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB2aWV3Lm8uc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnT3BhY2l0eScsIHByb3BlcnR5R3JvdXApKTtcbiAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBncmFkaWVudEZpbGxJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PT0gJ1N0YXJ0IFBvaW50JyB8fCB2YWwgPT09ICdzdGFydCBwb2ludCcpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uc3RhcnRQb2ludDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgPT09ICdFbmQgUG9pbnQnIHx8IHZhbCA9PT0gJ2VuZCBwb2ludCcpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uZW5kUG9pbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsID09PSAnT3BhY2l0eScgfHwgdmFsID09PSAnb3BhY2l0eScpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub3BhY2l0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBzdGFydFBvaW50OiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy5zKVxuICAgICAgICB9LFxuICAgICAgICBlbmRQb2ludDoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcuZSlcbiAgICAgICAgfSxcbiAgICAgICAgb3BhY2l0eToge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcubylcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuICdhJztcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9uYW1lOiB7XG4gICAgICAgICAgdmFsdWU6IHNoYXBlLm5tXG4gICAgICAgIH0sXG4gICAgICAgIG1uOiB7XG4gICAgICAgICAgdmFsdWU6IHNoYXBlLm1uXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmlldy5zLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1N0YXJ0IFBvaW50JywgcHJvcGVydHlHcm91cCkpO1xuICAgICAgdmlldy5lLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ0VuZCBQb2ludCcsIHByb3BlcnR5R3JvdXApKTtcbiAgICAgIHZpZXcuby5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdPcGFjaXR5JywgcHJvcGVydHlHcm91cCkpO1xuICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRJbnRlcmZhY2VGYWN0b3J5KCkge1xuICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3Ryb2tlSW50ZXJmYWNlRmFjdG9yeShzaGFwZSwgdmlldywgcHJvcGVydHlHcm91cCkge1xuICAgICAgdmFyIF9wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoaW50ZXJmYWNlRnVuY3Rpb24sIHByb3BlcnR5R3JvdXApO1xuXG4gICAgICB2YXIgX2Rhc2hQcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoZGFzaE9iLCBfcHJvcGVydHlHcm91cCk7XG5cbiAgICAgIGZ1bmN0aW9uIGFkZFByb3BlcnR5VG9EYXNoT2IoaSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGFzaE9iLCBzaGFwZS5kW2ldLm5tLCB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy5kLmRhdGFQcm9wc1tpXS5wKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gc2hhcGUuZCA/IHNoYXBlLmQubGVuZ3RoIDogMDtcbiAgICAgIHZhciBkYXNoT2IgPSB7fTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGFkZFByb3BlcnR5VG9EYXNoT2IoaSk7XG4gICAgICAgIHZpZXcuZC5kYXRhUHJvcHNbaV0ucC5zZXRHcm91cFByb3BlcnR5KF9kYXNoUHJvcGVydHlHcm91cCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbCkge1xuICAgICAgICBpZiAodmFsID09PSAnQ29sb3InIHx8IHZhbCA9PT0gJ2NvbG9yJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5jb2xvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgPT09ICdPcGFjaXR5JyB8fCB2YWwgPT09ICdvcGFjaXR5Jykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5vcGFjaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbCA9PT0gJ1N0cm9rZSBXaWR0aCcgfHwgdmFsID09PSAnc3Ryb2tlIHdpZHRoJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5zdHJva2VXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcuYylcbiAgICAgICAgfSxcbiAgICAgICAgb3BhY2l0eToge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcubylcbiAgICAgICAgfSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh2aWV3LncpXG4gICAgICAgIH0sXG4gICAgICAgIGRhc2g6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXNoT2I7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfbmFtZToge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5ubVxuICAgICAgICB9LFxuICAgICAgICBtbjoge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5tblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZpZXcuYy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdDb2xvcicsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB2aWV3Lm8uc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnT3BhY2l0eScsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB2aWV3Lncuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnU3Ryb2tlIFdpZHRoJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmltSW50ZXJmYWNlRmFjdG9yeShzaGFwZSwgdmlldywgcHJvcGVydHlHcm91cCkge1xuICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGlmICh2YWwgPT09IHNoYXBlLmUuaXggfHwgdmFsID09PSAnRW5kJyB8fCB2YWwgPT09ICdlbmQnKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLmVuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgPT09IHNoYXBlLnMuaXgpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsID09PSBzaGFwZS5vLml4KSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLm9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XG5cbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5SW5kZXggPSBzaGFwZS5peDtcbiAgICAgIHZpZXcucy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdTdGFydCcsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB2aWV3LmUuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnRW5kJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHZpZXcuby5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdPZmZzZXQnLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLml4O1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXA7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBzdGFydDoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcucylcbiAgICAgICAgfSxcbiAgICAgICAgZW5kOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy5lKVxuICAgICAgICB9LFxuICAgICAgICBvZmZzZXQ6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh2aWV3Lm8pXG4gICAgICAgIH0sXG4gICAgICAgIF9uYW1lOiB7XG4gICAgICAgICAgdmFsdWU6IHNoYXBlLm5tXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ubW4gPSBzaGFwZS5tbjtcbiAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1JbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoc2hhcGUuYS5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdBbmNob3IgUG9pbnQnKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLmFuY2hvclBvaW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYXBlLm8uaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnT3BhY2l0eScpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub3BhY2l0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFwZS5wLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ1Bvc2l0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5wb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFwZS5yLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ1JvdGF0aW9uJyB8fCB2YWx1ZSA9PT0gJ0FEQkUgVmVjdG9yIFJvdGF0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5yb3RhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFwZS5zLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ1NjYWxlJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5zY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFwZS5zayAmJiBzaGFwZS5zay5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdTa2V3Jykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5za2V3O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYXBlLnNhICYmIHNoYXBlLnNhLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ1NrZXcgQXhpcycpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uc2tld0F4aXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIF9wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoaW50ZXJmYWNlRnVuY3Rpb24sIHByb3BlcnR5R3JvdXApO1xuXG4gICAgICB2aWV3LnRyYW5zZm9ybS5tUHJvcHMuby5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdPcGFjaXR5JywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5wLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1Bvc2l0aW9uJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5hLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ0FuY2hvciBQb2ludCcsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB2aWV3LnRyYW5zZm9ybS5tUHJvcHMucy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdTY2FsZScsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB2aWV3LnRyYW5zZm9ybS5tUHJvcHMuci5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdSb3RhdGlvbicsIF9wcm9wZXJ0eUdyb3VwKSk7XG5cbiAgICAgIGlmICh2aWV3LnRyYW5zZm9ybS5tUHJvcHMuc2spIHtcbiAgICAgICAgdmlldy50cmFuc2Zvcm0ubVByb3BzLnNrLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1NrZXcnLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB2aWV3LnRyYW5zZm9ybS5tUHJvcHMuc2Euc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnU2tldyBBbmdsZScsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB9XG5cbiAgICAgIHZpZXcudHJhbnNmb3JtLm9wLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ09wYWNpdHknLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW50ZXJmYWNlRnVuY3Rpb24sIHtcbiAgICAgICAgb3BhY2l0eToge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5vKVxuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5wKVxuICAgICAgICB9LFxuICAgICAgICBhbmNob3JQb2ludDoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5hKVxuICAgICAgICB9LFxuICAgICAgICBzY2FsZToge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5zKVxuICAgICAgICB9LFxuICAgICAgICByb3RhdGlvbjoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5yKVxuICAgICAgICB9LFxuICAgICAgICBza2V3OiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy50cmFuc2Zvcm0ubVByb3BzLnNrKVxuICAgICAgICB9LFxuICAgICAgICBza2V3QXhpczoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5zYSlcbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi50eSA9ICd0cic7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXA7XG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZWxsaXBzZUludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcbiAgICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChzaGFwZS5wLml4ID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5wb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFwZS5zLml4ID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5zaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBfcHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXBGYWN0b3J5KGludGVyZmFjZUZ1bmN0aW9uLCBwcm9wZXJ0eUdyb3VwKTtcblxuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLml4O1xuICAgICAgdmFyIHByb3AgPSB2aWV3LnNoLnR5ID09PSAndG0nID8gdmlldy5zaC5wcm9wIDogdmlldy5zaDtcbiAgICAgIHByb3Aucy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdTaXplJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHByb3AucC5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdQb3NpdGlvbicsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5zKVxuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AucClcbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xuICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoc2hhcGUucC5peCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcGUuci5peCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucm90YXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcGUucHQuaXggPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnBvaW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFwZS5vci5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdBREJFIFZlY3RvciBTdGFyIE91dGVyIFJhZGl1cycpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub3V0ZXJSYWRpdXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcGUub3MuaXggPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLm91dGVyUm91bmRuZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYXBlLmlyICYmIChzaGFwZS5pci5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdBREJFIFZlY3RvciBTdGFyIElubmVyIFJhZGl1cycpKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLmlubmVyUmFkaXVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYXBlLmlzICYmIHNoYXBlLmlzLml4ID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5pbm5lclJvdW5kbmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XG5cbiAgICAgIHZhciBwcm9wID0gdmlldy5zaC50eSA9PT0gJ3RtJyA/IHZpZXcuc2gucHJvcCA6IHZpZXcuc2g7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUluZGV4ID0gc2hhcGUuaXg7XG4gICAgICBwcm9wLm9yLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ091dGVyIFJhZGl1cycsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBwcm9wLm9zLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ091dGVyIFJvdW5kbmVzcycsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBwcm9wLnB0LnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1BvaW50cycsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBwcm9wLnAuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnUG9zaXRpb24nLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgcHJvcC5yLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1JvdGF0aW9uJywgX3Byb3BlcnR5R3JvdXApKTtcblxuICAgICAgaWYgKHNoYXBlLmlyKSB7XG4gICAgICAgIHByb3AuaXIuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnSW5uZXIgUmFkaXVzJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgICAgcHJvcC5pcy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdJbm5lciBSb3VuZG5lc3MnLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AucClcbiAgICAgICAgfSxcbiAgICAgICAgcm90YXRpb246IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLnIpXG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50czoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AucHQpXG4gICAgICAgIH0sXG4gICAgICAgIG91dGVyUmFkaXVzOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5vcilcbiAgICAgICAgfSxcbiAgICAgICAgb3V0ZXJSb3VuZG5lc3M6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLm9zKVxuICAgICAgICB9LFxuICAgICAgICBpbm5lclJhZGl1czoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AuaXIpXG4gICAgICAgIH0sXG4gICAgICAgIGlubmVyUm91bmRuZXNzOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5pcylcbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xuICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlY3RJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoc2hhcGUucC5peCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcGUuci5peCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucm91bmRuZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYXBlLnMuaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnU2l6ZScgfHwgdmFsdWUgPT09ICdBREJFIFZlY3RvciBSZWN0IFNpemUnKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnNpemU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIF9wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoaW50ZXJmYWNlRnVuY3Rpb24sIHByb3BlcnR5R3JvdXApO1xuXG4gICAgICB2YXIgcHJvcCA9IHZpZXcuc2gudHkgPT09ICd0bScgPyB2aWV3LnNoLnByb3AgOiB2aWV3LnNoO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLml4O1xuICAgICAgcHJvcC5wLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1Bvc2l0aW9uJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHByb3Aucy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdTaXplJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHByb3Auci5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdSb3RhdGlvbicsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AucClcbiAgICAgICAgfSxcbiAgICAgICAgcm91bmRuZXNzOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5yKVxuICAgICAgICB9LFxuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5zKVxuICAgICAgICB9LFxuICAgICAgICBfbmFtZToge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5ubVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm1uID0gc2hhcGUubW47XG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcm91bmRlZEludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcbiAgICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChzaGFwZS5yLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ1JvdW5kIENvcm5lcnMgMScpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucmFkaXVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBfcHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXBGYWN0b3J5KGludGVyZmFjZUZ1bmN0aW9uLCBwcm9wZXJ0eUdyb3VwKTtcblxuICAgICAgdmFyIHByb3AgPSB2aWV3O1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLml4O1xuICAgICAgcHJvcC5yZC5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdSYWRpdXMnLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW50ZXJmYWNlRnVuY3Rpb24sIHtcbiAgICAgICAgcmFkaXVzOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5yZClcbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xuICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGVhdGVySW50ZXJmYWNlRmFjdG9yeShzaGFwZSwgdmlldywgcHJvcGVydHlHcm91cCkge1xuICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHNoYXBlLmMuaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnQ29waWVzJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5jb3BpZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcGUuby5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdPZmZzZXQnKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLm9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XG5cbiAgICAgIHZhciBwcm9wID0gdmlldztcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5SW5kZXggPSBzaGFwZS5peDtcbiAgICAgIHByb3AuYy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdDb3BpZXMnLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgcHJvcC5vLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ09mZnNldCcsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBjb3BpZXM6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLmMpXG4gICAgICAgIH0sXG4gICAgICAgIG9mZnNldDoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AubylcbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xuICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoc2hhcGVzLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICB2YXIgaW50ZXJmYWNlcztcblxuICAgICAgZnVuY3Rpb24gX2ludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gMSA6IHZhbHVlO1xuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcGVydHlHcm91cDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlc1t2YWx1ZSAtIDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gaW50ZXJmYWNlcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICBpZiAoaW50ZXJmYWNlc1tpXS5fbmFtZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VzW2ldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwYXJlbnRHcm91cFdyYXBwZXIoKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eUdyb3VwO1xuICAgICAgfVxuXG4gICAgICBfaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXBGYWN0b3J5KF9pbnRlcmZhY2VGdW5jdGlvbiwgcGFyZW50R3JvdXBXcmFwcGVyKTtcbiAgICAgIGludGVyZmFjZXMgPSBpdGVyYXRlRWxlbWVudHMoc2hhcGVzLCB2aWV3LCBfaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlHcm91cCk7XG4gICAgICBfaW50ZXJmYWNlRnVuY3Rpb24ubnVtUHJvcGVydGllcyA9IGludGVyZmFjZXMubGVuZ3RoO1xuICAgICAgX2ludGVyZmFjZUZ1bmN0aW9uLl9uYW1lID0gJ0NvbnRlbnRzJztcbiAgICAgIHJldHVybiBfaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBUZXh0RXhwcmVzc2lvbkludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgIHZhciBfc291cmNlVGV4dDtcblxuICAgICAgZnVuY3Rpb24gX3RoaXNMYXllckZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgY2FzZSAnQURCRSBUZXh0IERvY3VtZW50JzpcbiAgICAgICAgICAgIHJldHVybiBfdGhpc0xheWVyRnVuY3Rpb24uc291cmNlVGV4dDtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNMYXllckZ1bmN0aW9uLCAnc291cmNlVGV4dCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgZWxlbS50ZXh0UHJvcGVydHkuZ2V0VmFsdWUoKTtcbiAgICAgICAgICB2YXIgc3RyaW5nVmFsdWUgPSBlbGVtLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YS50O1xuXG4gICAgICAgICAgaWYgKCFfc291cmNlVGV4dCB8fCBzdHJpbmdWYWx1ZSAhPT0gX3NvdXJjZVRleHQudmFsdWUpIHtcbiAgICAgICAgICAgIF9zb3VyY2VUZXh0ID0gbmV3IFN0cmluZyhzdHJpbmdWYWx1ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG4gICAgICAgICAgICAvLyBJZiBzdHJpbmdWYWx1ZSBpcyBhbiBlbXB0eSBzdHJpbmcsIGV2YWwgcmV0dXJucyB1bmRlZmluZWQsIHNvIGl0IGhhcyB0byBiZSByZXR1cm5lZCBhcyBhIFN0cmluZyBwcmltaXRpdmVcblxuICAgICAgICAgICAgX3NvdXJjZVRleHQudmFsdWUgPSBzdHJpbmdWYWx1ZSB8fCBuZXcgU3RyaW5nKHN0cmluZ1ZhbHVlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9zb3VyY2VUZXh0LCAnc3R5bGUnLCB7XG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBmaWxsQ29sb3I6IGVsZW0udGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLmZjXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIF9zb3VyY2VUZXh0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfdGhpc0xheWVyRnVuY3Rpb247XG4gICAgfTtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuICB2YXIgRm9vdGFnZUludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3V0bGluZUludGVyZmFjZUZhY3RvcnkgPSBmdW5jdGlvbiBvdXRsaW5lSW50ZXJmYWNlRmFjdG9yeShlbGVtKSB7XG4gICAgICB2YXIgY3VycmVudFByb3BlcnR5TmFtZSA9ICcnO1xuICAgICAgdmFyIGN1cnJlbnRQcm9wZXJ0eSA9IGVsZW0uZ2V0Rm9vdGFnZURhdGEoKTtcblxuICAgICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgY3VycmVudFByb3BlcnR5TmFtZSA9ICcnO1xuICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBlbGVtLmdldEZvb3RhZ2VEYXRhKCk7XG4gICAgICAgIHJldHVybiBzZWFyY2hQcm9wZXJ0eTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2VhcmNoUHJvcGVydHkodmFsdWUpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRQcm9wZXJ0eVt2YWx1ZV0pIHtcbiAgICAgICAgICBjdXJyZW50UHJvcGVydHlOYW1lID0gdmFsdWU7XG4gICAgICAgICAgY3VycmVudFByb3BlcnR5ID0gY3VycmVudFByb3BlcnR5W3ZhbHVlXTtcblxuICAgICAgICAgIGlmIChfdHlwZW9mKGN1cnJlbnRQcm9wZXJ0eSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VhcmNoUHJvcGVydHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRQcm9wZXJ0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9wZXJ0eU5hbWVJbmRleCA9IHZhbHVlLmluZGV4T2YoY3VycmVudFByb3BlcnR5TmFtZSk7XG5cbiAgICAgICAgaWYgKHByb3BlcnR5TmFtZUluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KHZhbHVlLnN1YnN0cihwcm9wZXJ0eU5hbWVJbmRleCArIGN1cnJlbnRQcm9wZXJ0eU5hbWUubGVuZ3RoKSwgMTApO1xuICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eSA9IGN1cnJlbnRQcm9wZXJ0eVtpbmRleF07XG5cbiAgICAgICAgICBpZiAoX3R5cGVvZihjdXJyZW50UHJvcGVydHkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHNlYXJjaFByb3BlcnR5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjdXJyZW50UHJvcGVydHk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbml0O1xuICAgIH07XG5cbiAgICB2YXIgZGF0YUludGVyZmFjZUZhY3RvcnkgPSBmdW5jdGlvbiBkYXRhSW50ZXJmYWNlRmFjdG9yeShlbGVtKSB7XG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09ICdPdXRsaW5lJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5vdXRsaW5lSW50ZXJmYWNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24uX25hbWUgPSAnT3V0bGluZSc7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5vdXRsaW5lSW50ZXJmYWNlID0gb3V0bGluZUludGVyZmFjZUZhY3RvcnkoZWxlbSk7XG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgZnVuY3Rpb24gX2ludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ0RhdGEnKSB7XG4gICAgICAgICAgcmV0dXJuIF9pbnRlcmZhY2VGdW5jdGlvbi5kYXRhSW50ZXJmYWNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIF9pbnRlcmZhY2VGdW5jdGlvbi5fbmFtZSA9ICdEYXRhJztcbiAgICAgIF9pbnRlcmZhY2VGdW5jdGlvbi5kYXRhSW50ZXJmYWNlID0gZGF0YUludGVyZmFjZUZhY3RvcnkoZWxlbSk7XG4gICAgICByZXR1cm4gX2ludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgaW50ZXJmYWNlcyA9IHtcbiAgICBsYXllcjogTGF5ZXJFeHByZXNzaW9uSW50ZXJmYWNlLFxuICAgIGVmZmVjdHM6IEVmZmVjdHNFeHByZXNzaW9uSW50ZXJmYWNlLFxuICAgIGNvbXA6IENvbXBFeHByZXNzaW9uSW50ZXJmYWNlLFxuICAgIHNoYXBlOiBTaGFwZUV4cHJlc3Npb25JbnRlcmZhY2UsXG4gICAgdGV4dDogVGV4dEV4cHJlc3Npb25JbnRlcmZhY2UsXG4gICAgZm9vdGFnZTogRm9vdGFnZUludGVyZmFjZVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldEludGVyZmFjZSh0eXBlKSB7XG4gICAgcmV0dXJuIGludGVyZmFjZXNbdHlwZV0gfHwgbnVsbDtcbiAgfVxuXG4gIHZhciBleHByZXNzaW9uSGVscGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBzZWFyY2hFeHByZXNzaW9ucyhlbGVtLCBkYXRhLCBwcm9wKSB7XG4gICAgICBpZiAoZGF0YS54KSB7XG4gICAgICAgIHByb3AuayA9IHRydWU7XG4gICAgICAgIHByb3AueCA9IHRydWU7XG4gICAgICAgIHByb3AuaW5pdGlhdGVFeHByZXNzaW9uID0gRXhwcmVzc2lvbk1hbmFnZXIuaW5pdGlhdGVFeHByZXNzaW9uO1xuICAgICAgICBwcm9wLmVmZmVjdHNTZXF1ZW5jZS5wdXNoKHByb3AuaW5pdGlhdGVFeHByZXNzaW9uKGVsZW0sIGRhdGEsIHByb3ApLmJpbmQocHJvcCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFZhbHVlQXRUaW1lKGZyYW1lTnVtKSB7XG4gICAgICBmcmFtZU51bSAqPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XG4gICAgICBmcmFtZU51bSAtPSB0aGlzLm9mZnNldFRpbWU7XG5cbiAgICAgIGlmIChmcmFtZU51bSAhPT0gdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0RnJhbWUpIHtcbiAgICAgICAgdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0SW5kZXggPSB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RGcmFtZSA8IGZyYW1lTnVtID8gdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0SW5kZXggOiAwO1xuICAgICAgICB0aGlzLl9jYWNoaW5nQXRUaW1lLnZhbHVlID0gdGhpcy5pbnRlcnBvbGF0ZVZhbHVlKGZyYW1lTnVtLCB0aGlzLl9jYWNoaW5nQXRUaW1lKTtcbiAgICAgICAgdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0RnJhbWUgPSBmcmFtZU51bTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hpbmdBdFRpbWUudmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U3BlZWRBdFRpbWUoZnJhbWVOdW0pIHtcbiAgICAgIHZhciBkZWx0YSA9IC0wLjAxO1xuICAgICAgdmFyIHYxID0gdGhpcy5nZXRWYWx1ZUF0VGltZShmcmFtZU51bSk7XG4gICAgICB2YXIgdjIgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGZyYW1lTnVtICsgZGVsdGEpO1xuICAgICAgdmFyIHNwZWVkID0gMDtcblxuICAgICAgaWYgKHYxLmxlbmd0aCkge1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdjEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBzcGVlZCArPSBNYXRoLnBvdyh2MltpXSAtIHYxW2ldLCAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNwZWVkID0gTWF0aC5zcXJ0KHNwZWVkKSAqIDEwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwZWVkID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNwZWVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFZlbG9jaXR5QXRUaW1lKGZyYW1lTnVtKSB7XG4gICAgICBpZiAodGhpcy52ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZWw7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWx0YSA9IC0wLjAwMTsgLy8gZnJhbWVOdW0gKz0gdGhpcy5lbGVtLmRhdGEuc3Q7XG5cbiAgICAgIHZhciB2MSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoZnJhbWVOdW0pO1xuICAgICAgdmFyIHYyID0gdGhpcy5nZXRWYWx1ZUF0VGltZShmcmFtZU51bSArIGRlbHRhKTtcbiAgICAgIHZhciB2ZWxvY2l0eTtcblxuICAgICAgaWYgKHYxLmxlbmd0aCkge1xuICAgICAgICB2ZWxvY2l0eSA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCB2MS5sZW5ndGgpO1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdjEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAvLyByZW1vdmluZyBmcmFtZVJhdGVcbiAgICAgICAgICAvLyBpZiBuZWVkZWQsIGRvbid0IGFkZCBpdCBoZXJlXG4gICAgICAgICAgLy8gdmVsb2NpdHlbaV0gPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZVJhdGUqKCh2MltpXSAtIHYxW2ldKS9kZWx0YSk7XG4gICAgICAgICAgdmVsb2NpdHlbaV0gPSAodjJbaV0gLSB2MVtpXSkgLyBkZWx0YTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmVsb2NpdHkgPSAodjIgLSB2MSkgLyBkZWx0YTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZlbG9jaXR5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFN0YXRpY1ZhbHVlQXRUaW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0R3JvdXBQcm9wZXJ0eShwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICB0aGlzLnByb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzZWFyY2hFeHByZXNzaW9uczogc2VhcmNoRXhwcmVzc2lvbnMsXG4gICAgICBnZXRTcGVlZEF0VGltZTogZ2V0U3BlZWRBdFRpbWUsXG4gICAgICBnZXRWZWxvY2l0eUF0VGltZTogZ2V0VmVsb2NpdHlBdFRpbWUsXG4gICAgICBnZXRWYWx1ZUF0VGltZTogZ2V0VmFsdWVBdFRpbWUsXG4gICAgICBnZXRTdGF0aWNWYWx1ZUF0VGltZTogZ2V0U3RhdGljVmFsdWVBdFRpbWUsXG4gICAgICBzZXRHcm91cFByb3BlcnR5OiBzZXRHcm91cFByb3BlcnR5XG4gICAgfTtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIGFkZFByb3BlcnR5RGVjb3JhdG9yKCkge1xuICAgIGZ1bmN0aW9uIGxvb3BPdXQodHlwZSwgZHVyYXRpb24sIGR1cmF0aW9uRmxhZykge1xuICAgICAgaWYgKCF0aGlzLmsgfHwgIXRoaXMua2V5ZnJhbWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB2O1xuICAgICAgfVxuXG4gICAgICB0eXBlID0gdHlwZSA/IHR5cGUudG9Mb3dlckNhc2UoKSA6ICcnO1xuICAgICAgdmFyIGN1cnJlbnRGcmFtZSA9IHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lO1xuICAgICAgdmFyIGtleWZyYW1lcyA9IHRoaXMua2V5ZnJhbWVzO1xuICAgICAgdmFyIGxhc3RLZXlGcmFtZSA9IGtleWZyYW1lc1trZXlmcmFtZXMubGVuZ3RoIC0gMV0udDtcblxuICAgICAgaWYgKGN1cnJlbnRGcmFtZSA8PSBsYXN0S2V5RnJhbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHY7XG4gICAgICB9XG5cbiAgICAgIHZhciBjeWNsZUR1cmF0aW9uO1xuICAgICAgdmFyIGZpcnN0S2V5RnJhbWU7XG5cbiAgICAgIGlmICghZHVyYXRpb25GbGFnKSB7XG4gICAgICAgIGlmICghZHVyYXRpb24gfHwgZHVyYXRpb24gPiBrZXlmcmFtZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGR1cmF0aW9uID0ga2V5ZnJhbWVzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICBmaXJzdEtleUZyYW1lID0ga2V5ZnJhbWVzW2tleWZyYW1lcy5sZW5ndGggLSAxIC0gZHVyYXRpb25dLnQ7XG4gICAgICAgIGN5Y2xlRHVyYXRpb24gPSBsYXN0S2V5RnJhbWUgLSBmaXJzdEtleUZyYW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgICAgIGN5Y2xlRHVyYXRpb24gPSBNYXRoLm1heCgwLCBsYXN0S2V5RnJhbWUgLSB0aGlzLmVsZW0uZGF0YS5pcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3ljbGVEdXJhdGlvbiA9IE1hdGguYWJzKGxhc3RLZXlGcmFtZSAtIHRoaXMuZWxlbS5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlICogZHVyYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgZmlyc3RLZXlGcmFtZSA9IGxhc3RLZXlGcmFtZSAtIGN5Y2xlRHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbjtcbiAgICAgIHZhciByZXQ7XG5cbiAgICAgIGlmICh0eXBlID09PSAncGluZ3BvbmcnKSB7XG4gICAgICAgIHZhciBpdGVyYXRpb25zID0gTWF0aC5mbG9vcigoY3VycmVudEZyYW1lIC0gZmlyc3RLZXlGcmFtZSkgLyBjeWNsZUR1cmF0aW9uKTtcblxuICAgICAgICBpZiAoaXRlcmF0aW9ucyAlIDIgIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZUF0VGltZSgoY3ljbGVEdXJhdGlvbiAtIChjdXJyZW50RnJhbWUgLSBmaXJzdEtleUZyYW1lKSAlIGN5Y2xlRHVyYXRpb24gKyBmaXJzdEtleUZyYW1lKSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2Zmc2V0Jykge1xuICAgICAgICB2YXIgaW5pdFYgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGZpcnN0S2V5RnJhbWUgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xuICAgICAgICB2YXIgZW5kViA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUobGFzdEtleUZyYW1lIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldFZhbHVlQXRUaW1lKCgoY3VycmVudEZyYW1lIC0gZmlyc3RLZXlGcmFtZSkgJSBjeWNsZUR1cmF0aW9uICsgZmlyc3RLZXlGcmFtZSkgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICAgICAgdmFyIHJlcGVhdHMgPSBNYXRoLmZsb29yKChjdXJyZW50RnJhbWUgLSBmaXJzdEtleUZyYW1lKSAvIGN5Y2xlRHVyYXRpb24pO1xuXG4gICAgICAgIGlmICh0aGlzLnB2Lmxlbmd0aCkge1xuICAgICAgICAgIHJldCA9IG5ldyBBcnJheShpbml0Vi5sZW5ndGgpO1xuICAgICAgICAgIGxlbiA9IHJldC5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHJldFtpXSA9IChlbmRWW2ldIC0gaW5pdFZbaV0pICogcmVwZWF0cyArIGN1cnJlbnRbaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoZW5kViAtIGluaXRWKSAqIHJlcGVhdHMgKyBjdXJyZW50O1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnY29udGludWUnKSB7XG4gICAgICAgIHZhciBsYXN0VmFsdWUgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGxhc3RLZXlGcmFtZSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7XG4gICAgICAgIHZhciBuZXh0TGFzdFZhbHVlID0gdGhpcy5nZXRWYWx1ZUF0VGltZSgobGFzdEtleUZyYW1lIC0gMC4wMDEpIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcblxuICAgICAgICBpZiAodGhpcy5wdi5sZW5ndGgpIHtcbiAgICAgICAgICByZXQgPSBuZXcgQXJyYXkobGFzdFZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgbGVuID0gcmV0Lmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgcmV0W2ldID0gbGFzdFZhbHVlW2ldICsgKGxhc3RWYWx1ZVtpXSAtIG5leHRMYXN0VmFsdWVbaV0pICogKChjdXJyZW50RnJhbWUgLSBsYXN0S2V5RnJhbWUpIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlKSAvIDAuMDAwNTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGFzdFZhbHVlICsgKGxhc3RWYWx1ZSAtIG5leHRMYXN0VmFsdWUpICogKChjdXJyZW50RnJhbWUgLSBsYXN0S2V5RnJhbWUpIC8gMC4wMDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZUF0VGltZSgoKGN1cnJlbnRGcmFtZSAtIGZpcnN0S2V5RnJhbWUpICUgY3ljbGVEdXJhdGlvbiArIGZpcnN0S2V5RnJhbWUpIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvb3BJbih0eXBlLCBkdXJhdGlvbiwgZHVyYXRpb25GbGFnKSB7XG4gICAgICBpZiAoIXRoaXMuaykge1xuICAgICAgICByZXR1cm4gdGhpcy5wdjtcbiAgICAgIH1cblxuICAgICAgdHlwZSA9IHR5cGUgPyB0eXBlLnRvTG93ZXJDYXNlKCkgOiAnJztcbiAgICAgIHZhciBjdXJyZW50RnJhbWUgPSB0aGlzLmNvbXAucmVuZGVyZWRGcmFtZTtcbiAgICAgIHZhciBrZXlmcmFtZXMgPSB0aGlzLmtleWZyYW1lcztcbiAgICAgIHZhciBmaXJzdEtleUZyYW1lID0ga2V5ZnJhbWVzWzBdLnQ7XG5cbiAgICAgIGlmIChjdXJyZW50RnJhbWUgPj0gZmlyc3RLZXlGcmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdjtcbiAgICAgIH1cblxuICAgICAgdmFyIGN5Y2xlRHVyYXRpb247XG4gICAgICB2YXIgbGFzdEtleUZyYW1lO1xuXG4gICAgICBpZiAoIWR1cmF0aW9uRmxhZykge1xuICAgICAgICBpZiAoIWR1cmF0aW9uIHx8IGR1cmF0aW9uID4ga2V5ZnJhbWVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBkdXJhdGlvbiA9IGtleWZyYW1lcy5sZW5ndGggLSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdEtleUZyYW1lID0ga2V5ZnJhbWVzW2R1cmF0aW9uXS50O1xuICAgICAgICBjeWNsZUR1cmF0aW9uID0gbGFzdEtleUZyYW1lIC0gZmlyc3RLZXlGcmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghZHVyYXRpb24pIHtcbiAgICAgICAgICBjeWNsZUR1cmF0aW9uID0gTWF0aC5tYXgoMCwgdGhpcy5lbGVtLmRhdGEub3AgLSBmaXJzdEtleUZyYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeWNsZUR1cmF0aW9uID0gTWF0aC5hYnModGhpcy5lbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUgKiBkdXJhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0S2V5RnJhbWUgPSBmaXJzdEtleUZyYW1lICsgY3ljbGVEdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuO1xuICAgICAgdmFyIHJldDtcblxuICAgICAgaWYgKHR5cGUgPT09ICdwaW5ncG9uZycpIHtcbiAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBNYXRoLmZsb29yKChmaXJzdEtleUZyYW1lIC0gY3VycmVudEZyYW1lKSAvIGN5Y2xlRHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChpdGVyYXRpb25zICUgMiA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlQXRUaW1lKCgoZmlyc3RLZXlGcmFtZSAtIGN1cnJlbnRGcmFtZSkgJSBjeWNsZUR1cmF0aW9uICsgZmlyc3RLZXlGcmFtZSkgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29mZnNldCcpIHtcbiAgICAgICAgdmFyIGluaXRWID0gdGhpcy5nZXRWYWx1ZUF0VGltZShmaXJzdEtleUZyYW1lIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgdmFyIGVuZFYgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGxhc3RLZXlGcmFtZSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5nZXRWYWx1ZUF0VGltZSgoY3ljbGVEdXJhdGlvbiAtIChmaXJzdEtleUZyYW1lIC0gY3VycmVudEZyYW1lKSAlIGN5Y2xlRHVyYXRpb24gKyBmaXJzdEtleUZyYW1lKSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7XG4gICAgICAgIHZhciByZXBlYXRzID0gTWF0aC5mbG9vcigoZmlyc3RLZXlGcmFtZSAtIGN1cnJlbnRGcmFtZSkgLyBjeWNsZUR1cmF0aW9uKSArIDE7XG5cbiAgICAgICAgaWYgKHRoaXMucHYubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0ID0gbmV3IEFycmF5KGluaXRWLmxlbmd0aCk7XG4gICAgICAgICAgbGVuID0gcmV0Lmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgcmV0W2ldID0gY3VycmVudFtpXSAtIChlbmRWW2ldIC0gaW5pdFZbaV0pICogcmVwZWF0cztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQgLSAoZW5kViAtIGluaXRWKSAqIHJlcGVhdHM7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjb250aW51ZScpIHtcbiAgICAgICAgdmFyIGZpcnN0VmFsdWUgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGZpcnN0S2V5RnJhbWUgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xuICAgICAgICB2YXIgbmV4dEZpcnN0VmFsdWUgPSB0aGlzLmdldFZhbHVlQXRUaW1lKChmaXJzdEtleUZyYW1lICsgMC4wMDEpIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcblxuICAgICAgICBpZiAodGhpcy5wdi5sZW5ndGgpIHtcbiAgICAgICAgICByZXQgPSBuZXcgQXJyYXkoZmlyc3RWYWx1ZS5sZW5ndGgpO1xuICAgICAgICAgIGxlbiA9IHJldC5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHJldFtpXSA9IGZpcnN0VmFsdWVbaV0gKyAoZmlyc3RWYWx1ZVtpXSAtIG5leHRGaXJzdFZhbHVlW2ldKSAqIChmaXJzdEtleUZyYW1lIC0gY3VycmVudEZyYW1lKSAvIDAuMDAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmlyc3RWYWx1ZSArIChmaXJzdFZhbHVlIC0gbmV4dEZpcnN0VmFsdWUpICogKGZpcnN0S2V5RnJhbWUgLSBjdXJyZW50RnJhbWUpIC8gMC4wMDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlQXRUaW1lKChjeWNsZUR1cmF0aW9uIC0gKChmaXJzdEtleUZyYW1lIC0gY3VycmVudEZyYW1lKSAlIGN5Y2xlRHVyYXRpb24gKyBmaXJzdEtleUZyYW1lKSkgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc21vb3RoKHdpZHRoLCBzYW1wbGVzKSB7XG4gICAgICBpZiAoIXRoaXMuaykge1xuICAgICAgICByZXR1cm4gdGhpcy5wdjtcbiAgICAgIH1cblxuICAgICAgd2lkdGggPSAod2lkdGggfHwgMC40KSAqIDAuNTtcbiAgICAgIHNhbXBsZXMgPSBNYXRoLmZsb29yKHNhbXBsZXMgfHwgNSk7XG5cbiAgICAgIGlmIChzYW1wbGVzIDw9IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHY7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50VGltZSA9IHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuICAgICAgdmFyIGluaXRGcmFtZSA9IGN1cnJlbnRUaW1lIC0gd2lkdGg7XG4gICAgICB2YXIgZW5kRnJhbWUgPSBjdXJyZW50VGltZSArIHdpZHRoO1xuICAgICAgdmFyIHNhbXBsZUZyZXF1ZW5jeSA9IHNhbXBsZXMgPiAxID8gKGVuZEZyYW1lIC0gaW5pdEZyYW1lKSAvIChzYW1wbGVzIC0gMSkgOiAxO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGogPSAwO1xuICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICBpZiAodGhpcy5wdi5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgdGhpcy5wdi5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2FtcGxlVmFsdWU7XG5cbiAgICAgIHdoaWxlIChpIDwgc2FtcGxlcykge1xuICAgICAgICBzYW1wbGVWYWx1ZSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoaW5pdEZyYW1lICsgaSAqIHNhbXBsZUZyZXF1ZW5jeSk7XG5cbiAgICAgICAgaWYgKHRoaXMucHYubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXMucHYubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIHZhbHVlW2pdICs9IHNhbXBsZVZhbHVlW2pdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSArPSBzYW1wbGVWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucHYubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzLnB2Lmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgdmFsdWVbal0gLz0gc2FtcGxlcztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgLz0gc2FtcGxlcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRyYW5zZm9ybVZhbHVlQXRUaW1lKHRpbWUpIHtcbiAgICAgIGlmICghdGhpcy5fdHJhbnNmb3JtQ2FjaGluZ0F0VGltZSkge1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1DYWNoaW5nQXRUaW1lID0ge1xuICAgICAgICAgIHY6IG5ldyBNYXRyaXgoKVxuICAgICAgICB9O1xuICAgICAgfSAvLy8gL1xuXG5cbiAgICAgIHZhciBtYXRyaXggPSB0aGlzLl90cmFuc2Zvcm1DYWNoaW5nQXRUaW1lLnY7XG4gICAgICBtYXRyaXguY2xvbmVGcm9tUHJvcHModGhpcy5wcmUucHJvcHMpO1xuXG4gICAgICBpZiAodGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zIDwgMSkge1xuICAgICAgICB2YXIgYW5jaG9yID0gdGhpcy5hLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgICBtYXRyaXgudHJhbnNsYXRlKC1hbmNob3JbMF0gKiB0aGlzLmEubXVsdCwgLWFuY2hvclsxXSAqIHRoaXMuYS5tdWx0LCBhbmNob3JbMl0gKiB0aGlzLmEubXVsdCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPCAyKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMucy5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcbiAgICAgICAgbWF0cml4LnNjYWxlKHNjYWxlWzBdICogdGhpcy5zLm11bHQsIHNjYWxlWzFdICogdGhpcy5zLm11bHQsIHNjYWxlWzJdICogdGhpcy5zLm11bHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zayAmJiB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPCAzKSB7XG4gICAgICAgIHZhciBza2V3ID0gdGhpcy5zay5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcbiAgICAgICAgdmFyIHNrZXdBeGlzID0gdGhpcy5zYS5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcbiAgICAgICAgbWF0cml4LnNrZXdGcm9tQXhpcygtc2tldyAqIHRoaXMuc2subXVsdCwgc2tld0F4aXMgKiB0aGlzLnNhLm11bHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5yICYmIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDQpIHtcbiAgICAgICAgdmFyIHJvdGF0aW9uID0gdGhpcy5yLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgICBtYXRyaXgucm90YXRlKC1yb3RhdGlvbiAqIHRoaXMuci5tdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuciAmJiB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPCA0KSB7XG4gICAgICAgIHZhciByb3RhdGlvblogPSB0aGlzLnJ6LmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgICB2YXIgcm90YXRpb25ZID0gdGhpcy5yeS5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcbiAgICAgICAgdmFyIHJvdGF0aW9uWCA9IHRoaXMucnguZ2V0VmFsdWVBdFRpbWUodGltZSk7XG4gICAgICAgIHZhciBvcmllbnRhdGlvbiA9IHRoaXMub3IuZ2V0VmFsdWVBdFRpbWUodGltZSk7XG4gICAgICAgIG1hdHJpeC5yb3RhdGVaKC1yb3RhdGlvblogKiB0aGlzLnJ6Lm11bHQpLnJvdGF0ZVkocm90YXRpb25ZICogdGhpcy5yeS5tdWx0KS5yb3RhdGVYKHJvdGF0aW9uWCAqIHRoaXMucngubXVsdCkucm90YXRlWigtb3JpZW50YXRpb25bMl0gKiB0aGlzLm9yLm11bHQpLnJvdGF0ZVkob3JpZW50YXRpb25bMV0gKiB0aGlzLm9yLm11bHQpLnJvdGF0ZVgob3JpZW50YXRpb25bMF0gKiB0aGlzLm9yLm11bHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kYXRhLnAgJiYgdGhpcy5kYXRhLnAucykge1xuICAgICAgICB2YXIgcG9zaXRpb25YID0gdGhpcy5weC5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uWSA9IHRoaXMucHkuZ2V0VmFsdWVBdFRpbWUodGltZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YS5wLnopIHtcbiAgICAgICAgICB2YXIgcG9zaXRpb25aID0gdGhpcy5wei5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcbiAgICAgICAgICBtYXRyaXgudHJhbnNsYXRlKHBvc2l0aW9uWCAqIHRoaXMucHgubXVsdCwgcG9zaXRpb25ZICogdGhpcy5weS5tdWx0LCAtcG9zaXRpb25aICogdGhpcy5wei5tdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRyaXgudHJhbnNsYXRlKHBvc2l0aW9uWCAqIHRoaXMucHgubXVsdCwgcG9zaXRpb25ZICogdGhpcy5weS5tdWx0LCAwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5wLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgICBtYXRyaXgudHJhbnNsYXRlKHBvc2l0aW9uWzBdICogdGhpcy5wLm11bHQsIHBvc2l0aW9uWzFdICogdGhpcy5wLm11bHQsIC1wb3NpdGlvblsyXSAqIHRoaXMucC5tdWx0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hdHJpeDsgLy8vIC9cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1TdGF0aWNWYWx1ZUF0VGltZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnYuY2xvbmUobmV3IE1hdHJpeCgpKTtcbiAgICB9XG5cbiAgICB2YXIgZ2V0VHJhbnNmb3JtUHJvcGVydHkgPSBUcmFuc2Zvcm1Qcm9wZXJ0eUZhY3RvcnkuZ2V0VHJhbnNmb3JtUHJvcGVydHk7XG5cbiAgICBUcmFuc2Zvcm1Qcm9wZXJ0eUZhY3RvcnkuZ2V0VHJhbnNmb3JtUHJvcGVydHkgPSBmdW5jdGlvbiAoZWxlbSwgZGF0YSwgY29udGFpbmVyKSB7XG4gICAgICB2YXIgcHJvcCA9IGdldFRyYW5zZm9ybVByb3BlcnR5KGVsZW0sIGRhdGEsIGNvbnRhaW5lcik7XG5cbiAgICAgIGlmIChwcm9wLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgICBwcm9wLmdldFZhbHVlQXRUaW1lID0gZ2V0VHJhbnNmb3JtVmFsdWVBdFRpbWUuYmluZChwcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AuZ2V0VmFsdWVBdFRpbWUgPSBnZXRUcmFuc2Zvcm1TdGF0aWNWYWx1ZUF0VGltZS5iaW5kKHByb3ApO1xuICAgICAgfVxuXG4gICAgICBwcm9wLnNldEdyb3VwUHJvcGVydHkgPSBleHByZXNzaW9uSGVscGVycy5zZXRHcm91cFByb3BlcnR5O1xuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfTtcblxuICAgIHZhciBwcm9wZXJ0eUdldFByb3AgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcDtcblxuICAgIFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEsIHR5cGUsIG11bHQsIGNvbnRhaW5lcikge1xuICAgICAgdmFyIHByb3AgPSBwcm9wZXJ0eUdldFByb3AoZWxlbSwgZGF0YSwgdHlwZSwgbXVsdCwgY29udGFpbmVyKTsgLy8gcHJvcC5nZXRWZWxvY2l0eUF0VGltZSA9IGdldFZlbG9jaXR5QXRUaW1lO1xuICAgICAgLy8gcHJvcC5sb29wT3V0ID0gbG9vcE91dDtcbiAgICAgIC8vIHByb3AubG9vcEluID0gbG9vcEluO1xuXG4gICAgICBpZiAocHJvcC5rZikge1xuICAgICAgICBwcm9wLmdldFZhbHVlQXRUaW1lID0gZXhwcmVzc2lvbkhlbHBlcnMuZ2V0VmFsdWVBdFRpbWUuYmluZChwcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AuZ2V0VmFsdWVBdFRpbWUgPSBleHByZXNzaW9uSGVscGVycy5nZXRTdGF0aWNWYWx1ZUF0VGltZS5iaW5kKHByb3ApO1xuICAgICAgfVxuXG4gICAgICBwcm9wLnNldEdyb3VwUHJvcGVydHkgPSBleHByZXNzaW9uSGVscGVycy5zZXRHcm91cFByb3BlcnR5O1xuICAgICAgcHJvcC5sb29wT3V0ID0gbG9vcE91dDtcbiAgICAgIHByb3AubG9vcEluID0gbG9vcEluO1xuICAgICAgcHJvcC5zbW9vdGggPSBzbW9vdGg7XG4gICAgICBwcm9wLmdldFZlbG9jaXR5QXRUaW1lID0gZXhwcmVzc2lvbkhlbHBlcnMuZ2V0VmVsb2NpdHlBdFRpbWUuYmluZChwcm9wKTtcbiAgICAgIHByb3AuZ2V0U3BlZWRBdFRpbWUgPSBleHByZXNzaW9uSGVscGVycy5nZXRTcGVlZEF0VGltZS5iaW5kKHByb3ApO1xuICAgICAgcHJvcC5udW1LZXlzID0gZGF0YS5hID09PSAxID8gZGF0YS5rLmxlbmd0aCA6IDA7XG4gICAgICBwcm9wLnByb3BlcnR5SW5kZXggPSBkYXRhLml4O1xuICAgICAgdmFyIHZhbHVlID0gMDtcblxuICAgICAgaWYgKHR5cGUgIT09IDApIHtcbiAgICAgICAgdmFsdWUgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgZGF0YS5hID09PSAxID8gZGF0YS5rWzBdLnMubGVuZ3RoIDogZGF0YS5rLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIHByb3AuX2NhY2hpbmdBdFRpbWUgPSB7XG4gICAgICAgIGxhc3RGcmFtZTogaW5pdGlhbERlZmF1bHRGcmFtZSxcbiAgICAgICAgbGFzdEluZGV4OiAwLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH07XG4gICAgICBleHByZXNzaW9uSGVscGVycy5zZWFyY2hFeHByZXNzaW9ucyhlbGVtLCBkYXRhLCBwcm9wKTtcblxuICAgICAgaWYgKHByb3Auaykge1xuICAgICAgICBjb250YWluZXIuYWRkRHluYW1pY1Byb3BlcnR5KHByb3ApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0U2hhcGVWYWx1ZUF0VGltZShmcmFtZU51bSkge1xuICAgICAgLy8gRm9yIG5vdyB0aGlzIGNhY2hpbmcgb2JqZWN0IGlzIGNyZWF0ZWQgb25seSB3aGVuIG5lZWRlZCBpbnN0ZWFkIG9mIGNyZWF0aW5nIGl0IHdoZW4gdGhlIHNoYXBlIGlzIGluaXRpYWxpemVkLlxuICAgICAgaWYgKCF0aGlzLl9jYWNoaW5nQXRUaW1lKSB7XG4gICAgICAgIHRoaXMuX2NhY2hpbmdBdFRpbWUgPSB7XG4gICAgICAgICAgc2hhcGVWYWx1ZTogc2hhcGVQb29sLmNsb25lKHRoaXMucHYpLFxuICAgICAgICAgIGxhc3RJbmRleDogMCxcbiAgICAgICAgICBsYXN0VGltZTogaW5pdGlhbERlZmF1bHRGcmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmcmFtZU51bSAqPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XG4gICAgICBmcmFtZU51bSAtPSB0aGlzLm9mZnNldFRpbWU7XG5cbiAgICAgIGlmIChmcmFtZU51bSAhPT0gdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0VGltZSkge1xuICAgICAgICB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RJbmRleCA9IHRoaXMuX2NhY2hpbmdBdFRpbWUubGFzdFRpbWUgPCBmcmFtZU51bSA/IHRoaXMuX2NhY2hpbmcubGFzdEluZGV4IDogMDtcbiAgICAgICAgdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0VGltZSA9IGZyYW1lTnVtO1xuICAgICAgICB0aGlzLmludGVycG9sYXRlU2hhcGUoZnJhbWVOdW0sIHRoaXMuX2NhY2hpbmdBdFRpbWUuc2hhcGVWYWx1ZSwgdGhpcy5fY2FjaGluZ0F0VGltZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9jYWNoaW5nQXRUaW1lLnNoYXBlVmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIFNoYXBlUHJvcGVydHlDb25zdHJ1Y3RvckZ1bmN0aW9uID0gU2hhcGVQcm9wZXJ0eUZhY3RvcnkuZ2V0Q29uc3RydWN0b3JGdW5jdGlvbigpO1xuICAgIHZhciBLZXlmcmFtZWRTaGFwZVByb3BlcnR5Q29uc3RydWN0b3JGdW5jdGlvbiA9IFNoYXBlUHJvcGVydHlGYWN0b3J5LmdldEtleWZyYW1lZENvbnN0cnVjdG9yRnVuY3Rpb24oKTtcblxuICAgIGZ1bmN0aW9uIFNoYXBlRXhwcmVzc2lvbnMoKSB7fVxuXG4gICAgU2hhcGVFeHByZXNzaW9ucy5wcm90b3R5cGUgPSB7XG4gICAgICB2ZXJ0aWNlczogZnVuY3Rpb24gdmVydGljZXMocHJvcCwgdGltZSkge1xuICAgICAgICBpZiAodGhpcy5rKSB7XG4gICAgICAgICAgdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNoYXBlUGF0aCA9IHRoaXMudjtcblxuICAgICAgICBpZiAodGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2hhcGVQYXRoID0gdGhpcy5nZXRWYWx1ZUF0VGltZSh0aW1lLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbGVuID0gc2hhcGVQYXRoLl9sZW5ndGg7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHNoYXBlUGF0aFtwcm9wXTtcbiAgICAgICAgdmFyIHBvaW50cyA9IHNoYXBlUGF0aC52O1xuICAgICAgICB2YXIgYXJyID0gY3JlYXRlU2l6ZWRBcnJheShsZW4pO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChwcm9wID09PSAnaScgfHwgcHJvcCA9PT0gJ28nKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBbdmVydGljZXNbaV1bMF0gLSBwb2ludHNbaV1bMF0sIHZlcnRpY2VzW2ldWzFdIC0gcG9pbnRzW2ldWzFdXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyW2ldID0gW3ZlcnRpY2VzW2ldWzBdLCB2ZXJ0aWNlc1tpXVsxXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgIH0sXG4gICAgICBwb2ludHM6IGZ1bmN0aW9uIHBvaW50cyh0aW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZlcnRpY2VzKCd2JywgdGltZSk7XG4gICAgICB9LFxuICAgICAgaW5UYW5nZW50czogZnVuY3Rpb24gaW5UYW5nZW50cyh0aW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZlcnRpY2VzKCdpJywgdGltZSk7XG4gICAgICB9LFxuICAgICAgb3V0VGFuZ2VudHM6IGZ1bmN0aW9uIG91dFRhbmdlbnRzKHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVydGljZXMoJ28nLCB0aW1lKTtcbiAgICAgIH0sXG4gICAgICBpc0Nsb3NlZDogZnVuY3Rpb24gaXNDbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnYuYztcbiAgICAgIH0sXG4gICAgICBwb2ludE9uUGF0aDogZnVuY3Rpb24gcG9pbnRPblBhdGgocGVyYywgdGltZSkge1xuICAgICAgICB2YXIgc2hhcGVQYXRoID0gdGhpcy52O1xuXG4gICAgICAgIGlmICh0aW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzaGFwZVBhdGggPSB0aGlzLmdldFZhbHVlQXRUaW1lKHRpbWUsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9zZWdtZW50c0xlbmd0aCkge1xuICAgICAgICAgIHRoaXMuX3NlZ21lbnRzTGVuZ3RoID0gYmV6LmdldFNlZ21lbnRzTGVuZ3RoKHNoYXBlUGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VnbWVudHNMZW5ndGggPSB0aGlzLl9zZWdtZW50c0xlbmd0aDtcbiAgICAgICAgdmFyIGxlbmd0aHMgPSBzZWdtZW50c0xlbmd0aC5sZW5ndGhzO1xuICAgICAgICB2YXIgbGVuZ3RoUG9zID0gc2VnbWVudHNMZW5ndGgudG90YWxMZW5ndGggKiBwZXJjO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBsZW5ndGhzLmxlbmd0aDtcbiAgICAgICAgdmFyIGFjY3VtdWxhdGVkTGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIHB0O1xuXG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgaWYgKGFjY3VtdWxhdGVkTGVuZ3RoICsgbGVuZ3Roc1tpXS5hZGRlZExlbmd0aCA+IGxlbmd0aFBvcykge1xuICAgICAgICAgICAgdmFyIGluaXRJbmRleCA9IGk7XG4gICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBzaGFwZVBhdGguYyAmJiBpID09PSBsZW4gLSAxID8gMCA6IGkgKyAxO1xuICAgICAgICAgICAgdmFyIHNlZ21lbnRQZXJjID0gKGxlbmd0aFBvcyAtIGFjY3VtdWxhdGVkTGVuZ3RoKSAvIGxlbmd0aHNbaV0uYWRkZWRMZW5ndGg7XG4gICAgICAgICAgICBwdCA9IGJlei5nZXRQb2ludEluU2VnbWVudChzaGFwZVBhdGgudltpbml0SW5kZXhdLCBzaGFwZVBhdGgudltlbmRJbmRleF0sIHNoYXBlUGF0aC5vW2luaXRJbmRleF0sIHNoYXBlUGF0aC5pW2VuZEluZGV4XSwgc2VnbWVudFBlcmMsIGxlbmd0aHNbaV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkTGVuZ3RoICs9IGxlbmd0aHNbaV0uYWRkZWRMZW5ndGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwdCkge1xuICAgICAgICAgIHB0ID0gc2hhcGVQYXRoLmMgPyBbc2hhcGVQYXRoLnZbMF1bMF0sIHNoYXBlUGF0aC52WzBdWzFdXSA6IFtzaGFwZVBhdGgudltzaGFwZVBhdGguX2xlbmd0aCAtIDFdWzBdLCBzaGFwZVBhdGgudltzaGFwZVBhdGguX2xlbmd0aCAtIDFdWzFdXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwdDtcbiAgICAgIH0sXG4gICAgICB2ZWN0b3JPblBhdGg6IGZ1bmN0aW9uIHZlY3Rvck9uUGF0aChwZXJjLCB0aW1lLCB2ZWN0b3JUeXBlKSB7XG4gICAgICAgIC8vIHBlcmMgZG9lc24ndCB1c2UgdHJpcGxlIGVxdWFsaXR5IGJlY2F1c2UgaXQgY2FuIGJlIGEgTnVtYmVyIG9iamVjdCBhcyB3ZWxsIGFzIGEgcHJpbWl0aXZlLlxuICAgICAgICBpZiAocGVyYyA9PSAxKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICAgICAgICBwZXJjID0gdGhpcy52LmM7XG4gICAgICAgIH0gZWxzZSBpZiAocGVyYyA9PSAwKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICAgICAgICBwZXJjID0gMC45OTk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHQxID0gdGhpcy5wb2ludE9uUGF0aChwZXJjLCB0aW1lKTtcbiAgICAgICAgdmFyIHB0MiA9IHRoaXMucG9pbnRPblBhdGgocGVyYyArIDAuMDAxLCB0aW1lKTtcbiAgICAgICAgdmFyIHhMZW5ndGggPSBwdDJbMF0gLSBwdDFbMF07XG4gICAgICAgIHZhciB5TGVuZ3RoID0gcHQyWzFdIC0gcHQxWzFdO1xuICAgICAgICB2YXIgbWFnbml0dWRlID0gTWF0aC5zcXJ0KE1hdGgucG93KHhMZW5ndGgsIDIpICsgTWF0aC5wb3coeUxlbmd0aCwgMikpO1xuXG4gICAgICAgIGlmIChtYWduaXR1ZGUgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVuaXRWZWN0b3IgPSB2ZWN0b3JUeXBlID09PSAndGFuZ2VudCcgPyBbeExlbmd0aCAvIG1hZ25pdHVkZSwgeUxlbmd0aCAvIG1hZ25pdHVkZV0gOiBbLXlMZW5ndGggLyBtYWduaXR1ZGUsIHhMZW5ndGggLyBtYWduaXR1ZGVdO1xuICAgICAgICByZXR1cm4gdW5pdFZlY3RvcjtcbiAgICAgIH0sXG4gICAgICB0YW5nZW50T25QYXRoOiBmdW5jdGlvbiB0YW5nZW50T25QYXRoKHBlcmMsIHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVjdG9yT25QYXRoKHBlcmMsIHRpbWUsICd0YW5nZW50Jyk7XG4gICAgICB9LFxuICAgICAgbm9ybWFsT25QYXRoOiBmdW5jdGlvbiBub3JtYWxPblBhdGgocGVyYywgdGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZWN0b3JPblBhdGgocGVyYywgdGltZSwgJ25vcm1hbCcpO1xuICAgICAgfSxcbiAgICAgIHNldEdyb3VwUHJvcGVydHk6IGV4cHJlc3Npb25IZWxwZXJzLnNldEdyb3VwUHJvcGVydHksXG4gICAgICBnZXRWYWx1ZUF0VGltZTogZXhwcmVzc2lvbkhlbHBlcnMuZ2V0U3RhdGljVmFsdWVBdFRpbWVcbiAgICB9O1xuICAgIGV4dGVuZFByb3RvdHlwZShbU2hhcGVFeHByZXNzaW9uc10sIFNoYXBlUHJvcGVydHlDb25zdHJ1Y3RvckZ1bmN0aW9uKTtcbiAgICBleHRlbmRQcm90b3R5cGUoW1NoYXBlRXhwcmVzc2lvbnNdLCBLZXlmcmFtZWRTaGFwZVByb3BlcnR5Q29uc3RydWN0b3JGdW5jdGlvbik7XG4gICAgS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eUNvbnN0cnVjdG9yRnVuY3Rpb24ucHJvdG90eXBlLmdldFZhbHVlQXRUaW1lID0gZ2V0U2hhcGVWYWx1ZUF0VGltZTtcbiAgICBLZXlmcmFtZWRTaGFwZVByb3BlcnR5Q29uc3RydWN0b3JGdW5jdGlvbi5wcm90b3R5cGUuaW5pdGlhdGVFeHByZXNzaW9uID0gRXhwcmVzc2lvbk1hbmFnZXIuaW5pdGlhdGVFeHByZXNzaW9uO1xuICAgIHZhciBwcm9wZXJ0eUdldFNoYXBlUHJvcCA9IFNoYXBlUHJvcGVydHlGYWN0b3J5LmdldFNoYXBlUHJvcDtcblxuICAgIFNoYXBlUHJvcGVydHlGYWN0b3J5LmdldFNoYXBlUHJvcCA9IGZ1bmN0aW9uIChlbGVtLCBkYXRhLCB0eXBlLCBhcnIsIHRyaW1zKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BlcnR5R2V0U2hhcGVQcm9wKGVsZW0sIGRhdGEsIHR5cGUsIGFyciwgdHJpbXMpO1xuICAgICAgcHJvcC5wcm9wZXJ0eUluZGV4ID0gZGF0YS5peDtcbiAgICAgIHByb3AubG9jayA9IGZhbHNlO1xuXG4gICAgICBpZiAodHlwZSA9PT0gMykge1xuICAgICAgICBleHByZXNzaW9uSGVscGVycy5zZWFyY2hFeHByZXNzaW9ucyhlbGVtLCBkYXRhLnB0LCBwcm9wKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gNCkge1xuICAgICAgICBleHByZXNzaW9uSGVscGVycy5zZWFyY2hFeHByZXNzaW9ucyhlbGVtLCBkYXRhLmtzLCBwcm9wKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3Auaykge1xuICAgICAgICBlbGVtLmFkZER5bmFtaWNQcm9wZXJ0eShwcm9wKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUkMSgpIHtcbiAgICBhZGRQcm9wZXJ0eURlY29yYXRvcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRGVjb3JhdG9yKCkge1xuICAgIGZ1bmN0aW9uIHNlYXJjaEV4cHJlc3Npb25zKCkge1xuICAgICAgaWYgKHRoaXMuZGF0YS5kLngpIHtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVFeHByZXNzaW9uID0gRXhwcmVzc2lvbk1hbmFnZXIuaW5pdGlhdGVFeHByZXNzaW9uLmJpbmQodGhpcykodGhpcy5lbGVtLCB0aGlzLmRhdGEuZCwgdGhpcyk7XG4gICAgICAgIHRoaXMuYWRkRWZmZWN0KHRoaXMuZ2V0RXhwcmVzc2lvblZhbHVlLmJpbmQodGhpcykpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5nZXRFeHByZXNzaW9uVmFsdWUgPSBmdW5jdGlvbiAoY3VycmVudFZhbHVlLCB0ZXh0KSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLmNhbGN1bGF0ZUV4cHJlc3Npb24odGV4dCk7XG5cbiAgICAgIGlmIChjdXJyZW50VmFsdWUudCAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgdmFyIG5ld0RhdGEgPSB7fTtcbiAgICAgICAgdGhpcy5jb3B5RGF0YShuZXdEYXRhLCBjdXJyZW50VmFsdWUpO1xuICAgICAgICBuZXdEYXRhLnQgPSBuZXdWYWx1ZS50b1N0cmluZygpO1xuICAgICAgICBuZXdEYXRhLl9fY29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgfTtcblxuICAgIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUuc2VhcmNoUHJvcGVydHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaXNLZXlmcmFtZWQgPSB0aGlzLnNlYXJjaEtleWZyYW1lcygpO1xuICAgICAgdmFyIGhhc0V4cHJlc3Npb25zID0gdGhpcy5zZWFyY2hFeHByZXNzaW9ucygpO1xuICAgICAgdGhpcy5rZiA9IGlzS2V5ZnJhbWVkIHx8IGhhc0V4cHJlc3Npb25zO1xuICAgICAgcmV0dXJuIHRoaXMua2Y7XG4gICAgfTtcblxuICAgIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUuc2VhcmNoRXhwcmVzc2lvbnMgPSBzZWFyY2hFeHByZXNzaW9ucztcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgYWRkRGVjb3JhdG9yKCk7XG4gIH1cblxuICBmdW5jdGlvbiBTVkdDb21wb3NhYmxlRWZmZWN0KCkge31cblxuICBTVkdDb21wb3NhYmxlRWZmZWN0LnByb3RvdHlwZSA9IHtcbiAgICBjcmVhdGVNZXJnZU5vZGU6IGZ1bmN0aW9uIGNyZWF0ZU1lcmdlTm9kZShyZXN1bHRJZCwgaW5zKSB7XG4gICAgICB2YXIgZmVNZXJnZSA9IGNyZWF0ZU5TKCdmZU1lcmdlJyk7XG4gICAgICBmZU1lcmdlLnNldEF0dHJpYnV0ZSgncmVzdWx0JywgcmVzdWx0SWQpO1xuICAgICAgdmFyIGZlTWVyZ2VOb2RlO1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgZmVNZXJnZU5vZGUgPSBjcmVhdGVOUygnZmVNZXJnZU5vZGUnKTtcbiAgICAgICAgZmVNZXJnZU5vZGUuc2V0QXR0cmlidXRlKCdpbicsIGluc1tpXSk7XG4gICAgICAgIGZlTWVyZ2UuYXBwZW5kQ2hpbGQoZmVNZXJnZU5vZGUpO1xuICAgICAgICBmZU1lcmdlLmFwcGVuZENoaWxkKGZlTWVyZ2VOb2RlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZlTWVyZ2U7XG4gICAgfVxuICB9O1xuXG4gIHZhciBsaW5lYXJGaWx0ZXJWYWx1ZSA9ICcwLjMzMzMgMC4zMzMzIDAuMzMzMyAwIDAgMC4zMzMzIDAuMzMzMyAwLjMzMzMgMCAwIDAuMzMzMyAwLjMzMzMgMC4zMzMzIDAgMCAwIDAgMCc7XG5cbiAgZnVuY3Rpb24gU1ZHVGludEZpbHRlcihmaWx0ZXIsIGZpbHRlck1hbmFnZXIsIGVsZW0sIGlkLCBzb3VyY2UpIHtcbiAgICB0aGlzLmZpbHRlck1hbmFnZXIgPSBmaWx0ZXJNYW5hZ2VyO1xuICAgIHZhciBmZUNvbG9yTWF0cml4ID0gY3JlYXRlTlMoJ2ZlQ29sb3JNYXRyaXgnKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgndHlwZScsICdtYXRyaXgnKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2xpbmVhclJHQicpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCBsaW5lYXJGaWx0ZXJWYWx1ZSArICcgMSAwJyk7XG4gICAgdGhpcy5saW5lYXJGaWx0ZXIgPSBmZUNvbG9yTWF0cml4O1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCdyZXN1bHQnLCBpZCArICdfdGludF8xJyk7XG4gICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlQ29sb3JNYXRyaXgpO1xuICAgIGZlQ29sb3JNYXRyaXggPSBjcmVhdGVOUygnZmVDb2xvck1hdHJpeCcpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd0eXBlJywgJ21hdHJpeCcpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnc1JHQicpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCAnMSAwIDAgMCAwIDAgMSAwIDAgMCAwIDAgMSAwIDAgMCAwIDAgMSAwJyk7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3Jlc3VsdCcsIGlkICsgJ190aW50XzInKTtcbiAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVDb2xvck1hdHJpeCk7XG4gICAgdGhpcy5tYXRyaXhGaWx0ZXIgPSBmZUNvbG9yTWF0cml4O1xuICAgIHZhciBmZU1lcmdlID0gdGhpcy5jcmVhdGVNZXJnZU5vZGUoaWQsIFtzb3VyY2UsIGlkICsgJ190aW50XzEnLCBpZCArICdfdGludF8yJ10pO1xuICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZU1lcmdlKTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbU1ZHQ29tcG9zYWJsZUVmZmVjdF0sIFNWR1RpbnRGaWx0ZXIpO1xuXG4gIFNWR1RpbnRGaWx0ZXIucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKGZvcmNlUmVuZGVyKSB7XG4gICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5fbWRmKSB7XG4gICAgICB2YXIgY29sb3JCbGFjayA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1swXS5wLnY7XG4gICAgICB2YXIgY29sb3JXaGl0ZSA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxXS5wLnY7XG4gICAgICB2YXIgb3BhY2l0eSA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1syXS5wLnYgLyAxMDA7XG4gICAgICB0aGlzLmxpbmVhckZpbHRlci5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsIGxpbmVhckZpbHRlclZhbHVlICsgJyAnICsgb3BhY2l0eSArICcgMCcpO1xuICAgICAgdGhpcy5tYXRyaXhGaWx0ZXIuc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCBjb2xvcldoaXRlWzBdIC0gY29sb3JCbGFja1swXSArICcgMCAwIDAgJyArIGNvbG9yQmxhY2tbMF0gKyAnICcgKyAoY29sb3JXaGl0ZVsxXSAtIGNvbG9yQmxhY2tbMV0pICsgJyAwIDAgMCAnICsgY29sb3JCbGFja1sxXSArICcgJyArIChjb2xvcldoaXRlWzJdIC0gY29sb3JCbGFja1syXSkgKyAnIDAgMCAwICcgKyBjb2xvckJsYWNrWzJdICsgJyAwIDAgMCAxIDAnKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gU1ZHRmlsbEZpbHRlcihmaWx0ZXIsIGZpbHRlck1hbmFnZXIsIGVsZW0sIGlkKSB7XG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gZmlsdGVyTWFuYWdlcjtcbiAgICB2YXIgZmVDb2xvck1hdHJpeCA9IGNyZWF0ZU5TKCdmZUNvbG9yTWF0cml4Jyk7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnbWF0cml4Jyk7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdzUkdCJyk7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsICcxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxIDAnKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgncmVzdWx0JywgaWQpO1xuICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZUNvbG9yTWF0cml4KTtcbiAgICB0aGlzLm1hdHJpeEZpbHRlciA9IGZlQ29sb3JNYXRyaXg7XG4gIH1cblxuICBTVkdGaWxsRmlsdGVyLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChmb3JjZVJlbmRlcikge1xuICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuX21kZikge1xuICAgICAgdmFyIGNvbG9yID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzJdLnAudjtcbiAgICAgIHZhciBvcGFjaXR5ID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzZdLnAudjtcbiAgICAgIHRoaXMubWF0cml4RmlsdGVyLnNldEF0dHJpYnV0ZSgndmFsdWVzJywgJzAgMCAwIDAgJyArIGNvbG9yWzBdICsgJyAwIDAgMCAwICcgKyBjb2xvclsxXSArICcgMCAwIDAgMCAnICsgY29sb3JbMl0gKyAnIDAgMCAwICcgKyBvcGFjaXR5ICsgJyAwJyk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIFNWR1N0cm9rZUVmZmVjdChmaWwsIGZpbHRlck1hbmFnZXIsIGVsZW0pIHtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gZmlsdGVyTWFuYWdlcjtcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgIHRoaXMucGF0aHMgPSBbXTtcbiAgfVxuXG4gIFNWR1N0cm9rZUVmZmVjdC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlbUNoaWxkcmVuID0gdGhpcy5lbGVtLmxheWVyRWxlbWVudC5jaGlsZHJlbiB8fCB0aGlzLmVsZW0ubGF5ZXJFbGVtZW50LmNoaWxkTm9kZXM7XG4gICAgdmFyIHBhdGg7XG4gICAgdmFyIGdyb3VwUGF0aDtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuXG4gICAgaWYgKHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxXS5wLnYgPT09IDEpIHtcbiAgICAgIGxlbiA9IHRoaXMuZWxlbS5tYXNrTWFuYWdlci5tYXNrc1Byb3BlcnRpZXMubGVuZ3RoO1xuICAgICAgaSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMF0ucC52IC0gMTtcbiAgICAgIGxlbiA9IGkgKyAxO1xuICAgIH1cblxuICAgIGdyb3VwUGF0aCA9IGNyZWF0ZU5TKCdnJyk7XG4gICAgZ3JvdXBQYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdub25lJyk7XG4gICAgZ3JvdXBQYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCAncm91bmQnKTtcbiAgICBncm91cFBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcsIDEpO1xuXG4gICAgZm9yIChpOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHBhdGggPSBjcmVhdGVOUygncGF0aCcpO1xuICAgICAgZ3JvdXBQYXRoLmFwcGVuZENoaWxkKHBhdGgpO1xuICAgICAgdGhpcy5wYXRocy5wdXNoKHtcbiAgICAgICAgcDogcGF0aCxcbiAgICAgICAgbTogaVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxMF0ucC52ID09PSAzKSB7XG4gICAgICB2YXIgbWFzayA9IGNyZWF0ZU5TKCdtYXNrJyk7XG4gICAgICB2YXIgaWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICAgIG1hc2suc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgIG1hc2suc2V0QXR0cmlidXRlKCdtYXNrLXR5cGUnLCAnYWxwaGEnKTtcbiAgICAgIG1hc2suYXBwZW5kQ2hpbGQoZ3JvdXBQYXRoKTtcbiAgICAgIHRoaXMuZWxlbS5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQobWFzayk7XG4gICAgICB2YXIgZyA9IGNyZWF0ZU5TKCdnJyk7XG4gICAgICBnLnNldEF0dHJpYnV0ZSgnbWFzaycsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgaWQgKyAnKScpO1xuXG4gICAgICB3aGlsZSAoZWxlbUNoaWxkcmVuWzBdKSB7XG4gICAgICAgIGcuYXBwZW5kQ2hpbGQoZWxlbUNoaWxkcmVuWzBdKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbGVtLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZChnKTtcbiAgICAgIHRoaXMubWFza2VyID0gbWFzaztcbiAgICAgIGdyb3VwUGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICcjZmZmJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMTBdLnAudiA9PT0gMSB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMTBdLnAudiA9PT0gMikge1xuICAgICAgaWYgKHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxMF0ucC52ID09PSAyKSB7XG4gICAgICAgIGVsZW1DaGlsZHJlbiA9IHRoaXMuZWxlbS5sYXllckVsZW1lbnQuY2hpbGRyZW4gfHwgdGhpcy5lbGVtLmxheWVyRWxlbWVudC5jaGlsZE5vZGVzO1xuXG4gICAgICAgIHdoaWxlIChlbGVtQ2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5lbGVtLmxheWVyRWxlbWVudC5yZW1vdmVDaGlsZChlbGVtQ2hpbGRyZW5bMF0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWxlbS5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQoZ3JvdXBQYXRoKTtcbiAgICAgIHRoaXMuZWxlbS5sYXllckVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdtYXNrJyk7XG4gICAgICBncm91cFBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCAnI2ZmZicpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMucGF0aE1hc2tlciA9IGdyb3VwUGF0aDtcbiAgfTtcblxuICBTVkdTdHJva2VFZmZlY3QucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKGZvcmNlUmVuZGVyKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5wYXRocy5sZW5ndGg7XG4gICAgdmFyIG1hc2s7XG4gICAgdmFyIHBhdGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICh0aGlzLnBhdGhzW2ldLm0gIT09IC0xKSB7XG4gICAgICAgIG1hc2sgPSB0aGlzLmVsZW0ubWFza01hbmFnZXIudmlld0RhdGFbdGhpcy5wYXRoc1tpXS5tXTtcbiAgICAgICAgcGF0aCA9IHRoaXMucGF0aHNbaV0ucDtcblxuICAgICAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLl9tZGYgfHwgbWFzay5wcm9wLl9tZGYpIHtcbiAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZCcsIG1hc2subGFzdFBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s5XS5wLl9tZGYgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzRdLnAuX21kZiB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbN10ucC5fbWRmIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s4XS5wLl9tZGYgfHwgbWFzay5wcm9wLl9tZGYpIHtcbiAgICAgICAgICB2YXIgZGFzaGFycmF5VmFsdWU7XG5cbiAgICAgICAgICBpZiAodGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzddLnAudiAhPT0gMCB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbOF0ucC52ICE9PSAxMDApIHtcbiAgICAgICAgICAgIHZhciBzID0gTWF0aC5taW4odGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzddLnAudiwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzhdLnAudikgKiAwLjAxO1xuICAgICAgICAgICAgdmFyIGUgPSBNYXRoLm1heCh0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbN10ucC52LCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbOF0ucC52KSAqIDAuMDE7XG4gICAgICAgICAgICB2YXIgbCA9IHBhdGguZ2V0VG90YWxMZW5ndGgoKTtcbiAgICAgICAgICAgIGRhc2hhcnJheVZhbHVlID0gJzAgMCAwICcgKyBsICogcyArICcgJztcbiAgICAgICAgICAgIHZhciBsaW5lTGVuZ3RoID0gbCAqIChlIC0gcyk7XG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IDEgKyB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNF0ucC52ICogMiAqIHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s5XS5wLnYgKiAwLjAxO1xuICAgICAgICAgICAgdmFyIHVuaXRzID0gTWF0aC5mbG9vcihsaW5lTGVuZ3RoIC8gc2VnbWVudCk7XG4gICAgICAgICAgICB2YXIgajtcblxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHVuaXRzOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgZGFzaGFycmF5VmFsdWUgKz0gJzEgJyArIHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s0XS5wLnYgKiAyICogdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzldLnAudiAqIDAuMDEgKyAnICc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhc2hhcnJheVZhbHVlICs9ICcwICcgKyBsICogMTAgKyAnIDAgMCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhc2hhcnJheVZhbHVlID0gJzEgJyArIHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s0XS5wLnYgKiAyICogdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzldLnAudiAqIDAuMDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBkYXNoYXJyYXlWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzRdLnAuX21kZikge1xuICAgICAgdGhpcy5wYXRoTWFza2VyLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzRdLnAudiAqIDIpO1xuICAgIH1cblxuICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNl0ucC5fbWRmKSB7XG4gICAgICB0aGlzLnBhdGhNYXNrZXIuc2V0QXR0cmlidXRlKCdvcGFjaXR5JywgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzZdLnAudik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxMF0ucC52ID09PSAxIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxMF0ucC52ID09PSAyKSB7XG4gICAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzNdLnAuX21kZikge1xuICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbM10ucC52O1xuICAgICAgICB0aGlzLnBhdGhNYXNrZXIuc2V0QXR0cmlidXRlKCdzdHJva2UnLCAncmdiKCcgKyBibUZsb29yKGNvbG9yWzBdICogMjU1KSArICcsJyArIGJtRmxvb3IoY29sb3JbMV0gKiAyNTUpICsgJywnICsgYm1GbG9vcihjb2xvclsyXSAqIDI1NSkgKyAnKScpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBTVkdUcml0b25lRmlsdGVyKGZpbHRlciwgZmlsdGVyTWFuYWdlciwgZWxlbSwgaWQpIHtcbiAgICB0aGlzLmZpbHRlck1hbmFnZXIgPSBmaWx0ZXJNYW5hZ2VyO1xuICAgIHZhciBmZUNvbG9yTWF0cml4ID0gY3JlYXRlTlMoJ2ZlQ29sb3JNYXRyaXgnKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgndHlwZScsICdtYXRyaXgnKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2xpbmVhclJHQicpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCAnMC4zMzMzIDAuMzMzMyAwLjMzMzMgMCAwIDAuMzMzMyAwLjMzMzMgMC4zMzMzIDAgMCAwLjMzMzMgMC4zMzMzIDAuMzMzMyAwIDAgMCAwIDAgMSAwJyk7XG4gICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlQ29sb3JNYXRyaXgpO1xuICAgIHZhciBmZUNvbXBvbmVudFRyYW5zZmVyID0gY3JlYXRlTlMoJ2ZlQ29tcG9uZW50VHJhbnNmZXInKTtcbiAgICBmZUNvbXBvbmVudFRyYW5zZmVyLnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ3NSR0InKTtcbiAgICBmZUNvbXBvbmVudFRyYW5zZmVyLnNldEF0dHJpYnV0ZSgncmVzdWx0JywgaWQpO1xuICAgIHRoaXMubWF0cml4RmlsdGVyID0gZmVDb21wb25lbnRUcmFuc2ZlcjtcbiAgICB2YXIgZmVGdW5jUiA9IGNyZWF0ZU5TKCdmZUZ1bmNSJyk7XG4gICAgZmVGdW5jUi5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGFibGUnKTtcbiAgICBmZUNvbXBvbmVudFRyYW5zZmVyLmFwcGVuZENoaWxkKGZlRnVuY1IpO1xuICAgIHRoaXMuZmVGdW5jUiA9IGZlRnVuY1I7XG4gICAgdmFyIGZlRnVuY0cgPSBjcmVhdGVOUygnZmVGdW5jRycpO1xuICAgIGZlRnVuY0cuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RhYmxlJyk7XG4gICAgZmVDb21wb25lbnRUcmFuc2Zlci5hcHBlbmRDaGlsZChmZUZ1bmNHKTtcbiAgICB0aGlzLmZlRnVuY0cgPSBmZUZ1bmNHO1xuICAgIHZhciBmZUZ1bmNCID0gY3JlYXRlTlMoJ2ZlRnVuY0InKTtcbiAgICBmZUZ1bmNCLnNldEF0dHJpYnV0ZSgndHlwZScsICd0YWJsZScpO1xuICAgIGZlQ29tcG9uZW50VHJhbnNmZXIuYXBwZW5kQ2hpbGQoZmVGdW5jQik7XG4gICAgdGhpcy5mZUZ1bmNCID0gZmVGdW5jQjtcbiAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVDb21wb25lbnRUcmFuc2Zlcik7XG4gIH1cblxuICBTVkdUcml0b25lRmlsdGVyLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChmb3JjZVJlbmRlcikge1xuICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuX21kZikge1xuICAgICAgdmFyIGNvbG9yMSA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1swXS5wLnY7XG4gICAgICB2YXIgY29sb3IyID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzFdLnAudjtcbiAgICAgIHZhciBjb2xvcjMgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMl0ucC52O1xuICAgICAgdmFyIHRhYmxlUiA9IGNvbG9yM1swXSArICcgJyArIGNvbG9yMlswXSArICcgJyArIGNvbG9yMVswXTtcbiAgICAgIHZhciB0YWJsZUcgPSBjb2xvcjNbMV0gKyAnICcgKyBjb2xvcjJbMV0gKyAnICcgKyBjb2xvcjFbMV07XG4gICAgICB2YXIgdGFibGVCID0gY29sb3IzWzJdICsgJyAnICsgY29sb3IyWzJdICsgJyAnICsgY29sb3IxWzJdO1xuICAgICAgdGhpcy5mZUZ1bmNSLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB0YWJsZVIpO1xuICAgICAgdGhpcy5mZUZ1bmNHLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB0YWJsZUcpO1xuICAgICAgdGhpcy5mZUZ1bmNCLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB0YWJsZUIpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBTVkdQcm9MZXZlbHNGaWx0ZXIoZmlsdGVyLCBmaWx0ZXJNYW5hZ2VyLCBlbGVtLCBpZCkge1xuICAgIHRoaXMuZmlsdGVyTWFuYWdlciA9IGZpbHRlck1hbmFnZXI7XG4gICAgdmFyIGVmZmVjdEVsZW1lbnRzID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzO1xuICAgIHZhciBmZUNvbXBvbmVudFRyYW5zZmVyID0gY3JlYXRlTlMoJ2ZlQ29tcG9uZW50VHJhbnNmZXInKTsgLy8gUmVkXG5cbiAgICBpZiAoZWZmZWN0RWxlbWVudHNbMTBdLnAuayB8fCBlZmZlY3RFbGVtZW50c1sxMF0ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzExXS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMTFdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1sxMl0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzEyXS5wLnYgIT09IDEgfHwgZWZmZWN0RWxlbWVudHNbMTNdLnAuayB8fCBlZmZlY3RFbGVtZW50c1sxM10ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzE0XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMTRdLnAudiAhPT0gMSkge1xuICAgICAgdGhpcy5mZUZ1bmNSID0gdGhpcy5jcmVhdGVGZUZ1bmMoJ2ZlRnVuY1InLCBmZUNvbXBvbmVudFRyYW5zZmVyKTtcbiAgICB9IC8vIEdyZWVuXG5cblxuICAgIGlmIChlZmZlY3RFbGVtZW50c1sxN10ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzE3XS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbMThdLnAuayB8fCBlZmZlY3RFbGVtZW50c1sxOF0ucC52ICE9PSAxIHx8IGVmZmVjdEVsZW1lbnRzWzE5XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMTldLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1syMF0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzIwXS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbMjFdLnAuayB8fCBlZmZlY3RFbGVtZW50c1syMV0ucC52ICE9PSAxKSB7XG4gICAgICB0aGlzLmZlRnVuY0cgPSB0aGlzLmNyZWF0ZUZlRnVuYygnZmVGdW5jRycsIGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgIH0gLy8gQmx1ZVxuXG5cbiAgICBpZiAoZWZmZWN0RWxlbWVudHNbMjRdLnAuayB8fCBlZmZlY3RFbGVtZW50c1syNF0ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzI1XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMjVdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1syNl0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzI2XS5wLnYgIT09IDEgfHwgZWZmZWN0RWxlbWVudHNbMjddLnAuayB8fCBlZmZlY3RFbGVtZW50c1syN10ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzI4XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMjhdLnAudiAhPT0gMSkge1xuICAgICAgdGhpcy5mZUZ1bmNCID0gdGhpcy5jcmVhdGVGZUZ1bmMoJ2ZlRnVuY0InLCBmZUNvbXBvbmVudFRyYW5zZmVyKTtcbiAgICB9IC8vIEFscGhhXG5cblxuICAgIGlmIChlZmZlY3RFbGVtZW50c1szMV0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzMxXS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbMzJdLnAuayB8fCBlZmZlY3RFbGVtZW50c1szMl0ucC52ICE9PSAxIHx8IGVmZmVjdEVsZW1lbnRzWzMzXS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMzNdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1szNF0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzM0XS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbMzVdLnAuayB8fCBlZmZlY3RFbGVtZW50c1szNV0ucC52ICE9PSAxKSB7XG4gICAgICB0aGlzLmZlRnVuY0EgPSB0aGlzLmNyZWF0ZUZlRnVuYygnZmVGdW5jQScsIGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgIH0gLy8gUkdCXG5cblxuICAgIGlmICh0aGlzLmZlRnVuY1IgfHwgdGhpcy5mZUZ1bmNHIHx8IHRoaXMuZmVGdW5jQiB8fCB0aGlzLmZlRnVuY0EpIHtcbiAgICAgIGZlQ29tcG9uZW50VHJhbnNmZXIuc2V0QXR0cmlidXRlKCdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnc1JHQicpO1xuICAgICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgIH1cblxuICAgIGlmIChlZmZlY3RFbGVtZW50c1szXS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbM10ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzRdLnAuayB8fCBlZmZlY3RFbGVtZW50c1s0XS5wLnYgIT09IDEgfHwgZWZmZWN0RWxlbWVudHNbNV0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzVdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1s2XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbNl0ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzddLnAuayB8fCBlZmZlY3RFbGVtZW50c1s3XS5wLnYgIT09IDEpIHtcbiAgICAgIGZlQ29tcG9uZW50VHJhbnNmZXIgPSBjcmVhdGVOUygnZmVDb21wb25lbnRUcmFuc2ZlcicpO1xuICAgICAgZmVDb21wb25lbnRUcmFuc2Zlci5zZXRBdHRyaWJ1dGUoJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdzUkdCJyk7XG4gICAgICBmZUNvbXBvbmVudFRyYW5zZmVyLnNldEF0dHJpYnV0ZSgncmVzdWx0JywgaWQpO1xuICAgICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgICAgdGhpcy5mZUZ1bmNSQ29tcG9zZWQgPSB0aGlzLmNyZWF0ZUZlRnVuYygnZmVGdW5jUicsIGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgICAgdGhpcy5mZUZ1bmNHQ29tcG9zZWQgPSB0aGlzLmNyZWF0ZUZlRnVuYygnZmVGdW5jRycsIGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgICAgdGhpcy5mZUZ1bmNCQ29tcG9zZWQgPSB0aGlzLmNyZWF0ZUZlRnVuYygnZmVGdW5jQicsIGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgIH1cbiAgfVxuXG4gIFNWR1Byb0xldmVsc0ZpbHRlci5wcm90b3R5cGUuY3JlYXRlRmVGdW5jID0gZnVuY3Rpb24gKHR5cGUsIGZlQ29tcG9uZW50VHJhbnNmZXIpIHtcbiAgICB2YXIgZmVGdW5jID0gY3JlYXRlTlModHlwZSk7XG4gICAgZmVGdW5jLnNldEF0dHJpYnV0ZSgndHlwZScsICd0YWJsZScpO1xuICAgIGZlQ29tcG9uZW50VHJhbnNmZXIuYXBwZW5kQ2hpbGQoZmVGdW5jKTtcbiAgICByZXR1cm4gZmVGdW5jO1xuICB9O1xuXG4gIFNWR1Byb0xldmVsc0ZpbHRlci5wcm90b3R5cGUuZ2V0VGFibGVWYWx1ZSA9IGZ1bmN0aW9uIChpbnB1dEJsYWNrLCBpbnB1dFdoaXRlLCBnYW1tYSwgb3V0cHV0QmxhY2ssIG91dHB1dFdoaXRlKSB7XG4gICAgdmFyIGNudCA9IDA7XG4gICAgdmFyIHNlZ21lbnRzID0gMjU2O1xuICAgIHZhciBwZXJjO1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihpbnB1dEJsYWNrLCBpbnB1dFdoaXRlKTtcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXgoaW5wdXRCbGFjaywgaW5wdXRXaGl0ZSk7XG4gICAgdmFyIHRhYmxlID0gQXJyYXkuY2FsbChudWxsLCB7XG4gICAgICBsZW5ndGg6IHNlZ21lbnRzXG4gICAgfSk7XG4gICAgdmFyIGNvbG9yVmFsdWU7XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgdmFyIG91dHB1dERlbHRhID0gb3V0cHV0V2hpdGUgLSBvdXRwdXRCbGFjaztcbiAgICB2YXIgaW5wdXREZWx0YSA9IGlucHV0V2hpdGUgLSBpbnB1dEJsYWNrO1xuXG4gICAgd2hpbGUgKGNudCA8PSAyNTYpIHtcbiAgICAgIHBlcmMgPSBjbnQgLyAyNTY7XG5cbiAgICAgIGlmIChwZXJjIDw9IG1pbikge1xuICAgICAgICBjb2xvclZhbHVlID0gaW5wdXREZWx0YSA8IDAgPyBvdXRwdXRXaGl0ZSA6IG91dHB1dEJsYWNrO1xuICAgICAgfSBlbHNlIGlmIChwZXJjID49IG1heCkge1xuICAgICAgICBjb2xvclZhbHVlID0gaW5wdXREZWx0YSA8IDAgPyBvdXRwdXRCbGFjayA6IG91dHB1dFdoaXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sb3JWYWx1ZSA9IG91dHB1dEJsYWNrICsgb3V0cHV0RGVsdGEgKiBNYXRoLnBvdygocGVyYyAtIGlucHV0QmxhY2spIC8gaW5wdXREZWx0YSwgMSAvIGdhbW1hKTtcbiAgICAgIH1cblxuICAgICAgdGFibGVbcG9zXSA9IGNvbG9yVmFsdWU7XG4gICAgICBwb3MgKz0gMTtcbiAgICAgIGNudCArPSAyNTYgLyAoc2VnbWVudHMgLSAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFibGUuam9pbignICcpO1xuICB9O1xuXG4gIFNWR1Byb0xldmVsc0ZpbHRlci5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoZm9yY2VSZW5kZXIpIHtcbiAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLl9tZGYpIHtcbiAgICAgIHZhciB2YWw7XG4gICAgICB2YXIgZWZmZWN0RWxlbWVudHMgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHM7XG5cbiAgICAgIGlmICh0aGlzLmZlRnVuY1JDb21wb3NlZCAmJiAoZm9yY2VSZW5kZXIgfHwgZWZmZWN0RWxlbWVudHNbM10ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzRdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1s1XS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbNl0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzddLnAuX21kZikpIHtcbiAgICAgICAgdmFsID0gdGhpcy5nZXRUYWJsZVZhbHVlKGVmZmVjdEVsZW1lbnRzWzNdLnAudiwgZWZmZWN0RWxlbWVudHNbNF0ucC52LCBlZmZlY3RFbGVtZW50c1s1XS5wLnYsIGVmZmVjdEVsZW1lbnRzWzZdLnAudiwgZWZmZWN0RWxlbWVudHNbN10ucC52KTtcbiAgICAgICAgdGhpcy5mZUZ1bmNSQ29tcG9zZWQuc2V0QXR0cmlidXRlKCd0YWJsZVZhbHVlcycsIHZhbCk7XG4gICAgICAgIHRoaXMuZmVGdW5jR0NvbXBvc2VkLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB2YWwpO1xuICAgICAgICB0aGlzLmZlRnVuY0JDb21wb3NlZC5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZmVGdW5jUiAmJiAoZm9yY2VSZW5kZXIgfHwgZWZmZWN0RWxlbWVudHNbMTBdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1sxMV0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzEyXS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMTNdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1sxNF0ucC5fbWRmKSkge1xuICAgICAgICB2YWwgPSB0aGlzLmdldFRhYmxlVmFsdWUoZWZmZWN0RWxlbWVudHNbMTBdLnAudiwgZWZmZWN0RWxlbWVudHNbMTFdLnAudiwgZWZmZWN0RWxlbWVudHNbMTJdLnAudiwgZWZmZWN0RWxlbWVudHNbMTNdLnAudiwgZWZmZWN0RWxlbWVudHNbMTRdLnAudik7XG4gICAgICAgIHRoaXMuZmVGdW5jUi5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZmVGdW5jRyAmJiAoZm9yY2VSZW5kZXIgfHwgZWZmZWN0RWxlbWVudHNbMTddLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1sxOF0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzE5XS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMjBdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1syMV0ucC5fbWRmKSkge1xuICAgICAgICB2YWwgPSB0aGlzLmdldFRhYmxlVmFsdWUoZWZmZWN0RWxlbWVudHNbMTddLnAudiwgZWZmZWN0RWxlbWVudHNbMThdLnAudiwgZWZmZWN0RWxlbWVudHNbMTldLnAudiwgZWZmZWN0RWxlbWVudHNbMjBdLnAudiwgZWZmZWN0RWxlbWVudHNbMjFdLnAudik7XG4gICAgICAgIHRoaXMuZmVGdW5jRy5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZmVGdW5jQiAmJiAoZm9yY2VSZW5kZXIgfHwgZWZmZWN0RWxlbWVudHNbMjRdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1syNV0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzI2XS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMjddLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1syOF0ucC5fbWRmKSkge1xuICAgICAgICB2YWwgPSB0aGlzLmdldFRhYmxlVmFsdWUoZWZmZWN0RWxlbWVudHNbMjRdLnAudiwgZWZmZWN0RWxlbWVudHNbMjVdLnAudiwgZWZmZWN0RWxlbWVudHNbMjZdLnAudiwgZWZmZWN0RWxlbWVudHNbMjddLnAudiwgZWZmZWN0RWxlbWVudHNbMjhdLnAudik7XG4gICAgICAgIHRoaXMuZmVGdW5jQi5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZmVGdW5jQSAmJiAoZm9yY2VSZW5kZXIgfHwgZWZmZWN0RWxlbWVudHNbMzFdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1szMl0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzMzXS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMzRdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1szNV0ucC5fbWRmKSkge1xuICAgICAgICB2YWwgPSB0aGlzLmdldFRhYmxlVmFsdWUoZWZmZWN0RWxlbWVudHNbMzFdLnAudiwgZWZmZWN0RWxlbWVudHNbMzJdLnAudiwgZWZmZWN0RWxlbWVudHNbMzNdLnAudiwgZWZmZWN0RWxlbWVudHNbMzRdLnAudiwgZWZmZWN0RWxlbWVudHNbMzVdLnAudik7XG4gICAgICAgIHRoaXMuZmVGdW5jQS5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gU1ZHRHJvcFNoYWRvd0VmZmVjdChmaWx0ZXIsIGZpbHRlck1hbmFnZXIsIGVsZW0sIGlkLCBzb3VyY2UpIHtcbiAgICB2YXIgZ2xvYmFsRmlsdGVyU2l6ZSA9IGZpbHRlck1hbmFnZXIuY29udGFpbmVyLmdsb2JhbERhdGEucmVuZGVyQ29uZmlnLmZpbHRlclNpemU7XG4gICAgdmFyIGZpbHRlclNpemUgPSBmaWx0ZXJNYW5hZ2VyLmRhdGEuZnMgfHwgZ2xvYmFsRmlsdGVyU2l6ZTtcbiAgICBmaWx0ZXIuc2V0QXR0cmlidXRlKCd4JywgZmlsdGVyU2l6ZS54IHx8IGdsb2JhbEZpbHRlclNpemUueCk7XG4gICAgZmlsdGVyLnNldEF0dHJpYnV0ZSgneScsIGZpbHRlclNpemUueSB8fCBnbG9iYWxGaWx0ZXJTaXplLnkpO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgZmlsdGVyU2l6ZS53aWR0aCB8fCBnbG9iYWxGaWx0ZXJTaXplLndpZHRoKTtcbiAgICBmaWx0ZXIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBmaWx0ZXJTaXplLmhlaWdodCB8fCBnbG9iYWxGaWx0ZXJTaXplLmhlaWdodCk7XG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gZmlsdGVyTWFuYWdlcjtcbiAgICB2YXIgZmVHYXVzc2lhbkJsdXIgPSBjcmVhdGVOUygnZmVHYXVzc2lhbkJsdXInKTtcbiAgICBmZUdhdXNzaWFuQmx1ci5zZXRBdHRyaWJ1dGUoJ2luJywgJ1NvdXJjZUFscGhhJyk7XG4gICAgZmVHYXVzc2lhbkJsdXIuc2V0QXR0cmlidXRlKCdyZXN1bHQnLCBpZCArICdfZHJvcF9zaGFkb3dfMScpO1xuICAgIGZlR2F1c3NpYW5CbHVyLnNldEF0dHJpYnV0ZSgnc3RkRGV2aWF0aW9uJywgJzAnKTtcbiAgICB0aGlzLmZlR2F1c3NpYW5CbHVyID0gZmVHYXVzc2lhbkJsdXI7XG4gICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlR2F1c3NpYW5CbHVyKTtcbiAgICB2YXIgZmVPZmZzZXQgPSBjcmVhdGVOUygnZmVPZmZzZXQnKTtcbiAgICBmZU9mZnNldC5zZXRBdHRyaWJ1dGUoJ2R4JywgJzI1Jyk7XG4gICAgZmVPZmZzZXQuc2V0QXR0cmlidXRlKCdkeScsICcwJyk7XG4gICAgZmVPZmZzZXQuc2V0QXR0cmlidXRlKCdpbicsIGlkICsgJ19kcm9wX3NoYWRvd18xJyk7XG4gICAgZmVPZmZzZXQuc2V0QXR0cmlidXRlKCdyZXN1bHQnLCBpZCArICdfZHJvcF9zaGFkb3dfMicpO1xuICAgIHRoaXMuZmVPZmZzZXQgPSBmZU9mZnNldDtcbiAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVPZmZzZXQpO1xuICAgIHZhciBmZUZsb29kID0gY3JlYXRlTlMoJ2ZlRmxvb2QnKTtcbiAgICBmZUZsb29kLnNldEF0dHJpYnV0ZSgnZmxvb2QtY29sb3InLCAnIzAwZmYwMCcpO1xuICAgIGZlRmxvb2Quc2V0QXR0cmlidXRlKCdmbG9vZC1vcGFjaXR5JywgJzEnKTtcbiAgICBmZUZsb29kLnNldEF0dHJpYnV0ZSgncmVzdWx0JywgaWQgKyAnX2Ryb3Bfc2hhZG93XzMnKTtcbiAgICB0aGlzLmZlRmxvb2QgPSBmZUZsb29kO1xuICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZUZsb29kKTtcbiAgICB2YXIgZmVDb21wb3NpdGUgPSBjcmVhdGVOUygnZmVDb21wb3NpdGUnKTtcbiAgICBmZUNvbXBvc2l0ZS5zZXRBdHRyaWJ1dGUoJ2luJywgaWQgKyAnX2Ryb3Bfc2hhZG93XzMnKTtcbiAgICBmZUNvbXBvc2l0ZS5zZXRBdHRyaWJ1dGUoJ2luMicsIGlkICsgJ19kcm9wX3NoYWRvd18yJyk7XG4gICAgZmVDb21wb3NpdGUuc2V0QXR0cmlidXRlKCdvcGVyYXRvcicsICdpbicpO1xuICAgIGZlQ29tcG9zaXRlLnNldEF0dHJpYnV0ZSgncmVzdWx0JywgaWQgKyAnX2Ryb3Bfc2hhZG93XzQnKTtcbiAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVDb21wb3NpdGUpO1xuICAgIHZhciBmZU1lcmdlID0gdGhpcy5jcmVhdGVNZXJnZU5vZGUoaWQsIFtpZCArICdfZHJvcF9zaGFkb3dfNCcsIHNvdXJjZV0pO1xuICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZU1lcmdlKTsgLy9cbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbU1ZHQ29tcG9zYWJsZUVmZmVjdF0sIFNWR0Ryb3BTaGFkb3dFZmZlY3QpO1xuXG4gIFNWR0Ryb3BTaGFkb3dFZmZlY3QucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKGZvcmNlUmVuZGVyKSB7XG4gICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5fbWRmKSB7XG4gICAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzRdLnAuX21kZikge1xuICAgICAgICB0aGlzLmZlR2F1c3NpYW5CbHVyLnNldEF0dHJpYnV0ZSgnc3RkRGV2aWF0aW9uJywgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzRdLnAudiAvIDQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzBdLnAuX21kZikge1xuICAgICAgICB2YXIgY29sID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzBdLnAudjtcbiAgICAgICAgdGhpcy5mZUZsb29kLnNldEF0dHJpYnV0ZSgnZmxvb2QtY29sb3InLCByZ2JUb0hleChNYXRoLnJvdW5kKGNvbFswXSAqIDI1NSksIE1hdGgucm91bmQoY29sWzFdICogMjU1KSwgTWF0aC5yb3VuZChjb2xbMl0gKiAyNTUpKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMV0ucC5fbWRmKSB7XG4gICAgICAgIHRoaXMuZmVGbG9vZC5zZXRBdHRyaWJ1dGUoJ2Zsb29kLW9wYWNpdHknLCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMV0ucC52IC8gMjU1KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1syXS5wLl9tZGYgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzNdLnAuX21kZikge1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbM10ucC52O1xuICAgICAgICB2YXIgYW5nbGUgPSAodGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzJdLnAudiAtIDkwKSAqIGRlZ1RvUmFkcztcbiAgICAgICAgdmFyIHggPSBkaXN0YW5jZSAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgdmFyIHkgPSBkaXN0YW5jZSAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgdGhpcy5mZU9mZnNldC5zZXRBdHRyaWJ1dGUoJ2R4JywgeCk7XG4gICAgICAgIHRoaXMuZmVPZmZzZXQuc2V0QXR0cmlidXRlKCdkeScsIHkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgX3N2Z01hdHRlU3ltYm9scyA9IFtdO1xuXG4gIGZ1bmN0aW9uIFNWR01hdHRlM0VmZmVjdChmaWx0ZXJFbGVtLCBmaWx0ZXJNYW5hZ2VyLCBlbGVtKSB7XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuZmlsdGVyTWFuYWdlciA9IGZpbHRlck1hbmFnZXI7XG4gICAgdGhpcy5maWx0ZXJFbGVtID0gZmlsdGVyRWxlbTtcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgIGVsZW0ubWF0dGVFbGVtZW50ID0gY3JlYXRlTlMoJ2cnKTtcbiAgICBlbGVtLm1hdHRlRWxlbWVudC5hcHBlbmRDaGlsZChlbGVtLmxheWVyRWxlbWVudCk7XG4gICAgZWxlbS5tYXR0ZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbS50cmFuc2Zvcm1lZEVsZW1lbnQpO1xuICAgIGVsZW0uYmFzZUVsZW1lbnQgPSBlbGVtLm1hdHRlRWxlbWVudDtcbiAgfVxuXG4gIFNWR01hdHRlM0VmZmVjdC5wcm90b3R5cGUuZmluZFN5bWJvbCA9IGZ1bmN0aW9uIChtYXNrKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBfc3ZnTWF0dGVTeW1ib2xzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAoX3N2Z01hdHRlU3ltYm9sc1tpXSA9PT0gbWFzaykge1xuICAgICAgICByZXR1cm4gX3N2Z01hdHRlU3ltYm9sc1tpXTtcbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIFNWR01hdHRlM0VmZmVjdC5wcm90b3R5cGUucmVwbGFjZUluUGFyZW50ID0gZnVuY3Rpb24gKG1hc2ssIHN5bWJvbElkKSB7XG4gICAgdmFyIHBhcmVudE5vZGUgPSBtYXNrLmxheWVyRWxlbWVudC5wYXJlbnROb2RlO1xuXG4gICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gcGFyZW50Tm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAoY2hpbGRyZW5baV0gPT09IG1hc2subGF5ZXJFbGVtZW50KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpICs9IDE7XG4gICAgfVxuXG4gICAgdmFyIG5leHRDaGlsZDtcblxuICAgIGlmIChpIDw9IGxlbiAtIDIpIHtcbiAgICAgIG5leHRDaGlsZCA9IGNoaWxkcmVuW2kgKyAxXTtcbiAgICB9XG5cbiAgICB2YXIgdXNlRWxlbSA9IGNyZWF0ZU5TKCd1c2UnKTtcbiAgICB1c2VFbGVtLnNldEF0dHJpYnV0ZSgnaHJlZicsICcjJyArIHN5bWJvbElkKTtcblxuICAgIGlmIChuZXh0Q2hpbGQpIHtcbiAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHVzZUVsZW0sIG5leHRDaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodXNlRWxlbSk7XG4gICAgfVxuICB9O1xuXG4gIFNWR01hdHRlM0VmZmVjdC5wcm90b3R5cGUuc2V0RWxlbWVudEFzTWFzayA9IGZ1bmN0aW9uIChlbGVtLCBtYXNrKSB7XG4gICAgaWYgKCF0aGlzLmZpbmRTeW1ib2wobWFzaykpIHtcbiAgICAgIHZhciBzeW1ib2xJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xuICAgICAgdmFyIG1hc2tlciA9IGNyZWF0ZU5TKCdtYXNrJyk7XG4gICAgICBtYXNrZXIuc2V0QXR0cmlidXRlKCdpZCcsIG1hc2subGF5ZXJJZCk7XG4gICAgICBtYXNrZXIuc2V0QXR0cmlidXRlKCdtYXNrLXR5cGUnLCAnYWxwaGEnKTtcblxuICAgICAgX3N2Z01hdHRlU3ltYm9scy5wdXNoKG1hc2spO1xuXG4gICAgICB2YXIgZGVmcyA9IGVsZW0uZ2xvYmFsRGF0YS5kZWZzO1xuICAgICAgZGVmcy5hcHBlbmRDaGlsZChtYXNrZXIpO1xuICAgICAgdmFyIHN5bWJvbCA9IGNyZWF0ZU5TKCdzeW1ib2wnKTtcbiAgICAgIHN5bWJvbC5zZXRBdHRyaWJ1dGUoJ2lkJywgc3ltYm9sSWQpO1xuICAgICAgdGhpcy5yZXBsYWNlSW5QYXJlbnQobWFzaywgc3ltYm9sSWQpO1xuICAgICAgc3ltYm9sLmFwcGVuZENoaWxkKG1hc2subGF5ZXJFbGVtZW50KTtcbiAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoc3ltYm9sKTtcbiAgICAgIHZhciB1c2VFbGVtID0gY3JlYXRlTlMoJ3VzZScpO1xuICAgICAgdXNlRWxlbS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnIycgKyBzeW1ib2xJZCk7XG4gICAgICBtYXNrZXIuYXBwZW5kQ2hpbGQodXNlRWxlbSk7XG4gICAgICBtYXNrLmRhdGEuaGQgPSBmYWxzZTtcbiAgICAgIG1hc2suc2hvdygpO1xuICAgIH1cblxuICAgIGVsZW0uc2V0TWF0dGUobWFzay5sYXllcklkKTtcbiAgfTtcblxuICBTVkdNYXR0ZTNFZmZlY3QucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluZCA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1swXS5wLnY7XG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtLmNvbXAuZWxlbWVudHM7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBlbGVtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgaWYgKGVsZW1lbnRzW2ldICYmIGVsZW1lbnRzW2ldLmRhdGEuaW5kID09PSBpbmQpIHtcbiAgICAgICAgdGhpcy5zZXRFbGVtZW50QXNNYXNrKHRoaXMuZWxlbSwgZWxlbWVudHNbaV0pO1xuICAgICAgfVxuXG4gICAgICBpICs9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gIH07XG5cbiAgU1ZHTWF0dGUzRWZmZWN0LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBTVkdHYXVzc2lhbkJsdXJFZmZlY3QoZmlsdGVyLCBmaWx0ZXJNYW5hZ2VyLCBlbGVtLCBpZCkge1xuICAgIC8vIE91dHNldCB0aGUgZmlsdGVyIHJlZ2lvbiBieSAxMDAlIG9uIGFsbCBzaWRlcyB0byBhY2NvbW1vZGF0ZSBibHVyIGV4cGFuc2lvbi5cbiAgICBmaWx0ZXIuc2V0QXR0cmlidXRlKCd4JywgJy0xMDAlJyk7XG4gICAgZmlsdGVyLnNldEF0dHJpYnV0ZSgneScsICctMTAwJScpO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzMwMCUnKTtcbiAgICBmaWx0ZXIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnMzAwJScpO1xuICAgIHRoaXMuZmlsdGVyTWFuYWdlciA9IGZpbHRlck1hbmFnZXI7XG4gICAgdmFyIGZlR2F1c3NpYW5CbHVyID0gY3JlYXRlTlMoJ2ZlR2F1c3NpYW5CbHVyJyk7XG4gICAgZmVHYXVzc2lhbkJsdXIuc2V0QXR0cmlidXRlKCdyZXN1bHQnLCBpZCk7XG4gICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlR2F1c3NpYW5CbHVyKTtcbiAgICB0aGlzLmZlR2F1c3NpYW5CbHVyID0gZmVHYXVzc2lhbkJsdXI7XG4gIH1cblxuICBTVkdHYXVzc2lhbkJsdXJFZmZlY3QucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKGZvcmNlUmVuZGVyKSB7XG4gICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5fbWRmKSB7XG4gICAgICAvLyBFbXBpcmljYWwgdmFsdWUsIG1hdGNoaW5nIEFFJ3MgYmx1ciBhcHBlYXJhbmNlLlxuICAgICAgdmFyIGtCbHVycmluZXNzVG9TaWdtYSA9IDAuMztcbiAgICAgIHZhciBzaWdtYSA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1swXS5wLnYgKiBrQmx1cnJpbmVzc1RvU2lnbWE7IC8vIERpbWVuc2lvbnMgbWFwcGluZzpcbiAgICAgIC8vXG4gICAgICAvLyAgIDEgLT4gaG9yaXpvbnRhbCAmIHZlcnRpY2FsXG4gICAgICAvLyAgIDIgLT4gaG9yaXpvbnRhbCBvbmx5XG4gICAgICAvLyAgIDMgLT4gdmVydGljYWwgb25seVxuICAgICAgLy9cblxuICAgICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMV0ucC52O1xuICAgICAgdmFyIHNpZ21hWCA9IGRpbWVuc2lvbnMgPT0gMyA/IDAgOiBzaWdtYTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcblxuICAgICAgdmFyIHNpZ21hWSA9IGRpbWVuc2lvbnMgPT0gMiA/IDAgOiBzaWdtYTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcblxuICAgICAgdGhpcy5mZUdhdXNzaWFuQmx1ci5zZXRBdHRyaWJ1dGUoJ3N0ZERldmlhdGlvbicsIHNpZ21hWCArICcgJyArIHNpZ21hWSk7IC8vIFJlcGVhdCBlZGdlcyBtYXBwaW5nOlxuICAgICAgLy9cbiAgICAgIC8vICAgMCAtPiBvZmYgLT4gZHVwbGljYXRlXG4gICAgICAvLyAgIDEgLT4gb24gIC0+IHdyYXBcblxuICAgICAgdmFyIGVkZ2VNb2RlID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzJdLnAudiA9PSAxID8gJ3dyYXAnIDogJ2R1cGxpY2F0ZSc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG5cbiAgICAgIHRoaXMuZmVHYXVzc2lhbkJsdXIuc2V0QXR0cmlidXRlKCdlZGdlTW9kZScsIGVkZ2VNb2RlKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gVHJhbnNmb3JtRWZmZWN0KCkge31cblxuICBUcmFuc2Zvcm1FZmZlY3QucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZWZmZWN0c01hbmFnZXIpIHtcbiAgICB0aGlzLmVmZmVjdHNNYW5hZ2VyID0gZWZmZWN0c01hbmFnZXI7XG4gICAgdGhpcy50eXBlID0gZWZmZWN0VHlwZXMuVFJBTlNGT1JNX0VGRkVDVDtcbiAgICB0aGlzLm1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLm9wYWNpdHkgPSAtMTtcbiAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICB0aGlzLl9vcE1kZiA9IGZhbHNlO1xuICB9O1xuXG4gIFRyYW5zZm9ybUVmZmVjdC5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoZm9yY2VGcmFtZSkge1xuICAgIHRoaXMuX29wTWRmID0gZmFsc2U7XG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XG5cbiAgICBpZiAoZm9yY2VGcmFtZSB8fCB0aGlzLmVmZmVjdHNNYW5hZ2VyLl9tZGYpIHtcbiAgICAgIHZhciBlZmZlY3RFbGVtZW50cyA9IHRoaXMuZWZmZWN0c01hbmFnZXIuZWZmZWN0RWxlbWVudHM7XG4gICAgICB2YXIgYW5jaG9yID0gZWZmZWN0RWxlbWVudHNbMF0ucC52O1xuICAgICAgdmFyIHBvc2l0aW9uID0gZWZmZWN0RWxlbWVudHNbMV0ucC52O1xuICAgICAgdmFyIGlzVW5pZm9ybVNjYWxlID0gZWZmZWN0RWxlbWVudHNbMl0ucC52ID09PSAxO1xuICAgICAgdmFyIHNjYWxlSGVpZ2h0ID0gZWZmZWN0RWxlbWVudHNbM10ucC52O1xuICAgICAgdmFyIHNjYWxlV2lkdGggPSBpc1VuaWZvcm1TY2FsZSA/IHNjYWxlSGVpZ2h0IDogZWZmZWN0RWxlbWVudHNbNF0ucC52O1xuICAgICAgdmFyIHNrZXcgPSBlZmZlY3RFbGVtZW50c1s1XS5wLnY7XG4gICAgICB2YXIgc2tld0F4aXMgPSBlZmZlY3RFbGVtZW50c1s2XS5wLnY7XG4gICAgICB2YXIgcm90YXRpb24gPSBlZmZlY3RFbGVtZW50c1s3XS5wLnY7XG4gICAgICB0aGlzLm1hdHJpeC5yZXNldCgpO1xuICAgICAgdGhpcy5tYXRyaXgudHJhbnNsYXRlKC1hbmNob3JbMF0sIC1hbmNob3JbMV0sIGFuY2hvclsyXSk7XG4gICAgICB0aGlzLm1hdHJpeC5zY2FsZShzY2FsZVdpZHRoICogMC4wMSwgc2NhbGVIZWlnaHQgKiAwLjAxLCAxKTtcbiAgICAgIHRoaXMubWF0cml4LnJvdGF0ZSgtcm90YXRpb24gKiBkZWdUb1JhZHMpO1xuICAgICAgdGhpcy5tYXRyaXguc2tld0Zyb21BeGlzKC1za2V3ICogZGVnVG9SYWRzLCAoc2tld0F4aXMgKyA5MCkgKiBkZWdUb1JhZHMpO1xuICAgICAgdGhpcy5tYXRyaXgudHJhbnNsYXRlKHBvc2l0aW9uWzBdLCBwb3NpdGlvblsxXSwgMCk7XG4gICAgICB0aGlzLl9tZGYgPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5vcGFjaXR5ICE9PSBlZmZlY3RFbGVtZW50c1s4XS5wLnYpIHtcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gZWZmZWN0RWxlbWVudHNbOF0ucC52O1xuICAgICAgICB0aGlzLl9vcE1kZiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIFNWR1RyYW5zZm9ybUVmZmVjdChfLCBmaWx0ZXJNYW5hZ2VyKSB7XG4gICAgdGhpcy5pbml0KGZpbHRlck1hbmFnZXIpO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtUcmFuc2Zvcm1FZmZlY3RdLCBTVkdUcmFuc2Zvcm1FZmZlY3QpO1xuXG4gIGZ1bmN0aW9uIENWVHJhbnNmb3JtRWZmZWN0KGVmZmVjdHNNYW5hZ2VyKSB7XG4gICAgdGhpcy5pbml0KGVmZmVjdHNNYW5hZ2VyKTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbVHJhbnNmb3JtRWZmZWN0XSwgQ1ZUcmFuc2Zvcm1FZmZlY3QpO1xuXG4gIHJlZ2lzdGVyUmVuZGVyZXIoJ2NhbnZhcycsIENhbnZhc1JlbmRlcmVyKTtcbiAgcmVnaXN0ZXJSZW5kZXJlcignaHRtbCcsIEh5YnJpZFJlbmRlcmVyKTtcbiAgcmVnaXN0ZXJSZW5kZXJlcignc3ZnJywgU1ZHUmVuZGVyZXIpOyAvLyBSZWdpc3RlcmluZyBzaGFwZSBtb2RpZmllcnNcblxuICBTaGFwZU1vZGlmaWVycy5yZWdpc3Rlck1vZGlmaWVyKCd0bScsIFRyaW1Nb2RpZmllcik7XG4gIFNoYXBlTW9kaWZpZXJzLnJlZ2lzdGVyTW9kaWZpZXIoJ3BiJywgUHVja2VyQW5kQmxvYXRNb2RpZmllcik7XG4gIFNoYXBlTW9kaWZpZXJzLnJlZ2lzdGVyTW9kaWZpZXIoJ3JwJywgUmVwZWF0ZXJNb2RpZmllcik7XG4gIFNoYXBlTW9kaWZpZXJzLnJlZ2lzdGVyTW9kaWZpZXIoJ3JkJywgUm91bmRDb3JuZXJzTW9kaWZpZXIpO1xuICBTaGFwZU1vZGlmaWVycy5yZWdpc3Rlck1vZGlmaWVyKCd6eicsIFppZ1phZ01vZGlmaWVyKTtcbiAgU2hhcGVNb2RpZmllcnMucmVnaXN0ZXJNb2RpZmllcignb3AnLCBPZmZzZXRQYXRoTW9kaWZpZXIpOyAvLyBSZWdpc3RlcmluZyBleHByZXNzaW9uIHBsdWdpblxuXG4gIHNldEV4cHJlc3Npb25zUGx1Z2luKEV4cHJlc3Npb25zKTtcbiAgc2V0RXhwcmVzc2lvbkludGVyZmFjZXMoZ2V0SW50ZXJmYWNlKTtcbiAgaW5pdGlhbGl6ZSQxKCk7XG4gIGluaXRpYWxpemUoKTsgLy8gUmVnaXN0ZXJpbmcgc3ZnIGVmZmVjdHNcblxuICByZWdpc3RlckVmZmVjdCQxKDIwLCBTVkdUaW50RmlsdGVyLCB0cnVlKTtcbiAgcmVnaXN0ZXJFZmZlY3QkMSgyMSwgU1ZHRmlsbEZpbHRlciwgdHJ1ZSk7XG4gIHJlZ2lzdGVyRWZmZWN0JDEoMjIsIFNWR1N0cm9rZUVmZmVjdCwgZmFsc2UpO1xuICByZWdpc3RlckVmZmVjdCQxKDIzLCBTVkdUcml0b25lRmlsdGVyLCB0cnVlKTtcbiAgcmVnaXN0ZXJFZmZlY3QkMSgyNCwgU1ZHUHJvTGV2ZWxzRmlsdGVyLCB0cnVlKTtcbiAgcmVnaXN0ZXJFZmZlY3QkMSgyNSwgU1ZHRHJvcFNoYWRvd0VmZmVjdCwgdHJ1ZSk7XG4gIHJlZ2lzdGVyRWZmZWN0JDEoMjgsIFNWR01hdHRlM0VmZmVjdCwgZmFsc2UpO1xuICByZWdpc3RlckVmZmVjdCQxKDI5LCBTVkdHYXVzc2lhbkJsdXJFZmZlY3QsIHRydWUpO1xuICByZWdpc3RlckVmZmVjdCQxKDM1LCBTVkdUcmFuc2Zvcm1FZmZlY3QsIGZhbHNlKTtcbiAgcmVnaXN0ZXJFZmZlY3QoMzUsIENWVHJhbnNmb3JtRWZmZWN0KTtcblxuICByZXR1cm4gbG90dGllO1xuXG59KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lottie-web/build/player/lottie.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/image.js":
/*!*********************************************!*\
  !*** ./node_modules/next/dist/api/image.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* reexport default from dynamic */ _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0___default.a)\n/* harmony export */ });\n/* harmony import */ var _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/lib/image-external */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js\");\n/* harmony import */ var _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n//# sourceMappingURL=image.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2ltYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF1RDtBQUNWOztBQUU3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9pbWFnZS5qcz9jYjJhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuLi9zaGFyZWQvbGliL2ltYWdlLWV4dGVybmFsJztcbmV4cG9ydCAqIGZyb20gJy4uL3NoYXJlZC9saWIvaW1hZ2UtZXh0ZXJuYWwnO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/image.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/navigation.js":
/*!**************************************************!*\
  !*** ./node_modules/next/dist/api/navigation.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/components/navigation */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js\");\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n//# sourceMappingURL=navigation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdEOztBQUVoRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9uYXZpZ2F0aW9uLmpzP2I0YzAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi4vY2xpZW50L2NvbXBvbmVudHMvbmF2aWdhdGlvbic7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hdmlnYXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/picomatch/index.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/picomatch/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n(()=>{\"use strict\";var t={170:(t,e,u)=>{const n=u(510);const isWindows=()=>{if(typeof navigator!==\"undefined\"&&navigator.platform){const t=navigator.platform.toLowerCase();return t===\"win32\"||t===\"windows\"}if(typeof process!==\"undefined\"&&process.platform){return process.platform===\"win32\"}return false};function picomatch(t,e,u=false){if(e&&(e.windows===null||e.windows===undefined)){e={...e,windows:isWindows()}}return n(t,e,u)}Object.assign(picomatch,n);t.exports=picomatch},154:t=>{const e=\"\\\\\\\\/\";const u=`[^${e}]`;const n=\"\\\\.\";const o=\"\\\\+\";const s=\"\\\\?\";const r=\"\\\\/\";const a=\"(?=.)\";const i=\"[^/]\";const c=`(?:${r}|$)`;const p=`(?:^|${r})`;const l=`${n}{1,2}${c}`;const f=`(?!${n})`;const A=`(?!${p}${l})`;const _=`(?!${n}{0,1}${c})`;const R=`(?!${l})`;const E=`[^.${r}]`;const h=`${i}*?`;const g=\"/\";const b={DOT_LITERAL:n,PLUS_LITERAL:o,QMARK_LITERAL:s,SLASH_LITERAL:r,ONE_CHAR:a,QMARK:i,END_ANCHOR:c,DOTS_SLASH:l,NO_DOT:f,NO_DOTS:A,NO_DOT_SLASH:_,NO_DOTS_SLASH:R,QMARK_NO_DOT:E,STAR:h,START_ANCHOR:p,SEP:g};const C={...b,SLASH_LITERAL:`[${e}]`,QMARK:u,STAR:`${u}*?`,DOTS_SLASH:`${n}{1,2}(?:[${e}]|$)`,NO_DOT:`(?!${n})`,NO_DOTS:`(?!(?:^|[${e}])${n}{1,2}(?:[${e}]|$))`,NO_DOT_SLASH:`(?!${n}{0,1}(?:[${e}]|$))`,NO_DOTS_SLASH:`(?!${n}{1,2}(?:[${e}]|$))`,QMARK_NO_DOT:`[^.${e}]`,START_ANCHOR:`(?:^|[${e}])`,END_ANCHOR:`(?:[${e}]|$)`,SEP:\"\\\\\"};const y={alnum:\"a-zA-Z0-9\",alpha:\"a-zA-Z\",ascii:\"\\\\x00-\\\\x7F\",blank:\" \\\\t\",cntrl:\"\\\\x00-\\\\x1F\\\\x7F\",digit:\"0-9\",graph:\"\\\\x21-\\\\x7E\",lower:\"a-z\",print:\"\\\\x20-\\\\x7E \",punct:\"\\\\-!\\\"#$%&'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~\",space:\" \\\\t\\\\r\\\\n\\\\v\\\\f\",upper:\"A-Z\",word:\"A-Za-z0-9_\",xdigit:\"A-Fa-f0-9\"};t.exports={MAX_LENGTH:1024*64,POSIX_REGEX_SOURCE:y,REGEX_BACKSLASH:/\\\\(?![*+?^${}(|)[\\]])/g,REGEX_NON_SPECIAL_CHARS:/^[^@![\\].,$*+?^{}()|\\\\/]+/,REGEX_SPECIAL_CHARS:/[-*+?.^${}(|)[\\]]/,REGEX_SPECIAL_CHARS_BACKREF:/(\\\\?)((\\W)(\\3*))/g,REGEX_SPECIAL_CHARS_GLOBAL:/([-*+?.^${}(|)[\\]])/g,REGEX_REMOVE_BACKSLASH:/(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,REPLACEMENTS:{\"***\":\"*\",\"**/**\":\"**\",\"**/**/**\":\"**\"},CHAR_0:48,CHAR_9:57,CHAR_UPPERCASE_A:65,CHAR_LOWERCASE_A:97,CHAR_UPPERCASE_Z:90,CHAR_LOWERCASE_Z:122,CHAR_LEFT_PARENTHESES:40,CHAR_RIGHT_PARENTHESES:41,CHAR_ASTERISK:42,CHAR_AMPERSAND:38,CHAR_AT:64,CHAR_BACKWARD_SLASH:92,CHAR_CARRIAGE_RETURN:13,CHAR_CIRCUMFLEX_ACCENT:94,CHAR_COLON:58,CHAR_COMMA:44,CHAR_DOT:46,CHAR_DOUBLE_QUOTE:34,CHAR_EQUAL:61,CHAR_EXCLAMATION_MARK:33,CHAR_FORM_FEED:12,CHAR_FORWARD_SLASH:47,CHAR_GRAVE_ACCENT:96,CHAR_HASH:35,CHAR_HYPHEN_MINUS:45,CHAR_LEFT_ANGLE_BRACKET:60,CHAR_LEFT_CURLY_BRACE:123,CHAR_LEFT_SQUARE_BRACKET:91,CHAR_LINE_FEED:10,CHAR_NO_BREAK_SPACE:160,CHAR_PERCENT:37,CHAR_PLUS:43,CHAR_QUESTION_MARK:63,CHAR_RIGHT_ANGLE_BRACKET:62,CHAR_RIGHT_CURLY_BRACE:125,CHAR_RIGHT_SQUARE_BRACKET:93,CHAR_SEMICOLON:59,CHAR_SINGLE_QUOTE:39,CHAR_SPACE:32,CHAR_TAB:9,CHAR_UNDERSCORE:95,CHAR_VERTICAL_LINE:124,CHAR_ZERO_WIDTH_NOBREAK_SPACE:65279,extglobChars(t){return{\"!\":{type:\"negate\",open:\"(?:(?!(?:\",close:`))${t.STAR})`},\"?\":{type:\"qmark\",open:\"(?:\",close:\")?\"},\"+\":{type:\"plus\",open:\"(?:\",close:\")+\"},\"*\":{type:\"star\",open:\"(?:\",close:\")*\"},\"@\":{type:\"at\",open:\"(?:\",close:\")\"}}},globChars(t){return t===true?C:b}}},697:(t,e,u)=>{const n=u(154);const o=u(96);const{MAX_LENGTH:s,POSIX_REGEX_SOURCE:r,REGEX_NON_SPECIAL_CHARS:a,REGEX_SPECIAL_CHARS_BACKREF:i,REPLACEMENTS:c}=n;const expandRange=(t,e)=>{if(typeof e.expandRange===\"function\"){return e.expandRange(...t,e)}t.sort();const u=`[${t.join(\"-\")}]`;try{new RegExp(u)}catch(e){return t.map((t=>o.escapeRegex(t))).join(\"..\")}return u};const syntaxError=(t,e)=>`Missing ${t}: \"${e}\" - use \"\\\\\\\\${e}\" to match literal characters`;const parse=(t,e)=>{if(typeof t!==\"string\"){throw new TypeError(\"Expected a string\")}t=c[t]||t;const u={...e};const p=typeof u.maxLength===\"number\"?Math.min(s,u.maxLength):s;let l=t.length;if(l>p){throw new SyntaxError(`Input length: ${l}, exceeds maximum allowed length: ${p}`)}const f={type:\"bos\",value:\"\",output:u.prepend||\"\"};const A=[f];const _=u.capture?\"\":\"?:\";const R=n.globChars(u.windows);const E=n.extglobChars(R);const{DOT_LITERAL:h,PLUS_LITERAL:g,SLASH_LITERAL:b,ONE_CHAR:C,DOTS_SLASH:y,NO_DOT:$,NO_DOT_SLASH:x,NO_DOTS_SLASH:S,QMARK:H,QMARK_NO_DOT:v,STAR:d,START_ANCHOR:L}=R;const globstar=t=>`(${_}(?:(?!${L}${t.dot?y:h}).)*?)`;const T=u.dot?\"\":$;const O=u.dot?H:v;let k=u.bash===true?globstar(u):d;if(u.capture){k=`(${k})`}if(typeof u.noext===\"boolean\"){u.noextglob=u.noext}const m={input:t,index:-1,start:0,dot:u.dot===true,consumed:\"\",output:\"\",prefix:\"\",backtrack:false,negated:false,brackets:0,braces:0,parens:0,quotes:0,globstar:false,tokens:A};t=o.removePrefix(t,m);l=t.length;const w=[];const N=[];const I=[];let B=f;let G;const eos=()=>m.index===l-1;const D=m.peek=(e=1)=>t[m.index+e];const M=m.advance=()=>t[++m.index]||\"\";const remaining=()=>t.slice(m.index+1);const consume=(t=\"\",e=0)=>{m.consumed+=t;m.index+=e};const append=t=>{m.output+=t.output!=null?t.output:t.value;consume(t.value)};const negate=()=>{let t=1;while(D()===\"!\"&&(D(2)!==\"(\"||D(3)===\"?\")){M();m.start++;t++}if(t%2===0){return false}m.negated=true;m.start++;return true};const increment=t=>{m[t]++;I.push(t)};const decrement=t=>{m[t]--;I.pop()};const push=t=>{if(B.type===\"globstar\"){const e=m.braces>0&&(t.type===\"comma\"||t.type===\"brace\");const u=t.extglob===true||w.length&&(t.type===\"pipe\"||t.type===\"paren\");if(t.type!==\"slash\"&&t.type!==\"paren\"&&!e&&!u){m.output=m.output.slice(0,-B.output.length);B.type=\"star\";B.value=\"*\";B.output=k;m.output+=B.output}}if(w.length&&t.type!==\"paren\"){w[w.length-1].inner+=t.value}if(t.value||t.output)append(t);if(B&&B.type===\"text\"&&t.type===\"text\"){B.output=(B.output||B.value)+t.value;B.value+=t.value;return}t.prev=B;A.push(t);B=t};const extglobOpen=(t,e)=>{const n={...E[e],conditions:1,inner:\"\"};n.prev=B;n.parens=m.parens;n.output=m.output;const o=(u.capture?\"(\":\"\")+n.open;increment(\"parens\");push({type:t,value:e,output:m.output?\"\":C});push({type:\"paren\",extglob:true,value:M(),output:o});w.push(n)};const extglobClose=t=>{let n=t.close+(u.capture?\")\":\"\");let o;if(t.type===\"negate\"){let s=k;if(t.inner&&t.inner.length>1&&t.inner.includes(\"/\")){s=globstar(u)}if(s!==k||eos()||/^\\)+$/.test(remaining())){n=t.close=`)$))${s}`}if(t.inner.includes(\"*\")&&(o=remaining())&&/^\\.[^\\\\/.]+$/.test(o)){const u=parse(o,{...e,fastpaths:false}).output;n=t.close=`)${u})${s})`}if(t.prev.type===\"bos\"){m.negatedExtglob=true}}push({type:\"paren\",extglob:true,value:G,output:n});decrement(\"parens\")};if(u.fastpaths!==false&&!/(^[*!]|[/()[\\]{}\"])/.test(t)){let n=false;let s=t.replace(i,((t,e,u,o,s,r)=>{if(o===\"\\\\\"){n=true;return t}if(o===\"?\"){if(e){return e+o+(s?H.repeat(s.length):\"\")}if(r===0){return O+(s?H.repeat(s.length):\"\")}return H.repeat(u.length)}if(o===\".\"){return h.repeat(u.length)}if(o===\"*\"){if(e){return e+o+(s?k:\"\")}return k}return e?t:`\\\\${t}`}));if(n===true){if(u.unescape===true){s=s.replace(/\\\\/g,\"\")}else{s=s.replace(/\\\\+/g,(t=>t.length%2===0?\"\\\\\\\\\":t?\"\\\\\":\"\"))}}if(s===t&&u.contains===true){m.output=t;return m}m.output=o.wrapOutput(s,m,e);return m}while(!eos()){G=M();if(G===\"\\0\"){continue}if(G===\"\\\\\"){const t=D();if(t===\"/\"&&u.bash!==true){continue}if(t===\".\"||t===\";\"){continue}if(!t){G+=\"\\\\\";push({type:\"text\",value:G});continue}const e=/^\\\\+/.exec(remaining());let n=0;if(e&&e[0].length>2){n=e[0].length;m.index+=n;if(n%2!==0){G+=\"\\\\\"}}if(u.unescape===true){G=M()}else{G+=M()}if(m.brackets===0){push({type:\"text\",value:G});continue}}if(m.brackets>0&&(G!==\"]\"||B.value===\"[\"||B.value===\"[^\")){if(u.posix!==false&&G===\":\"){const t=B.value.slice(1);if(t.includes(\"[\")){B.posix=true;if(t.includes(\":\")){const t=B.value.lastIndexOf(\"[\");const e=B.value.slice(0,t);const u=B.value.slice(t+2);const n=r[u];if(n){B.value=e+n;m.backtrack=true;M();if(!f.output&&A.indexOf(B)===1){f.output=C}continue}}}}if(G===\"[\"&&D()!==\":\"||G===\"-\"&&D()===\"]\"){G=`\\\\${G}`}if(G===\"]\"&&(B.value===\"[\"||B.value===\"[^\")){G=`\\\\${G}`}if(u.posix===true&&G===\"!\"&&B.value===\"[\"){G=\"^\"}B.value+=G;append({value:G});continue}if(m.quotes===1&&G!=='\"'){G=o.escapeRegex(G);B.value+=G;append({value:G});continue}if(G==='\"'){m.quotes=m.quotes===1?0:1;if(u.keepQuotes===true){push({type:\"text\",value:G})}continue}if(G===\"(\"){increment(\"parens\");push({type:\"paren\",value:G});continue}if(G===\")\"){if(m.parens===0&&u.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"(\"))}const t=w[w.length-1];if(t&&m.parens===t.parens+1){extglobClose(w.pop());continue}push({type:\"paren\",value:G,output:m.parens?\")\":\"\\\\)\"});decrement(\"parens\");continue}if(G===\"[\"){if(u.nobracket===true||!remaining().includes(\"]\")){if(u.nobracket!==true&&u.strictBrackets===true){throw new SyntaxError(syntaxError(\"closing\",\"]\"))}G=`\\\\${G}`}else{increment(\"brackets\")}push({type:\"bracket\",value:G});continue}if(G===\"]\"){if(u.nobracket===true||B&&B.type===\"bracket\"&&B.value.length===1){push({type:\"text\",value:G,output:`\\\\${G}`});continue}if(m.brackets===0){if(u.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"[\"))}push({type:\"text\",value:G,output:`\\\\${G}`});continue}decrement(\"brackets\");const t=B.value.slice(1);if(B.posix!==true&&t[0]===\"^\"&&!t.includes(\"/\")){G=`/${G}`}B.value+=G;append({value:G});if(u.literalBrackets===false||o.hasRegexChars(t)){continue}const e=o.escapeRegex(B.value);m.output=m.output.slice(0,-B.value.length);if(u.literalBrackets===true){m.output+=e;B.value=e;continue}B.value=`(${_}${e}|${B.value})`;m.output+=B.value;continue}if(G===\"{\"&&u.nobrace!==true){increment(\"braces\");const t={type:\"brace\",value:G,output:\"(\",outputIndex:m.output.length,tokensIndex:m.tokens.length};N.push(t);push(t);continue}if(G===\"}\"){const t=N[N.length-1];if(u.nobrace===true||!t){push({type:\"text\",value:G,output:G});continue}let e=\")\";if(t.dots===true){const t=A.slice();const n=[];for(let e=t.length-1;e>=0;e--){A.pop();if(t[e].type===\"brace\"){break}if(t[e].type!==\"dots\"){n.unshift(t[e].value)}}e=expandRange(n,u);m.backtrack=true}if(t.comma!==true&&t.dots!==true){const u=m.output.slice(0,t.outputIndex);const n=m.tokens.slice(t.tokensIndex);t.value=t.output=\"\\\\{\";G=e=\"\\\\}\";m.output=u;for(const t of n){m.output+=t.output||t.value}}push({type:\"brace\",value:G,output:e});decrement(\"braces\");N.pop();continue}if(G===\"|\"){if(w.length>0){w[w.length-1].conditions++}push({type:\"text\",value:G});continue}if(G===\",\"){let t=G;const e=N[N.length-1];if(e&&I[I.length-1]===\"braces\"){e.comma=true;t=\"|\"}push({type:\"comma\",value:G,output:t});continue}if(G===\"/\"){if(B.type===\"dot\"&&m.index===m.start+1){m.start=m.index+1;m.consumed=\"\";m.output=\"\";A.pop();B=f;continue}push({type:\"slash\",value:G,output:b});continue}if(G===\".\"){if(m.braces>0&&B.type===\"dot\"){if(B.value===\".\")B.output=h;const t=N[N.length-1];B.type=\"dots\";B.output+=G;B.value+=G;t.dots=true;continue}if(m.braces+m.parens===0&&B.type!==\"bos\"&&B.type!==\"slash\"){push({type:\"text\",value:G,output:h});continue}push({type:\"dot\",value:G,output:h});continue}if(G===\"?\"){const t=B&&B.value===\"(\";if(!t&&u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){extglobOpen(\"qmark\",G);continue}if(B&&B.type===\"paren\"){const t=D();let e=G;if(B.value===\"(\"&&!/[!=<:]/.test(t)||t===\"<\"&&!/<([!=]|\\w+>)/.test(remaining())){e=`\\\\${G}`}push({type:\"text\",value:G,output:e});continue}if(u.dot!==true&&(B.type===\"slash\"||B.type===\"bos\")){push({type:\"qmark\",value:G,output:v});continue}push({type:\"qmark\",value:G,output:H});continue}if(G===\"!\"){if(u.noextglob!==true&&D()===\"(\"){if(D(2)!==\"?\"||!/[!=<:]/.test(D(3))){extglobOpen(\"negate\",G);continue}}if(u.nonegate!==true&&m.index===0){negate();continue}}if(G===\"+\"){if(u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){extglobOpen(\"plus\",G);continue}if(B&&B.value===\"(\"||u.regex===false){push({type:\"plus\",value:G,output:g});continue}if(B&&(B.type===\"bracket\"||B.type===\"paren\"||B.type===\"brace\")||m.parens>0){push({type:\"plus\",value:G});continue}push({type:\"plus\",value:g});continue}if(G===\"@\"){if(u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){push({type:\"at\",extglob:true,value:G,output:\"\"});continue}push({type:\"text\",value:G});continue}if(G!==\"*\"){if(G===\"$\"||G===\"^\"){G=`\\\\${G}`}const t=a.exec(remaining());if(t){G+=t[0];m.index+=t[0].length}push({type:\"text\",value:G});continue}if(B&&(B.type===\"globstar\"||B.star===true)){B.type=\"star\";B.star=true;B.value+=G;B.output=k;m.backtrack=true;m.globstar=true;consume(G);continue}let e=remaining();if(u.noextglob!==true&&/^\\([^?]/.test(e)){extglobOpen(\"star\",G);continue}if(B.type===\"star\"){if(u.noglobstar===true){consume(G);continue}const n=B.prev;const o=n.prev;const s=n.type===\"slash\"||n.type===\"bos\";const r=o&&(o.type===\"star\"||o.type===\"globstar\");if(u.bash===true&&(!s||e[0]&&e[0]!==\"/\")){push({type:\"star\",value:G,output:\"\"});continue}const a=m.braces>0&&(n.type===\"comma\"||n.type===\"brace\");const i=w.length&&(n.type===\"pipe\"||n.type===\"paren\");if(!s&&n.type!==\"paren\"&&!a&&!i){push({type:\"star\",value:G,output:\"\"});continue}while(e.slice(0,3)===\"/**\"){const u=t[m.index+4];if(u&&u!==\"/\"){break}e=e.slice(3);consume(\"/**\",3)}if(n.type===\"bos\"&&eos()){B.type=\"globstar\";B.value+=G;B.output=globstar(u);m.output=B.output;m.globstar=true;consume(G);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&!r&&eos()){m.output=m.output.slice(0,-(n.output+B.output).length);n.output=`(?:${n.output}`;B.type=\"globstar\";B.output=globstar(u)+(u.strictSlashes?\")\":\"|$)\");B.value+=G;m.globstar=true;m.output+=n.output+B.output;consume(G);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&e[0]===\"/\"){const t=e[1]!==void 0?\"|$\":\"\";m.output=m.output.slice(0,-(n.output+B.output).length);n.output=`(?:${n.output}`;B.type=\"globstar\";B.output=`${globstar(u)}${b}|${b}${t})`;B.value+=G;m.output+=n.output+B.output;m.globstar=true;consume(G+M());push({type:\"slash\",value:\"/\",output:\"\"});continue}if(n.type===\"bos\"&&e[0]===\"/\"){B.type=\"globstar\";B.value+=G;B.output=`(?:^|${b}|${globstar(u)}${b})`;m.output=B.output;m.globstar=true;consume(G+M());push({type:\"slash\",value:\"/\",output:\"\"});continue}m.output=m.output.slice(0,-B.output.length);B.type=\"globstar\";B.output=globstar(u);B.value+=G;m.output+=B.output;m.globstar=true;consume(G);continue}const n={type:\"star\",value:G,output:k};if(u.bash===true){n.output=\".*?\";if(B.type===\"bos\"||B.type===\"slash\"){n.output=T+n.output}push(n);continue}if(B&&(B.type===\"bracket\"||B.type===\"paren\")&&u.regex===true){n.output=G;push(n);continue}if(m.index===m.start||B.type===\"slash\"||B.type===\"dot\"){if(B.type===\"dot\"){m.output+=x;B.output+=x}else if(u.dot===true){m.output+=S;B.output+=S}else{m.output+=T;B.output+=T}if(D()!==\"*\"){m.output+=C;B.output+=C}}push(n)}while(m.brackets>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"]\"));m.output=o.escapeLast(m.output,\"[\");decrement(\"brackets\")}while(m.parens>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\")\"));m.output=o.escapeLast(m.output,\"(\");decrement(\"parens\")}while(m.braces>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"}\"));m.output=o.escapeLast(m.output,\"{\");decrement(\"braces\")}if(u.strictSlashes!==true&&(B.type===\"star\"||B.type===\"bracket\")){push({type:\"maybe_slash\",value:\"\",output:`${b}?`})}if(m.backtrack===true){m.output=\"\";for(const t of m.tokens){m.output+=t.output!=null?t.output:t.value;if(t.suffix){m.output+=t.suffix}}}return m};parse.fastpaths=(t,e)=>{const u={...e};const r=typeof u.maxLength===\"number\"?Math.min(s,u.maxLength):s;const a=t.length;if(a>r){throw new SyntaxError(`Input length: ${a}, exceeds maximum allowed length: ${r}`)}t=c[t]||t;const{DOT_LITERAL:i,SLASH_LITERAL:p,ONE_CHAR:l,DOTS_SLASH:f,NO_DOT:A,NO_DOTS:_,NO_DOTS_SLASH:R,STAR:E,START_ANCHOR:h}=n.globChars(u.windows);const g=u.dot?_:A;const b=u.dot?R:A;const C=u.capture?\"\":\"?:\";const y={negated:false,prefix:\"\"};let $=u.bash===true?\".*?\":E;if(u.capture){$=`(${$})`}const globstar=t=>{if(t.noglobstar===true)return $;return`(${C}(?:(?!${h}${t.dot?f:i}).)*?)`};const create=t=>{switch(t){case\"*\":return`${g}${l}${$}`;case\".*\":return`${i}${l}${$}`;case\"*.*\":return`${g}${$}${i}${l}${$}`;case\"*/*\":return`${g}${$}${p}${l}${b}${$}`;case\"**\":return g+globstar(u);case\"**/*\":return`(?:${g}${globstar(u)}${p})?${b}${l}${$}`;case\"**/*.*\":return`(?:${g}${globstar(u)}${p})?${b}${$}${i}${l}${$}`;case\"**/.*\":return`(?:${g}${globstar(u)}${p})?${i}${l}${$}`;default:{const e=/^(.*?)\\.(\\w+)$/.exec(t);if(!e)return;const u=create(e[1]);if(!u)return;return u+i+e[2]}}};const x=o.removePrefix(t,y);let S=create(x);if(S&&u.strictSlashes!==true){S+=`${p}?`}return S};t.exports=parse},510:(t,e,u)=>{const n=u(716);const o=u(697);const s=u(96);const r=u(154);const isObject=t=>t&&typeof t===\"object\"&&!Array.isArray(t);const picomatch=(t,e,u=false)=>{if(Array.isArray(t)){const n=t.map((t=>picomatch(t,e,u)));const arrayMatcher=t=>{for(const e of n){const u=e(t);if(u)return u}return false};return arrayMatcher}const n=isObject(t)&&t.tokens&&t.input;if(t===\"\"||typeof t!==\"string\"&&!n){throw new TypeError(\"Expected pattern to be a non-empty string\")}const o=e||{};const s=o.windows;const r=n?picomatch.compileRe(t,e):picomatch.makeRe(t,e,false,true);const a=r.state;delete r.state;let isIgnored=()=>false;if(o.ignore){const t={...e,ignore:null,onMatch:null,onResult:null};isIgnored=picomatch(o.ignore,t,u)}const matcher=(u,n=false)=>{const{isMatch:i,match:c,output:p}=picomatch.test(u,r,e,{glob:t,posix:s});const l={glob:t,state:a,regex:r,posix:s,input:u,output:p,match:c,isMatch:i};if(typeof o.onResult===\"function\"){o.onResult(l)}if(i===false){l.isMatch=false;return n?l:false}if(isIgnored(u)){if(typeof o.onIgnore===\"function\"){o.onIgnore(l)}l.isMatch=false;return n?l:false}if(typeof o.onMatch===\"function\"){o.onMatch(l)}return n?l:true};if(u){matcher.state=a}return matcher};picomatch.test=(t,e,u,{glob:n,posix:o}={})=>{if(typeof t!==\"string\"){throw new TypeError(\"Expected input to be a string\")}if(t===\"\"){return{isMatch:false,output:\"\"}}const r=u||{};const a=r.format||(o?s.toPosixSlashes:null);let i=t===n;let c=i&&a?a(t):t;if(i===false){c=a?a(t):t;i=c===n}if(i===false||r.capture===true){if(r.matchBase===true||r.basename===true){i=picomatch.matchBase(t,e,u,o)}else{i=e.exec(c)}}return{isMatch:Boolean(i),match:i,output:c}};picomatch.matchBase=(t,e,u)=>{const n=e instanceof RegExp?e:picomatch.makeRe(e,u);return n.test(s.basename(t))};picomatch.isMatch=(t,e,u)=>picomatch(e,u)(t);picomatch.parse=(t,e)=>{if(Array.isArray(t))return t.map((t=>picomatch.parse(t,e)));return o(t,{...e,fastpaths:false})};picomatch.scan=(t,e)=>n(t,e);picomatch.compileRe=(t,e,u=false,n=false)=>{if(u===true){return t.output}const o=e||{};const s=o.contains?\"\":\"^\";const r=o.contains?\"\":\"$\";let a=`${s}(?:${t.output})${r}`;if(t&&t.negated===true){a=`^(?!${a}).*$`}const i=picomatch.toRegex(a,e);if(n===true){i.state=t}return i};picomatch.makeRe=(t,e={},u=false,n=false)=>{if(!t||typeof t!==\"string\"){throw new TypeError(\"Expected a non-empty string\")}let s={negated:false,fastpaths:true};if(e.fastpaths!==false&&(t[0]===\".\"||t[0]===\"*\")){s.output=o.fastpaths(t,e)}if(!s.output){s=o(t,e)}return picomatch.compileRe(s,e,u,n)};picomatch.toRegex=(t,e)=>{try{const u=e||{};return new RegExp(t,u.flags||(u.nocase?\"i\":\"\"))}catch(t){if(e&&e.debug===true)throw t;return/$^/}};picomatch.constants=r;t.exports=picomatch},716:(t,e,u)=>{const n=u(96);const{CHAR_ASTERISK:o,CHAR_AT:s,CHAR_BACKWARD_SLASH:r,CHAR_COMMA:a,CHAR_DOT:i,CHAR_EXCLAMATION_MARK:c,CHAR_FORWARD_SLASH:p,CHAR_LEFT_CURLY_BRACE:l,CHAR_LEFT_PARENTHESES:f,CHAR_LEFT_SQUARE_BRACKET:A,CHAR_PLUS:_,CHAR_QUESTION_MARK:R,CHAR_RIGHT_CURLY_BRACE:E,CHAR_RIGHT_PARENTHESES:h,CHAR_RIGHT_SQUARE_BRACKET:g}=u(154);const isPathSeparator=t=>t===p||t===r;const depth=t=>{if(t.isPrefix!==true){t.depth=t.isGlobstar?Infinity:1}};const scan=(t,e)=>{const u=e||{};const b=t.length-1;const C=u.parts===true||u.scanToEnd===true;const y=[];const $=[];const x=[];let S=t;let H=-1;let v=0;let d=0;let L=false;let T=false;let O=false;let k=false;let m=false;let w=false;let N=false;let I=false;let B=false;let G=false;let D=0;let M;let P;let K={value:\"\",depth:0,isGlob:false};const eos=()=>H>=b;const peek=()=>S.charCodeAt(H+1);const advance=()=>{M=P;return S.charCodeAt(++H)};while(H<b){P=advance();let t;if(P===r){N=K.backslashes=true;P=advance();if(P===l){w=true}continue}if(w===true||P===l){D++;while(eos()!==true&&(P=advance())){if(P===r){N=K.backslashes=true;advance();continue}if(P===l){D++;continue}if(w!==true&&P===i&&(P=advance())===i){L=K.isBrace=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(w!==true&&P===a){L=K.isBrace=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===E){D--;if(D===0){w=false;L=K.isBrace=true;G=true;break}}}if(C===true){continue}break}if(P===p){y.push(H);$.push(K);K={value:\"\",depth:0,isGlob:false};if(G===true)continue;if(M===i&&H===v+1){v+=2;continue}d=H+1;continue}if(u.noext!==true){const t=P===_||P===s||P===o||P===R||P===c;if(t===true&&peek()===f){O=K.isGlob=true;k=K.isExtglob=true;G=true;if(P===c&&H===v){B=true}if(C===true){while(eos()!==true&&(P=advance())){if(P===r){N=K.backslashes=true;P=advance();continue}if(P===h){O=K.isGlob=true;G=true;break}}continue}break}}if(P===o){if(M===o)m=K.isGlobstar=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===R){O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===A){while(eos()!==true&&(t=advance())){if(t===r){N=K.backslashes=true;advance();continue}if(t===g){T=K.isBracket=true;O=K.isGlob=true;G=true;break}}if(C===true){continue}break}if(u.nonegate!==true&&P===c&&H===v){I=K.negated=true;v++;continue}if(u.noparen!==true&&P===f){O=K.isGlob=true;if(C===true){while(eos()!==true&&(P=advance())){if(P===f){N=K.backslashes=true;P=advance();continue}if(P===h){G=true;break}}continue}break}if(O===true){G=true;if(C===true){continue}break}}if(u.noext===true){k=false;O=false}let U=S;let X=\"\";let F=\"\";if(v>0){X=S.slice(0,v);S=S.slice(v);d-=v}if(U&&O===true&&d>0){U=S.slice(0,d);F=S.slice(d)}else if(O===true){U=\"\";F=S}else{U=S}if(U&&U!==\"\"&&U!==\"/\"&&U!==S){if(isPathSeparator(U.charCodeAt(U.length-1))){U=U.slice(0,-1)}}if(u.unescape===true){if(F)F=n.removeBackslashes(F);if(U&&N===true){U=n.removeBackslashes(U)}}const Q={prefix:X,input:t,start:v,base:U,glob:F,isBrace:L,isBracket:T,isGlob:O,isExtglob:k,isGlobstar:m,negated:I,negatedExtglob:B};if(u.tokens===true){Q.maxDepth=0;if(!isPathSeparator(P)){$.push(K)}Q.tokens=$}if(u.parts===true||u.tokens===true){let e;for(let n=0;n<y.length;n++){const o=e?e+1:v;const s=y[n];const r=t.slice(o,s);if(u.tokens){if(n===0&&v!==0){$[n].isPrefix=true;$[n].value=X}else{$[n].value=r}depth($[n]);Q.maxDepth+=$[n].depth}if(n!==0||r!==\"\"){x.push(r)}e=s}if(e&&e+1<t.length){const n=t.slice(e+1);x.push(n);if(u.tokens){$[$.length-1].value=n;depth($[$.length-1]);Q.maxDepth+=$[$.length-1].depth}}Q.slashes=y;Q.parts=x}return Q};t.exports=scan},96:(t,e,u)=>{const{REGEX_BACKSLASH:n,REGEX_REMOVE_BACKSLASH:o,REGEX_SPECIAL_CHARS:s,REGEX_SPECIAL_CHARS_GLOBAL:r}=u(154);e.isObject=t=>t!==null&&typeof t===\"object\"&&!Array.isArray(t);e.hasRegexChars=t=>s.test(t);e.isRegexChar=t=>t.length===1&&e.hasRegexChars(t);e.escapeRegex=t=>t.replace(r,\"\\\\$1\");e.toPosixSlashes=t=>t.replace(n,\"/\");e.removeBackslashes=t=>t.replace(o,(t=>t===\"\\\\\"?\"\":t));e.escapeLast=(t,u,n)=>{const o=t.lastIndexOf(u,n);if(o===-1)return t;if(t[o-1]===\"\\\\\")return e.escapeLast(t,u,o-1);return`${t.slice(0,o)}\\\\${t.slice(o)}`};e.removePrefix=(t,e={})=>{let u=t;if(u.startsWith(\"./\")){u=u.slice(2);e.prefix=\"./\"}return u};e.wrapOutput=(t,e={},u={})=>{const n=u.contains?\"\":\"^\";const o=u.contains?\"\":\"$\";let s=`${n}(?:${t})${o}`;if(e.negated===true){s=`(?:^(?!${s}).*$)`}return s};e.basename=(t,{windows:e}={})=>{const u=t.split(e?/[\\\\/]/:\"/\");const n=u[u.length-1];if(n===\"\"){return u[u.length-2]}return n}}};var e={};function __nccwpck_require__(u){var n=e[u];if(n!==undefined){return n.exports}var o=e[u]={exports:{}};var s=true;try{t[u](o,o.exports,__nccwpck_require__);s=false}finally{if(s)delete e[u]}return o.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var u=__nccwpck_require__(170);module.exports=u})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcGljb21hdGNoL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7O0FBQUEsTUFBTSxhQUFhLE9BQU8sY0FBYyxlQUFlLHFCQUFxQix1REFBdUQseUNBQXlDLGtDQUFrQyxVQUFVLE9BQU8sZ0JBQWdCLE9BQU8sV0FBVyxPQUFPLE9BQU8sb0JBQW9CLGNBQWMsZ0NBQWdDLGlEQUFpRCxHQUFHLDBCQUEwQixnQkFBZ0IsMkJBQTJCLG9CQUFvQixTQUFTLGdCQUFnQixhQUFhLEVBQUUsR0FBRyxjQUFjLGNBQWMsY0FBYyxjQUFjLGdCQUFnQixlQUFlLGNBQWMsRUFBRSxLQUFLLGdCQUFnQixFQUFFLEdBQUcsV0FBVyxHQUFHLElBQUksRUFBRSxFQUFFLEVBQUUsY0FBYyxFQUFFLEdBQUcsY0FBYyxFQUFFLEVBQUUsRUFBRSxHQUFHLGNBQWMsR0FBRyxJQUFJLEVBQUUsRUFBRSxHQUFHLGNBQWMsRUFBRSxHQUFHLGNBQWMsRUFBRSxHQUFHLFdBQVcsRUFBRSxJQUFJLFlBQVksU0FBUyx3TUFBd00sU0FBUyx1QkFBdUIsRUFBRSxtQkFBbUIsRUFBRSxrQkFBa0IsR0FBRyxJQUFJLE1BQU0sRUFBRSxtQkFBbUIsRUFBRSx1QkFBdUIsRUFBRSxJQUFJLEdBQUcsSUFBSSxNQUFNLEVBQUUsMEJBQTBCLEdBQUcsSUFBSSxNQUFNLEVBQUUsMkJBQTJCLEdBQUcsSUFBSSxNQUFNLEVBQUUsMEJBQTBCLEVBQUUseUJBQXlCLEVBQUUsc0JBQXNCLEVBQUUsZ0JBQWdCLFNBQVMseUxBQXlMLGFBQWEsRUFBRSw4RUFBOEUsV0FBVyxzRUFBc0UscURBQXFELHlDQUF5QyxnR0FBZ0csNEVBQTRFLHVDQUF1QyxtM0JBQW0zQixPQUFPLEtBQUssMENBQTBDLE9BQU8sR0FBRyxNQUFNLG1DQUFtQyxNQUFNLGtDQUFrQyxNQUFNLGtDQUFrQyxNQUFNLGlDQUFpQyxjQUFjLHNCQUFzQixlQUFlLGVBQWUs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QUFPLGFBQWEsU0FBUyxPQUFPLG1CQUFtQixRQUFRLFFBQVEsUUFBUSxTQUFTLFNBQVMsUUFBUSxlQUFlLGFBQWEsS0FBSyxxQkFBcUIsZUFBZSxhQUFhLGtCQUFrQixLQUFLLElBQUksS0FBSyxJQUFJLDhCQUE4Qiw4Q0FBOEMsaUJBQWlCLHNCQUFzQiw4QkFBOEIsZ0JBQWdCLDBCQUEwQixTQUFTLDJIQUEySCxvQkFBb0IsYUFBYSx3QkFBd0IsVUFBVSxXQUFXLG9DQUFvQyxNQUFNLFlBQVksV0FBVyxLQUFLLGdCQUFnQixhQUFhLHFCQUFxQixhQUFhLGlCQUFpQixtQkFBbUIsYUFBYSxLQUFLLGFBQWEsWUFBWSx1QkFBdUIsa0JBQWtCLFVBQVUsSUFBSSxvQkFBb0IscUJBQXFCLFVBQVUsYUFBYSxzQkFBc0IscUJBQXFCLGlDQUFpQyxZQUFZLFVBQVUsVUFBVSxlQUFlLGNBQWMsTUFBTSw4RkFBOEYsUUFBUSwrREFBK0QsNkJBQTZCLGtEQUFrRCxxQ0FBcUMscUNBQXFDLHVEQUF1RCx1QkFBdUIsMkJBQTJCLG1CQUFtQiw4Q0FBOEMsU0FBUyxhQUFhLElBQUksV0FBVyxHQUFHLHNCQUFzQixJQUFJLFFBQVEsdUJBQXVCLGFBQWEsY0FBYyxVQUFVLG9CQUFvQixLQUFLLElBQUksMEJBQTBCLDBCQUEwQixTQUFTLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxFQUFFLHFCQUFxQixZQUFZLEVBQUUsT0FBTyxVQUFVLGVBQWUsVUFBVSxHQUFHLElBQUksK0JBQStCLHNCQUFzQixXQUFXLHFCQUFxQixZQUFZLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLCtCQUErQixpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9waWNvbWF0Y2gvaW5kZXguanM/YTVjNCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgdD17MTcwOih0LGUsdSk9Pntjb25zdCBuPXUoNTEwKTtjb25zdCBpc1dpbmRvd3M9KCk9PntpZih0eXBlb2YgbmF2aWdhdG9yIT09XCJ1bmRlZmluZWRcIiYmbmF2aWdhdG9yLnBsYXRmb3JtKXtjb25zdCB0PW5hdmlnYXRvci5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO3JldHVybiB0PT09XCJ3aW4zMlwifHx0PT09XCJ3aW5kb3dzXCJ9aWYodHlwZW9mIHByb2Nlc3MhPT1cInVuZGVmaW5lZFwiJiZwcm9jZXNzLnBsYXRmb3JtKXtyZXR1cm4gcHJvY2Vzcy5wbGF0Zm9ybT09PVwid2luMzJcIn1yZXR1cm4gZmFsc2V9O2Z1bmN0aW9uIHBpY29tYXRjaCh0LGUsdT1mYWxzZSl7aWYoZSYmKGUud2luZG93cz09PW51bGx8fGUud2luZG93cz09PXVuZGVmaW5lZCkpe2U9ey4uLmUsd2luZG93czppc1dpbmRvd3MoKX19cmV0dXJuIG4odCxlLHUpfU9iamVjdC5hc3NpZ24ocGljb21hdGNoLG4pO3QuZXhwb3J0cz1waWNvbWF0Y2h9LDE1NDp0PT57Y29uc3QgZT1cIlxcXFxcXFxcL1wiO2NvbnN0IHU9YFteJHtlfV1gO2NvbnN0IG49XCJcXFxcLlwiO2NvbnN0IG89XCJcXFxcK1wiO2NvbnN0IHM9XCJcXFxcP1wiO2NvbnN0IHI9XCJcXFxcL1wiO2NvbnN0IGE9XCIoPz0uKVwiO2NvbnN0IGk9XCJbXi9dXCI7Y29uc3QgYz1gKD86JHtyfXwkKWA7Y29uc3QgcD1gKD86Xnwke3J9KWA7Y29uc3QgbD1gJHtufXsxLDJ9JHtjfWA7Y29uc3QgZj1gKD8hJHtufSlgO2NvbnN0IEE9YCg/ISR7cH0ke2x9KWA7Y29uc3QgXz1gKD8hJHtufXswLDF9JHtjfSlgO2NvbnN0IFI9YCg/ISR7bH0pYDtjb25zdCBFPWBbXi4ke3J9XWA7Y29uc3QgaD1gJHtpfSo/YDtjb25zdCBnPVwiL1wiO2NvbnN0IGI9e0RPVF9MSVRFUkFMOm4sUExVU19MSVRFUkFMOm8sUU1BUktfTElURVJBTDpzLFNMQVNIX0xJVEVSQUw6cixPTkVfQ0hBUjphLFFNQVJLOmksRU5EX0FOQ0hPUjpjLERPVFNfU0xBU0g6bCxOT19ET1Q6ZixOT19ET1RTOkEsTk9fRE9UX1NMQVNIOl8sTk9fRE9UU19TTEFTSDpSLFFNQVJLX05PX0RPVDpFLFNUQVI6aCxTVEFSVF9BTkNIT1I6cCxTRVA6Z307Y29uc3QgQz17Li4uYixTTEFTSF9MSVRFUkFMOmBbJHtlfV1gLFFNQVJLOnUsU1RBUjpgJHt1fSo/YCxET1RTX1NMQVNIOmAke259ezEsMn0oPzpbJHtlfV18JClgLE5PX0RPVDpgKD8hJHtufSlgLE5PX0RPVFM6YCg/ISg/Ol58WyR7ZX1dKSR7bn17MSwyfSg/Olske2V9XXwkKSlgLE5PX0RPVF9TTEFTSDpgKD8hJHtufXswLDF9KD86WyR7ZX1dfCQpKWAsTk9fRE9UU19TTEFTSDpgKD8hJHtufXsxLDJ9KD86WyR7ZX1dfCQpKWAsUU1BUktfTk9fRE9UOmBbXi4ke2V9XWAsU1RBUlRfQU5DSE9SOmAoPzpefFske2V9XSlgLEVORF9BTkNIT1I6YCg/Olske2V9XXwkKWAsU0VQOlwiXFxcXFwifTtjb25zdCB5PXthbG51bTpcImEtekEtWjAtOVwiLGFscGhhOlwiYS16QS1aXCIsYXNjaWk6XCJcXFxceDAwLVxcXFx4N0ZcIixibGFuazpcIiBcXFxcdFwiLGNudHJsOlwiXFxcXHgwMC1cXFxceDFGXFxcXHg3RlwiLGRpZ2l0OlwiMC05XCIsZ3JhcGg6XCJcXFxceDIxLVxcXFx4N0VcIixsb3dlcjpcImEtelwiLHByaW50OlwiXFxcXHgyMC1cXFxceDdFIFwiLHB1bmN0OlwiXFxcXC0hXFxcIiMkJSYnKClcXFxcKissLi86Ozw9Pj9AW1xcXFxdXl9ge3x9flwiLHNwYWNlOlwiIFxcXFx0XFxcXHJcXFxcblxcXFx2XFxcXGZcIix1cHBlcjpcIkEtWlwiLHdvcmQ6XCJBLVphLXowLTlfXCIseGRpZ2l0OlwiQS1GYS1mMC05XCJ9O3QuZXhwb3J0cz17TUFYX0xFTkdUSDoxMDI0KjY0LFBPU0lYX1JFR0VYX1NPVVJDRTp5LFJFR0VYX0JBQ0tTTEFTSDovXFxcXCg/IVsqKz9eJHt9KHwpW1xcXV0pL2csUkVHRVhfTk9OX1NQRUNJQUxfQ0hBUlM6L15bXkAhW1xcXS4sJCorP157fSgpfFxcXFwvXSsvLFJFR0VYX1NQRUNJQUxfQ0hBUlM6L1stKis/Ll4ke30ofClbXFxdXS8sUkVHRVhfU1BFQ0lBTF9DSEFSU19CQUNLUkVGOi8oXFxcXD8pKChcXFcpKFxcMyopKS9nLFJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMOi8oWy0qKz8uXiR7fSh8KVtcXF1dKS9nLFJFR0VYX1JFTU9WRV9CQUNLU0xBU0g6Lyg/OlxcWy4qP1teXFxcXF1cXF18XFxcXCg/PS4pKS9nLFJFUExBQ0VNRU5UUzp7XCIqKipcIjpcIipcIixcIioqLyoqXCI6XCIqKlwiLFwiKiovKiovKipcIjpcIioqXCJ9LENIQVJfMDo0OCxDSEFSXzk6NTcsQ0hBUl9VUFBFUkNBU0VfQTo2NSxDSEFSX0xPV0VSQ0FTRV9BOjk3LENIQVJfVVBQRVJDQVNFX1o6OTAsQ0hBUl9MT1dFUkNBU0VfWjoxMjIsQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOjQwLENIQVJfUklHSFRfUEFSRU5USEVTRVM6NDEsQ0hBUl9BU1RFUklTSzo0MixDSEFSX0FNUEVSU0FORDozOCxDSEFSX0FUOjY0LENIQVJfQkFDS1dBUkRfU0xBU0g6OTIsQ0hBUl9DQVJSSUFHRV9SRVRVUk46MTMsQ0hBUl9DSVJDVU1GTEVYX0FDQ0VOVDo5NCxDSEFSX0NPTE9OOjU4LENIQVJfQ09NTUE6NDQsQ0hBUl9ET1Q6NDYsQ0hBUl9ET1VCTEVfUVVPVEU6MzQsQ0hBUl9FUVVBTDo2MSxDSEFSX0VYQ0xBTUFUSU9OX01BUks6MzMsQ0hBUl9GT1JNX0ZFRUQ6MTIsQ0hBUl9GT1JXQVJEX1NMQVNIOjQ3LENIQVJfR1JBVkVfQUNDRU5UOjk2LENIQVJfSEFTSDozNSxDSEFSX0hZUEhFTl9NSU5VUzo0NSxDSEFSX0xFRlRfQU5HTEVfQlJBQ0tFVDo2MCxDSEFSX0xFRlRfQ1VSTFlfQlJBQ0U6MTIzLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDo5MSxDSEFSX0xJTkVfRkVFRDoxMCxDSEFSX05PX0JSRUFLX1NQQUNFOjE2MCxDSEFSX1BFUkNFTlQ6MzcsQ0hBUl9QTFVTOjQzLENIQVJfUVVFU1RJT05fTUFSSzo2MyxDSEFSX1JJR0hUX0FOR0xFX0JSQUNLRVQ6NjIsQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRToxMjUsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDo5MyxDSEFSX1NFTUlDT0xPTjo1OSxDSEFSX1NJTkdMRV9RVU9URTozOSxDSEFSX1NQQUNFOjMyLENIQVJfVEFCOjksQ0hBUl9VTkRFUlNDT1JFOjk1LENIQVJfVkVSVElDQUxfTElORToxMjQsQ0hBUl9aRVJPX1dJRFRIX05PQlJFQUtfU1BBQ0U6NjUyNzksZXh0Z2xvYkNoYXJzKHQpe3JldHVybntcIiFcIjp7dHlwZTpcIm5lZ2F0ZVwiLG9wZW46XCIoPzooPyEoPzpcIixjbG9zZTpgKSkke3QuU1RBUn0pYH0sXCI/XCI6e3R5cGU6XCJxbWFya1wiLG9wZW46XCIoPzpcIixjbG9zZTpcIik/XCJ9LFwiK1wiOnt0eXBlOlwicGx1c1wiLG9wZW46XCIoPzpcIixjbG9zZTpcIikrXCJ9LFwiKlwiOnt0eXBlOlwic3RhclwiLG9wZW46XCIoPzpcIixjbG9zZTpcIikqXCJ9LFwiQFwiOnt0eXBlOlwiYXRcIixvcGVuOlwiKD86XCIsY2xvc2U6XCIpXCJ9fX0sZ2xvYkNoYXJzKHQpe3JldHVybiB0PT09dHJ1ZT9DOmJ9fX0sNjk3Oih0LGUsdSk9Pntjb25zdCBuPXUoMTU0KTtjb25zdCBvPXUoOTYpO2NvbnN0e01BWF9MRU5HVEg6cyxQT1NJWF9SRUdFWF9TT1VSQ0U6cixSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUzphLFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjppLFJFUExBQ0VNRU5UUzpjfT1uO2NvbnN0IGV4cGFuZFJhbmdlPSh0LGUpPT57aWYodHlwZW9mIGUuZXhwYW5kUmFuZ2U9PT1cImZ1bmN0aW9uXCIpe3JldHVybiBlLmV4cGFuZFJhbmdlKC4uLnQsZSl9dC5zb3J0KCk7Y29uc3QgdT1gWyR7dC5qb2luKFwiLVwiKX1dYDt0cnl7bmV3IFJlZ0V4cCh1KX1jYXRjaChlKXtyZXR1cm4gdC5tYXAoKHQ9Pm8uZXNjYXBlUmVnZXgodCkpKS5qb2luKFwiLi5cIil9cmV0dXJuIHV9O2NvbnN0IHN5bnRheEVycm9yPSh0LGUpPT5gTWlzc2luZyAke3R9OiBcIiR7ZX1cIiAtIHVzZSBcIlxcXFxcXFxcJHtlfVwiIHRvIG1hdGNoIGxpdGVyYWwgY2hhcmFjdGVyc2A7Y29uc3QgcGFyc2U9KHQsZSk9PntpZih0eXBlb2YgdCE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKX10PWNbdF18fHQ7Y29uc3QgdT17Li4uZX07Y29uc3QgcD10eXBlb2YgdS5tYXhMZW5ndGg9PT1cIm51bWJlclwiP01hdGgubWluKHMsdS5tYXhMZW5ndGgpOnM7bGV0IGw9dC5sZW5ndGg7aWYobD5wKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aDogJHtsfSwgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoOiAke3B9YCl9Y29uc3QgZj17dHlwZTpcImJvc1wiLHZhbHVlOlwiXCIsb3V0cHV0OnUucHJlcGVuZHx8XCJcIn07Y29uc3QgQT1bZl07Y29uc3QgXz11LmNhcHR1cmU/XCJcIjpcIj86XCI7Y29uc3QgUj1uLmdsb2JDaGFycyh1LndpbmRvd3MpO2NvbnN0IEU9bi5leHRnbG9iQ2hhcnMoUik7Y29uc3R7RE9UX0xJVEVSQUw6aCxQTFVTX0xJVEVSQUw6ZyxTTEFTSF9MSVRFUkFMOmIsT05FX0NIQVI6QyxET1RTX1NMQVNIOnksTk9fRE9UOiQsTk9fRE9UX1NMQVNIOngsTk9fRE9UU19TTEFTSDpTLFFNQVJLOkgsUU1BUktfTk9fRE9UOnYsU1RBUjpkLFNUQVJUX0FOQ0hPUjpMfT1SO2NvbnN0IGdsb2JzdGFyPXQ9PmAoJHtffSg/Oig/ISR7TH0ke3QuZG90P3k6aH0pLikqPylgO2NvbnN0IFQ9dS5kb3Q/XCJcIjokO2NvbnN0IE89dS5kb3Q/SDp2O2xldCBrPXUuYmFzaD09PXRydWU/Z2xvYnN0YXIodSk6ZDtpZih1LmNhcHR1cmUpe2s9YCgke2t9KWB9aWYodHlwZW9mIHUubm9leHQ9PT1cImJvb2xlYW5cIil7dS5ub2V4dGdsb2I9dS5ub2V4dH1jb25zdCBtPXtpbnB1dDp0LGluZGV4Oi0xLHN0YXJ0OjAsZG90OnUuZG90PT09dHJ1ZSxjb25zdW1lZDpcIlwiLG91dHB1dDpcIlwiLHByZWZpeDpcIlwiLGJhY2t0cmFjazpmYWxzZSxuZWdhdGVkOmZhbHNlLGJyYWNrZXRzOjAsYnJhY2VzOjAscGFyZW5zOjAscXVvdGVzOjAsZ2xvYnN0YXI6ZmFsc2UsdG9rZW5zOkF9O3Q9by5yZW1vdmVQcmVmaXgodCxtKTtsPXQubGVuZ3RoO2NvbnN0IHc9W107Y29uc3QgTj1bXTtjb25zdCBJPVtdO2xldCBCPWY7bGV0IEc7Y29uc3QgZW9zPSgpPT5tLmluZGV4PT09bC0xO2NvbnN0IEQ9bS5wZWVrPShlPTEpPT50W20uaW5kZXgrZV07Y29uc3QgTT1tLmFkdmFuY2U9KCk9PnRbKyttLmluZGV4XXx8XCJcIjtjb25zdCByZW1haW5pbmc9KCk9PnQuc2xpY2UobS5pbmRleCsxKTtjb25zdCBjb25zdW1lPSh0PVwiXCIsZT0wKT0+e20uY29uc3VtZWQrPXQ7bS5pbmRleCs9ZX07Y29uc3QgYXBwZW5kPXQ9PnttLm91dHB1dCs9dC5vdXRwdXQhPW51bGw/dC5vdXRwdXQ6dC52YWx1ZTtjb25zdW1lKHQudmFsdWUpfTtjb25zdCBuZWdhdGU9KCk9PntsZXQgdD0xO3doaWxlKEQoKT09PVwiIVwiJiYoRCgyKSE9PVwiKFwifHxEKDMpPT09XCI/XCIpKXtNKCk7bS5zdGFydCsrO3QrK31pZih0JTI9PT0wKXtyZXR1cm4gZmFsc2V9bS5uZWdhdGVkPXRydWU7bS5zdGFydCsrO3JldHVybiB0cnVlfTtjb25zdCBpbmNyZW1lbnQ9dD0+e21bdF0rKztJLnB1c2godCl9O2NvbnN0IGRlY3JlbWVudD10PT57bVt0XS0tO0kucG9wKCl9O2NvbnN0IHB1c2g9dD0+e2lmKEIudHlwZT09PVwiZ2xvYnN0YXJcIil7Y29uc3QgZT1tLmJyYWNlcz4wJiYodC50eXBlPT09XCJjb21tYVwifHx0LnR5cGU9PT1cImJyYWNlXCIpO2NvbnN0IHU9dC5leHRnbG9iPT09dHJ1ZXx8dy5sZW5ndGgmJih0LnR5cGU9PT1cInBpcGVcInx8dC50eXBlPT09XCJwYXJlblwiKTtpZih0LnR5cGUhPT1cInNsYXNoXCImJnQudHlwZSE9PVwicGFyZW5cIiYmIWUmJiF1KXttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC1CLm91dHB1dC5sZW5ndGgpO0IudHlwZT1cInN0YXJcIjtCLnZhbHVlPVwiKlwiO0Iub3V0cHV0PWs7bS5vdXRwdXQrPUIub3V0cHV0fX1pZih3Lmxlbmd0aCYmdC50eXBlIT09XCJwYXJlblwiKXt3W3cubGVuZ3RoLTFdLmlubmVyKz10LnZhbHVlfWlmKHQudmFsdWV8fHQub3V0cHV0KWFwcGVuZCh0KTtpZihCJiZCLnR5cGU9PT1cInRleHRcIiYmdC50eXBlPT09XCJ0ZXh0XCIpe0Iub3V0cHV0PShCLm91dHB1dHx8Qi52YWx1ZSkrdC52YWx1ZTtCLnZhbHVlKz10LnZhbHVlO3JldHVybn10LnByZXY9QjtBLnB1c2godCk7Qj10fTtjb25zdCBleHRnbG9iT3Blbj0odCxlKT0+e2NvbnN0IG49ey4uLkVbZV0sY29uZGl0aW9uczoxLGlubmVyOlwiXCJ9O24ucHJldj1CO24ucGFyZW5zPW0ucGFyZW5zO24ub3V0cHV0PW0ub3V0cHV0O2NvbnN0IG89KHUuY2FwdHVyZT9cIihcIjpcIlwiKStuLm9wZW47aW5jcmVtZW50KFwicGFyZW5zXCIpO3B1c2goe3R5cGU6dCx2YWx1ZTplLG91dHB1dDptLm91dHB1dD9cIlwiOkN9KTtwdXNoKHt0eXBlOlwicGFyZW5cIixleHRnbG9iOnRydWUsdmFsdWU6TSgpLG91dHB1dDpvfSk7dy5wdXNoKG4pfTtjb25zdCBleHRnbG9iQ2xvc2U9dD0+e2xldCBuPXQuY2xvc2UrKHUuY2FwdHVyZT9cIilcIjpcIlwiKTtsZXQgbztpZih0LnR5cGU9PT1cIm5lZ2F0ZVwiKXtsZXQgcz1rO2lmKHQuaW5uZXImJnQuaW5uZXIubGVuZ3RoPjEmJnQuaW5uZXIuaW5jbHVkZXMoXCIvXCIpKXtzPWdsb2JzdGFyKHUpfWlmKHMhPT1rfHxlb3MoKXx8L15cXCkrJC8udGVzdChyZW1haW5pbmcoKSkpe249dC5jbG9zZT1gKSQpKSR7c31gfWlmKHQuaW5uZXIuaW5jbHVkZXMoXCIqXCIpJiYobz1yZW1haW5pbmcoKSkmJi9eXFwuW15cXFxcLy5dKyQvLnRlc3Qobykpe2NvbnN0IHU9cGFyc2Uobyx7Li4uZSxmYXN0cGF0aHM6ZmFsc2V9KS5vdXRwdXQ7bj10LmNsb3NlPWApJHt1fSkke3N9KWB9aWYodC5wcmV2LnR5cGU9PT1cImJvc1wiKXttLm5lZ2F0ZWRFeHRnbG9iPXRydWV9fXB1c2goe3R5cGU6XCJwYXJlblwiLGV4dGdsb2I6dHJ1ZSx2YWx1ZTpHLG91dHB1dDpufSk7ZGVjcmVtZW50KFwicGFyZW5zXCIpfTtpZih1LmZhc3RwYXRocyE9PWZhbHNlJiYhLyheWyohXXxbLygpW1xcXXt9XCJdKS8udGVzdCh0KSl7bGV0IG49ZmFsc2U7bGV0IHM9dC5yZXBsYWNlKGksKCh0LGUsdSxvLHMscik9PntpZihvPT09XCJcXFxcXCIpe249dHJ1ZTtyZXR1cm4gdH1pZihvPT09XCI/XCIpe2lmKGUpe3JldHVybiBlK28rKHM/SC5yZXBlYXQocy5sZW5ndGgpOlwiXCIpfWlmKHI9PT0wKXtyZXR1cm4gTysocz9ILnJlcGVhdChzLmxlbmd0aCk6XCJcIil9cmV0dXJuIEgucmVwZWF0KHUubGVuZ3RoKX1pZihvPT09XCIuXCIpe3JldHVybiBoLnJlcGVhdCh1Lmxlbmd0aCl9aWYobz09PVwiKlwiKXtpZihlKXtyZXR1cm4gZStvKyhzP2s6XCJcIil9cmV0dXJuIGt9cmV0dXJuIGU/dDpgXFxcXCR7dH1gfSkpO2lmKG49PT10cnVlKXtpZih1LnVuZXNjYXBlPT09dHJ1ZSl7cz1zLnJlcGxhY2UoL1xcXFwvZyxcIlwiKX1lbHNle3M9cy5yZXBsYWNlKC9cXFxcKy9nLCh0PT50Lmxlbmd0aCUyPT09MD9cIlxcXFxcXFxcXCI6dD9cIlxcXFxcIjpcIlwiKSl9fWlmKHM9PT10JiZ1LmNvbnRhaW5zPT09dHJ1ZSl7bS5vdXRwdXQ9dDtyZXR1cm4gbX1tLm91dHB1dD1vLndyYXBPdXRwdXQocyxtLGUpO3JldHVybiBtfXdoaWxlKCFlb3MoKSl7Rz1NKCk7aWYoRz09PVwiXFwwXCIpe2NvbnRpbnVlfWlmKEc9PT1cIlxcXFxcIil7Y29uc3QgdD1EKCk7aWYodD09PVwiL1wiJiZ1LmJhc2ghPT10cnVlKXtjb250aW51ZX1pZih0PT09XCIuXCJ8fHQ9PT1cIjtcIil7Y29udGludWV9aWYoIXQpe0crPVwiXFxcXFwiO3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6R30pO2NvbnRpbnVlfWNvbnN0IGU9L15cXFxcKy8uZXhlYyhyZW1haW5pbmcoKSk7bGV0IG49MDtpZihlJiZlWzBdLmxlbmd0aD4yKXtuPWVbMF0ubGVuZ3RoO20uaW5kZXgrPW47aWYobiUyIT09MCl7Rys9XCJcXFxcXCJ9fWlmKHUudW5lc2NhcGU9PT10cnVlKXtHPU0oKX1lbHNle0crPU0oKX1pZihtLmJyYWNrZXRzPT09MCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHfSk7Y29udGludWV9fWlmKG0uYnJhY2tldHM+MCYmKEchPT1cIl1cInx8Qi52YWx1ZT09PVwiW1wifHxCLnZhbHVlPT09XCJbXlwiKSl7aWYodS5wb3NpeCE9PWZhbHNlJiZHPT09XCI6XCIpe2NvbnN0IHQ9Qi52YWx1ZS5zbGljZSgxKTtpZih0LmluY2x1ZGVzKFwiW1wiKSl7Qi5wb3NpeD10cnVlO2lmKHQuaW5jbHVkZXMoXCI6XCIpKXtjb25zdCB0PUIudmFsdWUubGFzdEluZGV4T2YoXCJbXCIpO2NvbnN0IGU9Qi52YWx1ZS5zbGljZSgwLHQpO2NvbnN0IHU9Qi52YWx1ZS5zbGljZSh0KzIpO2NvbnN0IG49clt1XTtpZihuKXtCLnZhbHVlPWUrbjttLmJhY2t0cmFjaz10cnVlO00oKTtpZighZi5vdXRwdXQmJkEuaW5kZXhPZihCKT09PTEpe2Yub3V0cHV0PUN9Y29udGludWV9fX19aWYoRz09PVwiW1wiJiZEKCkhPT1cIjpcInx8Rz09PVwiLVwiJiZEKCk9PT1cIl1cIil7Rz1gXFxcXCR7R31gfWlmKEc9PT1cIl1cIiYmKEIudmFsdWU9PT1cIltcInx8Qi52YWx1ZT09PVwiW15cIikpe0c9YFxcXFwke0d9YH1pZih1LnBvc2l4PT09dHJ1ZSYmRz09PVwiIVwiJiZCLnZhbHVlPT09XCJbXCIpe0c9XCJeXCJ9Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtjb250aW51ZX1pZihtLnF1b3Rlcz09PTEmJkchPT0nXCInKXtHPW8uZXNjYXBlUmVnZXgoRyk7Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09J1wiJyl7bS5xdW90ZXM9bS5xdW90ZXM9PT0xPzA6MTtpZih1LmtlZXBRdW90ZXM9PT10cnVlKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KX1jb250aW51ZX1pZihHPT09XCIoXCIpe2luY3JlbWVudChcInBhcmVuc1wiKTtwdXNoKHt0eXBlOlwicGFyZW5cIix2YWx1ZTpHfSk7Y29udGludWV9aWYoRz09PVwiKVwiKXtpZihtLnBhcmVucz09PTAmJnUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJvcGVuaW5nXCIsXCIoXCIpKX1jb25zdCB0PXdbdy5sZW5ndGgtMV07aWYodCYmbS5wYXJlbnM9PT10LnBhcmVucysxKXtleHRnbG9iQ2xvc2Uody5wb3AoKSk7Y29udGludWV9cHVzaCh7dHlwZTpcInBhcmVuXCIsdmFsdWU6RyxvdXRwdXQ6bS5wYXJlbnM/XCIpXCI6XCJcXFxcKVwifSk7ZGVjcmVtZW50KFwicGFyZW5zXCIpO2NvbnRpbnVlfWlmKEc9PT1cIltcIil7aWYodS5ub2JyYWNrZXQ9PT10cnVlfHwhcmVtYWluaW5nKCkuaW5jbHVkZXMoXCJdXCIpKXtpZih1Lm5vYnJhY2tldCE9PXRydWUmJnUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCJdXCIpKX1HPWBcXFxcJHtHfWB9ZWxzZXtpbmNyZW1lbnQoXCJicmFja2V0c1wiKX1wdXNoKHt0eXBlOlwiYnJhY2tldFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09XCJdXCIpe2lmKHUubm9icmFja2V0PT09dHJ1ZXx8QiYmQi50eXBlPT09XCJicmFja2V0XCImJkIudmFsdWUubGVuZ3RoPT09MSl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHLG91dHB1dDpgXFxcXCR7R31gfSk7Y29udGludWV9aWYobS5icmFja2V0cz09PTApe2lmKHUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJvcGVuaW5nXCIsXCJbXCIpKX1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkcsb3V0cHV0OmBcXFxcJHtHfWB9KTtjb250aW51ZX1kZWNyZW1lbnQoXCJicmFja2V0c1wiKTtjb25zdCB0PUIudmFsdWUuc2xpY2UoMSk7aWYoQi5wb3NpeCE9PXRydWUmJnRbMF09PT1cIl5cIiYmIXQuaW5jbHVkZXMoXCIvXCIpKXtHPWAvJHtHfWB9Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtpZih1LmxpdGVyYWxCcmFja2V0cz09PWZhbHNlfHxvLmhhc1JlZ2V4Q2hhcnModCkpe2NvbnRpbnVlfWNvbnN0IGU9by5lc2NhcGVSZWdleChCLnZhbHVlKTttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC1CLnZhbHVlLmxlbmd0aCk7aWYodS5saXRlcmFsQnJhY2tldHM9PT10cnVlKXttLm91dHB1dCs9ZTtCLnZhbHVlPWU7Y29udGludWV9Qi52YWx1ZT1gKCR7X30ke2V9fCR7Qi52YWx1ZX0pYDttLm91dHB1dCs9Qi52YWx1ZTtjb250aW51ZX1pZihHPT09XCJ7XCImJnUubm9icmFjZSE9PXRydWUpe2luY3JlbWVudChcImJyYWNlc1wiKTtjb25zdCB0PXt0eXBlOlwiYnJhY2VcIix2YWx1ZTpHLG91dHB1dDpcIihcIixvdXRwdXRJbmRleDptLm91dHB1dC5sZW5ndGgsdG9rZW5zSW5kZXg6bS50b2tlbnMubGVuZ3RofTtOLnB1c2godCk7cHVzaCh0KTtjb250aW51ZX1pZihHPT09XCJ9XCIpe2NvbnN0IHQ9TltOLmxlbmd0aC0xXTtpZih1Lm5vYnJhY2U9PT10cnVlfHwhdCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHLG91dHB1dDpHfSk7Y29udGludWV9bGV0IGU9XCIpXCI7aWYodC5kb3RzPT09dHJ1ZSl7Y29uc3QgdD1BLnNsaWNlKCk7Y29uc3Qgbj1bXTtmb3IobGV0IGU9dC5sZW5ndGgtMTtlPj0wO2UtLSl7QS5wb3AoKTtpZih0W2VdLnR5cGU9PT1cImJyYWNlXCIpe2JyZWFrfWlmKHRbZV0udHlwZSE9PVwiZG90c1wiKXtuLnVuc2hpZnQodFtlXS52YWx1ZSl9fWU9ZXhwYW5kUmFuZ2Uobix1KTttLmJhY2t0cmFjaz10cnVlfWlmKHQuY29tbWEhPT10cnVlJiZ0LmRvdHMhPT10cnVlKXtjb25zdCB1PW0ub3V0cHV0LnNsaWNlKDAsdC5vdXRwdXRJbmRleCk7Y29uc3Qgbj1tLnRva2Vucy5zbGljZSh0LnRva2Vuc0luZGV4KTt0LnZhbHVlPXQub3V0cHV0PVwiXFxcXHtcIjtHPWU9XCJcXFxcfVwiO20ub3V0cHV0PXU7Zm9yKGNvbnN0IHQgb2Ygbil7bS5vdXRwdXQrPXQub3V0cHV0fHx0LnZhbHVlfX1wdXNoKHt0eXBlOlwiYnJhY2VcIix2YWx1ZTpHLG91dHB1dDplfSk7ZGVjcmVtZW50KFwiYnJhY2VzXCIpO04ucG9wKCk7Y29udGludWV9aWYoRz09PVwifFwiKXtpZih3Lmxlbmd0aD4wKXt3W3cubGVuZ3RoLTFdLmNvbmRpdGlvbnMrK31wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09XCIsXCIpe2xldCB0PUc7Y29uc3QgZT1OW04ubGVuZ3RoLTFdO2lmKGUmJklbSS5sZW5ndGgtMV09PT1cImJyYWNlc1wiKXtlLmNvbW1hPXRydWU7dD1cInxcIn1wdXNoKHt0eXBlOlwiY29tbWFcIix2YWx1ZTpHLG91dHB1dDp0fSk7Y29udGludWV9aWYoRz09PVwiL1wiKXtpZihCLnR5cGU9PT1cImRvdFwiJiZtLmluZGV4PT09bS5zdGFydCsxKXttLnN0YXJ0PW0uaW5kZXgrMTttLmNvbnN1bWVkPVwiXCI7bS5vdXRwdXQ9XCJcIjtBLnBvcCgpO0I9Zjtjb250aW51ZX1wdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpHLG91dHB1dDpifSk7Y29udGludWV9aWYoRz09PVwiLlwiKXtpZihtLmJyYWNlcz4wJiZCLnR5cGU9PT1cImRvdFwiKXtpZihCLnZhbHVlPT09XCIuXCIpQi5vdXRwdXQ9aDtjb25zdCB0PU5bTi5sZW5ndGgtMV07Qi50eXBlPVwiZG90c1wiO0Iub3V0cHV0Kz1HO0IudmFsdWUrPUc7dC5kb3RzPXRydWU7Y29udGludWV9aWYobS5icmFjZXMrbS5wYXJlbnM9PT0wJiZCLnR5cGUhPT1cImJvc1wiJiZCLnR5cGUhPT1cInNsYXNoXCIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6RyxvdXRwdXQ6aH0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJkb3RcIix2YWx1ZTpHLG91dHB1dDpofSk7Y29udGludWV9aWYoRz09PVwiP1wiKXtjb25zdCB0PUImJkIudmFsdWU9PT1cIihcIjtpZighdCYmdS5ub2V4dGdsb2IhPT10cnVlJiZEKCk9PT1cIihcIiYmRCgyKSE9PVwiP1wiKXtleHRnbG9iT3BlbihcInFtYXJrXCIsRyk7Y29udGludWV9aWYoQiYmQi50eXBlPT09XCJwYXJlblwiKXtjb25zdCB0PUQoKTtsZXQgZT1HO2lmKEIudmFsdWU9PT1cIihcIiYmIS9bIT08Ol0vLnRlc3QodCl8fHQ9PT1cIjxcIiYmIS88KFshPV18XFx3Kz4pLy50ZXN0KHJlbWFpbmluZygpKSl7ZT1gXFxcXCR7R31gfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6RyxvdXRwdXQ6ZX0pO2NvbnRpbnVlfWlmKHUuZG90IT09dHJ1ZSYmKEIudHlwZT09PVwic2xhc2hcInx8Qi50eXBlPT09XCJib3NcIikpe3B1c2goe3R5cGU6XCJxbWFya1wiLHZhbHVlOkcsb3V0cHV0OnZ9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwicW1hcmtcIix2YWx1ZTpHLG91dHB1dDpIfSk7Y29udGludWV9aWYoRz09PVwiIVwiKXtpZih1Lm5vZXh0Z2xvYiE9PXRydWUmJkQoKT09PVwiKFwiKXtpZihEKDIpIT09XCI/XCJ8fCEvWyE9PDpdLy50ZXN0KEQoMykpKXtleHRnbG9iT3BlbihcIm5lZ2F0ZVwiLEcpO2NvbnRpbnVlfX1pZih1Lm5vbmVnYXRlIT09dHJ1ZSYmbS5pbmRleD09PTApe25lZ2F0ZSgpO2NvbnRpbnVlfX1pZihHPT09XCIrXCIpe2lmKHUubm9leHRnbG9iIT09dHJ1ZSYmRCgpPT09XCIoXCImJkQoMikhPT1cIj9cIil7ZXh0Z2xvYk9wZW4oXCJwbHVzXCIsRyk7Y29udGludWV9aWYoQiYmQi52YWx1ZT09PVwiKFwifHx1LnJlZ2V4PT09ZmFsc2Upe3B1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6RyxvdXRwdXQ6Z30pO2NvbnRpbnVlfWlmKEImJihCLnR5cGU9PT1cImJyYWNrZXRcInx8Qi50eXBlPT09XCJwYXJlblwifHxCLnR5cGU9PT1cImJyYWNlXCIpfHxtLnBhcmVucz4wKXtwdXNoKHt0eXBlOlwicGx1c1wiLHZhbHVlOkd9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwicGx1c1wiLHZhbHVlOmd9KTtjb250aW51ZX1pZihHPT09XCJAXCIpe2lmKHUubm9leHRnbG9iIT09dHJ1ZSYmRCgpPT09XCIoXCImJkQoMikhPT1cIj9cIil7cHVzaCh7dHlwZTpcImF0XCIsZXh0Z2xvYjp0cnVlLHZhbHVlOkcsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHIT09XCIqXCIpe2lmKEc9PT1cIiRcInx8Rz09PVwiXlwiKXtHPWBcXFxcJHtHfWB9Y29uc3QgdD1hLmV4ZWMocmVtYWluaW5nKCkpO2lmKHQpe0crPXRbMF07bS5pbmRleCs9dFswXS5sZW5ndGh9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHfSk7Y29udGludWV9aWYoQiYmKEIudHlwZT09PVwiZ2xvYnN0YXJcInx8Qi5zdGFyPT09dHJ1ZSkpe0IudHlwZT1cInN0YXJcIjtCLnN0YXI9dHJ1ZTtCLnZhbHVlKz1HO0Iub3V0cHV0PWs7bS5iYWNrdHJhY2s9dHJ1ZTttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHKTtjb250aW51ZX1sZXQgZT1yZW1haW5pbmcoKTtpZih1Lm5vZXh0Z2xvYiE9PXRydWUmJi9eXFwoW14/XS8udGVzdChlKSl7ZXh0Z2xvYk9wZW4oXCJzdGFyXCIsRyk7Y29udGludWV9aWYoQi50eXBlPT09XCJzdGFyXCIpe2lmKHUubm9nbG9ic3Rhcj09PXRydWUpe2NvbnN1bWUoRyk7Y29udGludWV9Y29uc3Qgbj1CLnByZXY7Y29uc3Qgbz1uLnByZXY7Y29uc3Qgcz1uLnR5cGU9PT1cInNsYXNoXCJ8fG4udHlwZT09PVwiYm9zXCI7Y29uc3Qgcj1vJiYoby50eXBlPT09XCJzdGFyXCJ8fG8udHlwZT09PVwiZ2xvYnN0YXJcIik7aWYodS5iYXNoPT09dHJ1ZSYmKCFzfHxlWzBdJiZlWzBdIT09XCIvXCIpKXtwdXNoKHt0eXBlOlwic3RhclwiLHZhbHVlOkcsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1jb25zdCBhPW0uYnJhY2VzPjAmJihuLnR5cGU9PT1cImNvbW1hXCJ8fG4udHlwZT09PVwiYnJhY2VcIik7Y29uc3QgaT13Lmxlbmd0aCYmKG4udHlwZT09PVwicGlwZVwifHxuLnR5cGU9PT1cInBhcmVuXCIpO2lmKCFzJiZuLnR5cGUhPT1cInBhcmVuXCImJiFhJiYhaSl7cHVzaCh7dHlwZTpcInN0YXJcIix2YWx1ZTpHLG91dHB1dDpcIlwifSk7Y29udGludWV9d2hpbGUoZS5zbGljZSgwLDMpPT09XCIvKipcIil7Y29uc3QgdT10W20uaW5kZXgrNF07aWYodSYmdSE9PVwiL1wiKXticmVha31lPWUuc2xpY2UoMyk7Y29uc3VtZShcIi8qKlwiLDMpfWlmKG4udHlwZT09PVwiYm9zXCImJmVvcygpKXtCLnR5cGU9XCJnbG9ic3RhclwiO0IudmFsdWUrPUc7Qi5vdXRwdXQ9Z2xvYnN0YXIodSk7bS5vdXRwdXQ9Qi5vdXRwdXQ7bS5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoRyk7Y29udGludWV9aWYobi50eXBlPT09XCJzbGFzaFwiJiZuLnByZXYudHlwZSE9PVwiYm9zXCImJiFyJiZlb3MoKSl7bS5vdXRwdXQ9bS5vdXRwdXQuc2xpY2UoMCwtKG4ub3V0cHV0K0Iub3V0cHV0KS5sZW5ndGgpO24ub3V0cHV0PWAoPzoke24ub3V0cHV0fWA7Qi50eXBlPVwiZ2xvYnN0YXJcIjtCLm91dHB1dD1nbG9ic3Rhcih1KSsodS5zdHJpY3RTbGFzaGVzP1wiKVwiOlwifCQpXCIpO0IudmFsdWUrPUc7bS5nbG9ic3Rhcj10cnVlO20ub3V0cHV0Kz1uLm91dHB1dCtCLm91dHB1dDtjb25zdW1lKEcpO2NvbnRpbnVlfWlmKG4udHlwZT09PVwic2xhc2hcIiYmbi5wcmV2LnR5cGUhPT1cImJvc1wiJiZlWzBdPT09XCIvXCIpe2NvbnN0IHQ9ZVsxXSE9PXZvaWQgMD9cInwkXCI6XCJcIjttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC0obi5vdXRwdXQrQi5vdXRwdXQpLmxlbmd0aCk7bi5vdXRwdXQ9YCg/OiR7bi5vdXRwdXR9YDtCLnR5cGU9XCJnbG9ic3RhclwiO0Iub3V0cHV0PWAke2dsb2JzdGFyKHUpfSR7Yn18JHtifSR7dH0pYDtCLnZhbHVlKz1HO20ub3V0cHV0Kz1uLm91dHB1dCtCLm91dHB1dDttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHK00oKSk7cHVzaCh7dHlwZTpcInNsYXNoXCIsdmFsdWU6XCIvXCIsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1pZihuLnR5cGU9PT1cImJvc1wiJiZlWzBdPT09XCIvXCIpe0IudHlwZT1cImdsb2JzdGFyXCI7Qi52YWx1ZSs9RztCLm91dHB1dD1gKD86Xnwke2J9fCR7Z2xvYnN0YXIodSl9JHtifSlgO20ub3V0cHV0PUIub3V0cHV0O20uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEcrTSgpKTtwdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpcIi9cIixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfW0ub3V0cHV0PW0ub3V0cHV0LnNsaWNlKDAsLUIub3V0cHV0Lmxlbmd0aCk7Qi50eXBlPVwiZ2xvYnN0YXJcIjtCLm91dHB1dD1nbG9ic3Rhcih1KTtCLnZhbHVlKz1HO20ub3V0cHV0Kz1CLm91dHB1dDttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHKTtjb250aW51ZX1jb25zdCBuPXt0eXBlOlwic3RhclwiLHZhbHVlOkcsb3V0cHV0Omt9O2lmKHUuYmFzaD09PXRydWUpe24ub3V0cHV0PVwiLio/XCI7aWYoQi50eXBlPT09XCJib3NcInx8Qi50eXBlPT09XCJzbGFzaFwiKXtuLm91dHB1dD1UK24ub3V0cHV0fXB1c2gobik7Y29udGludWV9aWYoQiYmKEIudHlwZT09PVwiYnJhY2tldFwifHxCLnR5cGU9PT1cInBhcmVuXCIpJiZ1LnJlZ2V4PT09dHJ1ZSl7bi5vdXRwdXQ9RztwdXNoKG4pO2NvbnRpbnVlfWlmKG0uaW5kZXg9PT1tLnN0YXJ0fHxCLnR5cGU9PT1cInNsYXNoXCJ8fEIudHlwZT09PVwiZG90XCIpe2lmKEIudHlwZT09PVwiZG90XCIpe20ub3V0cHV0Kz14O0Iub3V0cHV0Kz14fWVsc2UgaWYodS5kb3Q9PT10cnVlKXttLm91dHB1dCs9UztCLm91dHB1dCs9U31lbHNle20ub3V0cHV0Kz1UO0Iub3V0cHV0Kz1UfWlmKEQoKSE9PVwiKlwiKXttLm91dHB1dCs9QztCLm91dHB1dCs9Q319cHVzaChuKX13aGlsZShtLmJyYWNrZXRzPjApe2lmKHUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcImNsb3NpbmdcIixcIl1cIikpO20ub3V0cHV0PW8uZXNjYXBlTGFzdChtLm91dHB1dCxcIltcIik7ZGVjcmVtZW50KFwiYnJhY2tldHNcIil9d2hpbGUobS5wYXJlbnM+MCl7aWYodS5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwiKVwiKSk7bS5vdXRwdXQ9by5lc2NhcGVMYXN0KG0ub3V0cHV0LFwiKFwiKTtkZWNyZW1lbnQoXCJwYXJlbnNcIil9d2hpbGUobS5icmFjZXM+MCl7aWYodS5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwifVwiKSk7bS5vdXRwdXQ9by5lc2NhcGVMYXN0KG0ub3V0cHV0LFwie1wiKTtkZWNyZW1lbnQoXCJicmFjZXNcIil9aWYodS5zdHJpY3RTbGFzaGVzIT09dHJ1ZSYmKEIudHlwZT09PVwic3RhclwifHxCLnR5cGU9PT1cImJyYWNrZXRcIikpe3B1c2goe3R5cGU6XCJtYXliZV9zbGFzaFwiLHZhbHVlOlwiXCIsb3V0cHV0OmAke2J9P2B9KX1pZihtLmJhY2t0cmFjaz09PXRydWUpe20ub3V0cHV0PVwiXCI7Zm9yKGNvbnN0IHQgb2YgbS50b2tlbnMpe20ub3V0cHV0Kz10Lm91dHB1dCE9bnVsbD90Lm91dHB1dDp0LnZhbHVlO2lmKHQuc3VmZml4KXttLm91dHB1dCs9dC5zdWZmaXh9fX1yZXR1cm4gbX07cGFyc2UuZmFzdHBhdGhzPSh0LGUpPT57Y29uc3QgdT17Li4uZX07Y29uc3Qgcj10eXBlb2YgdS5tYXhMZW5ndGg9PT1cIm51bWJlclwiP01hdGgubWluKHMsdS5tYXhMZW5ndGgpOnM7Y29uc3QgYT10Lmxlbmd0aDtpZihhPnIpe3Rocm93IG5ldyBTeW50YXhFcnJvcihgSW5wdXQgbGVuZ3RoOiAke2F9LCBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBsZW5ndGg6ICR7cn1gKX10PWNbdF18fHQ7Y29uc3R7RE9UX0xJVEVSQUw6aSxTTEFTSF9MSVRFUkFMOnAsT05FX0NIQVI6bCxET1RTX1NMQVNIOmYsTk9fRE9UOkEsTk9fRE9UUzpfLE5PX0RPVFNfU0xBU0g6UixTVEFSOkUsU1RBUlRfQU5DSE9SOmh9PW4uZ2xvYkNoYXJzKHUud2luZG93cyk7Y29uc3QgZz11LmRvdD9fOkE7Y29uc3QgYj11LmRvdD9SOkE7Y29uc3QgQz11LmNhcHR1cmU/XCJcIjpcIj86XCI7Y29uc3QgeT17bmVnYXRlZDpmYWxzZSxwcmVmaXg6XCJcIn07bGV0ICQ9dS5iYXNoPT09dHJ1ZT9cIi4qP1wiOkU7aWYodS5jYXB0dXJlKXskPWAoJHskfSlgfWNvbnN0IGdsb2JzdGFyPXQ9PntpZih0Lm5vZ2xvYnN0YXI9PT10cnVlKXJldHVybiAkO3JldHVybmAoJHtDfSg/Oig/ISR7aH0ke3QuZG90P2Y6aX0pLikqPylgfTtjb25zdCBjcmVhdGU9dD0+e3N3aXRjaCh0KXtjYXNlXCIqXCI6cmV0dXJuYCR7Z30ke2x9JHskfWA7Y2FzZVwiLipcIjpyZXR1cm5gJHtpfSR7bH0keyR9YDtjYXNlXCIqLipcIjpyZXR1cm5gJHtnfSR7JH0ke2l9JHtsfSR7JH1gO2Nhc2VcIiovKlwiOnJldHVybmAke2d9JHskfSR7cH0ke2x9JHtifSR7JH1gO2Nhc2VcIioqXCI6cmV0dXJuIGcrZ2xvYnN0YXIodSk7Y2FzZVwiKiovKlwiOnJldHVybmAoPzoke2d9JHtnbG9ic3Rhcih1KX0ke3B9KT8ke2J9JHtsfSR7JH1gO2Nhc2VcIioqLyouKlwiOnJldHVybmAoPzoke2d9JHtnbG9ic3Rhcih1KX0ke3B9KT8ke2J9JHskfSR7aX0ke2x9JHskfWA7Y2FzZVwiKiovLipcIjpyZXR1cm5gKD86JHtnfSR7Z2xvYnN0YXIodSl9JHtwfSk/JHtpfSR7bH0keyR9YDtkZWZhdWx0Ontjb25zdCBlPS9eKC4qPylcXC4oXFx3KykkLy5leGVjKHQpO2lmKCFlKXJldHVybjtjb25zdCB1PWNyZWF0ZShlWzFdKTtpZighdSlyZXR1cm47cmV0dXJuIHUraStlWzJdfX19O2NvbnN0IHg9by5yZW1vdmVQcmVmaXgodCx5KTtsZXQgUz1jcmVhdGUoeCk7aWYoUyYmdS5zdHJpY3RTbGFzaGVzIT09dHJ1ZSl7Uys9YCR7cH0/YH1yZXR1cm4gU307dC5leHBvcnRzPXBhcnNlfSw1MTA6KHQsZSx1KT0+e2NvbnN0IG49dSg3MTYpO2NvbnN0IG89dSg2OTcpO2NvbnN0IHM9dSg5Nik7Y29uc3Qgcj11KDE1NCk7Y29uc3QgaXNPYmplY3Q9dD0+dCYmdHlwZW9mIHQ9PT1cIm9iamVjdFwiJiYhQXJyYXkuaXNBcnJheSh0KTtjb25zdCBwaWNvbWF0Y2g9KHQsZSx1PWZhbHNlKT0+e2lmKEFycmF5LmlzQXJyYXkodCkpe2NvbnN0IG49dC5tYXAoKHQ9PnBpY29tYXRjaCh0LGUsdSkpKTtjb25zdCBhcnJheU1hdGNoZXI9dD0+e2Zvcihjb25zdCBlIG9mIG4pe2NvbnN0IHU9ZSh0KTtpZih1KXJldHVybiB1fXJldHVybiBmYWxzZX07cmV0dXJuIGFycmF5TWF0Y2hlcn1jb25zdCBuPWlzT2JqZWN0KHQpJiZ0LnRva2VucyYmdC5pbnB1dDtpZih0PT09XCJcInx8dHlwZW9mIHQhPT1cInN0cmluZ1wiJiYhbil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHBhdHRlcm4gdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpfWNvbnN0IG89ZXx8e307Y29uc3Qgcz1vLndpbmRvd3M7Y29uc3Qgcj1uP3BpY29tYXRjaC5jb21waWxlUmUodCxlKTpwaWNvbWF0Y2gubWFrZVJlKHQsZSxmYWxzZSx0cnVlKTtjb25zdCBhPXIuc3RhdGU7ZGVsZXRlIHIuc3RhdGU7bGV0IGlzSWdub3JlZD0oKT0+ZmFsc2U7aWYoby5pZ25vcmUpe2NvbnN0IHQ9ey4uLmUsaWdub3JlOm51bGwsb25NYXRjaDpudWxsLG9uUmVzdWx0Om51bGx9O2lzSWdub3JlZD1waWNvbWF0Y2goby5pZ25vcmUsdCx1KX1jb25zdCBtYXRjaGVyPSh1LG49ZmFsc2UpPT57Y29uc3R7aXNNYXRjaDppLG1hdGNoOmMsb3V0cHV0OnB9PXBpY29tYXRjaC50ZXN0KHUscixlLHtnbG9iOnQscG9zaXg6c30pO2NvbnN0IGw9e2dsb2I6dCxzdGF0ZTphLHJlZ2V4OnIscG9zaXg6cyxpbnB1dDp1LG91dHB1dDpwLG1hdGNoOmMsaXNNYXRjaDppfTtpZih0eXBlb2Ygby5vblJlc3VsdD09PVwiZnVuY3Rpb25cIil7by5vblJlc3VsdChsKX1pZihpPT09ZmFsc2Upe2wuaXNNYXRjaD1mYWxzZTtyZXR1cm4gbj9sOmZhbHNlfWlmKGlzSWdub3JlZCh1KSl7aWYodHlwZW9mIG8ub25JZ25vcmU9PT1cImZ1bmN0aW9uXCIpe28ub25JZ25vcmUobCl9bC5pc01hdGNoPWZhbHNlO3JldHVybiBuP2w6ZmFsc2V9aWYodHlwZW9mIG8ub25NYXRjaD09PVwiZnVuY3Rpb25cIil7by5vbk1hdGNoKGwpfXJldHVybiBuP2w6dHJ1ZX07aWYodSl7bWF0Y2hlci5zdGF0ZT1hfXJldHVybiBtYXRjaGVyfTtwaWNvbWF0Y2gudGVzdD0odCxlLHUse2dsb2I6bixwb3NpeDpvfT17fSk9PntpZih0eXBlb2YgdCE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBpbnB1dCB0byBiZSBhIHN0cmluZ1wiKX1pZih0PT09XCJcIil7cmV0dXJue2lzTWF0Y2g6ZmFsc2Usb3V0cHV0OlwiXCJ9fWNvbnN0IHI9dXx8e307Y29uc3QgYT1yLmZvcm1hdHx8KG8/cy50b1Bvc2l4U2xhc2hlczpudWxsKTtsZXQgaT10PT09bjtsZXQgYz1pJiZhP2EodCk6dDtpZihpPT09ZmFsc2Upe2M9YT9hKHQpOnQ7aT1jPT09bn1pZihpPT09ZmFsc2V8fHIuY2FwdHVyZT09PXRydWUpe2lmKHIubWF0Y2hCYXNlPT09dHJ1ZXx8ci5iYXNlbmFtZT09PXRydWUpe2k9cGljb21hdGNoLm1hdGNoQmFzZSh0LGUsdSxvKX1lbHNle2k9ZS5leGVjKGMpfX1yZXR1cm57aXNNYXRjaDpCb29sZWFuKGkpLG1hdGNoOmksb3V0cHV0OmN9fTtwaWNvbWF0Y2gubWF0Y2hCYXNlPSh0LGUsdSk9Pntjb25zdCBuPWUgaW5zdGFuY2VvZiBSZWdFeHA/ZTpwaWNvbWF0Y2gubWFrZVJlKGUsdSk7cmV0dXJuIG4udGVzdChzLmJhc2VuYW1lKHQpKX07cGljb21hdGNoLmlzTWF0Y2g9KHQsZSx1KT0+cGljb21hdGNoKGUsdSkodCk7cGljb21hdGNoLnBhcnNlPSh0LGUpPT57aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdC5tYXAoKHQ9PnBpY29tYXRjaC5wYXJzZSh0LGUpKSk7cmV0dXJuIG8odCx7Li4uZSxmYXN0cGF0aHM6ZmFsc2V9KX07cGljb21hdGNoLnNjYW49KHQsZSk9Pm4odCxlKTtwaWNvbWF0Y2guY29tcGlsZVJlPSh0LGUsdT1mYWxzZSxuPWZhbHNlKT0+e2lmKHU9PT10cnVlKXtyZXR1cm4gdC5vdXRwdXR9Y29uc3Qgbz1lfHx7fTtjb25zdCBzPW8uY29udGFpbnM/XCJcIjpcIl5cIjtjb25zdCByPW8uY29udGFpbnM/XCJcIjpcIiRcIjtsZXQgYT1gJHtzfSg/OiR7dC5vdXRwdXR9KSR7cn1gO2lmKHQmJnQubmVnYXRlZD09PXRydWUpe2E9YF4oPyEke2F9KS4qJGB9Y29uc3QgaT1waWNvbWF0Y2gudG9SZWdleChhLGUpO2lmKG49PT10cnVlKXtpLnN0YXRlPXR9cmV0dXJuIGl9O3BpY29tYXRjaC5tYWtlUmU9KHQsZT17fSx1PWZhbHNlLG49ZmFsc2UpPT57aWYoIXR8fHR5cGVvZiB0IT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgbm9uLWVtcHR5IHN0cmluZ1wiKX1sZXQgcz17bmVnYXRlZDpmYWxzZSxmYXN0cGF0aHM6dHJ1ZX07aWYoZS5mYXN0cGF0aHMhPT1mYWxzZSYmKHRbMF09PT1cIi5cInx8dFswXT09PVwiKlwiKSl7cy5vdXRwdXQ9by5mYXN0cGF0aHModCxlKX1pZighcy5vdXRwdXQpe3M9byh0LGUpfXJldHVybiBwaWNvbWF0Y2guY29tcGlsZVJlKHMsZSx1LG4pfTtwaWNvbWF0Y2gudG9SZWdleD0odCxlKT0+e3RyeXtjb25zdCB1PWV8fHt9O3JldHVybiBuZXcgUmVnRXhwKHQsdS5mbGFnc3x8KHUubm9jYXNlP1wiaVwiOlwiXCIpKX1jYXRjaCh0KXtpZihlJiZlLmRlYnVnPT09dHJ1ZSl0aHJvdyB0O3JldHVybi8kXi99fTtwaWNvbWF0Y2guY29uc3RhbnRzPXI7dC5leHBvcnRzPXBpY29tYXRjaH0sNzE2Oih0LGUsdSk9Pntjb25zdCBuPXUoOTYpO2NvbnN0e0NIQVJfQVNURVJJU0s6byxDSEFSX0FUOnMsQ0hBUl9CQUNLV0FSRF9TTEFTSDpyLENIQVJfQ09NTUE6YSxDSEFSX0RPVDppLENIQVJfRVhDTEFNQVRJT05fTUFSSzpjLENIQVJfRk9SV0FSRF9TTEFTSDpwLENIQVJfTEVGVF9DVVJMWV9CUkFDRTpsLENIQVJfTEVGVF9QQVJFTlRIRVNFUzpmLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDpBLENIQVJfUExVUzpfLENIQVJfUVVFU1RJT05fTUFSSzpSLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6RSxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOmgsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpnfT11KDE1NCk7Y29uc3QgaXNQYXRoU2VwYXJhdG9yPXQ9PnQ9PT1wfHx0PT09cjtjb25zdCBkZXB0aD10PT57aWYodC5pc1ByZWZpeCE9PXRydWUpe3QuZGVwdGg9dC5pc0dsb2JzdGFyP0luZmluaXR5OjF9fTtjb25zdCBzY2FuPSh0LGUpPT57Y29uc3QgdT1lfHx7fTtjb25zdCBiPXQubGVuZ3RoLTE7Y29uc3QgQz11LnBhcnRzPT09dHJ1ZXx8dS5zY2FuVG9FbmQ9PT10cnVlO2NvbnN0IHk9W107Y29uc3QgJD1bXTtjb25zdCB4PVtdO2xldCBTPXQ7bGV0IEg9LTE7bGV0IHY9MDtsZXQgZD0wO2xldCBMPWZhbHNlO2xldCBUPWZhbHNlO2xldCBPPWZhbHNlO2xldCBrPWZhbHNlO2xldCBtPWZhbHNlO2xldCB3PWZhbHNlO2xldCBOPWZhbHNlO2xldCBJPWZhbHNlO2xldCBCPWZhbHNlO2xldCBHPWZhbHNlO2xldCBEPTA7bGV0IE07bGV0IFA7bGV0IEs9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2NvbnN0IGVvcz0oKT0+SD49Yjtjb25zdCBwZWVrPSgpPT5TLmNoYXJDb2RlQXQoSCsxKTtjb25zdCBhZHZhbmNlPSgpPT57TT1QO3JldHVybiBTLmNoYXJDb2RlQXQoKytIKX07d2hpbGUoSDxiKXtQPWFkdmFuY2UoKTtsZXQgdDtpZihQPT09cil7Tj1LLmJhY2tzbGFzaGVzPXRydWU7UD1hZHZhbmNlKCk7aWYoUD09PWwpe3c9dHJ1ZX1jb250aW51ZX1pZih3PT09dHJ1ZXx8UD09PWwpe0QrKzt3aGlsZShlb3MoKSE9PXRydWUmJihQPWFkdmFuY2UoKSkpe2lmKFA9PT1yKXtOPUsuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYoUD09PWwpe0QrKztjb250aW51ZX1pZih3IT09dHJ1ZSYmUD09PWkmJihQPWFkdmFuY2UoKSk9PT1pKXtMPUsuaXNCcmFjZT10cnVlO089Sy5pc0dsb2I9dHJ1ZTtHPXRydWU7aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKHchPT10cnVlJiZQPT09YSl7TD1LLmlzQnJhY2U9dHJ1ZTtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2lmKEM9PT10cnVlKXtjb250aW51ZX1icmVha31pZihQPT09RSl7RC0tO2lmKEQ9PT0wKXt3PWZhbHNlO0w9Sy5pc0JyYWNlPXRydWU7Rz10cnVlO2JyZWFrfX19aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKFA9PT1wKXt5LnB1c2goSCk7JC5wdXNoKEspO0s9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2lmKEc9PT10cnVlKWNvbnRpbnVlO2lmKE09PT1pJiZIPT09disxKXt2Kz0yO2NvbnRpbnVlfWQ9SCsxO2NvbnRpbnVlfWlmKHUubm9leHQhPT10cnVlKXtjb25zdCB0PVA9PT1ffHxQPT09c3x8UD09PW98fFA9PT1SfHxQPT09YztpZih0PT09dHJ1ZSYmcGVlaygpPT09Zil7Tz1LLmlzR2xvYj10cnVlO2s9Sy5pc0V4dGdsb2I9dHJ1ZTtHPXRydWU7aWYoUD09PWMmJkg9PT12KXtCPXRydWV9aWYoQz09PXRydWUpe3doaWxlKGVvcygpIT09dHJ1ZSYmKFA9YWR2YW5jZSgpKSl7aWYoUD09PXIpe049Sy5iYWNrc2xhc2hlcz10cnVlO1A9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKFA9PT1oKXtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2JyZWFrfX1jb250aW51ZX1icmVha319aWYoUD09PW8pe2lmKE09PT1vKW09Sy5pc0dsb2JzdGFyPXRydWU7Tz1LLmlzR2xvYj10cnVlO0c9dHJ1ZTtpZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoUD09PVIpe089Sy5pc0dsb2I9dHJ1ZTtHPXRydWU7aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKFA9PT1BKXt3aGlsZShlb3MoKSE9PXRydWUmJih0PWFkdmFuY2UoKSkpe2lmKHQ9PT1yKXtOPUsuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYodD09PWcpe1Q9Sy5pc0JyYWNrZXQ9dHJ1ZTtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2JyZWFrfX1pZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYodS5ub25lZ2F0ZSE9PXRydWUmJlA9PT1jJiZIPT09dil7ST1LLm5lZ2F0ZWQ9dHJ1ZTt2Kys7Y29udGludWV9aWYodS5ub3BhcmVuIT09dHJ1ZSYmUD09PWYpe089Sy5pc0dsb2I9dHJ1ZTtpZihDPT09dHJ1ZSl7d2hpbGUoZW9zKCkhPT10cnVlJiYoUD1hZHZhbmNlKCkpKXtpZihQPT09Zil7Tj1LLmJhY2tzbGFzaGVzPXRydWU7UD1hZHZhbmNlKCk7Y29udGludWV9aWYoUD09PWgpe0c9dHJ1ZTticmVha319Y29udGludWV9YnJlYWt9aWYoTz09PXRydWUpe0c9dHJ1ZTtpZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9fWlmKHUubm9leHQ9PT10cnVlKXtrPWZhbHNlO089ZmFsc2V9bGV0IFU9UztsZXQgWD1cIlwiO2xldCBGPVwiXCI7aWYodj4wKXtYPVMuc2xpY2UoMCx2KTtTPVMuc2xpY2Uodik7ZC09dn1pZihVJiZPPT09dHJ1ZSYmZD4wKXtVPVMuc2xpY2UoMCxkKTtGPVMuc2xpY2UoZCl9ZWxzZSBpZihPPT09dHJ1ZSl7VT1cIlwiO0Y9U31lbHNle1U9U31pZihVJiZVIT09XCJcIiYmVSE9PVwiL1wiJiZVIT09Uyl7aWYoaXNQYXRoU2VwYXJhdG9yKFUuY2hhckNvZGVBdChVLmxlbmd0aC0xKSkpe1U9VS5zbGljZSgwLC0xKX19aWYodS51bmVzY2FwZT09PXRydWUpe2lmKEYpRj1uLnJlbW92ZUJhY2tzbGFzaGVzKEYpO2lmKFUmJk49PT10cnVlKXtVPW4ucmVtb3ZlQmFja3NsYXNoZXMoVSl9fWNvbnN0IFE9e3ByZWZpeDpYLGlucHV0OnQsc3RhcnQ6dixiYXNlOlUsZ2xvYjpGLGlzQnJhY2U6TCxpc0JyYWNrZXQ6VCxpc0dsb2I6Tyxpc0V4dGdsb2I6ayxpc0dsb2JzdGFyOm0sbmVnYXRlZDpJLG5lZ2F0ZWRFeHRnbG9iOkJ9O2lmKHUudG9rZW5zPT09dHJ1ZSl7US5tYXhEZXB0aD0wO2lmKCFpc1BhdGhTZXBhcmF0b3IoUCkpeyQucHVzaChLKX1RLnRva2Vucz0kfWlmKHUucGFydHM9PT10cnVlfHx1LnRva2Vucz09PXRydWUpe2xldCBlO2ZvcihsZXQgbj0wO248eS5sZW5ndGg7bisrKXtjb25zdCBvPWU/ZSsxOnY7Y29uc3Qgcz15W25dO2NvbnN0IHI9dC5zbGljZShvLHMpO2lmKHUudG9rZW5zKXtpZihuPT09MCYmdiE9PTApeyRbbl0uaXNQcmVmaXg9dHJ1ZTskW25dLnZhbHVlPVh9ZWxzZXskW25dLnZhbHVlPXJ9ZGVwdGgoJFtuXSk7US5tYXhEZXB0aCs9JFtuXS5kZXB0aH1pZihuIT09MHx8ciE9PVwiXCIpe3gucHVzaChyKX1lPXN9aWYoZSYmZSsxPHQubGVuZ3RoKXtjb25zdCBuPXQuc2xpY2UoZSsxKTt4LnB1c2gobik7aWYodS50b2tlbnMpeyRbJC5sZW5ndGgtMV0udmFsdWU9bjtkZXB0aCgkWyQubGVuZ3RoLTFdKTtRLm1heERlcHRoKz0kWyQubGVuZ3RoLTFdLmRlcHRofX1RLnNsYXNoZXM9eTtRLnBhcnRzPXh9cmV0dXJuIFF9O3QuZXhwb3J0cz1zY2FufSw5NjoodCxlLHUpPT57Y29uc3R7UkVHRVhfQkFDS1NMQVNIOm4sUkVHRVhfUkVNT1ZFX0JBQ0tTTEFTSDpvLFJFR0VYX1NQRUNJQUxfQ0hBUlM6cyxSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTDpyfT11KDE1NCk7ZS5pc09iamVjdD10PT50IT09bnVsbCYmdHlwZW9mIHQ9PT1cIm9iamVjdFwiJiYhQXJyYXkuaXNBcnJheSh0KTtlLmhhc1JlZ2V4Q2hhcnM9dD0+cy50ZXN0KHQpO2UuaXNSZWdleENoYXI9dD0+dC5sZW5ndGg9PT0xJiZlLmhhc1JlZ2V4Q2hhcnModCk7ZS5lc2NhcGVSZWdleD10PT50LnJlcGxhY2UocixcIlxcXFwkMVwiKTtlLnRvUG9zaXhTbGFzaGVzPXQ9PnQucmVwbGFjZShuLFwiL1wiKTtlLnJlbW92ZUJhY2tzbGFzaGVzPXQ9PnQucmVwbGFjZShvLCh0PT50PT09XCJcXFxcXCI/XCJcIjp0KSk7ZS5lc2NhcGVMYXN0PSh0LHUsbik9Pntjb25zdCBvPXQubGFzdEluZGV4T2YodSxuKTtpZihvPT09LTEpcmV0dXJuIHQ7aWYodFtvLTFdPT09XCJcXFxcXCIpcmV0dXJuIGUuZXNjYXBlTGFzdCh0LHUsby0xKTtyZXR1cm5gJHt0LnNsaWNlKDAsbyl9XFxcXCR7dC5zbGljZShvKX1gfTtlLnJlbW92ZVByZWZpeD0odCxlPXt9KT0+e2xldCB1PXQ7aWYodS5zdGFydHNXaXRoKFwiLi9cIikpe3U9dS5zbGljZSgyKTtlLnByZWZpeD1cIi4vXCJ9cmV0dXJuIHV9O2Uud3JhcE91dHB1dD0odCxlPXt9LHU9e30pPT57Y29uc3Qgbj11LmNvbnRhaW5zP1wiXCI6XCJeXCI7Y29uc3Qgbz11LmNvbnRhaW5zP1wiXCI6XCIkXCI7bGV0IHM9YCR7bn0oPzoke3R9KSR7b31gO2lmKGUubmVnYXRlZD09PXRydWUpe3M9YCg/Ol4oPyEke3N9KS4qJClgfXJldHVybiBzfTtlLmJhc2VuYW1lPSh0LHt3aW5kb3dzOmV9PXt9KT0+e2NvbnN0IHU9dC5zcGxpdChlPy9bXFxcXC9dLzpcIi9cIik7Y29uc3Qgbj11W3UubGVuZ3RoLTFdO2lmKG49PT1cIlwiKXtyZXR1cm4gdVt1Lmxlbmd0aC0yXX1yZXR1cm4gbn19fTt2YXIgZT17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHUpe3ZhciBuPWVbdV07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgbz1lW3VdPXtleHBvcnRzOnt9fTt2YXIgcz10cnVlO3RyeXt0W3VdKG8sby5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO3M9ZmFsc2V9ZmluYWxseXtpZihzKWRlbGV0ZSBlW3VdfXJldHVybiBvLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB1PV9fbmNjd3Bja19yZXF1aXJlX18oMTcwKTttb2R1bGUuZXhwb3J0cz11fSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/picomatch/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-slick/lib/arrows.js":
/*!************************************************!*\
  !*** ./node_modules/react-slick/lib/arrows.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PrevArrow = exports.NextArrow = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar _classnames = _interopRequireDefault(__webpack_require__(/*! classnames */ \"(app-pages-browser)/./node_modules/classnames/index.js\"));\nvar _innerSliderUtils = __webpack_require__(/*! ./utils/innerSliderUtils */ \"(app-pages-browser)/./node_modules/react-slick/lib/utils/innerSliderUtils.js\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nvar PrevArrow = exports.PrevArrow = /*#__PURE__*/function (_React$PureComponent) {\n  _inherits(PrevArrow, _React$PureComponent);\n  var _super = _createSuper(PrevArrow);\n  function PrevArrow() {\n    _classCallCheck(this, PrevArrow);\n    return _super.apply(this, arguments);\n  }\n  _createClass(PrevArrow, [{\n    key: \"clickHandler\",\n    value: function clickHandler(options, e) {\n      if (e) {\n        e.preventDefault();\n      }\n      this.props.clickHandler(options, e);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var prevClasses = {\n        \"slick-arrow\": true,\n        \"slick-prev\": true\n      };\n      var prevHandler = this.clickHandler.bind(this, {\n        message: \"previous\"\n      });\n      if (!this.props.infinite && (this.props.currentSlide === 0 || this.props.slideCount <= this.props.slidesToShow)) {\n        prevClasses[\"slick-disabled\"] = true;\n        prevHandler = null;\n      }\n      var prevArrowProps = {\n        key: \"0\",\n        \"data-role\": \"none\",\n        className: (0, _classnames[\"default\"])(prevClasses),\n        style: {\n          display: \"block\"\n        },\n        onClick: prevHandler\n      };\n      var customProps = {\n        currentSlide: this.props.currentSlide,\n        slideCount: this.props.slideCount\n      };\n      var prevArrow;\n      if (this.props.prevArrow) {\n        prevArrow = /*#__PURE__*/_react[\"default\"].cloneElement(this.props.prevArrow, _objectSpread(_objectSpread({}, prevArrowProps), customProps));\n      } else {\n        prevArrow = /*#__PURE__*/_react[\"default\"].createElement(\"button\", _extends({\n          key: \"0\",\n          type: \"button\"\n        }, prevArrowProps), \" \", \"Previous\");\n      }\n      return prevArrow;\n    }\n  }]);\n  return PrevArrow;\n}(_react[\"default\"].PureComponent);\nvar NextArrow = exports.NextArrow = /*#__PURE__*/function (_React$PureComponent2) {\n  _inherits(NextArrow, _React$PureComponent2);\n  var _super2 = _createSuper(NextArrow);\n  function NextArrow() {\n    _classCallCheck(this, NextArrow);\n    return _super2.apply(this, arguments);\n  }\n  _createClass(NextArrow, [{\n    key: \"clickHandler\",\n    value: function clickHandler(options, e) {\n      if (e) {\n        e.preventDefault();\n      }\n      this.props.clickHandler(options, e);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var nextClasses = {\n        \"slick-arrow\": true,\n        \"slick-next\": true\n      };\n      var nextHandler = this.clickHandler.bind(this, {\n        message: \"next\"\n      });\n      if (!(0, _innerSliderUtils.canGoNext)(this.props)) {\n        nextClasses[\"slick-disabled\"] = true;\n        nextHandler = null;\n      }\n      var nextArrowProps = {\n        key: \"1\",\n        \"data-role\": \"none\",\n        className: (0, _classnames[\"default\"])(nextClasses),\n        style: {\n          display: \"block\"\n        },\n        onClick: nextHandler\n      };\n      var customProps = {\n        currentSlide: this.props.currentSlide,\n        slideCount: this.props.slideCount\n      };\n      var nextArrow;\n      if (this.props.nextArrow) {\n        nextArrow = /*#__PURE__*/_react[\"default\"].cloneElement(this.props.nextArrow, _objectSpread(_objectSpread({}, nextArrowProps), customProps));\n      } else {\n        nextArrow = /*#__PURE__*/_react[\"default\"].createElement(\"button\", _extends({\n          key: \"1\",\n          type: \"button\"\n        }, nextArrowProps), \" \", \"Next\");\n      }\n      return nextArrow;\n    }\n  }]);\n  return NextArrow;\n}(_react[\"default\"].PureComponent);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvYXJyb3dzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGlCQUFpQixHQUFHLGlCQUFpQjtBQUNyQyxvQ0FBb0MsbUJBQU8sQ0FBQyxtRkFBTztBQUNuRCx5Q0FBeUMsbUJBQU8sQ0FBQywwRUFBWTtBQUM3RCx3QkFBd0IsbUJBQU8sQ0FBQyw4R0FBMEI7QUFDMUQsdUNBQXVDLHVDQUF1QztBQUM5RSxzQkFBc0Isc0VBQXNFLGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCxpQ0FBaUMsa0JBQWtCO0FBQzFTLHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsOEJBQThCLG1KQUFtSixxRUFBcUUsS0FBSztBQUM1YSw0Q0FBNEMsMkJBQTJCLGtCQUFrQixrQ0FBa0Msb0VBQW9FLEtBQUssT0FBTyxvQkFBb0I7QUFDL04sa0RBQWtELDBDQUEwQztBQUM1Riw0Q0FBNEMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RDtBQUMvUCw4REFBOEQsc0VBQXNFLDhEQUE4RCxrREFBa0QsaUJBQWlCLEdBQUc7QUFDeFEsNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsNENBQTRDLCtCQUErQixvQkFBb0IsbUNBQW1DLHNDQUFzQyx1RUFBdUU7QUFDN1EsMkNBQTJDLCtEQUErRCw2RUFBNkUseUVBQXlFLGVBQWUsdURBQXVELEdBQUcsK0NBQStDLGlCQUFpQixHQUFHO0FBQzVZLGlDQUFpQywwR0FBMEcsaUJBQWlCLGFBQWE7QUFDekssaUNBQWlDLDZEQUE2RCx5Q0FBeUMsOENBQThDLGlDQUFpQyxtREFBbUQsMkRBQTJELE9BQU8seUNBQXlDO0FBQ3BYLGtEQUFrRCwwRUFBMEUsZUFBZSw0QkFBNEIsbUZBQW1GO0FBQzFQLHdDQUF3Qyx1QkFBdUIseUZBQXlGO0FBQ3hKLHVDQUF1QyxNQUFNLHFGQUFxRixNQUFNLGFBQWEsMkVBQTJFLGFBQWE7QUFDN08sOEJBQThCLHVHQUF1RyxtREFBbUQ7QUFDeEwsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSDtBQUNwSCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRCxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0hBQW9IO0FBQ3BILFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2xpY2svbGliL2Fycm93cy5qcz81NzYyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5QcmV2QXJyb3cgPSBleHBvcnRzLk5leHRBcnJvdyA9IHZvaWQgMDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2NsYXNzbmFtZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbGFzc25hbWVzXCIpKTtcbnZhciBfaW5uZXJTbGlkZXJVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzL2lubmVyU2xpZGVyVXRpbHNcIik7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBTdHJpbmcoaSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxudmFyIFByZXZBcnJvdyA9IGV4cG9ydHMuUHJldkFycm93ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkUHVyZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUHJldkFycm93LCBfUmVhY3QkUHVyZUNvbXBvbmVudCk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUHJldkFycm93KTtcbiAgZnVuY3Rpb24gUHJldkFycm93KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcmV2QXJyb3cpO1xuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoUHJldkFycm93LCBbe1xuICAgIGtleTogXCJjbGlja0hhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xpY2tIYW5kbGVyKG9wdGlvbnMsIGUpIHtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJvcHMuY2xpY2tIYW5kbGVyKG9wdGlvbnMsIGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIHByZXZDbGFzc2VzID0ge1xuICAgICAgICBcInNsaWNrLWFycm93XCI6IHRydWUsXG4gICAgICAgIFwic2xpY2stcHJldlwiOiB0cnVlXG4gICAgICB9O1xuICAgICAgdmFyIHByZXZIYW5kbGVyID0gdGhpcy5jbGlja0hhbmRsZXIuYmluZCh0aGlzLCB7XG4gICAgICAgIG1lc3NhZ2U6IFwicHJldmlvdXNcIlxuICAgICAgfSk7XG4gICAgICBpZiAoIXRoaXMucHJvcHMuaW5maW5pdGUgJiYgKHRoaXMucHJvcHMuY3VycmVudFNsaWRlID09PSAwIHx8IHRoaXMucHJvcHMuc2xpZGVDb3VudCA8PSB0aGlzLnByb3BzLnNsaWRlc1RvU2hvdykpIHtcbiAgICAgICAgcHJldkNsYXNzZXNbXCJzbGljay1kaXNhYmxlZFwiXSA9IHRydWU7XG4gICAgICAgIHByZXZIYW5kbGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBwcmV2QXJyb3dQcm9wcyA9IHtcbiAgICAgICAga2V5OiBcIjBcIixcbiAgICAgICAgXCJkYXRhLXJvbGVcIjogXCJub25lXCIsXG4gICAgICAgIGNsYXNzTmFtZTogKDAsIF9jbGFzc25hbWVzW1wiZGVmYXVsdFwiXSkocHJldkNsYXNzZXMpLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICAgICAgICB9LFxuICAgICAgICBvbkNsaWNrOiBwcmV2SGFuZGxlclxuICAgICAgfTtcbiAgICAgIHZhciBjdXN0b21Qcm9wcyA9IHtcbiAgICAgICAgY3VycmVudFNsaWRlOiB0aGlzLnByb3BzLmN1cnJlbnRTbGlkZSxcbiAgICAgICAgc2xpZGVDb3VudDogdGhpcy5wcm9wcy5zbGlkZUNvdW50XG4gICAgICB9O1xuICAgICAgdmFyIHByZXZBcnJvdztcbiAgICAgIGlmICh0aGlzLnByb3BzLnByZXZBcnJvdykge1xuICAgICAgICBwcmV2QXJyb3cgPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQodGhpcy5wcm9wcy5wcmV2QXJyb3csIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJldkFycm93UHJvcHMpLCBjdXN0b21Qcm9wcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldkFycm93ID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBfZXh0ZW5kcyh7XG4gICAgICAgICAga2V5OiBcIjBcIixcbiAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiXG4gICAgICAgIH0sIHByZXZBcnJvd1Byb3BzKSwgXCIgXCIsIFwiUHJldmlvdXNcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJldkFycm93O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUHJldkFycm93O1xufShfcmVhY3RbXCJkZWZhdWx0XCJdLlB1cmVDb21wb25lbnQpO1xudmFyIE5leHRBcnJvdyA9IGV4cG9ydHMuTmV4dEFycm93ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkUHVyZUNvbXBvbmVudDIpIHtcbiAgX2luaGVyaXRzKE5leHRBcnJvdywgX1JlYWN0JFB1cmVDb21wb25lbnQyKTtcbiAgdmFyIF9zdXBlcjIgPSBfY3JlYXRlU3VwZXIoTmV4dEFycm93KTtcbiAgZnVuY3Rpb24gTmV4dEFycm93KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOZXh0QXJyb3cpO1xuICAgIHJldHVybiBfc3VwZXIyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKE5leHRBcnJvdywgW3tcbiAgICBrZXk6IFwiY2xpY2tIYW5kbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsaWNrSGFuZGxlcihvcHRpb25zLCBlKSB7XG4gICAgICBpZiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLnByb3BzLmNsaWNrSGFuZGxlcihvcHRpb25zLCBlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBuZXh0Q2xhc3NlcyA9IHtcbiAgICAgICAgXCJzbGljay1hcnJvd1wiOiB0cnVlLFxuICAgICAgICBcInNsaWNrLW5leHRcIjogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHZhciBuZXh0SGFuZGxlciA9IHRoaXMuY2xpY2tIYW5kbGVyLmJpbmQodGhpcywge1xuICAgICAgICBtZXNzYWdlOiBcIm5leHRcIlxuICAgICAgfSk7XG4gICAgICBpZiAoISgwLCBfaW5uZXJTbGlkZXJVdGlscy5jYW5Hb05leHQpKHRoaXMucHJvcHMpKSB7XG4gICAgICAgIG5leHRDbGFzc2VzW1wic2xpY2stZGlzYWJsZWRcIl0gPSB0cnVlO1xuICAgICAgICBuZXh0SGFuZGxlciA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgbmV4dEFycm93UHJvcHMgPSB7XG4gICAgICAgIGtleTogXCIxXCIsXG4gICAgICAgIFwiZGF0YS1yb2xlXCI6IFwibm9uZVwiLFxuICAgICAgICBjbGFzc05hbWU6ICgwLCBfY2xhc3NuYW1lc1tcImRlZmF1bHRcIl0pKG5leHRDbGFzc2VzKSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCJcbiAgICAgICAgfSxcbiAgICAgICAgb25DbGljazogbmV4dEhhbmRsZXJcbiAgICAgIH07XG4gICAgICB2YXIgY3VzdG9tUHJvcHMgPSB7XG4gICAgICAgIGN1cnJlbnRTbGlkZTogdGhpcy5wcm9wcy5jdXJyZW50U2xpZGUsXG4gICAgICAgIHNsaWRlQ291bnQ6IHRoaXMucHJvcHMuc2xpZGVDb3VudFxuICAgICAgfTtcbiAgICAgIHZhciBuZXh0QXJyb3c7XG4gICAgICBpZiAodGhpcy5wcm9wcy5uZXh0QXJyb3cpIHtcbiAgICAgICAgbmV4dEFycm93ID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KHRoaXMucHJvcHMubmV4dEFycm93LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG5leHRBcnJvd1Byb3BzKSwgY3VzdG9tUHJvcHMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRBcnJvdyA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgX2V4dGVuZHMoe1xuICAgICAgICAgIGtleTogXCIxXCIsXG4gICAgICAgICAgdHlwZTogXCJidXR0b25cIlxuICAgICAgICB9LCBuZXh0QXJyb3dQcm9wcyksIFwiIFwiLCBcIk5leHRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV4dEFycm93O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTmV4dEFycm93O1xufShfcmVhY3RbXCJkZWZhdWx0XCJdLlB1cmVDb21wb25lbnQpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-slick/lib/arrows.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-slick/lib/default-props.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-slick/lib/default-props.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar defaultProps = {\n  accessibility: true,\n  adaptiveHeight: false,\n  afterChange: null,\n  appendDots: function appendDots(dots) {\n    return /*#__PURE__*/_react[\"default\"].createElement(\"ul\", {\n      style: {\n        display: \"block\"\n      }\n    }, dots);\n  },\n  arrows: true,\n  autoplay: false,\n  autoplaySpeed: 3000,\n  beforeChange: null,\n  centerMode: false,\n  centerPadding: \"50px\",\n  className: \"\",\n  cssEase: \"ease\",\n  customPaging: function customPaging(i) {\n    return /*#__PURE__*/_react[\"default\"].createElement(\"button\", null, i + 1);\n  },\n  dots: false,\n  dotsClass: \"slick-dots\",\n  draggable: true,\n  easing: \"linear\",\n  edgeFriction: 0.35,\n  fade: false,\n  focusOnSelect: false,\n  infinite: true,\n  initialSlide: 0,\n  lazyLoad: null,\n  nextArrow: null,\n  onEdge: null,\n  onInit: null,\n  onLazyLoadError: null,\n  onReInit: null,\n  pauseOnDotsHover: false,\n  pauseOnFocus: false,\n  pauseOnHover: true,\n  prevArrow: null,\n  responsive: null,\n  rows: 1,\n  rtl: false,\n  slide: \"div\",\n  slidesPerRow: 1,\n  slidesToScroll: 1,\n  slidesToShow: 1,\n  speed: 500,\n  swipe: true,\n  swipeEvent: null,\n  swipeToSlide: false,\n  touchMove: true,\n  touchThreshold: 5,\n  useCSS: true,\n  useTransform: true,\n  variableWidth: false,\n  vertical: false,\n  waitForAnimate: true,\n  asNavFor: null\n};\nvar _default = exports[\"default\"] = defaultProps;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvZGVmYXVsdC1wcm9wcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7QUFDbEIsb0NBQW9DLG1CQUFPLENBQUMsbUZBQU87QUFDbkQsdUNBQXVDLHVDQUF1QztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvZGVmYXVsdC1wcm9wcy5qcz9hYTI3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBhY2Nlc3NpYmlsaXR5OiB0cnVlLFxuICBhZGFwdGl2ZUhlaWdodDogZmFsc2UsXG4gIGFmdGVyQ2hhbmdlOiBudWxsLFxuICBhcHBlbmREb3RzOiBmdW5jdGlvbiBhcHBlbmREb3RzKGRvdHMpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInVsXCIsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICAgICAgfVxuICAgIH0sIGRvdHMpO1xuICB9LFxuICBhcnJvd3M6IHRydWUsXG4gIGF1dG9wbGF5OiBmYWxzZSxcbiAgYXV0b3BsYXlTcGVlZDogMzAwMCxcbiAgYmVmb3JlQ2hhbmdlOiBudWxsLFxuICBjZW50ZXJNb2RlOiBmYWxzZSxcbiAgY2VudGVyUGFkZGluZzogXCI1MHB4XCIsXG4gIGNsYXNzTmFtZTogXCJcIixcbiAgY3NzRWFzZTogXCJlYXNlXCIsXG4gIGN1c3RvbVBhZ2luZzogZnVuY3Rpb24gY3VzdG9tUGFnaW5nKGkpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBudWxsLCBpICsgMSk7XG4gIH0sXG4gIGRvdHM6IGZhbHNlLFxuICBkb3RzQ2xhc3M6IFwic2xpY2stZG90c1wiLFxuICBkcmFnZ2FibGU6IHRydWUsXG4gIGVhc2luZzogXCJsaW5lYXJcIixcbiAgZWRnZUZyaWN0aW9uOiAwLjM1LFxuICBmYWRlOiBmYWxzZSxcbiAgZm9jdXNPblNlbGVjdDogZmFsc2UsXG4gIGluZmluaXRlOiB0cnVlLFxuICBpbml0aWFsU2xpZGU6IDAsXG4gIGxhenlMb2FkOiBudWxsLFxuICBuZXh0QXJyb3c6IG51bGwsXG4gIG9uRWRnZTogbnVsbCxcbiAgb25Jbml0OiBudWxsLFxuICBvbkxhenlMb2FkRXJyb3I6IG51bGwsXG4gIG9uUmVJbml0OiBudWxsLFxuICBwYXVzZU9uRG90c0hvdmVyOiBmYWxzZSxcbiAgcGF1c2VPbkZvY3VzOiBmYWxzZSxcbiAgcGF1c2VPbkhvdmVyOiB0cnVlLFxuICBwcmV2QXJyb3c6IG51bGwsXG4gIHJlc3BvbnNpdmU6IG51bGwsXG4gIHJvd3M6IDEsXG4gIHJ0bDogZmFsc2UsXG4gIHNsaWRlOiBcImRpdlwiLFxuICBzbGlkZXNQZXJSb3c6IDEsXG4gIHNsaWRlc1RvU2Nyb2xsOiAxLFxuICBzbGlkZXNUb1Nob3c6IDEsXG4gIHNwZWVkOiA1MDAsXG4gIHN3aXBlOiB0cnVlLFxuICBzd2lwZUV2ZW50OiBudWxsLFxuICBzd2lwZVRvU2xpZGU6IGZhbHNlLFxuICB0b3VjaE1vdmU6IHRydWUsXG4gIHRvdWNoVGhyZXNob2xkOiA1LFxuICB1c2VDU1M6IHRydWUsXG4gIHVzZVRyYW5zZm9ybTogdHJ1ZSxcbiAgdmFyaWFibGVXaWR0aDogZmFsc2UsXG4gIHZlcnRpY2FsOiBmYWxzZSxcbiAgd2FpdEZvckFuaW1hdGU6IHRydWUsXG4gIGFzTmF2Rm9yOiBudWxsXG59O1xudmFyIF9kZWZhdWx0ID0gZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBkZWZhdWx0UHJvcHM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-slick/lib/default-props.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-slick/lib/dots.js":
/*!**********************************************!*\
  !*** ./node_modules/react-slick/lib/dots.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.Dots = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar _classnames = _interopRequireDefault(__webpack_require__(/*! classnames */ \"(app-pages-browser)/./node_modules/classnames/index.js\"));\nvar _innerSliderUtils = __webpack_require__(/*! ./utils/innerSliderUtils */ \"(app-pages-browser)/./node_modules/react-slick/lib/utils/innerSliderUtils.js\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nvar getDotCount = function getDotCount(spec) {\n  var dots;\n  if (spec.infinite) {\n    dots = Math.ceil(spec.slideCount / spec.slidesToScroll);\n  } else {\n    dots = Math.ceil((spec.slideCount - spec.slidesToShow) / spec.slidesToScroll) + 1;\n  }\n  return dots;\n};\nvar Dots = exports.Dots = /*#__PURE__*/function (_React$PureComponent) {\n  _inherits(Dots, _React$PureComponent);\n  var _super = _createSuper(Dots);\n  function Dots() {\n    _classCallCheck(this, Dots);\n    return _super.apply(this, arguments);\n  }\n  _createClass(Dots, [{\n    key: \"clickHandler\",\n    value: function clickHandler(options, e) {\n      // In Autoplay the focus stays on clicked button even after transition\n      // to next slide. That only goes away by click somewhere outside\n      e.preventDefault();\n      this.props.clickHandler(options);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n        onMouseEnter = _this$props.onMouseEnter,\n        onMouseOver = _this$props.onMouseOver,\n        onMouseLeave = _this$props.onMouseLeave,\n        infinite = _this$props.infinite,\n        slidesToScroll = _this$props.slidesToScroll,\n        slidesToShow = _this$props.slidesToShow,\n        slideCount = _this$props.slideCount,\n        currentSlide = _this$props.currentSlide;\n      var dotCount = getDotCount({\n        slideCount: slideCount,\n        slidesToScroll: slidesToScroll,\n        slidesToShow: slidesToShow,\n        infinite: infinite\n      });\n      var mouseEvents = {\n        onMouseEnter: onMouseEnter,\n        onMouseOver: onMouseOver,\n        onMouseLeave: onMouseLeave\n      };\n      var dots = [];\n      for (var i = 0; i < dotCount; i++) {\n        var _rightBound = (i + 1) * slidesToScroll - 1;\n        var rightBound = infinite ? _rightBound : (0, _innerSliderUtils.clamp)(_rightBound, 0, slideCount - 1);\n        var _leftBound = rightBound - (slidesToScroll - 1);\n        var leftBound = infinite ? _leftBound : (0, _innerSliderUtils.clamp)(_leftBound, 0, slideCount - 1);\n        var className = (0, _classnames[\"default\"])({\n          \"slick-active\": infinite ? currentSlide >= leftBound && currentSlide <= rightBound : currentSlide === leftBound\n        });\n        var dotOptions = {\n          message: \"dots\",\n          index: i,\n          slidesToScroll: slidesToScroll,\n          currentSlide: currentSlide\n        };\n        var onClick = this.clickHandler.bind(this, dotOptions);\n        dots = dots.concat( /*#__PURE__*/_react[\"default\"].createElement(\"li\", {\n          key: i,\n          className: className\n        }, /*#__PURE__*/_react[\"default\"].cloneElement(this.props.customPaging(i), {\n          onClick: onClick\n        })));\n      }\n      return /*#__PURE__*/_react[\"default\"].cloneElement(this.props.appendDots(dots), _objectSpread({\n        className: this.props.dotsClass\n      }, mouseEvents));\n    }\n  }]);\n  return Dots;\n}(_react[\"default\"].PureComponent);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvZG90cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUyw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixZQUFZO0FBQ1osb0NBQW9DLG1CQUFPLENBQUMsbUZBQU87QUFDbkQseUNBQXlDLG1CQUFPLENBQUMsMEVBQVk7QUFDN0Qsd0JBQXdCLG1CQUFPLENBQUMsOEdBQTBCO0FBQzFELHVDQUF1Qyx1Q0FBdUM7QUFDOUUseUJBQXlCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3BQLDRCQUE0QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHNEQUFzRCw4QkFBOEIsbUpBQW1KLHFFQUFxRSxLQUFLO0FBQzVhLDRDQUE0QywyQkFBMkIsa0JBQWtCLGtDQUFrQyxvRUFBb0UsS0FBSyxPQUFPLG9CQUFvQjtBQUMvTixrREFBa0QsMENBQTBDO0FBQzVGLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEO0FBQy9QLDhEQUE4RCxzRUFBc0UsOERBQThELGtEQUFrRCxpQkFBaUIsR0FBRztBQUN4USw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4Qiw0Q0FBNEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsc0NBQXNDLHVFQUF1RTtBQUM3USwyQ0FBMkMsK0RBQStELDZFQUE2RSx5RUFBeUUsZUFBZSx1REFBdUQsR0FBRywrQ0FBK0MsaUJBQWlCLEdBQUc7QUFDNVksaUNBQWlDLDBHQUEwRyxpQkFBaUIsYUFBYTtBQUN6SyxpQ0FBaUMsNkRBQTZELHlDQUF5Qyw4Q0FBOEMsaUNBQWlDLG1EQUFtRCwyREFBMkQsT0FBTyx5Q0FBeUM7QUFDcFgsa0RBQWtELDBFQUEwRSxlQUFlLDRCQUE0QixtRkFBbUY7QUFDMVAsd0NBQXdDLHVCQUF1Qix5RkFBeUY7QUFDeEosdUNBQXVDLE1BQU0scUZBQXFGLE1BQU0sYUFBYSwyRUFBMkUsYUFBYTtBQUM3Tyw4QkFBOEIsdUdBQXVHLG1EQUFtRDtBQUN4TDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvZG90cy5qcz83MmUzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Eb3RzID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfY2xhc3NuYW1lcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsYXNzbmFtZXNcIikpO1xudmFyIF9pbm5lclNsaWRlclV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMvaW5uZXJTbGlkZXJVdGlsc1wiKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBTdHJpbmcoaSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxudmFyIGdldERvdENvdW50ID0gZnVuY3Rpb24gZ2V0RG90Q291bnQoc3BlYykge1xuICB2YXIgZG90cztcbiAgaWYgKHNwZWMuaW5maW5pdGUpIHtcbiAgICBkb3RzID0gTWF0aC5jZWlsKHNwZWMuc2xpZGVDb3VudCAvIHNwZWMuc2xpZGVzVG9TY3JvbGwpO1xuICB9IGVsc2Uge1xuICAgIGRvdHMgPSBNYXRoLmNlaWwoKHNwZWMuc2xpZGVDb3VudCAtIHNwZWMuc2xpZGVzVG9TaG93KSAvIHNwZWMuc2xpZGVzVG9TY3JvbGwpICsgMTtcbiAgfVxuICByZXR1cm4gZG90cztcbn07XG52YXIgRG90cyA9IGV4cG9ydHMuRG90cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JFB1cmVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKERvdHMsIF9SZWFjdCRQdXJlQ29tcG9uZW50KTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihEb3RzKTtcbiAgZnVuY3Rpb24gRG90cygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRG90cyk7XG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhEb3RzLCBbe1xuICAgIGtleTogXCJjbGlja0hhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xpY2tIYW5kbGVyKG9wdGlvbnMsIGUpIHtcbiAgICAgIC8vIEluIEF1dG9wbGF5IHRoZSBmb2N1cyBzdGF5cyBvbiBjbGlja2VkIGJ1dHRvbiBldmVuIGFmdGVyIHRyYW5zaXRpb25cbiAgICAgIC8vIHRvIG5leHQgc2xpZGUuIFRoYXQgb25seSBnb2VzIGF3YXkgYnkgY2xpY2sgc29tZXdoZXJlIG91dHNpZGVcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMucHJvcHMuY2xpY2tIYW5kbGVyKG9wdGlvbnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgb25Nb3VzZUVudGVyID0gX3RoaXMkcHJvcHMub25Nb3VzZUVudGVyLFxuICAgICAgICBvbk1vdXNlT3ZlciA9IF90aGlzJHByb3BzLm9uTW91c2VPdmVyLFxuICAgICAgICBvbk1vdXNlTGVhdmUgPSBfdGhpcyRwcm9wcy5vbk1vdXNlTGVhdmUsXG4gICAgICAgIGluZmluaXRlID0gX3RoaXMkcHJvcHMuaW5maW5pdGUsXG4gICAgICAgIHNsaWRlc1RvU2Nyb2xsID0gX3RoaXMkcHJvcHMuc2xpZGVzVG9TY3JvbGwsXG4gICAgICAgIHNsaWRlc1RvU2hvdyA9IF90aGlzJHByb3BzLnNsaWRlc1RvU2hvdyxcbiAgICAgICAgc2xpZGVDb3VudCA9IF90aGlzJHByb3BzLnNsaWRlQ291bnQsXG4gICAgICAgIGN1cnJlbnRTbGlkZSA9IF90aGlzJHByb3BzLmN1cnJlbnRTbGlkZTtcbiAgICAgIHZhciBkb3RDb3VudCA9IGdldERvdENvdW50KHtcbiAgICAgICAgc2xpZGVDb3VudDogc2xpZGVDb3VudCxcbiAgICAgICAgc2xpZGVzVG9TY3JvbGw6IHNsaWRlc1RvU2Nyb2xsLFxuICAgICAgICBzbGlkZXNUb1Nob3c6IHNsaWRlc1RvU2hvdyxcbiAgICAgICAgaW5maW5pdGU6IGluZmluaXRlXG4gICAgICB9KTtcbiAgICAgIHZhciBtb3VzZUV2ZW50cyA9IHtcbiAgICAgICAgb25Nb3VzZUVudGVyOiBvbk1vdXNlRW50ZXIsXG4gICAgICAgIG9uTW91c2VPdmVyOiBvbk1vdXNlT3ZlcixcbiAgICAgICAgb25Nb3VzZUxlYXZlOiBvbk1vdXNlTGVhdmVcbiAgICAgIH07XG4gICAgICB2YXIgZG90cyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb3RDb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciBfcmlnaHRCb3VuZCA9IChpICsgMSkgKiBzbGlkZXNUb1Njcm9sbCAtIDE7XG4gICAgICAgIHZhciByaWdodEJvdW5kID0gaW5maW5pdGUgPyBfcmlnaHRCb3VuZCA6ICgwLCBfaW5uZXJTbGlkZXJVdGlscy5jbGFtcCkoX3JpZ2h0Qm91bmQsIDAsIHNsaWRlQ291bnQgLSAxKTtcbiAgICAgICAgdmFyIF9sZWZ0Qm91bmQgPSByaWdodEJvdW5kIC0gKHNsaWRlc1RvU2Nyb2xsIC0gMSk7XG4gICAgICAgIHZhciBsZWZ0Qm91bmQgPSBpbmZpbml0ZSA/IF9sZWZ0Qm91bmQgOiAoMCwgX2lubmVyU2xpZGVyVXRpbHMuY2xhbXApKF9sZWZ0Qm91bmQsIDAsIHNsaWRlQ291bnQgLSAxKTtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9ICgwLCBfY2xhc3NuYW1lc1tcImRlZmF1bHRcIl0pKHtcbiAgICAgICAgICBcInNsaWNrLWFjdGl2ZVwiOiBpbmZpbml0ZSA/IGN1cnJlbnRTbGlkZSA+PSBsZWZ0Qm91bmQgJiYgY3VycmVudFNsaWRlIDw9IHJpZ2h0Qm91bmQgOiBjdXJyZW50U2xpZGUgPT09IGxlZnRCb3VuZFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGRvdE9wdGlvbnMgPSB7XG4gICAgICAgICAgbWVzc2FnZTogXCJkb3RzXCIsXG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgc2xpZGVzVG9TY3JvbGw6IHNsaWRlc1RvU2Nyb2xsLFxuICAgICAgICAgIGN1cnJlbnRTbGlkZTogY3VycmVudFNsaWRlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBvbkNsaWNrID0gdGhpcy5jbGlja0hhbmRsZXIuYmluZCh0aGlzLCBkb3RPcHRpb25zKTtcbiAgICAgICAgZG90cyA9IGRvdHMuY29uY2F0KCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwibGlcIiwge1xuICAgICAgICAgIGtleTogaSxcbiAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICAgICAgICB9LCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQodGhpcy5wcm9wcy5jdXN0b21QYWdpbmcoaSksIHtcbiAgICAgICAgICBvbkNsaWNrOiBvbkNsaWNrXG4gICAgICAgIH0pKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KHRoaXMucHJvcHMuYXBwZW5kRG90cyhkb3RzKSwgX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGNsYXNzTmFtZTogdGhpcy5wcm9wcy5kb3RzQ2xhc3NcbiAgICAgIH0sIG1vdXNlRXZlbnRzKSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBEb3RzO1xufShfcmVhY3RbXCJkZWZhdWx0XCJdLlB1cmVDb21wb25lbnQpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-slick/lib/dots.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-slick/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/react-slick/lib/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _slider = _interopRequireDefault(__webpack_require__(/*! ./slider */ \"(app-pages-browser)/./node_modules/react-slick/lib/slider.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar _default = exports[\"default\"] = _slider[\"default\"];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWtCO0FBQ2xCLHFDQUFxQyxtQkFBTyxDQUFDLDhFQUFVO0FBQ3ZELHVDQUF1Qyx1Q0FBdUM7QUFDOUUsZUFBZSxrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXNsaWNrL2xpYi9pbmRleC5qcz8yNWJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG52YXIgX3NsaWRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc2xpZGVyXCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxudmFyIF9kZWZhdWx0ID0gZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfc2xpZGVyW1wiZGVmYXVsdFwiXTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-slick/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-slick/lib/initial-state.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-slick/lib/initial-state.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar initialState = {\n  animating: false,\n  autoplaying: null,\n  currentDirection: 0,\n  currentLeft: null,\n  currentSlide: 0,\n  direction: 1,\n  dragging: false,\n  edgeDragged: false,\n  initialized: false,\n  lazyLoadedList: [],\n  listHeight: null,\n  listWidth: null,\n  scrolling: false,\n  slideCount: null,\n  slideHeight: null,\n  slideWidth: null,\n  swipeLeft: null,\n  swiped: false,\n  // used by swipeEvent. differentites between touch and swipe.\n  swiping: false,\n  touchObject: {\n    startX: 0,\n    startY: 0,\n    curX: 0,\n    curY: 0\n  },\n  trackStyle: {},\n  trackWidth: 0,\n  targetSlide: 0\n};\nvar _default = exports[\"default\"] = initialState;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvaW5pdGlhbC1zdGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXNsaWNrL2xpYi9pbml0aWFsLXN0YXRlLmpzPzVkNzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcbnZhciBpbml0aWFsU3RhdGUgPSB7XG4gIGFuaW1hdGluZzogZmFsc2UsXG4gIGF1dG9wbGF5aW5nOiBudWxsLFxuICBjdXJyZW50RGlyZWN0aW9uOiAwLFxuICBjdXJyZW50TGVmdDogbnVsbCxcbiAgY3VycmVudFNsaWRlOiAwLFxuICBkaXJlY3Rpb246IDEsXG4gIGRyYWdnaW5nOiBmYWxzZSxcbiAgZWRnZURyYWdnZWQ6IGZhbHNlLFxuICBpbml0aWFsaXplZDogZmFsc2UsXG4gIGxhenlMb2FkZWRMaXN0OiBbXSxcbiAgbGlzdEhlaWdodDogbnVsbCxcbiAgbGlzdFdpZHRoOiBudWxsLFxuICBzY3JvbGxpbmc6IGZhbHNlLFxuICBzbGlkZUNvdW50OiBudWxsLFxuICBzbGlkZUhlaWdodDogbnVsbCxcbiAgc2xpZGVXaWR0aDogbnVsbCxcbiAgc3dpcGVMZWZ0OiBudWxsLFxuICBzd2lwZWQ6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IHN3aXBlRXZlbnQuIGRpZmZlcmVudGl0ZXMgYmV0d2VlbiB0b3VjaCBhbmQgc3dpcGUuXG4gIHN3aXBpbmc6IGZhbHNlLFxuICB0b3VjaE9iamVjdDoge1xuICAgIHN0YXJ0WDogMCxcbiAgICBzdGFydFk6IDAsXG4gICAgY3VyWDogMCxcbiAgICBjdXJZOiAwXG4gIH0sXG4gIHRyYWNrU3R5bGU6IHt9LFxuICB0cmFja1dpZHRoOiAwLFxuICB0YXJnZXRTbGlkZTogMFxufTtcbnZhciBfZGVmYXVsdCA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gaW5pdGlhbFN0YXRlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-slick/lib/initial-state.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-slick/lib/inner-slider.js":
/*!******************************************************!*\
  !*** ./node_modules/react-slick/lib/inner-slider.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.InnerSlider = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar _initialState = _interopRequireDefault(__webpack_require__(/*! ./initial-state */ \"(app-pages-browser)/./node_modules/react-slick/lib/initial-state.js\"));\nvar _lodash = _interopRequireDefault(__webpack_require__(/*! lodash.debounce */ \"(app-pages-browser)/./node_modules/lodash.debounce/index.js\"));\nvar _classnames = _interopRequireDefault(__webpack_require__(/*! classnames */ \"(app-pages-browser)/./node_modules/classnames/index.js\"));\nvar _innerSliderUtils = __webpack_require__(/*! ./utils/innerSliderUtils */ \"(app-pages-browser)/./node_modules/react-slick/lib/utils/innerSliderUtils.js\");\nvar _track = __webpack_require__(/*! ./track */ \"(app-pages-browser)/./node_modules/react-slick/lib/track.js\");\nvar _dots = __webpack_require__(/*! ./dots */ \"(app-pages-browser)/./node_modules/react-slick/lib/dots.js\");\nvar _arrows = __webpack_require__(/*! ./arrows */ \"(app-pages-browser)/./node_modules/react-slick/lib/arrows.js\");\nvar _resizeObserverPolyfill = _interopRequireDefault(__webpack_require__(/*! resize-observer-polyfill */ \"(app-pages-browser)/./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar InnerSlider = exports.InnerSlider = /*#__PURE__*/function (_React$Component) {\n  _inherits(InnerSlider, _React$Component);\n  var _super = _createSuper(InnerSlider);\n  function InnerSlider(props) {\n    var _this;\n    _classCallCheck(this, InnerSlider);\n    _this = _super.call(this, props);\n    _defineProperty(_assertThisInitialized(_this), \"listRefHandler\", function (ref) {\n      return _this.list = ref;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"trackRefHandler\", function (ref) {\n      return _this.track = ref;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"adaptHeight\", function () {\n      if (_this.props.adaptiveHeight && _this.list) {\n        var elem = _this.list.querySelector(\"[data-index=\\\"\".concat(_this.state.currentSlide, \"\\\"]\"));\n        _this.list.style.height = (0, _innerSliderUtils.getHeight)(elem) + \"px\";\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"componentDidMount\", function () {\n      _this.props.onInit && _this.props.onInit();\n      if (_this.props.lazyLoad) {\n        var slidesToLoad = (0, _innerSliderUtils.getOnDemandLazySlides)(_objectSpread(_objectSpread({}, _this.props), _this.state));\n        if (slidesToLoad.length > 0) {\n          _this.setState(function (prevState) {\n            return {\n              lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)\n            };\n          });\n          if (_this.props.onLazyLoad) {\n            _this.props.onLazyLoad(slidesToLoad);\n          }\n        }\n      }\n      var spec = _objectSpread({\n        listRef: _this.list,\n        trackRef: _this.track\n      }, _this.props);\n      _this.updateState(spec, true, function () {\n        _this.adaptHeight();\n        _this.props.autoplay && _this.autoPlay(\"update\");\n      });\n      if (_this.props.lazyLoad === \"progressive\") {\n        _this.lazyLoadTimer = setInterval(_this.progressiveLazyLoad, 1000);\n      }\n      _this.ro = new _resizeObserverPolyfill[\"default\"](function () {\n        if (_this.state.animating) {\n          _this.onWindowResized(false); // don't set trackStyle hence don't break animation\n          _this.callbackTimers.push(setTimeout(function () {\n            return _this.onWindowResized();\n          }, _this.props.speed));\n        } else {\n          _this.onWindowResized();\n        }\n      });\n      _this.ro.observe(_this.list);\n      document.querySelectorAll && Array.prototype.forEach.call(document.querySelectorAll(\".slick-slide\"), function (slide) {\n        slide.onfocus = _this.props.pauseOnFocus ? _this.onSlideFocus : null;\n        slide.onblur = _this.props.pauseOnFocus ? _this.onSlideBlur : null;\n      });\n      if (window.addEventListener) {\n        window.addEventListener(\"resize\", _this.onWindowResized);\n      } else {\n        window.attachEvent(\"onresize\", _this.onWindowResized);\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"componentWillUnmount\", function () {\n      if (_this.animationEndCallback) {\n        clearTimeout(_this.animationEndCallback);\n      }\n      if (_this.lazyLoadTimer) {\n        clearInterval(_this.lazyLoadTimer);\n      }\n      if (_this.callbackTimers.length) {\n        _this.callbackTimers.forEach(function (timer) {\n          return clearTimeout(timer);\n        });\n        _this.callbackTimers = [];\n      }\n      if (window.addEventListener) {\n        window.removeEventListener(\"resize\", _this.onWindowResized);\n      } else {\n        window.detachEvent(\"onresize\", _this.onWindowResized);\n      }\n      if (_this.autoplayTimer) {\n        clearInterval(_this.autoplayTimer);\n      }\n      _this.ro.disconnect();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"componentDidUpdate\", function (prevProps) {\n      _this.checkImagesLoad();\n      _this.props.onReInit && _this.props.onReInit();\n      if (_this.props.lazyLoad) {\n        var slidesToLoad = (0, _innerSliderUtils.getOnDemandLazySlides)(_objectSpread(_objectSpread({}, _this.props), _this.state));\n        if (slidesToLoad.length > 0) {\n          _this.setState(function (prevState) {\n            return {\n              lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)\n            };\n          });\n          if (_this.props.onLazyLoad) {\n            _this.props.onLazyLoad(slidesToLoad);\n          }\n        }\n      }\n      // if (this.props.onLazyLoad) {\n      //   this.props.onLazyLoad([leftMostSlide])\n      // }\n      _this.adaptHeight();\n      var spec = _objectSpread(_objectSpread({\n        listRef: _this.list,\n        trackRef: _this.track\n      }, _this.props), _this.state);\n      var setTrackStyle = _this.didPropsChange(prevProps);\n      setTrackStyle && _this.updateState(spec, setTrackStyle, function () {\n        if (_this.state.currentSlide >= _react[\"default\"].Children.count(_this.props.children)) {\n          _this.changeSlide({\n            message: \"index\",\n            index: _react[\"default\"].Children.count(_this.props.children) - _this.props.slidesToShow,\n            currentSlide: _this.state.currentSlide\n          });\n        }\n        if (_this.props.autoplay) {\n          _this.autoPlay(\"update\");\n        } else {\n          _this.pause(\"paused\");\n        }\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onWindowResized\", function (setTrackStyle) {\n      if (_this.debouncedResize) _this.debouncedResize.cancel();\n      _this.debouncedResize = (0, _lodash[\"default\"])(function () {\n        return _this.resizeWindow(setTrackStyle);\n      }, 50);\n      _this.debouncedResize();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"resizeWindow\", function () {\n      var setTrackStyle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var isTrackMounted = Boolean(_this.track && _this.track.node);\n      // prevent warning: setting state on unmounted component (server side rendering)\n      if (!isTrackMounted) return;\n      var spec = _objectSpread(_objectSpread({\n        listRef: _this.list,\n        trackRef: _this.track\n      }, _this.props), _this.state);\n      _this.updateState(spec, setTrackStyle, function () {\n        if (_this.props.autoplay) _this.autoPlay(\"update\");else _this.pause(\"paused\");\n      });\n      // animating state should be cleared while resizing, otherwise autoplay stops working\n      _this.setState({\n        animating: false\n      });\n      clearTimeout(_this.animationEndCallback);\n      delete _this.animationEndCallback;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"updateState\", function (spec, setTrackStyle, callback) {\n      var updatedState = (0, _innerSliderUtils.initializedState)(spec);\n      spec = _objectSpread(_objectSpread(_objectSpread({}, spec), updatedState), {}, {\n        slideIndex: updatedState.currentSlide\n      });\n      var targetLeft = (0, _innerSliderUtils.getTrackLeft)(spec);\n      spec = _objectSpread(_objectSpread({}, spec), {}, {\n        left: targetLeft\n      });\n      var trackStyle = (0, _innerSliderUtils.getTrackCSS)(spec);\n      if (setTrackStyle || _react[\"default\"].Children.count(_this.props.children) !== _react[\"default\"].Children.count(spec.children)) {\n        updatedState[\"trackStyle\"] = trackStyle;\n      }\n      _this.setState(updatedState, callback);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"ssrInit\", function () {\n      if (_this.props.variableWidth) {\n        var _trackWidth = 0,\n          _trackLeft = 0;\n        var childrenWidths = [];\n        var preClones = (0, _innerSliderUtils.getPreClones)(_objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {\n          slideCount: _this.props.children.length\n        }));\n        var postClones = (0, _innerSliderUtils.getPostClones)(_objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {\n          slideCount: _this.props.children.length\n        }));\n        _this.props.children.forEach(function (child) {\n          childrenWidths.push(child.props.style.width);\n          _trackWidth += child.props.style.width;\n        });\n        for (var i = 0; i < preClones; i++) {\n          _trackLeft += childrenWidths[childrenWidths.length - 1 - i];\n          _trackWidth += childrenWidths[childrenWidths.length - 1 - i];\n        }\n        for (var _i = 0; _i < postClones; _i++) {\n          _trackWidth += childrenWidths[_i];\n        }\n        for (var _i2 = 0; _i2 < _this.state.currentSlide; _i2++) {\n          _trackLeft += childrenWidths[_i2];\n        }\n        var _trackStyle = {\n          width: _trackWidth + \"px\",\n          left: -_trackLeft + \"px\"\n        };\n        if (_this.props.centerMode) {\n          var currentWidth = \"\".concat(childrenWidths[_this.state.currentSlide], \"px\");\n          _trackStyle.left = \"calc(\".concat(_trackStyle.left, \" + (100% - \").concat(currentWidth, \") / 2 ) \");\n        }\n        return {\n          trackStyle: _trackStyle\n        };\n      }\n      var childrenCount = _react[\"default\"].Children.count(_this.props.children);\n      var spec = _objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {\n        slideCount: childrenCount\n      });\n      var slideCount = (0, _innerSliderUtils.getPreClones)(spec) + (0, _innerSliderUtils.getPostClones)(spec) + childrenCount;\n      var trackWidth = 100 / _this.props.slidesToShow * slideCount;\n      var slideWidth = 100 / slideCount;\n      var trackLeft = -slideWidth * ((0, _innerSliderUtils.getPreClones)(spec) + _this.state.currentSlide) * trackWidth / 100;\n      if (_this.props.centerMode) {\n        trackLeft += (100 - slideWidth * trackWidth / 100) / 2;\n      }\n      var trackStyle = {\n        width: trackWidth + \"%\",\n        left: trackLeft + \"%\"\n      };\n      return {\n        slideWidth: slideWidth + \"%\",\n        trackStyle: trackStyle\n      };\n    });\n    _defineProperty(_assertThisInitialized(_this), \"checkImagesLoad\", function () {\n      var images = _this.list && _this.list.querySelectorAll && _this.list.querySelectorAll(\".slick-slide img\") || [];\n      var imagesCount = images.length,\n        loadedCount = 0;\n      Array.prototype.forEach.call(images, function (image) {\n        var handler = function handler() {\n          return ++loadedCount && loadedCount >= imagesCount && _this.onWindowResized();\n        };\n        if (!image.onclick) {\n          image.onclick = function () {\n            return image.parentNode.focus();\n          };\n        } else {\n          var prevClickHandler = image.onclick;\n          image.onclick = function (e) {\n            prevClickHandler(e);\n            image.parentNode.focus();\n          };\n        }\n        if (!image.onload) {\n          if (_this.props.lazyLoad) {\n            image.onload = function () {\n              _this.adaptHeight();\n              _this.callbackTimers.push(setTimeout(_this.onWindowResized, _this.props.speed));\n            };\n          } else {\n            image.onload = handler;\n            image.onerror = function () {\n              handler();\n              _this.props.onLazyLoadError && _this.props.onLazyLoadError();\n            };\n          }\n        }\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"progressiveLazyLoad\", function () {\n      var slidesToLoad = [];\n      var spec = _objectSpread(_objectSpread({}, _this.props), _this.state);\n      for (var index = _this.state.currentSlide; index < _this.state.slideCount + (0, _innerSliderUtils.getPostClones)(spec); index++) {\n        if (_this.state.lazyLoadedList.indexOf(index) < 0) {\n          slidesToLoad.push(index);\n          break;\n        }\n      }\n      for (var _index = _this.state.currentSlide - 1; _index >= -(0, _innerSliderUtils.getPreClones)(spec); _index--) {\n        if (_this.state.lazyLoadedList.indexOf(_index) < 0) {\n          slidesToLoad.push(_index);\n          break;\n        }\n      }\n      if (slidesToLoad.length > 0) {\n        _this.setState(function (state) {\n          return {\n            lazyLoadedList: state.lazyLoadedList.concat(slidesToLoad)\n          };\n        });\n        if (_this.props.onLazyLoad) {\n          _this.props.onLazyLoad(slidesToLoad);\n        }\n      } else {\n        if (_this.lazyLoadTimer) {\n          clearInterval(_this.lazyLoadTimer);\n          delete _this.lazyLoadTimer;\n        }\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"slideHandler\", function (index) {\n      var dontAnimate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var _this$props = _this.props,\n        asNavFor = _this$props.asNavFor,\n        beforeChange = _this$props.beforeChange,\n        onLazyLoad = _this$props.onLazyLoad,\n        speed = _this$props.speed,\n        afterChange = _this$props.afterChange; // capture currentslide before state is updated\n      var currentSlide = _this.state.currentSlide;\n      var _slideHandler = (0, _innerSliderUtils.slideHandler)(_objectSpread(_objectSpread(_objectSpread({\n          index: index\n        }, _this.props), _this.state), {}, {\n          trackRef: _this.track,\n          useCSS: _this.props.useCSS && !dontAnimate\n        })),\n        state = _slideHandler.state,\n        nextState = _slideHandler.nextState;\n      if (!state) return;\n      beforeChange && beforeChange(currentSlide, state.currentSlide);\n      var slidesToLoad = state.lazyLoadedList.filter(function (value) {\n        return _this.state.lazyLoadedList.indexOf(value) < 0;\n      });\n      onLazyLoad && slidesToLoad.length > 0 && onLazyLoad(slidesToLoad);\n      if (!_this.props.waitForAnimate && _this.animationEndCallback) {\n        clearTimeout(_this.animationEndCallback);\n        afterChange && afterChange(currentSlide);\n        delete _this.animationEndCallback;\n      }\n      _this.setState(state, function () {\n        // asNavForIndex check is to avoid recursive calls of slideHandler in waitForAnimate=false mode\n        if (asNavFor && _this.asNavForIndex !== index) {\n          _this.asNavForIndex = index;\n          asNavFor.innerSlider.slideHandler(index);\n        }\n        if (!nextState) return;\n        _this.animationEndCallback = setTimeout(function () {\n          var animating = nextState.animating,\n            firstBatch = _objectWithoutProperties(nextState, [\"animating\"]);\n          _this.setState(firstBatch, function () {\n            _this.callbackTimers.push(setTimeout(function () {\n              return _this.setState({\n                animating: animating\n              });\n            }, 10));\n            afterChange && afterChange(state.currentSlide);\n            delete _this.animationEndCallback;\n          });\n        }, speed);\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"changeSlide\", function (options) {\n      var dontAnimate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var spec = _objectSpread(_objectSpread({}, _this.props), _this.state);\n      var targetSlide = (0, _innerSliderUtils.changeSlide)(spec, options);\n      if (targetSlide !== 0 && !targetSlide) return;\n      if (dontAnimate === true) {\n        _this.slideHandler(targetSlide, dontAnimate);\n      } else {\n        _this.slideHandler(targetSlide);\n      }\n      _this.props.autoplay && _this.autoPlay(\"update\");\n      if (_this.props.focusOnSelect) {\n        var nodes = _this.list.querySelectorAll(\".slick-current\");\n        nodes[0] && nodes[0].focus();\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"clickHandler\", function (e) {\n      if (_this.clickable === false) {\n        e.stopPropagation();\n        e.preventDefault();\n      }\n      _this.clickable = true;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"keyHandler\", function (e) {\n      var dir = (0, _innerSliderUtils.keyHandler)(e, _this.props.accessibility, _this.props.rtl);\n      dir !== \"\" && _this.changeSlide({\n        message: dir\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"selectHandler\", function (options) {\n      _this.changeSlide(options);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"disableBodyScroll\", function () {\n      var preventDefault = function preventDefault(e) {\n        e = e || window.event;\n        if (e.preventDefault) e.preventDefault();\n        e.returnValue = false;\n      };\n      window.ontouchmove = preventDefault;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"enableBodyScroll\", function () {\n      window.ontouchmove = null;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"swipeStart\", function (e) {\n      if (_this.props.verticalSwiping) {\n        _this.disableBodyScroll();\n      }\n      var state = (0, _innerSliderUtils.swipeStart)(e, _this.props.swipe, _this.props.draggable);\n      state !== \"\" && _this.setState(state);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"swipeMove\", function (e) {\n      var state = (0, _innerSliderUtils.swipeMove)(e, _objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {\n        trackRef: _this.track,\n        listRef: _this.list,\n        slideIndex: _this.state.currentSlide\n      }));\n      if (!state) return;\n      if (state[\"swiping\"]) {\n        _this.clickable = false;\n      }\n      _this.setState(state);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"swipeEnd\", function (e) {\n      var state = (0, _innerSliderUtils.swipeEnd)(e, _objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {\n        trackRef: _this.track,\n        listRef: _this.list,\n        slideIndex: _this.state.currentSlide\n      }));\n      if (!state) return;\n      var triggerSlideHandler = state[\"triggerSlideHandler\"];\n      delete state[\"triggerSlideHandler\"];\n      _this.setState(state);\n      if (triggerSlideHandler === undefined) return;\n      _this.slideHandler(triggerSlideHandler);\n      if (_this.props.verticalSwiping) {\n        _this.enableBodyScroll();\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"touchEnd\", function (e) {\n      _this.swipeEnd(e);\n      _this.clickable = true;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"slickPrev\", function () {\n      // this and fellow methods are wrapped in setTimeout\n      // to make sure initialize setState has happened before\n      // any of such methods are called\n      _this.callbackTimers.push(setTimeout(function () {\n        return _this.changeSlide({\n          message: \"previous\"\n        });\n      }, 0));\n    });\n    _defineProperty(_assertThisInitialized(_this), \"slickNext\", function () {\n      _this.callbackTimers.push(setTimeout(function () {\n        return _this.changeSlide({\n          message: \"next\"\n        });\n      }, 0));\n    });\n    _defineProperty(_assertThisInitialized(_this), \"slickGoTo\", function (slide) {\n      var dontAnimate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      slide = Number(slide);\n      if (isNaN(slide)) return \"\";\n      _this.callbackTimers.push(setTimeout(function () {\n        return _this.changeSlide({\n          message: \"index\",\n          index: slide,\n          currentSlide: _this.state.currentSlide\n        }, dontAnimate);\n      }, 0));\n    });\n    _defineProperty(_assertThisInitialized(_this), \"play\", function () {\n      var nextIndex;\n      if (_this.props.rtl) {\n        nextIndex = _this.state.currentSlide - _this.props.slidesToScroll;\n      } else {\n        if ((0, _innerSliderUtils.canGoNext)(_objectSpread(_objectSpread({}, _this.props), _this.state))) {\n          nextIndex = _this.state.currentSlide + _this.props.slidesToScroll;\n        } else {\n          return false;\n        }\n      }\n      _this.slideHandler(nextIndex);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"autoPlay\", function (playType) {\n      if (_this.autoplayTimer) {\n        clearInterval(_this.autoplayTimer);\n      }\n      var autoplaying = _this.state.autoplaying;\n      if (playType === \"update\") {\n        if (autoplaying === \"hovered\" || autoplaying === \"focused\" || autoplaying === \"paused\") {\n          return;\n        }\n      } else if (playType === \"leave\") {\n        if (autoplaying === \"paused\" || autoplaying === \"focused\") {\n          return;\n        }\n      } else if (playType === \"blur\") {\n        if (autoplaying === \"paused\" || autoplaying === \"hovered\") {\n          return;\n        }\n      }\n      _this.autoplayTimer = setInterval(_this.play, _this.props.autoplaySpeed + 50);\n      _this.setState({\n        autoplaying: \"playing\"\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"pause\", function (pauseType) {\n      if (_this.autoplayTimer) {\n        clearInterval(_this.autoplayTimer);\n        _this.autoplayTimer = null;\n      }\n      var autoplaying = _this.state.autoplaying;\n      if (pauseType === \"paused\") {\n        _this.setState({\n          autoplaying: \"paused\"\n        });\n      } else if (pauseType === \"focused\") {\n        if (autoplaying === \"hovered\" || autoplaying === \"playing\") {\n          _this.setState({\n            autoplaying: \"focused\"\n          });\n        }\n      } else {\n        // pauseType  is 'hovered'\n        if (autoplaying === \"playing\") {\n          _this.setState({\n            autoplaying: \"hovered\"\n          });\n        }\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onDotsOver\", function () {\n      return _this.props.autoplay && _this.pause(\"hovered\");\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onDotsLeave\", function () {\n      return _this.props.autoplay && _this.state.autoplaying === \"hovered\" && _this.autoPlay(\"leave\");\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onTrackOver\", function () {\n      return _this.props.autoplay && _this.pause(\"hovered\");\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onTrackLeave\", function () {\n      return _this.props.autoplay && _this.state.autoplaying === \"hovered\" && _this.autoPlay(\"leave\");\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onSlideFocus\", function () {\n      return _this.props.autoplay && _this.pause(\"focused\");\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onSlideBlur\", function () {\n      return _this.props.autoplay && _this.state.autoplaying === \"focused\" && _this.autoPlay(\"blur\");\n    });\n    _defineProperty(_assertThisInitialized(_this), \"render\", function () {\n      var className = (0, _classnames[\"default\"])(\"slick-slider\", _this.props.className, {\n        \"slick-vertical\": _this.props.vertical,\n        \"slick-initialized\": true\n      });\n      var spec = _objectSpread(_objectSpread({}, _this.props), _this.state);\n      var trackProps = (0, _innerSliderUtils.extractObject)(spec, [\"fade\", \"cssEase\", \"speed\", \"infinite\", \"centerMode\", \"focusOnSelect\", \"currentSlide\", \"lazyLoad\", \"lazyLoadedList\", \"rtl\", \"slideWidth\", \"slideHeight\", \"listHeight\", \"vertical\", \"slidesToShow\", \"slidesToScroll\", \"slideCount\", \"trackStyle\", \"variableWidth\", \"unslick\", \"centerPadding\", \"targetSlide\", \"useCSS\"]);\n      var pauseOnHover = _this.props.pauseOnHover;\n      trackProps = _objectSpread(_objectSpread({}, trackProps), {}, {\n        onMouseEnter: pauseOnHover ? _this.onTrackOver : null,\n        onMouseLeave: pauseOnHover ? _this.onTrackLeave : null,\n        onMouseOver: pauseOnHover ? _this.onTrackOver : null,\n        focusOnSelect: _this.props.focusOnSelect && _this.clickable ? _this.selectHandler : null\n      });\n      var dots;\n      if (_this.props.dots === true && _this.state.slideCount >= _this.props.slidesToShow) {\n        var dotProps = (0, _innerSliderUtils.extractObject)(spec, [\"dotsClass\", \"slideCount\", \"slidesToShow\", \"currentSlide\", \"slidesToScroll\", \"clickHandler\", \"children\", \"customPaging\", \"infinite\", \"appendDots\"]);\n        var pauseOnDotsHover = _this.props.pauseOnDotsHover;\n        dotProps = _objectSpread(_objectSpread({}, dotProps), {}, {\n          clickHandler: _this.changeSlide,\n          onMouseEnter: pauseOnDotsHover ? _this.onDotsLeave : null,\n          onMouseOver: pauseOnDotsHover ? _this.onDotsOver : null,\n          onMouseLeave: pauseOnDotsHover ? _this.onDotsLeave : null\n        });\n        dots = /*#__PURE__*/_react[\"default\"].createElement(_dots.Dots, dotProps);\n      }\n      var prevArrow, nextArrow;\n      var arrowProps = (0, _innerSliderUtils.extractObject)(spec, [\"infinite\", \"centerMode\", \"currentSlide\", \"slideCount\", \"slidesToShow\", \"prevArrow\", \"nextArrow\"]);\n      arrowProps.clickHandler = _this.changeSlide;\n      if (_this.props.arrows) {\n        prevArrow = /*#__PURE__*/_react[\"default\"].createElement(_arrows.PrevArrow, arrowProps);\n        nextArrow = /*#__PURE__*/_react[\"default\"].createElement(_arrows.NextArrow, arrowProps);\n      }\n      var verticalHeightStyle = null;\n      if (_this.props.vertical) {\n        verticalHeightStyle = {\n          height: _this.state.listHeight\n        };\n      }\n      var centerPaddingStyle = null;\n      if (_this.props.vertical === false) {\n        if (_this.props.centerMode === true) {\n          centerPaddingStyle = {\n            padding: \"0px \" + _this.props.centerPadding\n          };\n        }\n      } else {\n        if (_this.props.centerMode === true) {\n          centerPaddingStyle = {\n            padding: _this.props.centerPadding + \" 0px\"\n          };\n        }\n      }\n      var listStyle = _objectSpread(_objectSpread({}, verticalHeightStyle), centerPaddingStyle);\n      var touchMove = _this.props.touchMove;\n      var listProps = {\n        className: \"slick-list\",\n        style: listStyle,\n        onClick: _this.clickHandler,\n        onMouseDown: touchMove ? _this.swipeStart : null,\n        onMouseMove: _this.state.dragging && touchMove ? _this.swipeMove : null,\n        onMouseUp: touchMove ? _this.swipeEnd : null,\n        onMouseLeave: _this.state.dragging && touchMove ? _this.swipeEnd : null,\n        onTouchStart: touchMove ? _this.swipeStart : null,\n        onTouchMove: _this.state.dragging && touchMove ? _this.swipeMove : null,\n        onTouchEnd: touchMove ? _this.touchEnd : null,\n        onTouchCancel: _this.state.dragging && touchMove ? _this.swipeEnd : null,\n        onKeyDown: _this.props.accessibility ? _this.keyHandler : null\n      };\n      var innerSliderProps = {\n        className: className,\n        dir: \"ltr\",\n        style: _this.props.style\n      };\n      if (_this.props.unslick) {\n        listProps = {\n          className: \"slick-list\"\n        };\n        innerSliderProps = {\n          className: className\n        };\n      }\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", innerSliderProps, !_this.props.unslick ? prevArrow : \"\", /*#__PURE__*/_react[\"default\"].createElement(\"div\", _extends({\n        ref: _this.listRefHandler\n      }, listProps), /*#__PURE__*/_react[\"default\"].createElement(_track.Track, _extends({\n        ref: _this.trackRefHandler\n      }, trackProps), _this.props.children)), !_this.props.unslick ? nextArrow : \"\", !_this.props.unslick ? dots : \"\");\n    });\n    _this.list = null;\n    _this.track = null;\n    _this.state = _objectSpread(_objectSpread({}, _initialState[\"default\"]), {}, {\n      currentSlide: _this.props.initialSlide,\n      targetSlide: _this.props.initialSlide ? _this.props.initialSlide : 0,\n      slideCount: _react[\"default\"].Children.count(_this.props.children)\n    });\n    _this.callbackTimers = [];\n    _this.clickable = true;\n    _this.debouncedResize = null;\n    var ssrState = _this.ssrInit();\n    _this.state = _objectSpread(_objectSpread({}, _this.state), ssrState);\n    return _this;\n  }\n  _createClass(InnerSlider, [{\n    key: \"didPropsChange\",\n    value: function didPropsChange(prevProps) {\n      var setTrackStyle = false;\n      for (var _i3 = 0, _Object$keys = Object.keys(this.props); _i3 < _Object$keys.length; _i3++) {\n        var key = _Object$keys[_i3];\n        if (!prevProps.hasOwnProperty(key)) {\n          setTrackStyle = true;\n          break;\n        }\n        if (_typeof(prevProps[key]) === \"object\" || typeof prevProps[key] === \"function\" || isNaN(prevProps[key])) {\n          continue;\n        }\n        if (prevProps[key] !== this.props[key]) {\n          setTrackStyle = true;\n          break;\n        }\n      }\n      return setTrackStyle || _react[\"default\"].Children.count(this.props.children) !== _react[\"default\"].Children.count(prevProps.children);\n    }\n  }]);\n  return InnerSlider;\n}(_react[\"default\"].Component);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvaW5uZXItc2xpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLG1CQUFtQjtBQUNuQixvQ0FBb0MsbUJBQU8sQ0FBQyxtRkFBTztBQUNuRCwyQ0FBMkMsbUJBQU8sQ0FBQyw0RkFBaUI7QUFDcEUscUNBQXFDLG1CQUFPLENBQUMsb0ZBQWlCO0FBQzlELHlDQUF5QyxtQkFBTyxDQUFDLDBFQUFZO0FBQzdELHdCQUF3QixtQkFBTyxDQUFDLDhHQUEwQjtBQUMxRCxhQUFhLG1CQUFPLENBQUMsNEVBQVM7QUFDOUIsWUFBWSxtQkFBTyxDQUFDLDBFQUFRO0FBQzVCLGNBQWMsbUJBQU8sQ0FBQyw4RUFBVTtBQUNoQyxxREFBcUQsbUJBQU8sQ0FBQyx1SEFBMEI7QUFDdkYsdUNBQXVDLHVDQUF1QztBQUM5RSxzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUyxzQkFBc0Isc0VBQXNFLGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCxpQ0FBaUMsa0JBQWtCO0FBQzFTLHNEQUFzRCwrQkFBK0IsOERBQThELFlBQVksb0NBQW9DLDZEQUE2RCxZQUFZLDZCQUE2QixPQUFPLDJCQUEyQiwwQ0FBMEMsd0VBQXdFLCtCQUErQjtBQUM1ZCwyREFBMkQsK0JBQStCLGlCQUFpQixzQ0FBc0MsWUFBWSxZQUFZLHVCQUF1QixPQUFPLHFCQUFxQiwwQ0FBMEMsNkJBQTZCO0FBQ25TLHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsOEJBQThCLG1KQUFtSixxRUFBcUUsS0FBSztBQUM1YSxrREFBa0QsMENBQTBDO0FBQzVGLDRDQUE0QyxnQkFBZ0Isa0JB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Q0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSwyQkFBMkI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2xpY2svbGliL2lubmVyLXNsaWRlci5qcz8zZmRlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Jbm5lclNsaWRlciA9IHZvaWQgMDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2luaXRpYWxTdGF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaW5pdGlhbC1zdGF0ZVwiKSk7XG52YXIgX2xvZGFzaCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC5kZWJvdW5jZVwiKSk7XG52YXIgX2NsYXNzbmFtZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbGFzc25hbWVzXCIpKTtcbnZhciBfaW5uZXJTbGlkZXJVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzL2lubmVyU2xpZGVyVXRpbHNcIik7XG52YXIgX3RyYWNrID0gcmVxdWlyZShcIi4vdHJhY2tcIik7XG52YXIgX2RvdHMgPSByZXF1aXJlKFwiLi9kb3RzXCIpO1xudmFyIF9hcnJvd3MgPSByZXF1aXJlKFwiLi9hcnJvd3NcIik7XG52YXIgX3Jlc2l6ZU9ic2VydmVyUG9seWZpbGwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZXNpemUtb2JzZXJ2ZXItcG9seWZpbGxcIikpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogU3RyaW5nKGkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIElubmVyU2xpZGVyID0gZXhwb3J0cy5Jbm5lclNsaWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoSW5uZXJTbGlkZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKElubmVyU2xpZGVyKTtcbiAgZnVuY3Rpb24gSW5uZXJTbGlkZXIocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElubmVyU2xpZGVyKTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwibGlzdFJlZkhhbmRsZXJcIiwgZnVuY3Rpb24gKHJlZikge1xuICAgICAgcmV0dXJuIF90aGlzLmxpc3QgPSByZWY7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInRyYWNrUmVmSGFuZGxlclwiLCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICByZXR1cm4gX3RoaXMudHJhY2sgPSByZWY7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImFkYXB0SGVpZ2h0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5hZGFwdGl2ZUhlaWdodCAmJiBfdGhpcy5saXN0KSB7XG4gICAgICAgIHZhciBlbGVtID0gX3RoaXMubGlzdC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtaW5kZXg9XFxcIlwiLmNvbmNhdChfdGhpcy5zdGF0ZS5jdXJyZW50U2xpZGUsIFwiXFxcIl1cIikpO1xuICAgICAgICBfdGhpcy5saXN0LnN0eWxlLmhlaWdodCA9ICgwLCBfaW5uZXJTbGlkZXJVdGlscy5nZXRIZWlnaHQpKGVsZW0pICsgXCJweFwiO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJjb21wb25lbnREaWRNb3VudFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5wcm9wcy5vbkluaXQgJiYgX3RoaXMucHJvcHMub25Jbml0KCk7XG4gICAgICBpZiAoX3RoaXMucHJvcHMubGF6eUxvYWQpIHtcbiAgICAgICAgdmFyIHNsaWRlc1RvTG9hZCA9ICgwLCBfaW5uZXJTbGlkZXJVdGlscy5nZXRPbkRlbWFuZExhenlTbGlkZXMpKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX3RoaXMucHJvcHMpLCBfdGhpcy5zdGF0ZSkpO1xuICAgICAgICBpZiAoc2xpZGVzVG9Mb2FkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAocHJldlN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBsYXp5TG9hZGVkTGlzdDogcHJldlN0YXRlLmxhenlMb2FkZWRMaXN0LmNvbmNhdChzbGlkZXNUb0xvYWQpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkxhenlMb2FkKSB7XG4gICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkxhenlMb2FkKHNsaWRlc1RvTG9hZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgc3BlYyA9IF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBsaXN0UmVmOiBfdGhpcy5saXN0LFxuICAgICAgICB0cmFja1JlZjogX3RoaXMudHJhY2tcbiAgICAgIH0sIF90aGlzLnByb3BzKTtcbiAgICAgIF90aGlzLnVwZGF0ZVN0YXRlKHNwZWMsIHRydWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuYWRhcHRIZWlnaHQoKTtcbiAgICAgICAgX3RoaXMucHJvcHMuYXV0b3BsYXkgJiYgX3RoaXMuYXV0b1BsYXkoXCJ1cGRhdGVcIik7XG4gICAgICB9KTtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5sYXp5TG9hZCA9PT0gXCJwcm9ncmVzc2l2ZVwiKSB7XG4gICAgICAgIF90aGlzLmxhenlMb2FkVGltZXIgPSBzZXRJbnRlcnZhbChfdGhpcy5wcm9ncmVzc2l2ZUxhenlMb2FkLCAxMDAwKTtcbiAgICAgIH1cbiAgICAgIF90aGlzLnJvID0gbmV3IF9yZXNpemVPYnNlcnZlclBvbHlmaWxsW1wiZGVmYXVsdFwiXShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5zdGF0ZS5hbmltYXRpbmcpIHtcbiAgICAgICAgICBfdGhpcy5vbldpbmRvd1Jlc2l6ZWQoZmFsc2UpOyAvLyBkb24ndCBzZXQgdHJhY2tTdHlsZSBoZW5jZSBkb24ndCBicmVhayBhbmltYXRpb25cbiAgICAgICAgICBfdGhpcy5jYWxsYmFja1RpbWVycy5wdXNoKHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm9uV2luZG93UmVzaXplZCgpO1xuICAgICAgICAgIH0sIF90aGlzLnByb3BzLnNwZWVkKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMub25XaW5kb3dSZXNpemVkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgX3RoaXMucm8ub2JzZXJ2ZShfdGhpcy5saXN0KTtcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgJiYgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnNsaWNrLXNsaWRlXCIpLCBmdW5jdGlvbiAoc2xpZGUpIHtcbiAgICAgICAgc2xpZGUub25mb2N1cyA9IF90aGlzLnByb3BzLnBhdXNlT25Gb2N1cyA/IF90aGlzLm9uU2xpZGVGb2N1cyA6IG51bGw7XG4gICAgICAgIHNsaWRlLm9uYmx1ciA9IF90aGlzLnByb3BzLnBhdXNlT25Gb2N1cyA/IF90aGlzLm9uU2xpZGVCbHVyIDogbnVsbDtcbiAgICAgIH0pO1xuICAgICAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIF90aGlzLm9uV2luZG93UmVzaXplZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuYXR0YWNoRXZlbnQoXCJvbnJlc2l6ZVwiLCBfdGhpcy5vbldpbmRvd1Jlc2l6ZWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMuYW5pbWF0aW9uRW5kQ2FsbGJhY2spIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmFuaW1hdGlvbkVuZENhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIGlmIChfdGhpcy5sYXp5TG9hZFRpbWVyKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoX3RoaXMubGF6eUxvYWRUaW1lcik7XG4gICAgICB9XG4gICAgICBpZiAoX3RoaXMuY2FsbGJhY2tUaW1lcnMubGVuZ3RoKSB7XG4gICAgICAgIF90aGlzLmNhbGxiYWNrVGltZXJzLmZvckVhY2goZnVuY3Rpb24gKHRpbWVyKSB7XG4gICAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5jYWxsYmFja1RpbWVycyA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIF90aGlzLm9uV2luZG93UmVzaXplZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuZGV0YWNoRXZlbnQoXCJvbnJlc2l6ZVwiLCBfdGhpcy5vbldpbmRvd1Jlc2l6ZWQpO1xuICAgICAgfVxuICAgICAgaWYgKF90aGlzLmF1dG9wbGF5VGltZXIpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChfdGhpcy5hdXRvcGxheVRpbWVyKTtcbiAgICAgIH1cbiAgICAgIF90aGlzLnJvLmRpc2Nvbm5lY3QoKTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiY29tcG9uZW50RGlkVXBkYXRlXCIsIGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgIF90aGlzLmNoZWNrSW1hZ2VzTG9hZCgpO1xuICAgICAgX3RoaXMucHJvcHMub25SZUluaXQgJiYgX3RoaXMucHJvcHMub25SZUluaXQoKTtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5sYXp5TG9hZCkge1xuICAgICAgICB2YXIgc2xpZGVzVG9Mb2FkID0gKDAsIF9pbm5lclNsaWRlclV0aWxzLmdldE9uRGVtYW5kTGF6eVNsaWRlcykoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfdGhpcy5wcm9wcyksIF90aGlzLnN0YXRlKSk7XG4gICAgICAgIGlmIChzbGlkZXNUb0xvYWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChwcmV2U3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGxhenlMb2FkZWRMaXN0OiBwcmV2U3RhdGUubGF6eUxvYWRlZExpc3QuY29uY2F0KHNsaWRlc1RvTG9hZClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKF90aGlzLnByb3BzLm9uTGF6eUxvYWQpIHtcbiAgICAgICAgICAgIF90aGlzLnByb3BzLm9uTGF6eUxvYWQoc2xpZGVzVG9Mb2FkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGlmICh0aGlzLnByb3BzLm9uTGF6eUxvYWQpIHtcbiAgICAgIC8vICAgdGhpcy5wcm9wcy5vbkxhenlMb2FkKFtsZWZ0TW9zdFNsaWRlXSlcbiAgICAgIC8vIH1cbiAgICAgIF90aGlzLmFkYXB0SGVpZ2h0KCk7XG4gICAgICB2YXIgc3BlYyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGxpc3RSZWY6IF90aGlzLmxpc3QsXG4gICAgICAgIHRyYWNrUmVmOiBfdGhpcy50cmFja1xuICAgICAgfSwgX3RoaXMucHJvcHMpLCBfdGhpcy5zdGF0ZSk7XG4gICAgICB2YXIgc2V0VHJhY2tTdHlsZSA9IF90aGlzLmRpZFByb3BzQ2hhbmdlKHByZXZQcm9wcyk7XG4gICAgICBzZXRUcmFja1N0eWxlICYmIF90aGlzLnVwZGF0ZVN0YXRlKHNwZWMsIHNldFRyYWNrU3R5bGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzLnN0YXRlLmN1cnJlbnRTbGlkZSA+PSBfcmVhY3RbXCJkZWZhdWx0XCJdLkNoaWxkcmVuLmNvdW50KF90aGlzLnByb3BzLmNoaWxkcmVuKSkge1xuICAgICAgICAgIF90aGlzLmNoYW5nZVNsaWRlKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiaW5kZXhcIixcbiAgICAgICAgICAgIGluZGV4OiBfcmVhY3RbXCJkZWZhdWx0XCJdLkNoaWxkcmVuLmNvdW50KF90aGlzLnByb3BzLmNoaWxkcmVuKSAtIF90aGlzLnByb3BzLnNsaWRlc1RvU2hvdyxcbiAgICAgICAgICAgIGN1cnJlbnRTbGlkZTogX3RoaXMuc3RhdGUuY3VycmVudFNsaWRlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzLnByb3BzLmF1dG9wbGF5KSB7XG4gICAgICAgICAgX3RoaXMuYXV0b1BsYXkoXCJ1cGRhdGVcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMucGF1c2UoXCJwYXVzZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvbldpbmRvd1Jlc2l6ZWRcIiwgZnVuY3Rpb24gKHNldFRyYWNrU3R5bGUpIHtcbiAgICAgIGlmIChfdGhpcy5kZWJvdW5jZWRSZXNpemUpIF90aGlzLmRlYm91bmNlZFJlc2l6ZS5jYW5jZWwoKTtcbiAgICAgIF90aGlzLmRlYm91bmNlZFJlc2l6ZSA9ICgwLCBfbG9kYXNoW1wiZGVmYXVsdFwiXSkoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMucmVzaXplV2luZG93KHNldFRyYWNrU3R5bGUpO1xuICAgICAgfSwgNTApO1xuICAgICAgX3RoaXMuZGVib3VuY2VkUmVzaXplKCk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInJlc2l6ZVdpbmRvd1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2V0VHJhY2tTdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgICAgIHZhciBpc1RyYWNrTW91bnRlZCA9IEJvb2xlYW4oX3RoaXMudHJhY2sgJiYgX3RoaXMudHJhY2subm9kZSk7XG4gICAgICAvLyBwcmV2ZW50IHdhcm5pbmc6IHNldHRpbmcgc3RhdGUgb24gdW5tb3VudGVkIGNvbXBvbmVudCAoc2VydmVyIHNpZGUgcmVuZGVyaW5nKVxuICAgICAgaWYgKCFpc1RyYWNrTW91bnRlZCkgcmV0dXJuO1xuICAgICAgdmFyIHNwZWMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBsaXN0UmVmOiBfdGhpcy5saXN0LFxuICAgICAgICB0cmFja1JlZjogX3RoaXMudHJhY2tcbiAgICAgIH0sIF90aGlzLnByb3BzKSwgX3RoaXMuc3RhdGUpO1xuICAgICAgX3RoaXMudXBkYXRlU3RhdGUoc3BlYywgc2V0VHJhY2tTdHlsZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMucHJvcHMuYXV0b3BsYXkpIF90aGlzLmF1dG9QbGF5KFwidXBkYXRlXCIpO2Vsc2UgX3RoaXMucGF1c2UoXCJwYXVzZWRcIik7XG4gICAgICB9KTtcbiAgICAgIC8vIGFuaW1hdGluZyBzdGF0ZSBzaG91bGQgYmUgY2xlYXJlZCB3aGlsZSByZXNpemluZywgb3RoZXJ3aXNlIGF1dG9wbGF5IHN0b3BzIHdvcmtpbmdcbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgYW5pbWF0aW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBjbGVhclRpbWVvdXQoX3RoaXMuYW5pbWF0aW9uRW5kQ2FsbGJhY2spO1xuICAgICAgZGVsZXRlIF90aGlzLmFuaW1hdGlvbkVuZENhbGxiYWNrO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJ1cGRhdGVTdGF0ZVwiLCBmdW5jdGlvbiAoc3BlYywgc2V0VHJhY2tTdHlsZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciB1cGRhdGVkU3RhdGUgPSAoMCwgX2lubmVyU2xpZGVyVXRpbHMuaW5pdGlhbGl6ZWRTdGF0ZSkoc3BlYyk7XG4gICAgICBzcGVjID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHNwZWMpLCB1cGRhdGVkU3RhdGUpLCB7fSwge1xuICAgICAgICBzbGlkZUluZGV4OiB1cGRhdGVkU3RhdGUuY3VycmVudFNsaWRlXG4gICAgICB9KTtcbiAgICAgIHZhciB0YXJnZXRMZWZ0ID0gKDAsIF9pbm5lclNsaWRlclV0aWxzLmdldFRyYWNrTGVmdCkoc3BlYyk7XG4gICAgICBzcGVjID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzcGVjKSwge30sIHtcbiAgICAgICAgbGVmdDogdGFyZ2V0TGVmdFxuICAgICAgfSk7XG4gICAgICB2YXIgdHJhY2tTdHlsZSA9ICgwLCBfaW5uZXJTbGlkZXJVdGlscy5nZXRUcmFja0NTUykoc3BlYyk7XG4gICAgICBpZiAoc2V0VHJhY2tTdHlsZSB8fCBfcmVhY3RbXCJkZWZhdWx0XCJdLkNoaWxkcmVuLmNvdW50KF90aGlzLnByb3BzLmNoaWxkcmVuKSAhPT0gX3JlYWN0W1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5jb3VudChzcGVjLmNoaWxkcmVuKSkge1xuICAgICAgICB1cGRhdGVkU3RhdGVbXCJ0cmFja1N0eWxlXCJdID0gdHJhY2tTdHlsZTtcbiAgICAgIH1cbiAgICAgIF90aGlzLnNldFN0YXRlKHVwZGF0ZWRTdGF0ZSwgY2FsbGJhY2spO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzc3JJbml0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy52YXJpYWJsZVdpZHRoKSB7XG4gICAgICAgIHZhciBfdHJhY2tXaWR0aCA9IDAsXG4gICAgICAgICAgX3RyYWNrTGVmdCA9IDA7XG4gICAgICAgIHZhciBjaGlsZHJlbldpZHRocyA9IFtdO1xuICAgICAgICB2YXIgcHJlQ2xvbmVzID0gKDAsIF9pbm5lclNsaWRlclV0aWxzLmdldFByZUNsb25lcykoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIF90aGlzLnByb3BzKSwgX3RoaXMuc3RhdGUpLCB7fSwge1xuICAgICAgICAgIHNsaWRlQ291bnQ6IF90aGlzLnByb3BzLmNoaWxkcmVuLmxlbmd0aFxuICAgICAgICB9KSk7XG4gICAgICAgIHZhciBwb3N0Q2xvbmVzID0gKDAsIF9pbm5lclNsaWRlclV0aWxzLmdldFBvc3RDbG9uZXMpKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfdGhpcy5wcm9wcyksIF90aGlzLnN0YXRlKSwge30sIHtcbiAgICAgICAgICBzbGlkZUNvdW50OiBfdGhpcy5wcm9wcy5jaGlsZHJlbi5sZW5ndGhcbiAgICAgICAgfSkpO1xuICAgICAgICBfdGhpcy5wcm9wcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgIGNoaWxkcmVuV2lkdGhzLnB1c2goY2hpbGQucHJvcHMuc3R5bGUud2lkdGgpO1xuICAgICAgICAgIF90cmFja1dpZHRoICs9IGNoaWxkLnByb3BzLnN0eWxlLndpZHRoO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVDbG9uZXM7IGkrKykge1xuICAgICAgICAgIF90cmFja0xlZnQgKz0gY2hpbGRyZW5XaWR0aHNbY2hpbGRyZW5XaWR0aHMubGVuZ3RoIC0gMSAtIGldO1xuICAgICAgICAgIF90cmFja1dpZHRoICs9IGNoaWxkcmVuV2lkdGhzW2NoaWxkcmVuV2lkdGhzLmxlbmd0aCAtIDEgLSBpXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcG9zdENsb25lczsgX2krKykge1xuICAgICAgICAgIF90cmFja1dpZHRoICs9IGNoaWxkcmVuV2lkdGhzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBfdGhpcy5zdGF0ZS5jdXJyZW50U2xpZGU7IF9pMisrKSB7XG4gICAgICAgICAgX3RyYWNrTGVmdCArPSBjaGlsZHJlbldpZHRoc1tfaTJdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfdHJhY2tTdHlsZSA9IHtcbiAgICAgICAgICB3aWR0aDogX3RyYWNrV2lkdGggKyBcInB4XCIsXG4gICAgICAgICAgbGVmdDogLV90cmFja0xlZnQgKyBcInB4XCJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKF90aGlzLnByb3BzLmNlbnRlck1vZGUpIHtcbiAgICAgICAgICB2YXIgY3VycmVudFdpZHRoID0gXCJcIi5jb25jYXQoY2hpbGRyZW5XaWR0aHNbX3RoaXMuc3RhdGUuY3VycmVudFNsaWRlXSwgXCJweFwiKTtcbiAgICAgICAgICBfdHJhY2tTdHlsZS5sZWZ0ID0gXCJjYWxjKFwiLmNvbmNhdChfdHJhY2tTdHlsZS5sZWZ0LCBcIiArICgxMDAlIC0gXCIpLmNvbmNhdChjdXJyZW50V2lkdGgsIFwiKSAvIDIgKSBcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0cmFja1N0eWxlOiBfdHJhY2tTdHlsZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuQ291bnQgPSBfcmVhY3RbXCJkZWZhdWx0XCJdLkNoaWxkcmVuLmNvdW50KF90aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgICAgIHZhciBzcGVjID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIF90aGlzLnByb3BzKSwgX3RoaXMuc3RhdGUpLCB7fSwge1xuICAgICAgICBzbGlkZUNvdW50OiBjaGlsZHJlbkNvdW50XG4gICAgICB9KTtcbiAgICAgIHZhciBzbGlkZUNvdW50ID0gKDAsIF9pbm5lclNsaWRlclV0aWxzLmdldFByZUNsb25lcykoc3BlYykgKyAoMCwgX2lubmVyU2xpZGVyVXRpbHMuZ2V0UG9zdENsb25lcykoc3BlYykgKyBjaGlsZHJlbkNvdW50O1xuICAgICAgdmFyIHRyYWNrV2lkdGggPSAxMDAgLyBfdGhpcy5wcm9wcy5zbGlkZXNUb1Nob3cgKiBzbGlkZUNvdW50O1xuICAgICAgdmFyIHNsaWRlV2lkdGggPSAxMDAgLyBzbGlkZUNvdW50O1xuICAgICAgdmFyIHRyYWNrTGVmdCA9IC1zbGlkZVdpZHRoICogKCgwLCBfaW5uZXJTbGlkZXJVdGlscy5nZXRQcmVDbG9uZXMpKHNwZWMpICsgX3RoaXMuc3RhdGUuY3VycmVudFNsaWRlKSAqIHRyYWNrV2lkdGggLyAxMDA7XG4gICAgICBpZiAoX3RoaXMucHJvcHMuY2VudGVyTW9kZSkge1xuICAgICAgICB0cmFja0xlZnQgKz0gKDEwMCAtIHNsaWRlV2lkdGggKiB0cmFja1dpZHRoIC8gMTAwKSAvIDI7XG4gICAgICB9XG4gICAgICB2YXIgdHJhY2tTdHlsZSA9IHtcbiAgICAgICAgd2lkdGg6IHRyYWNrV2lkdGggKyBcIiVcIixcbiAgICAgICAgbGVmdDogdHJhY2tMZWZ0ICsgXCIlXCJcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzbGlkZVdpZHRoOiBzbGlkZVdpZHRoICsgXCIlXCIsXG4gICAgICAgIHRyYWNrU3R5bGU6IHRyYWNrU3R5bGVcbiAgICAgIH07XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImNoZWNrSW1hZ2VzTG9hZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaW1hZ2VzID0gX3RoaXMubGlzdCAmJiBfdGhpcy5saXN0LnF1ZXJ5U2VsZWN0b3JBbGwgJiYgX3RoaXMubGlzdC5xdWVyeVNlbGVjdG9yQWxsKFwiLnNsaWNrLXNsaWRlIGltZ1wiKSB8fCBbXTtcbiAgICAgIHZhciBpbWFnZXNDb3VudCA9IGltYWdlcy5sZW5ndGgsXG4gICAgICAgIGxvYWRlZENvdW50ID0gMDtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoaW1hZ2VzLCBmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICAgIHJldHVybiArK2xvYWRlZENvdW50ICYmIGxvYWRlZENvdW50ID49IGltYWdlc0NvdW50ICYmIF90aGlzLm9uV2luZG93UmVzaXplZCgpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIWltYWdlLm9uY2xpY2spIHtcbiAgICAgICAgICBpbWFnZS5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGltYWdlLnBhcmVudE5vZGUuZm9jdXMoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2Q2xpY2tIYW5kbGVyID0gaW1hZ2Uub25jbGljaztcbiAgICAgICAgICBpbWFnZS5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHByZXZDbGlja0hhbmRsZXIoZSk7XG4gICAgICAgICAgICBpbWFnZS5wYXJlbnROb2RlLmZvY3VzKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWltYWdlLm9ubG9hZCkge1xuICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5sYXp5TG9hZCkge1xuICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpcy5hZGFwdEhlaWdodCgpO1xuICAgICAgICAgICAgICBfdGhpcy5jYWxsYmFja1RpbWVycy5wdXNoKHNldFRpbWVvdXQoX3RoaXMub25XaW5kb3dSZXNpemVkLCBfdGhpcy5wcm9wcy5zcGVlZCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gaGFuZGxlcjtcbiAgICAgICAgICAgIGltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25MYXp5TG9hZEVycm9yICYmIF90aGlzLnByb3BzLm9uTGF6eUxvYWRFcnJvcigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJwcm9ncmVzc2l2ZUxhenlMb2FkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzbGlkZXNUb0xvYWQgPSBbXTtcbiAgICAgIHZhciBzcGVjID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfdGhpcy5wcm9wcyksIF90aGlzLnN0YXRlKTtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gX3RoaXMuc3RhdGUuY3VycmVudFNsaWRlOyBpbmRleCA8IF90aGlzLnN0YXRlLnNsaWRlQ291bnQgKyAoMCwgX2lubmVyU2xpZGVyVXRpbHMuZ2V0UG9zdENsb25lcykoc3BlYyk7IGluZGV4KyspIHtcbiAgICAgICAgaWYgKF90aGlzLnN0YXRlLmxhenlMb2FkZWRMaXN0LmluZGV4T2YoaW5kZXgpIDwgMCkge1xuICAgICAgICAgIHNsaWRlc1RvTG9hZC5wdXNoKGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2luZGV4ID0gX3RoaXMuc3RhdGUuY3VycmVudFNsaWRlIC0gMTsgX2luZGV4ID49IC0oMCwgX2lubmVyU2xpZGVyVXRpbHMuZ2V0UHJlQ2xvbmVzKShzcGVjKTsgX2luZGV4LS0pIHtcbiAgICAgICAgaWYgKF90aGlzLnN0YXRlLmxhenlMb2FkZWRMaXN0LmluZGV4T2YoX2luZGV4KSA8IDApIHtcbiAgICAgICAgICBzbGlkZXNUb0xvYWQucHVzaChfaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2xpZGVzVG9Mb2FkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhenlMb2FkZWRMaXN0OiBzdGF0ZS5sYXp5TG9hZGVkTGlzdC5jb25jYXQoc2xpZGVzVG9Mb2FkKVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoX3RoaXMucHJvcHMub25MYXp5TG9hZCkge1xuICAgICAgICAgIF90aGlzLnByb3BzLm9uTGF6eUxvYWQoc2xpZGVzVG9Mb2FkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKF90aGlzLmxhenlMb2FkVGltZXIpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKF90aGlzLmxhenlMb2FkVGltZXIpO1xuICAgICAgICAgIGRlbGV0ZSBfdGhpcy5sYXp5TG9hZFRpbWVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInNsaWRlSGFuZGxlclwiLCBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHZhciBkb250QW5pbWF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgYXNOYXZGb3IgPSBfdGhpcyRwcm9wcy5hc05hdkZvcixcbiAgICAgICAgYmVmb3JlQ2hhbmdlID0gX3RoaXMkcHJvcHMuYmVmb3JlQ2hhbmdlLFxuICAgICAgICBvbkxhenlMb2FkID0gX3RoaXMkcHJvcHMub25MYXp5TG9hZCxcbiAgICAgICAgc3BlZWQgPSBfdGhpcyRwcm9wcy5zcGVlZCxcbiAgICAgICAgYWZ0ZXJDaGFuZ2UgPSBfdGhpcyRwcm9wcy5hZnRlckNoYW5nZTsgLy8gY2FwdHVyZSBjdXJyZW50c2xpZGUgYmVmb3JlIHN0YXRlIGlzIHVwZGF0ZWRcbiAgICAgIHZhciBjdXJyZW50U2xpZGUgPSBfdGhpcy5zdGF0ZS5jdXJyZW50U2xpZGU7XG4gICAgICB2YXIgX3NsaWRlSGFuZGxlciA9ICgwLCBfaW5uZXJTbGlkZXJVdGlscy5zbGlkZUhhbmRsZXIpKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgfSwgX3RoaXMucHJvcHMpLCBfdGhpcy5zdGF0ZSksIHt9LCB7XG4gICAgICAgICAgdHJhY2tSZWY6IF90aGlzLnRyYWNrLFxuICAgICAgICAgIHVzZUNTUzogX3RoaXMucHJvcHMudXNlQ1NTICYmICFkb250QW5pbWF0ZVxuICAgICAgICB9KSksXG4gICAgICAgIHN0YXRlID0gX3NsaWRlSGFuZGxlci5zdGF0ZSxcbiAgICAgICAgbmV4dFN0YXRlID0gX3NsaWRlSGFuZGxlci5uZXh0U3RhdGU7XG4gICAgICBpZiAoIXN0YXRlKSByZXR1cm47XG4gICAgICBiZWZvcmVDaGFuZ2UgJiYgYmVmb3JlQ2hhbmdlKGN1cnJlbnRTbGlkZSwgc3RhdGUuY3VycmVudFNsaWRlKTtcbiAgICAgIHZhciBzbGlkZXNUb0xvYWQgPSBzdGF0ZS5sYXp5TG9hZGVkTGlzdC5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5zdGF0ZS5sYXp5TG9hZGVkTGlzdC5pbmRleE9mKHZhbHVlKSA8IDA7XG4gICAgICB9KTtcbiAgICAgIG9uTGF6eUxvYWQgJiYgc2xpZGVzVG9Mb2FkLmxlbmd0aCA+IDAgJiYgb25MYXp5TG9hZChzbGlkZXNUb0xvYWQpO1xuICAgICAgaWYgKCFfdGhpcy5wcm9wcy53YWl0Rm9yQW5pbWF0ZSAmJiBfdGhpcy5hbmltYXRpb25FbmRDYWxsYmFjaykge1xuICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMuYW5pbWF0aW9uRW5kQ2FsbGJhY2spO1xuICAgICAgICBhZnRlckNoYW5nZSAmJiBhZnRlckNoYW5nZShjdXJyZW50U2xpZGUpO1xuICAgICAgICBkZWxldGUgX3RoaXMuYW5pbWF0aW9uRW5kQ2FsbGJhY2s7XG4gICAgICB9XG4gICAgICBfdGhpcy5zZXRTdGF0ZShzdGF0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBhc05hdkZvckluZGV4IGNoZWNrIGlzIHRvIGF2b2lkIHJlY3Vyc2l2ZSBjYWxscyBvZiBzbGlkZUhhbmRsZXIgaW4gd2FpdEZvckFuaW1hdGU9ZmFsc2UgbW9kZVxuICAgICAgICBpZiAoYXNOYXZGb3IgJiYgX3RoaXMuYXNOYXZGb3JJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgICAgICBfdGhpcy5hc05hdkZvckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgYXNOYXZGb3IuaW5uZXJTbGlkZXIuc2xpZGVIYW5kbGVyKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5leHRTdGF0ZSkgcmV0dXJuO1xuICAgICAgICBfdGhpcy5hbmltYXRpb25FbmRDYWxsYmFjayA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBhbmltYXRpbmcgPSBuZXh0U3RhdGUuYW5pbWF0aW5nLFxuICAgICAgICAgICAgZmlyc3RCYXRjaCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhuZXh0U3RhdGUsIFtcImFuaW1hdGluZ1wiXSk7XG4gICAgICAgICAgX3RoaXMuc2V0U3RhdGUoZmlyc3RCYXRjaCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY2FsbGJhY2tUaW1lcnMucHVzaChzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBhbmltYXRpbmc6IGFuaW1hdGluZ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIDEwKSk7XG4gICAgICAgICAgICBhZnRlckNoYW5nZSAmJiBhZnRlckNoYW5nZShzdGF0ZS5jdXJyZW50U2xpZGUpO1xuICAgICAgICAgICAgZGVsZXRlIF90aGlzLmFuaW1hdGlvbkVuZENhbGxiYWNrO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBzcGVlZCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiY2hhbmdlU2xpZGVcIiwgZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHZhciBkb250QW5pbWF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgc3BlYyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX3RoaXMucHJvcHMpLCBfdGhpcy5zdGF0ZSk7XG4gICAgICB2YXIgdGFyZ2V0U2xpZGUgPSAoMCwgX2lubmVyU2xpZGVyVXRpbHMuY2hhbmdlU2xpZGUpKHNwZWMsIG9wdGlvbnMpO1xuICAgICAgaWYgKHRhcmdldFNsaWRlICE9PSAwICYmICF0YXJnZXRTbGlkZSkgcmV0dXJuO1xuICAgICAgaWYgKGRvbnRBbmltYXRlID09PSB0cnVlKSB7XG4gICAgICAgIF90aGlzLnNsaWRlSGFuZGxlcih0YXJnZXRTbGlkZSwgZG9udEFuaW1hdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuc2xpZGVIYW5kbGVyKHRhcmdldFNsaWRlKTtcbiAgICAgIH1cbiAgICAgIF90aGlzLnByb3BzLmF1dG9wbGF5ICYmIF90aGlzLmF1dG9QbGF5KFwidXBkYXRlXCIpO1xuICAgICAgaWYgKF90aGlzLnByb3BzLmZvY3VzT25TZWxlY3QpIHtcbiAgICAgICAgdmFyIG5vZGVzID0gX3RoaXMubGlzdC5xdWVyeVNlbGVjdG9yQWxsKFwiLnNsaWNrLWN1cnJlbnRcIik7XG4gICAgICAgIG5vZGVzWzBdICYmIG5vZGVzWzBdLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImNsaWNrSGFuZGxlclwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKF90aGlzLmNsaWNrYWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgX3RoaXMuY2xpY2thYmxlID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwia2V5SGFuZGxlclwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGRpciA9ICgwLCBfaW5uZXJTbGlkZXJVdGlscy5rZXlIYW5kbGVyKShlLCBfdGhpcy5wcm9wcy5hY2Nlc3NpYmlsaXR5LCBfdGhpcy5wcm9wcy5ydGwpO1xuICAgICAgZGlyICE9PSBcIlwiICYmIF90aGlzLmNoYW5nZVNsaWRlKHtcbiAgICAgICAgbWVzc2FnZTogZGlyXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic2VsZWN0SGFuZGxlclwiLCBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgX3RoaXMuY2hhbmdlU2xpZGUob3B0aW9ucyk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImRpc2FibGVCb2R5U2Nyb2xsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGUpIHtcbiAgICAgICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICB9O1xuICAgICAgd2luZG93Lm9udG91Y2htb3ZlID0gcHJldmVudERlZmF1bHQ7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImVuYWJsZUJvZHlTY3JvbGxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgd2luZG93Lm9udG91Y2htb3ZlID0gbnVsbDtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic3dpcGVTdGFydFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKF90aGlzLnByb3BzLnZlcnRpY2FsU3dpcGluZykge1xuICAgICAgICBfdGhpcy5kaXNhYmxlQm9keVNjcm9sbCgpO1xuICAgICAgfVxuICAgICAgdmFyIHN0YXRlID0gKDAsIF9pbm5lclNsaWRlclV0aWxzLnN3aXBlU3RhcnQpKGUsIF90aGlzLnByb3BzLnN3aXBlLCBfdGhpcy5wcm9wcy5kcmFnZ2FibGUpO1xuICAgICAgc3RhdGUgIT09IFwiXCIgJiYgX3RoaXMuc2V0U3RhdGUoc3RhdGUpO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzd2lwZU1vdmVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBzdGF0ZSA9ICgwLCBfaW5uZXJTbGlkZXJVdGlscy5zd2lwZU1vdmUpKGUsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfdGhpcy5wcm9wcyksIF90aGlzLnN0YXRlKSwge30sIHtcbiAgICAgICAgdHJhY2tSZWY6IF90aGlzLnRyYWNrLFxuICAgICAgICBsaXN0UmVmOiBfdGhpcy5saXN0LFxuICAgICAgICBzbGlkZUluZGV4OiBfdGhpcy5zdGF0ZS5jdXJyZW50U2xpZGVcbiAgICAgIH0pKTtcbiAgICAgIGlmICghc3RhdGUpIHJldHVybjtcbiAgICAgIGlmIChzdGF0ZVtcInN3aXBpbmdcIl0pIHtcbiAgICAgICAgX3RoaXMuY2xpY2thYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBfdGhpcy5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInN3aXBlRW5kXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgc3RhdGUgPSAoMCwgX2lubmVyU2xpZGVyVXRpbHMuc3dpcGVFbmQpKGUsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfdGhpcy5wcm9wcyksIF90aGlzLnN0YXRlKSwge30sIHtcbiAgICAgICAgdHJhY2tSZWY6IF90aGlzLnRyYWNrLFxuICAgICAgICBsaXN0UmVmOiBfdGhpcy5saXN0LFxuICAgICAgICBzbGlkZUluZGV4OiBfdGhpcy5zdGF0ZS5jdXJyZW50U2xpZGVcbiAgICAgIH0pKTtcbiAgICAgIGlmICghc3RhdGUpIHJldHVybjtcbiAgICAgIHZhciB0cmlnZ2VyU2xpZGVIYW5kbGVyID0gc3RhdGVbXCJ0cmlnZ2VyU2xpZGVIYW5kbGVyXCJdO1xuICAgICAgZGVsZXRlIHN0YXRlW1widHJpZ2dlclNsaWRlSGFuZGxlclwiXTtcbiAgICAgIF90aGlzLnNldFN0YXRlKHN0YXRlKTtcbiAgICAgIGlmICh0cmlnZ2VyU2xpZGVIYW5kbGVyID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgIF90aGlzLnNsaWRlSGFuZGxlcih0cmlnZ2VyU2xpZGVIYW5kbGVyKTtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy52ZXJ0aWNhbFN3aXBpbmcpIHtcbiAgICAgICAgX3RoaXMuZW5hYmxlQm9keVNjcm9sbCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJ0b3VjaEVuZFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgX3RoaXMuc3dpcGVFbmQoZSk7XG4gICAgICBfdGhpcy5jbGlja2FibGUgPSB0cnVlO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzbGlja1ByZXZcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gdGhpcyBhbmQgZmVsbG93IG1ldGhvZHMgYXJlIHdyYXBwZWQgaW4gc2V0VGltZW91dFxuICAgICAgLy8gdG8gbWFrZSBzdXJlIGluaXRpYWxpemUgc2V0U3RhdGUgaGFzIGhhcHBlbmVkIGJlZm9yZVxuICAgICAgLy8gYW55IG9mIHN1Y2ggbWV0aG9kcyBhcmUgY2FsbGVkXG4gICAgICBfdGhpcy5jYWxsYmFja1RpbWVycy5wdXNoKHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuY2hhbmdlU2xpZGUoe1xuICAgICAgICAgIG1lc3NhZ2U6IFwicHJldmlvdXNcIlxuICAgICAgICB9KTtcbiAgICAgIH0sIDApKTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic2xpY2tOZXh0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmNhbGxiYWNrVGltZXJzLnB1c2goc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5jaGFuZ2VTbGlkZSh7XG4gICAgICAgICAgbWVzc2FnZTogXCJuZXh0XCJcbiAgICAgICAgfSk7XG4gICAgICB9LCAwKSk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInNsaWNrR29Ub1wiLCBmdW5jdGlvbiAoc2xpZGUpIHtcbiAgICAgIHZhciBkb250QW5pbWF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICBzbGlkZSA9IE51bWJlcihzbGlkZSk7XG4gICAgICBpZiAoaXNOYU4oc2xpZGUpKSByZXR1cm4gXCJcIjtcbiAgICAgIF90aGlzLmNhbGxiYWNrVGltZXJzLnB1c2goc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5jaGFuZ2VTbGlkZSh7XG4gICAgICAgICAgbWVzc2FnZTogXCJpbmRleFwiLFxuICAgICAgICAgIGluZGV4OiBzbGlkZSxcbiAgICAgICAgICBjdXJyZW50U2xpZGU6IF90aGlzLnN0YXRlLmN1cnJlbnRTbGlkZVxuICAgICAgICB9LCBkb250QW5pbWF0ZSk7XG4gICAgICB9LCAwKSk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInBsYXlcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5leHRJbmRleDtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5ydGwpIHtcbiAgICAgICAgbmV4dEluZGV4ID0gX3RoaXMuc3RhdGUuY3VycmVudFNsaWRlIC0gX3RoaXMucHJvcHMuc2xpZGVzVG9TY3JvbGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKDAsIF9pbm5lclNsaWRlclV0aWxzLmNhbkdvTmV4dCkoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfdGhpcy5wcm9wcyksIF90aGlzLnN0YXRlKSkpIHtcbiAgICAgICAgICBuZXh0SW5kZXggPSBfdGhpcy5zdGF0ZS5jdXJyZW50U2xpZGUgKyBfdGhpcy5wcm9wcy5zbGlkZXNUb1Njcm9sbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF90aGlzLnNsaWRlSGFuZGxlcihuZXh0SW5kZXgpO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJhdXRvUGxheVwiLCBmdW5jdGlvbiAocGxheVR5cGUpIHtcbiAgICAgIGlmIChfdGhpcy5hdXRvcGxheVRpbWVyKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoX3RoaXMuYXV0b3BsYXlUaW1lcik7XG4gICAgICB9XG4gICAgICB2YXIgYXV0b3BsYXlpbmcgPSBfdGhpcy5zdGF0ZS5hdXRvcGxheWluZztcbiAgICAgIGlmIChwbGF5VHlwZSA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgICBpZiAoYXV0b3BsYXlpbmcgPT09IFwiaG92ZXJlZFwiIHx8IGF1dG9wbGF5aW5nID09PSBcImZvY3VzZWRcIiB8fCBhdXRvcGxheWluZyA9PT0gXCJwYXVzZWRcIikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwbGF5VHlwZSA9PT0gXCJsZWF2ZVwiKSB7XG4gICAgICAgIGlmIChhdXRvcGxheWluZyA9PT0gXCJwYXVzZWRcIiB8fCBhdXRvcGxheWluZyA9PT0gXCJmb2N1c2VkXCIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGxheVR5cGUgPT09IFwiYmx1clwiKSB7XG4gICAgICAgIGlmIChhdXRvcGxheWluZyA9PT0gXCJwYXVzZWRcIiB8fCBhdXRvcGxheWluZyA9PT0gXCJob3ZlcmVkXCIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF90aGlzLmF1dG9wbGF5VGltZXIgPSBzZXRJbnRlcnZhbChfdGhpcy5wbGF5LCBfdGhpcy5wcm9wcy5hdXRvcGxheVNwZWVkICsgNTApO1xuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBhdXRvcGxheWluZzogXCJwbGF5aW5nXCJcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJwYXVzZVwiLCBmdW5jdGlvbiAocGF1c2VUeXBlKSB7XG4gICAgICBpZiAoX3RoaXMuYXV0b3BsYXlUaW1lcikge1xuICAgICAgICBjbGVhckludGVydmFsKF90aGlzLmF1dG9wbGF5VGltZXIpO1xuICAgICAgICBfdGhpcy5hdXRvcGxheVRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBhdXRvcGxheWluZyA9IF90aGlzLnN0YXRlLmF1dG9wbGF5aW5nO1xuICAgICAgaWYgKHBhdXNlVHlwZSA9PT0gXCJwYXVzZWRcIikge1xuICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgYXV0b3BsYXlpbmc6IFwicGF1c2VkXCJcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHBhdXNlVHlwZSA9PT0gXCJmb2N1c2VkXCIpIHtcbiAgICAgICAgaWYgKGF1dG9wbGF5aW5nID09PSBcImhvdmVyZWRcIiB8fCBhdXRvcGxheWluZyA9PT0gXCJwbGF5aW5nXCIpIHtcbiAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBhdXRvcGxheWluZzogXCJmb2N1c2VkXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcGF1c2VUeXBlICBpcyAnaG92ZXJlZCdcbiAgICAgICAgaWYgKGF1dG9wbGF5aW5nID09PSBcInBsYXlpbmdcIikge1xuICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGF1dG9wbGF5aW5nOiBcImhvdmVyZWRcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uRG90c092ZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnByb3BzLmF1dG9wbGF5ICYmIF90aGlzLnBhdXNlKFwiaG92ZXJlZFwiKTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25Eb3RzTGVhdmVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnByb3BzLmF1dG9wbGF5ICYmIF90aGlzLnN0YXRlLmF1dG9wbGF5aW5nID09PSBcImhvdmVyZWRcIiAmJiBfdGhpcy5hdXRvUGxheShcImxlYXZlXCIpO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvblRyYWNrT3ZlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMucHJvcHMuYXV0b3BsYXkgJiYgX3RoaXMucGF1c2UoXCJob3ZlcmVkXCIpO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvblRyYWNrTGVhdmVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnByb3BzLmF1dG9wbGF5ICYmIF90aGlzLnN0YXRlLmF1dG9wbGF5aW5nID09PSBcImhvdmVyZWRcIiAmJiBfdGhpcy5hdXRvUGxheShcImxlYXZlXCIpO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvblNsaWRlRm9jdXNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnByb3BzLmF1dG9wbGF5ICYmIF90aGlzLnBhdXNlKFwiZm9jdXNlZFwiKTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25TbGlkZUJsdXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnByb3BzLmF1dG9wbGF5ICYmIF90aGlzLnN0YXRlLmF1dG9wbGF5aW5nID09PSBcImZvY3VzZWRcIiAmJiBfdGhpcy5hdXRvUGxheShcImJsdXJcIik7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInJlbmRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2xhc3NOYW1lID0gKDAsIF9jbGFzc25hbWVzW1wiZGVmYXVsdFwiXSkoXCJzbGljay1zbGlkZXJcIiwgX3RoaXMucHJvcHMuY2xhc3NOYW1lLCB7XG4gICAgICAgIFwic2xpY2stdmVydGljYWxcIjogX3RoaXMucHJvcHMudmVydGljYWwsXG4gICAgICAgIFwic2xpY2staW5pdGlhbGl6ZWRcIjogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB2YXIgc3BlYyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX3RoaXMucHJvcHMpLCBfdGhpcy5zdGF0ZSk7XG4gICAgICB2YXIgdHJhY2tQcm9wcyA9ICgwLCBfaW5uZXJTbGlkZXJVdGlscy5leHRyYWN0T2JqZWN0KShzcGVjLCBbXCJmYWRlXCIsIFwiY3NzRWFzZVwiLCBcInNwZWVkXCIsIFwiaW5maW5pdGVcIiwgXCJjZW50ZXJNb2RlXCIsIFwiZm9jdXNPblNlbGVjdFwiLCBcImN1cnJlbnRTbGlkZVwiLCBcImxhenlMb2FkXCIsIFwibGF6eUxvYWRlZExpc3RcIiwgXCJydGxcIiwgXCJzbGlkZVdpZHRoXCIsIFwic2xpZGVIZWlnaHRcIiwgXCJsaXN0SGVpZ2h0XCIsIFwidmVydGljYWxcIiwgXCJzbGlkZXNUb1Nob3dcIiwgXCJzbGlkZXNUb1Njcm9sbFwiLCBcInNsaWRlQ291bnRcIiwgXCJ0cmFja1N0eWxlXCIsIFwidmFyaWFibGVXaWR0aFwiLCBcInVuc2xpY2tcIiwgXCJjZW50ZXJQYWRkaW5nXCIsIFwidGFyZ2V0U2xpZGVcIiwgXCJ1c2VDU1NcIl0pO1xuICAgICAgdmFyIHBhdXNlT25Ib3ZlciA9IF90aGlzLnByb3BzLnBhdXNlT25Ib3ZlcjtcbiAgICAgIHRyYWNrUHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRyYWNrUHJvcHMpLCB7fSwge1xuICAgICAgICBvbk1vdXNlRW50ZXI6IHBhdXNlT25Ib3ZlciA/IF90aGlzLm9uVHJhY2tPdmVyIDogbnVsbCxcbiAgICAgICAgb25Nb3VzZUxlYXZlOiBwYXVzZU9uSG92ZXIgPyBfdGhpcy5vblRyYWNrTGVhdmUgOiBudWxsLFxuICAgICAgICBvbk1vdXNlT3ZlcjogcGF1c2VPbkhvdmVyID8gX3RoaXMub25UcmFja092ZXIgOiBudWxsLFxuICAgICAgICBmb2N1c09uU2VsZWN0OiBfdGhpcy5wcm9wcy5mb2N1c09uU2VsZWN0ICYmIF90aGlzLmNsaWNrYWJsZSA/IF90aGlzLnNlbGVjdEhhbmRsZXIgOiBudWxsXG4gICAgICB9KTtcbiAgICAgIHZhciBkb3RzO1xuICAgICAgaWYgKF90aGlzLnByb3BzLmRvdHMgPT09IHRydWUgJiYgX3RoaXMuc3RhdGUuc2xpZGVDb3VudCA+PSBfdGhpcy5wcm9wcy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgdmFyIGRvdFByb3BzID0gKDAsIF9pbm5lclNsaWRlclV0aWxzLmV4dHJhY3RPYmplY3QpKHNwZWMsIFtcImRvdHNDbGFzc1wiLCBcInNsaWRlQ291bnRcIiwgXCJzbGlkZXNUb1Nob3dcIiwgXCJjdXJyZW50U2xpZGVcIiwgXCJzbGlkZXNUb1Njcm9sbFwiLCBcImNsaWNrSGFuZGxlclwiLCBcImNoaWxkcmVuXCIsIFwiY3VzdG9tUGFnaW5nXCIsIFwiaW5maW5pdGVcIiwgXCJhcHBlbmREb3RzXCJdKTtcbiAgICAgICAgdmFyIHBhdXNlT25Eb3RzSG92ZXIgPSBfdGhpcy5wcm9wcy5wYXVzZU9uRG90c0hvdmVyO1xuICAgICAgICBkb3RQcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZG90UHJvcHMpLCB7fSwge1xuICAgICAgICAgIGNsaWNrSGFuZGxlcjogX3RoaXMuY2hhbmdlU2xpZGUsXG4gICAgICAgICAgb25Nb3VzZUVudGVyOiBwYXVzZU9uRG90c0hvdmVyID8gX3RoaXMub25Eb3RzTGVhdmUgOiBudWxsLFxuICAgICAgICAgIG9uTW91c2VPdmVyOiBwYXVzZU9uRG90c0hvdmVyID8gX3RoaXMub25Eb3RzT3ZlciA6IG51bGwsXG4gICAgICAgICAgb25Nb3VzZUxlYXZlOiBwYXVzZU9uRG90c0hvdmVyID8gX3RoaXMub25Eb3RzTGVhdmUgOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICBkb3RzID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfZG90cy5Eb3RzLCBkb3RQcm9wcyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJldkFycm93LCBuZXh0QXJyb3c7XG4gICAgICB2YXIgYXJyb3dQcm9wcyA9ICgwLCBfaW5uZXJTbGlkZXJVdGlscy5leHRyYWN0T2JqZWN0KShzcGVjLCBbXCJpbmZpbml0ZVwiLCBcImNlbnRlck1vZGVcIiwgXCJjdXJyZW50U2xpZGVcIiwgXCJzbGlkZUNvdW50XCIsIFwic2xpZGVzVG9TaG93XCIsIFwicHJldkFycm93XCIsIFwibmV4dEFycm93XCJdKTtcbiAgICAgIGFycm93UHJvcHMuY2xpY2tIYW5kbGVyID0gX3RoaXMuY2hhbmdlU2xpZGU7XG4gICAgICBpZiAoX3RoaXMucHJvcHMuYXJyb3dzKSB7XG4gICAgICAgIHByZXZBcnJvdyA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX2Fycm93cy5QcmV2QXJyb3csIGFycm93UHJvcHMpO1xuICAgICAgICBuZXh0QXJyb3cgPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9hcnJvd3MuTmV4dEFycm93LCBhcnJvd1Byb3BzKTtcbiAgICAgIH1cbiAgICAgIHZhciB2ZXJ0aWNhbEhlaWdodFN0eWxlID0gbnVsbDtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy52ZXJ0aWNhbCkge1xuICAgICAgICB2ZXJ0aWNhbEhlaWdodFN0eWxlID0ge1xuICAgICAgICAgIGhlaWdodDogX3RoaXMuc3RhdGUubGlzdEhlaWdodFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIGNlbnRlclBhZGRpbmdTdHlsZSA9IG51bGw7XG4gICAgICBpZiAoX3RoaXMucHJvcHMudmVydGljYWwgPT09IGZhbHNlKSB7XG4gICAgICAgIGlmIChfdGhpcy5wcm9wcy5jZW50ZXJNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgY2VudGVyUGFkZGluZ1N0eWxlID0ge1xuICAgICAgICAgICAgcGFkZGluZzogXCIwcHggXCIgKyBfdGhpcy5wcm9wcy5jZW50ZXJQYWRkaW5nXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKF90aGlzLnByb3BzLmNlbnRlck1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICBjZW50ZXJQYWRkaW5nU3R5bGUgPSB7XG4gICAgICAgICAgICBwYWRkaW5nOiBfdGhpcy5wcm9wcy5jZW50ZXJQYWRkaW5nICsgXCIgMHB4XCJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbGlzdFN0eWxlID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB2ZXJ0aWNhbEhlaWdodFN0eWxlKSwgY2VudGVyUGFkZGluZ1N0eWxlKTtcbiAgICAgIHZhciB0b3VjaE1vdmUgPSBfdGhpcy5wcm9wcy50b3VjaE1vdmU7XG4gICAgICB2YXIgbGlzdFByb3BzID0ge1xuICAgICAgICBjbGFzc05hbWU6IFwic2xpY2stbGlzdFwiLFxuICAgICAgICBzdHlsZTogbGlzdFN0eWxlLFxuICAgICAgICBvbkNsaWNrOiBfdGhpcy5jbGlja0hhbmRsZXIsXG4gICAgICAgIG9uTW91c2VEb3duOiB0b3VjaE1vdmUgPyBfdGhpcy5zd2lwZVN0YXJ0IDogbnVsbCxcbiAgICAgICAgb25Nb3VzZU1vdmU6IF90aGlzLnN0YXRlLmRyYWdnaW5nICYmIHRvdWNoTW92ZSA/IF90aGlzLnN3aXBlTW92ZSA6IG51bGwsXG4gICAgICAgIG9uTW91c2VVcDogdG91Y2hNb3ZlID8gX3RoaXMuc3dpcGVFbmQgOiBudWxsLFxuICAgICAgICBvbk1vdXNlTGVhdmU6IF90aGlzLnN0YXRlLmRyYWdnaW5nICYmIHRvdWNoTW92ZSA/IF90aGlzLnN3aXBlRW5kIDogbnVsbCxcbiAgICAgICAgb25Ub3VjaFN0YXJ0OiB0b3VjaE1vdmUgPyBfdGhpcy5zd2lwZVN0YXJ0IDogbnVsbCxcbiAgICAgICAgb25Ub3VjaE1vdmU6IF90aGlzLnN0YXRlLmRyYWdnaW5nICYmIHRvdWNoTW92ZSA/IF90aGlzLnN3aXBlTW92ZSA6IG51bGwsXG4gICAgICAgIG9uVG91Y2hFbmQ6IHRvdWNoTW92ZSA/IF90aGlzLnRvdWNoRW5kIDogbnVsbCxcbiAgICAgICAgb25Ub3VjaENhbmNlbDogX3RoaXMuc3RhdGUuZHJhZ2dpbmcgJiYgdG91Y2hNb3ZlID8gX3RoaXMuc3dpcGVFbmQgOiBudWxsLFxuICAgICAgICBvbktleURvd246IF90aGlzLnByb3BzLmFjY2Vzc2liaWxpdHkgPyBfdGhpcy5rZXlIYW5kbGVyIDogbnVsbFxuICAgICAgfTtcbiAgICAgIHZhciBpbm5lclNsaWRlclByb3BzID0ge1xuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgZGlyOiBcImx0clwiLFxuICAgICAgICBzdHlsZTogX3RoaXMucHJvcHMuc3R5bGVcbiAgICAgIH07XG4gICAgICBpZiAoX3RoaXMucHJvcHMudW5zbGljaykge1xuICAgICAgICBsaXN0UHJvcHMgPSB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcInNsaWNrLWxpc3RcIlxuICAgICAgICB9O1xuICAgICAgICBpbm5lclNsaWRlclByb3BzID0ge1xuICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLCBpbm5lclNsaWRlclByb3BzLCAhX3RoaXMucHJvcHMudW5zbGljayA/IHByZXZBcnJvdyA6IFwiXCIsIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe1xuICAgICAgICByZWY6IF90aGlzLmxpc3RSZWZIYW5kbGVyXG4gICAgICB9LCBsaXN0UHJvcHMpLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF90cmFjay5UcmFjaywgX2V4dGVuZHMoe1xuICAgICAgICByZWY6IF90aGlzLnRyYWNrUmVmSGFuZGxlclxuICAgICAgfSwgdHJhY2tQcm9wcyksIF90aGlzLnByb3BzLmNoaWxkcmVuKSksICFfdGhpcy5wcm9wcy51bnNsaWNrID8gbmV4dEFycm93IDogXCJcIiwgIV90aGlzLnByb3BzLnVuc2xpY2sgPyBkb3RzIDogXCJcIik7XG4gICAgfSk7XG4gICAgX3RoaXMubGlzdCA9IG51bGw7XG4gICAgX3RoaXMudHJhY2sgPSBudWxsO1xuICAgIF90aGlzLnN0YXRlID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfaW5pdGlhbFN0YXRlW1wiZGVmYXVsdFwiXSksIHt9LCB7XG4gICAgICBjdXJyZW50U2xpZGU6IF90aGlzLnByb3BzLmluaXRpYWxTbGlkZSxcbiAgICAgIHRhcmdldFNsaWRlOiBfdGhpcy5wcm9wcy5pbml0aWFsU2xpZGUgPyBfdGhpcy5wcm9wcy5pbml0aWFsU2xpZGUgOiAwLFxuICAgICAgc2xpZGVDb3VudDogX3JlYWN0W1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5jb3VudChfdGhpcy5wcm9wcy5jaGlsZHJlbilcbiAgICB9KTtcbiAgICBfdGhpcy5jYWxsYmFja1RpbWVycyA9IFtdO1xuICAgIF90aGlzLmNsaWNrYWJsZSA9IHRydWU7XG4gICAgX3RoaXMuZGVib3VuY2VkUmVzaXplID0gbnVsbDtcbiAgICB2YXIgc3NyU3RhdGUgPSBfdGhpcy5zc3JJbml0KCk7XG4gICAgX3RoaXMuc3RhdGUgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIF90aGlzLnN0YXRlKSwgc3NyU3RhdGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfY3JlYXRlQ2xhc3MoSW5uZXJTbGlkZXIsIFt7XG4gICAga2V5OiBcImRpZFByb3BzQ2hhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpZFByb3BzQ2hhbmdlKHByZXZQcm9wcykge1xuICAgICAgdmFyIHNldFRyYWNrU3R5bGUgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIF9pMyA9IDAsIF9PYmplY3Qka2V5cyA9IE9iamVjdC5rZXlzKHRoaXMucHJvcHMpOyBfaTMgPCBfT2JqZWN0JGtleXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICB2YXIga2V5ID0gX09iamVjdCRrZXlzW19pM107XG4gICAgICAgIGlmICghcHJldlByb3BzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBzZXRUcmFja1N0eWxlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3R5cGVvZihwcmV2UHJvcHNba2V5XSkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHByZXZQcm9wc1trZXldID09PSBcImZ1bmN0aW9uXCIgfHwgaXNOYU4ocHJldlByb3BzW2tleV0pKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZQcm9wc1trZXldICE9PSB0aGlzLnByb3BzW2tleV0pIHtcbiAgICAgICAgICBzZXRUcmFja1N0eWxlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNldFRyYWNrU3R5bGUgfHwgX3JlYWN0W1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5jb3VudCh0aGlzLnByb3BzLmNoaWxkcmVuKSAhPT0gX3JlYWN0W1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5jb3VudChwcmV2UHJvcHMuY2hpbGRyZW4pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSW5uZXJTbGlkZXI7XG59KF9yZWFjdFtcImRlZmF1bHRcIl0uQ29tcG9uZW50KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-slick/lib/inner-slider.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-slick/lib/slider.js":
/*!************************************************!*\
  !*** ./node_modules/react-slick/lib/slider.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar _innerSlider = __webpack_require__(/*! ./inner-slider */ \"(app-pages-browser)/./node_modules/react-slick/lib/inner-slider.js\");\nvar _json2mq = _interopRequireDefault(__webpack_require__(/*! json2mq */ \"(app-pages-browser)/./node_modules/json2mq/index.js\"));\nvar _defaultProps = _interopRequireDefault(__webpack_require__(/*! ./default-props */ \"(app-pages-browser)/./node_modules/react-slick/lib/default-props.js\"));\nvar _innerSliderUtils = __webpack_require__(/*! ./utils/innerSliderUtils */ \"(app-pages-browser)/./node_modules/react-slick/lib/utils/innerSliderUtils.js\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar enquire = (0, _innerSliderUtils.canUseDOM)() && __webpack_require__(/*! enquire.js */ \"(app-pages-browser)/./node_modules/enquire.js/src/index.js\");\nvar Slider = exports[\"default\"] = /*#__PURE__*/function (_React$Component) {\n  _inherits(Slider, _React$Component);\n  var _super = _createSuper(Slider);\n  function Slider(props) {\n    var _this;\n    _classCallCheck(this, Slider);\n    _this = _super.call(this, props);\n    _defineProperty(_assertThisInitialized(_this), \"innerSliderRefHandler\", function (ref) {\n      return _this.innerSlider = ref;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"slickPrev\", function () {\n      return _this.innerSlider.slickPrev();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"slickNext\", function () {\n      return _this.innerSlider.slickNext();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"slickGoTo\", function (slide) {\n      var dontAnimate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return _this.innerSlider.slickGoTo(slide, dontAnimate);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"slickPause\", function () {\n      return _this.innerSlider.pause(\"paused\");\n    });\n    _defineProperty(_assertThisInitialized(_this), \"slickPlay\", function () {\n      return _this.innerSlider.autoPlay(\"play\");\n    });\n    _this.state = {\n      breakpoint: null\n    };\n    _this._responsiveMediaHandlers = [];\n    return _this;\n  }\n  _createClass(Slider, [{\n    key: \"media\",\n    value: function media(query, handler) {\n      // javascript handler for  css media query\n      enquire.register(query, handler);\n      this._responsiveMediaHandlers.push({\n        query: query,\n        handler: handler\n      });\n    } // handles responsive breakpoints\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n      // performance monitoring\n      //if (process.env.NODE_ENV !== 'production') {\n      //const { whyDidYouUpdate } = require('why-did-you-update')\n      //whyDidYouUpdate(React)\n      //}\n      if (this.props.responsive) {\n        var breakpoints = this.props.responsive.map(function (breakpt) {\n          return breakpt.breakpoint;\n        });\n        // sort them in increasing order of their numerical value\n        breakpoints.sort(function (x, y) {\n          return x - y;\n        });\n        breakpoints.forEach(function (breakpoint, index) {\n          // media query for each breakpoint\n          var bQuery;\n          if (index === 0) {\n            bQuery = (0, _json2mq[\"default\"])({\n              minWidth: 0,\n              maxWidth: breakpoint\n            });\n          } else {\n            bQuery = (0, _json2mq[\"default\"])({\n              minWidth: breakpoints[index - 1] + 1,\n              maxWidth: breakpoint\n            });\n          }\n          // when not using server side rendering\n          (0, _innerSliderUtils.canUseDOM)() && _this2.media(bQuery, function () {\n            _this2.setState({\n              breakpoint: breakpoint\n            });\n          });\n        });\n\n        // Register media query for full screen. Need to support resize from small to large\n        // convert javascript object to media query string\n        var query = (0, _json2mq[\"default\"])({\n          minWidth: breakpoints.slice(-1)[0]\n        });\n        (0, _innerSliderUtils.canUseDOM)() && this.media(query, function () {\n          _this2.setState({\n            breakpoint: null\n          });\n        });\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this._responsiveMediaHandlers.forEach(function (obj) {\n        enquire.unregister(obj.query, obj.handler);\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n      var settings;\n      var newProps;\n      if (this.state.breakpoint) {\n        newProps = this.props.responsive.filter(function (resp) {\n          return resp.breakpoint === _this3.state.breakpoint;\n        });\n        settings = newProps[0].settings === \"unslick\" ? \"unslick\" : _objectSpread(_objectSpread(_objectSpread({}, _defaultProps[\"default\"]), this.props), newProps[0].settings);\n      } else {\n        settings = _objectSpread(_objectSpread({}, _defaultProps[\"default\"]), this.props);\n      }\n\n      // force scrolling by one if centerMode is on\n      if (settings.centerMode) {\n        if (settings.slidesToScroll > 1 && \"development\" !== \"production\") {\n          console.warn(\"slidesToScroll should be equal to 1 in centerMode, you are using \".concat(settings.slidesToScroll));\n        }\n        settings.slidesToScroll = 1;\n      }\n      // force showing one slide and scrolling by one if the fade mode is on\n      if (settings.fade) {\n        if (settings.slidesToShow > 1 && \"development\" !== \"production\") {\n          console.warn(\"slidesToShow should be equal to 1 when fade is true, you're using \".concat(settings.slidesToShow));\n        }\n        if (settings.slidesToScroll > 1 && \"development\" !== \"production\") {\n          console.warn(\"slidesToScroll should be equal to 1 when fade is true, you're using \".concat(settings.slidesToScroll));\n        }\n        settings.slidesToShow = 1;\n        settings.slidesToScroll = 1;\n      }\n\n      // makes sure that children is an array, even when there is only 1 child\n      var children = _react[\"default\"].Children.toArray(this.props.children);\n\n      // Children may contain false or null, so we should filter them\n      // children may also contain string filled with spaces (in certain cases where we use jsx strings)\n      children = children.filter(function (child) {\n        if (typeof child === \"string\") {\n          return !!child.trim();\n        }\n        return !!child;\n      });\n\n      // rows and slidesPerRow logic is handled here\n      if (settings.variableWidth && (settings.rows > 1 || settings.slidesPerRow > 1)) {\n        console.warn(\"variableWidth is not supported in case of rows > 1 or slidesPerRow > 1\");\n        settings.variableWidth = false;\n      }\n      var newChildren = [];\n      var currentWidth = null;\n      for (var i = 0; i < children.length; i += settings.rows * settings.slidesPerRow) {\n        var newSlide = [];\n        for (var j = i; j < i + settings.rows * settings.slidesPerRow; j += settings.slidesPerRow) {\n          var row = [];\n          for (var k = j; k < j + settings.slidesPerRow; k += 1) {\n            if (settings.variableWidth && children[k].props.style) {\n              currentWidth = children[k].props.style.width;\n            }\n            if (k >= children.length) break;\n            row.push( /*#__PURE__*/_react[\"default\"].cloneElement(children[k], {\n              key: 100 * i + 10 * j + k,\n              tabIndex: -1,\n              style: {\n                width: \"\".concat(100 / settings.slidesPerRow, \"%\"),\n                display: \"inline-block\"\n              }\n            }));\n          }\n          newSlide.push( /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            key: 10 * i + j\n          }, row));\n        }\n        if (settings.variableWidth) {\n          newChildren.push( /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            key: i,\n            style: {\n              width: currentWidth\n            }\n          }, newSlide));\n        } else {\n          newChildren.push( /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            key: i\n          }, newSlide));\n        }\n      }\n      if (settings === \"unslick\") {\n        var className = \"regular slider \" + (this.props.className || \"\");\n        return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: className\n        }, children);\n      } else if (newChildren.length <= settings.slidesToShow && !settings.infinite) {\n        settings.unslick = true;\n      }\n      return /*#__PURE__*/_react[\"default\"].createElement(_innerSlider.InnerSlider, _extends({\n        style: this.props.style,\n        ref: this.innerSliderRefHandler\n      }, (0, _innerSliderUtils.filterSettings)(settings)), newChildren);\n    }\n  }]);\n  return Slider;\n}(_react[\"default\"].Component);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvc2xpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFrQjtBQUNsQixvQ0FBb0MsbUJBQU8sQ0FBQyxtRkFBTztBQUNuRCxtQkFBbUIsbUJBQU8sQ0FBQywwRkFBZ0I7QUFDM0Msc0NBQXNDLG1CQUFPLENBQUMsb0VBQVM7QUFDdkQsMkNBQTJDLG1CQUFPLENBQUMsNEZBQWlCO0FBQ3BFLHdCQUF3QixtQkFBTyxDQUFDLDhHQUEwQjtBQUMxRCx1Q0FBdUMsdUNBQXVDO0FBQzlFLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLHNCQUFzQixzRUFBc0UsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELGlDQUFpQyxrQkFBa0I7QUFDMVMseUJBQXlCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3BQLDRCQUE0QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHNEQUFzRCw4QkFBOEIsbUpBQW1KLHFFQUFxRSxLQUFLO0FBQzVhLGtEQUFrRCwwQ0FBMEM7QUFDNUYsNENBQTRDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQ7QUFDL1AsOERBQThELHNFQUFzRSw4REFBOEQsa0RBQWtELGlCQUFpQixHQUFHO0FBQ3hRLDJDQUEyQywrREFBK0QsNkVBQTZFLHlFQUF5RSxlQUFlLHVEQUF1RCxHQUFHLCtDQUErQyxpQkFBaUIsR0FBRztBQUM1WSxpQ0FBaUMsMEdBQTBHLGlCQUFpQixhQUFhO0FBQ3pLLGlDQUFpQyw2REFBNkQseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELDJEQUEyRCxPQUFPLHlDQUF5QztBQUNwWCxrREFBa0QsMEVBQTBFLGVBQWUsNEJBQTRCLG1GQUFtRjtBQUMxUCx3Q0FBd0MsdUJBQXVCLHlGQUF5RjtBQUN4Six1Q0FBdUMsTUFBTSxxRkFBcUYsTUFBTSxhQUFhLDJFQUEyRSxhQUFhO0FBQzdPLDhCQUE4Qix1R0FBdUcsbURBQW1EO0FBQ3hMLDRDQUE0QywyQkFBMkIsa0JBQWtCLGtDQUFrQyxvRUFBb0UsS0FBSyxPQUFPLG9CQUFvQjtBQUMvTiw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4Qiw0Q0FBNEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsc0NBQXNDLHVFQUF1RTtBQUM3USxvREFBb0QsbUJBQU8sQ0FBQyw4RUFBWTtBQUN4RSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0hBQWdIO0FBQ2hILFFBQVE7QUFDUixpREFBaUQ7QUFDakQ7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQyxhQUFvQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsYUFBb0I7QUFDN0Q7QUFDQTtBQUNBLDJDQUEyQyxhQUFvQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBLHdCQUF3QiwrQ0FBK0M7QUFDdkU7QUFDQSwwQkFBMEIsK0JBQStCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXNsaWNrL2xpYi9zbGlkZXIuanM/ZDY5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfaW5uZXJTbGlkZXIgPSByZXF1aXJlKFwiLi9pbm5lci1zbGlkZXJcIik7XG52YXIgX2pzb24ybXEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJqc29uMm1xXCIpKTtcbnZhciBfZGVmYXVsdFByb3BzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9kZWZhdWx0LXByb3BzXCIpKTtcbnZhciBfaW5uZXJTbGlkZXJVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzL2lubmVyU2xpZGVyVXRpbHNcIik7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogU3RyaW5nKGkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIGVucXVpcmUgPSAoMCwgX2lubmVyU2xpZGVyVXRpbHMuY2FuVXNlRE9NKSgpICYmIHJlcXVpcmUoXCJlbnF1aXJlLmpzXCIpO1xudmFyIFNsaWRlciA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhTbGlkZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFNsaWRlcik7XG4gIGZ1bmN0aW9uIFNsaWRlcihwcm9wcykge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2xpZGVyKTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiaW5uZXJTbGlkZXJSZWZIYW5kbGVyXCIsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIHJldHVybiBfdGhpcy5pbm5lclNsaWRlciA9IHJlZjtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic2xpY2tQcmV2XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5pbm5lclNsaWRlci5zbGlja1ByZXYoKTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic2xpY2tOZXh0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5pbm5lclNsaWRlci5zbGlja05leHQoKTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic2xpY2tHb1RvXCIsIGZ1bmN0aW9uIChzbGlkZSkge1xuICAgICAgdmFyIGRvbnRBbmltYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHJldHVybiBfdGhpcy5pbm5lclNsaWRlci5zbGlja0dvVG8oc2xpZGUsIGRvbnRBbmltYXRlKTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic2xpY2tQYXVzZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuaW5uZXJTbGlkZXIucGF1c2UoXCJwYXVzZWRcIik7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInNsaWNrUGxheVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuaW5uZXJTbGlkZXIuYXV0b1BsYXkoXCJwbGF5XCIpO1xuICAgIH0pO1xuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgYnJlYWtwb2ludDogbnVsbFxuICAgIH07XG4gICAgX3RoaXMuX3Jlc3BvbnNpdmVNZWRpYUhhbmRsZXJzID0gW107XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhTbGlkZXIsIFt7XG4gICAga2V5OiBcIm1lZGlhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lZGlhKHF1ZXJ5LCBoYW5kbGVyKSB7XG4gICAgICAvLyBqYXZhc2NyaXB0IGhhbmRsZXIgZm9yICBjc3MgbWVkaWEgcXVlcnlcbiAgICAgIGVucXVpcmUucmVnaXN0ZXIocXVlcnksIGhhbmRsZXIpO1xuICAgICAgdGhpcy5fcmVzcG9uc2l2ZU1lZGlhSGFuZGxlcnMucHVzaCh7XG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgaGFuZGxlcjogaGFuZGxlclxuICAgICAgfSk7XG4gICAgfSAvLyBoYW5kbGVzIHJlc3BvbnNpdmUgYnJlYWtwb2ludHNcbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgLy8gcGVyZm9ybWFuY2UgbW9uaXRvcmluZ1xuICAgICAgLy9pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy9jb25zdCB7IHdoeURpZFlvdVVwZGF0ZSB9ID0gcmVxdWlyZSgnd2h5LWRpZC15b3UtdXBkYXRlJylcbiAgICAgIC8vd2h5RGlkWW91VXBkYXRlKFJlYWN0KVxuICAgICAgLy99XG4gICAgICBpZiAodGhpcy5wcm9wcy5yZXNwb25zaXZlKSB7XG4gICAgICAgIHZhciBicmVha3BvaW50cyA9IHRoaXMucHJvcHMucmVzcG9uc2l2ZS5tYXAoZnVuY3Rpb24gKGJyZWFrcHQpIHtcbiAgICAgICAgICByZXR1cm4gYnJlYWtwdC5icmVha3BvaW50O1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gc29ydCB0aGVtIGluIGluY3JlYXNpbmcgb3JkZXIgb2YgdGhlaXIgbnVtZXJpY2FsIHZhbHVlXG4gICAgICAgIGJyZWFrcG9pbnRzLnNvcnQoZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICByZXR1cm4geCAtIHk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVha3BvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChicmVha3BvaW50LCBpbmRleCkge1xuICAgICAgICAgIC8vIG1lZGlhIHF1ZXJ5IGZvciBlYWNoIGJyZWFrcG9pbnRcbiAgICAgICAgICB2YXIgYlF1ZXJ5O1xuICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgYlF1ZXJ5ID0gKDAsIF9qc29uMm1xW1wiZGVmYXVsdFwiXSkoe1xuICAgICAgICAgICAgICBtaW5XaWR0aDogMCxcbiAgICAgICAgICAgICAgbWF4V2lkdGg6IGJyZWFrcG9pbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiUXVlcnkgPSAoMCwgX2pzb24ybXFbXCJkZWZhdWx0XCJdKSh7XG4gICAgICAgICAgICAgIG1pbldpZHRoOiBicmVha3BvaW50c1tpbmRleCAtIDFdICsgMSxcbiAgICAgICAgICAgICAgbWF4V2lkdGg6IGJyZWFrcG9pbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3aGVuIG5vdCB1c2luZyBzZXJ2ZXIgc2lkZSByZW5kZXJpbmdcbiAgICAgICAgICAoMCwgX2lubmVyU2xpZGVyVXRpbHMuY2FuVXNlRE9NKSgpICYmIF90aGlzMi5tZWRpYShiUXVlcnksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMi5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgIGJyZWFrcG9pbnQ6IGJyZWFrcG9pbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZWdpc3RlciBtZWRpYSBxdWVyeSBmb3IgZnVsbCBzY3JlZW4uIE5lZWQgdG8gc3VwcG9ydCByZXNpemUgZnJvbSBzbWFsbCB0byBsYXJnZVxuICAgICAgICAvLyBjb252ZXJ0IGphdmFzY3JpcHQgb2JqZWN0IHRvIG1lZGlhIHF1ZXJ5IHN0cmluZ1xuICAgICAgICB2YXIgcXVlcnkgPSAoMCwgX2pzb24ybXFbXCJkZWZhdWx0XCJdKSh7XG4gICAgICAgICAgbWluV2lkdGg6IGJyZWFrcG9pbnRzLnNsaWNlKC0xKVswXVxuICAgICAgICB9KTtcbiAgICAgICAgKDAsIF9pbm5lclNsaWRlclV0aWxzLmNhblVzZURPTSkoKSAmJiB0aGlzLm1lZGlhKHF1ZXJ5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGJyZWFrcG9pbnQ6IG51bGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgdGhpcy5fcmVzcG9uc2l2ZU1lZGlhSGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGVucXVpcmUudW5yZWdpc3RlcihvYmoucXVlcnksIG9iai5oYW5kbGVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgc2V0dGluZ3M7XG4gICAgICB2YXIgbmV3UHJvcHM7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5icmVha3BvaW50KSB7XG4gICAgICAgIG5ld1Byb3BzID0gdGhpcy5wcm9wcy5yZXNwb25zaXZlLmZpbHRlcihmdW5jdGlvbiAocmVzcCkge1xuICAgICAgICAgIHJldHVybiByZXNwLmJyZWFrcG9pbnQgPT09IF90aGlzMy5zdGF0ZS5icmVha3BvaW50O1xuICAgICAgICB9KTtcbiAgICAgICAgc2V0dGluZ3MgPSBuZXdQcm9wc1swXS5zZXR0aW5ncyA9PT0gXCJ1bnNsaWNrXCIgPyBcInVuc2xpY2tcIiA6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfZGVmYXVsdFByb3BzW1wiZGVmYXVsdFwiXSksIHRoaXMucHJvcHMpLCBuZXdQcm9wc1swXS5zZXR0aW5ncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXR0aW5ncyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX2RlZmF1bHRQcm9wc1tcImRlZmF1bHRcIl0pLCB0aGlzLnByb3BzKTtcbiAgICAgIH1cblxuICAgICAgLy8gZm9yY2Ugc2Nyb2xsaW5nIGJ5IG9uZSBpZiBjZW50ZXJNb2RlIGlzIG9uXG4gICAgICBpZiAoc2V0dGluZ3MuY2VudGVyTW9kZSkge1xuICAgICAgICBpZiAoc2V0dGluZ3Muc2xpZGVzVG9TY3JvbGwgPiAxICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcInNsaWRlc1RvU2Nyb2xsIHNob3VsZCBiZSBlcXVhbCB0byAxIGluIGNlbnRlck1vZGUsIHlvdSBhcmUgdXNpbmcgXCIuY29uY2F0KHNldHRpbmdzLnNsaWRlc1RvU2Nyb2xsKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0dGluZ3Muc2xpZGVzVG9TY3JvbGwgPSAxO1xuICAgICAgfVxuICAgICAgLy8gZm9yY2Ugc2hvd2luZyBvbmUgc2xpZGUgYW5kIHNjcm9sbGluZyBieSBvbmUgaWYgdGhlIGZhZGUgbW9kZSBpcyBvblxuICAgICAgaWYgKHNldHRpbmdzLmZhZGUpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLnNsaWRlc1RvU2hvdyA+IDEgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwic2xpZGVzVG9TaG93IHNob3VsZCBiZSBlcXVhbCB0byAxIHdoZW4gZmFkZSBpcyB0cnVlLCB5b3UncmUgdXNpbmcgXCIuY29uY2F0KHNldHRpbmdzLnNsaWRlc1RvU2hvdykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5zbGlkZXNUb1Njcm9sbCA+IDEgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwic2xpZGVzVG9TY3JvbGwgc2hvdWxkIGJlIGVxdWFsIHRvIDEgd2hlbiBmYWRlIGlzIHRydWUsIHlvdSdyZSB1c2luZyBcIi5jb25jYXQoc2V0dGluZ3Muc2xpZGVzVG9TY3JvbGwpKTtcbiAgICAgICAgfVxuICAgICAgICBzZXR0aW5ncy5zbGlkZXNUb1Nob3cgPSAxO1xuICAgICAgICBzZXR0aW5ncy5zbGlkZXNUb1Njcm9sbCA9IDE7XG4gICAgICB9XG5cbiAgICAgIC8vIG1ha2VzIHN1cmUgdGhhdCBjaGlsZHJlbiBpcyBhbiBhcnJheSwgZXZlbiB3aGVuIHRoZXJlIGlzIG9ubHkgMSBjaGlsZFxuICAgICAgdmFyIGNoaWxkcmVuID0gX3JlYWN0W1wiZGVmYXVsdFwiXS5DaGlsZHJlbi50b0FycmF5KHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgICAvLyBDaGlsZHJlbiBtYXkgY29udGFpbiBmYWxzZSBvciBudWxsLCBzbyB3ZSBzaG91bGQgZmlsdGVyIHRoZW1cbiAgICAgIC8vIGNoaWxkcmVuIG1heSBhbHNvIGNvbnRhaW4gc3RyaW5nIGZpbGxlZCB3aXRoIHNwYWNlcyAoaW4gY2VydGFpbiBjYXNlcyB3aGVyZSB3ZSB1c2UganN4IHN0cmluZ3MpXG4gICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJldHVybiAhIWNoaWxkLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISFjaGlsZDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyByb3dzIGFuZCBzbGlkZXNQZXJSb3cgbG9naWMgaXMgaGFuZGxlZCBoZXJlXG4gICAgICBpZiAoc2V0dGluZ3MudmFyaWFibGVXaWR0aCAmJiAoc2V0dGluZ3Mucm93cyA+IDEgfHwgc2V0dGluZ3Muc2xpZGVzUGVyUm93ID4gMSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwidmFyaWFibGVXaWR0aCBpcyBub3Qgc3VwcG9ydGVkIGluIGNhc2Ugb2Ygcm93cyA+IDEgb3Igc2xpZGVzUGVyUm93ID4gMVwiKTtcbiAgICAgICAgc2V0dGluZ3MudmFyaWFibGVXaWR0aCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0NoaWxkcmVuID0gW107XG4gICAgICB2YXIgY3VycmVudFdpZHRoID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IHNldHRpbmdzLnJvd3MgKiBzZXR0aW5ncy5zbGlkZXNQZXJSb3cpIHtcbiAgICAgICAgdmFyIG5ld1NsaWRlID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSBpOyBqIDwgaSArIHNldHRpbmdzLnJvd3MgKiBzZXR0aW5ncy5zbGlkZXNQZXJSb3c7IGogKz0gc2V0dGluZ3Muc2xpZGVzUGVyUm93KSB7XG4gICAgICAgICAgdmFyIHJvdyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGsgPSBqOyBrIDwgaiArIHNldHRpbmdzLnNsaWRlc1BlclJvdzsgayArPSAxKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MudmFyaWFibGVXaWR0aCAmJiBjaGlsZHJlbltrXS5wcm9wcy5zdHlsZSkge1xuICAgICAgICAgICAgICBjdXJyZW50V2lkdGggPSBjaGlsZHJlbltrXS5wcm9wcy5zdHlsZS53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID49IGNoaWxkcmVuLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICByb3cucHVzaCggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KGNoaWxkcmVuW2tdLCB7XG4gICAgICAgICAgICAgIGtleTogMTAwICogaSArIDEwICogaiArIGssXG4gICAgICAgICAgICAgIHRhYkluZGV4OiAtMSxcbiAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogXCJcIi5jb25jYXQoMTAwIC8gc2V0dGluZ3Muc2xpZGVzUGVyUm93LCBcIiVcIiksXG4gICAgICAgICAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5ld1NsaWRlLnB1c2goIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAgICAga2V5OiAxMCAqIGkgKyBqXG4gICAgICAgICAgfSwgcm93KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLnZhcmlhYmxlV2lkdGgpIHtcbiAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICAgIGtleTogaSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIHdpZHRoOiBjdXJyZW50V2lkdGhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBuZXdTbGlkZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2goIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAgICAga2V5OiBpXG4gICAgICAgICAgfSwgbmV3U2xpZGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNldHRpbmdzID09PSBcInVuc2xpY2tcIikge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gXCJyZWd1bGFyIHNsaWRlciBcIiArICh0aGlzLnByb3BzLmNsYXNzTmFtZSB8fCBcIlwiKTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gICAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICAgIH0gZWxzZSBpZiAobmV3Q2hpbGRyZW4ubGVuZ3RoIDw9IHNldHRpbmdzLnNsaWRlc1RvU2hvdyAmJiAhc2V0dGluZ3MuaW5maW5pdGUpIHtcbiAgICAgICAgc2V0dGluZ3MudW5zbGljayA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfaW5uZXJTbGlkZXIuSW5uZXJTbGlkZXIsIF9leHRlbmRzKHtcbiAgICAgICAgc3R5bGU6IHRoaXMucHJvcHMuc3R5bGUsXG4gICAgICAgIHJlZjogdGhpcy5pbm5lclNsaWRlclJlZkhhbmRsZXJcbiAgICAgIH0sICgwLCBfaW5uZXJTbGlkZXJVdGlscy5maWx0ZXJTZXR0aW5ncykoc2V0dGluZ3MpKSwgbmV3Q2hpbGRyZW4pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU2xpZGVyO1xufShfcmVhY3RbXCJkZWZhdWx0XCJdLkNvbXBvbmVudCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-slick/lib/slider.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-slick/lib/track.js":
/*!***********************************************!*\
  !*** ./node_modules/react-slick/lib/track.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.Track = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar _classnames = _interopRequireDefault(__webpack_require__(/*! classnames */ \"(app-pages-browser)/./node_modules/classnames/index.js\"));\nvar _innerSliderUtils = __webpack_require__(/*! ./utils/innerSliderUtils */ \"(app-pages-browser)/./node_modules/react-slick/lib/utils/innerSliderUtils.js\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// given specifications/props for a slide, fetch all the classes that need to be applied to the slide\nvar getSlideClasses = function getSlideClasses(spec) {\n  var slickActive, slickCenter, slickCloned;\n  var centerOffset, index;\n  if (spec.rtl) {\n    index = spec.slideCount - 1 - spec.index;\n  } else {\n    index = spec.index;\n  }\n  slickCloned = index < 0 || index >= spec.slideCount;\n  if (spec.centerMode) {\n    centerOffset = Math.floor(spec.slidesToShow / 2);\n    slickCenter = (index - spec.currentSlide) % spec.slideCount === 0;\n    if (index > spec.currentSlide - centerOffset - 1 && index <= spec.currentSlide + centerOffset) {\n      slickActive = true;\n    }\n  } else {\n    slickActive = spec.currentSlide <= index && index < spec.currentSlide + spec.slidesToShow;\n  }\n  var focusedSlide;\n  if (spec.targetSlide < 0) {\n    focusedSlide = spec.targetSlide + spec.slideCount;\n  } else if (spec.targetSlide >= spec.slideCount) {\n    focusedSlide = spec.targetSlide - spec.slideCount;\n  } else {\n    focusedSlide = spec.targetSlide;\n  }\n  var slickCurrent = index === focusedSlide;\n  return {\n    \"slick-slide\": true,\n    \"slick-active\": slickActive,\n    \"slick-center\": slickCenter,\n    \"slick-cloned\": slickCloned,\n    \"slick-current\": slickCurrent // dubious in case of RTL\n  };\n};\nvar getSlideStyle = function getSlideStyle(spec) {\n  var style = {};\n  if (spec.variableWidth === undefined || spec.variableWidth === false) {\n    style.width = spec.slideWidth;\n  }\n  if (spec.fade) {\n    style.position = \"relative\";\n    if (spec.vertical) {\n      style.top = -spec.index * parseInt(spec.slideHeight);\n    } else {\n      style.left = -spec.index * parseInt(spec.slideWidth);\n    }\n    style.opacity = spec.currentSlide === spec.index ? 1 : 0;\n    style.zIndex = spec.currentSlide === spec.index ? 999 : 998;\n    if (spec.useCSS) {\n      style.transition = \"opacity \" + spec.speed + \"ms \" + spec.cssEase + \", \" + \"visibility \" + spec.speed + \"ms \" + spec.cssEase;\n    }\n  }\n  return style;\n};\nvar getKey = function getKey(child, fallbackKey) {\n  return child.key || fallbackKey;\n};\nvar renderSlides = function renderSlides(spec) {\n  var key;\n  var slides = [];\n  var preCloneSlides = [];\n  var postCloneSlides = [];\n  var childrenCount = _react[\"default\"].Children.count(spec.children);\n  var startIndex = (0, _innerSliderUtils.lazyStartIndex)(spec);\n  var endIndex = (0, _innerSliderUtils.lazyEndIndex)(spec);\n  _react[\"default\"].Children.forEach(spec.children, function (elem, index) {\n    var child;\n    var childOnClickOptions = {\n      message: \"children\",\n      index: index,\n      slidesToScroll: spec.slidesToScroll,\n      currentSlide: spec.currentSlide\n    };\n\n    // in case of lazyLoad, whether or not we want to fetch the slide\n    if (!spec.lazyLoad || spec.lazyLoad && spec.lazyLoadedList.indexOf(index) >= 0) {\n      child = elem;\n    } else {\n      child = /*#__PURE__*/_react[\"default\"].createElement(\"div\", null);\n    }\n    var childStyle = getSlideStyle(_objectSpread(_objectSpread({}, spec), {}, {\n      index: index\n    }));\n    var slideClass = child.props.className || \"\";\n    var slideClasses = getSlideClasses(_objectSpread(_objectSpread({}, spec), {}, {\n      index: index\n    }));\n    // push a cloned element of the desired slide\n    slides.push( /*#__PURE__*/_react[\"default\"].cloneElement(child, {\n      key: \"original\" + getKey(child, index),\n      \"data-index\": index,\n      className: (0, _classnames[\"default\"])(slideClasses, slideClass),\n      tabIndex: \"-1\",\n      \"aria-hidden\": !slideClasses[\"slick-active\"],\n      style: _objectSpread(_objectSpread({\n        outline: \"none\"\n      }, child.props.style || {}), childStyle),\n      onClick: function onClick(e) {\n        child.props && child.props.onClick && child.props.onClick(e);\n        if (spec.focusOnSelect) {\n          spec.focusOnSelect(childOnClickOptions);\n        }\n      }\n    }));\n\n    // if slide needs to be precloned or postcloned\n    if (spec.infinite && spec.fade === false) {\n      var preCloneNo = childrenCount - index;\n      if (preCloneNo <= (0, _innerSliderUtils.getPreClones)(spec)) {\n        key = -preCloneNo;\n        if (key >= startIndex) {\n          child = elem;\n        }\n        slideClasses = getSlideClasses(_objectSpread(_objectSpread({}, spec), {}, {\n          index: key\n        }));\n        preCloneSlides.push( /*#__PURE__*/_react[\"default\"].cloneElement(child, {\n          key: \"precloned\" + getKey(child, key),\n          \"data-index\": key,\n          tabIndex: \"-1\",\n          className: (0, _classnames[\"default\"])(slideClasses, slideClass),\n          \"aria-hidden\": !slideClasses[\"slick-active\"],\n          style: _objectSpread(_objectSpread({}, child.props.style || {}), childStyle),\n          onClick: function onClick(e) {\n            child.props && child.props.onClick && child.props.onClick(e);\n            if (spec.focusOnSelect) {\n              spec.focusOnSelect(childOnClickOptions);\n            }\n          }\n        }));\n      }\n      key = childrenCount + index;\n      if (key < endIndex) {\n        child = elem;\n      }\n      slideClasses = getSlideClasses(_objectSpread(_objectSpread({}, spec), {}, {\n        index: key\n      }));\n      postCloneSlides.push( /*#__PURE__*/_react[\"default\"].cloneElement(child, {\n        key: \"postcloned\" + getKey(child, key),\n        \"data-index\": key,\n        tabIndex: \"-1\",\n        className: (0, _classnames[\"default\"])(slideClasses, slideClass),\n        \"aria-hidden\": !slideClasses[\"slick-active\"],\n        style: _objectSpread(_objectSpread({}, child.props.style || {}), childStyle),\n        onClick: function onClick(e) {\n          child.props && child.props.onClick && child.props.onClick(e);\n          if (spec.focusOnSelect) {\n            spec.focusOnSelect(childOnClickOptions);\n          }\n        }\n      }));\n    }\n  });\n  if (spec.rtl) {\n    return preCloneSlides.concat(slides, postCloneSlides).reverse();\n  } else {\n    return preCloneSlides.concat(slides, postCloneSlides);\n  }\n};\nvar Track = exports.Track = /*#__PURE__*/function (_React$PureComponent) {\n  _inherits(Track, _React$PureComponent);\n  var _super = _createSuper(Track);\n  function Track() {\n    var _this;\n    _classCallCheck(this, Track);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this), \"node\", null);\n    _defineProperty(_assertThisInitialized(_this), \"handleRef\", function (ref) {\n      _this.node = ref;\n    });\n    return _this;\n  }\n  _createClass(Track, [{\n    key: \"render\",\n    value: function render() {\n      var slides = renderSlides(this.props);\n      var _this$props = this.props,\n        onMouseEnter = _this$props.onMouseEnter,\n        onMouseOver = _this$props.onMouseOver,\n        onMouseLeave = _this$props.onMouseLeave;\n      var mouseEvents = {\n        onMouseEnter: onMouseEnter,\n        onMouseOver: onMouseOver,\n        onMouseLeave: onMouseLeave\n      };\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", _extends({\n        ref: this.handleRef,\n        className: \"slick-track\",\n        style: this.props.trackStyle\n      }, mouseEvents), slides);\n    }\n  }]);\n  return Track;\n}(_react[\"default\"].PureComponent);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvdHJhY2suanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsYUFBYTtBQUNiLG9DQUFvQyxtQkFBTyxDQUFDLG1GQUFPO0FBQ25ELHlDQUF5QyxtQkFBTyxDQUFDLDBFQUFZO0FBQzdELHdCQUF3QixtQkFBTyxDQUFDLDhHQUEwQjtBQUMxRCx1Q0FBdUMsdUNBQXVDO0FBQzlFLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLHNCQUFzQixzRUFBc0UsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELGlDQUFpQyxrQkFBa0I7QUFDMVMsa0RBQWtELDBDQUEwQztBQUM1Riw0Q0FBNEMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RDtBQUMvUCw4REFBOEQsc0VBQXNFLDhEQUE4RCxrREFBa0QsaUJBQWlCLEdBQUc7QUFDeFEsMkNBQTJDLCtEQUErRCw2RUFBNkUseUVBQXlFLGVBQWUsdURBQXVELEdBQUcsK0NBQStDLGlCQUFpQixHQUFHO0FBQzVZLGlDQUFpQywwR0FBMEcsaUJBQWlCLGFBQWE7QUFDekssaUNBQWlDLDZEQUE2RCx5Q0FBeUMsOENBQThDLGlDQUFpQyxtREFBbUQsMkRBQTJELE9BQU8seUNBQXlDO0FBQ3BYLGtEQUFrRCwwRUFBMEUsZUFBZSw0QkFBNEIsbUZBQW1GO0FBQzFQLHdDQUF3Qyx1QkFBdUIseUZBQXlGO0FBQ3hKLHVDQUF1QyxNQUFNLHFGQUFxRixNQUFNLGFBQWEsMkVBQTJFLGFBQWE7QUFDN08sOEJBQThCLHVHQUF1RyxtREFBbUQ7QUFDeEwseUJBQXlCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3BQLDRCQUE0QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHNEQUFzRCw4QkFBOEIsbUpBQW1KLHFFQUFxRSxLQUFLO0FBQzVhLDRDQUE0QywyQkFBMkIsa0JBQWtCLGtDQUFrQyxvRUFBb0UsS0FBSyxPQUFPLG9CQUFvQjtBQUMvTiw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4Qiw0Q0FBNEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsc0NBQXNDLHVFQUF1RTtBQUM3UTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsaUVBQWlFLFdBQVc7QUFDNUU7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxRUFBcUUsV0FBVztBQUNoRjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHlCQUF5QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsV0FBVztBQUNoRjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MseUJBQXlCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFdBQVc7QUFDOUU7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHlCQUF5QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXNsaWNrL2xpYi90cmFjay5qcz85MTE1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5UcmFjayA9IHZvaWQgMDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2NsYXNzbmFtZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbGFzc25hbWVzXCIpKTtcbnZhciBfaW5uZXJTbGlkZXJVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzL2lubmVyU2xpZGVyVXRpbHNcIik7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogU3RyaW5nKGkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuLy8gZ2l2ZW4gc3BlY2lmaWNhdGlvbnMvcHJvcHMgZm9yIGEgc2xpZGUsIGZldGNoIGFsbCB0aGUgY2xhc3NlcyB0aGF0IG5lZWQgdG8gYmUgYXBwbGllZCB0byB0aGUgc2xpZGVcbnZhciBnZXRTbGlkZUNsYXNzZXMgPSBmdW5jdGlvbiBnZXRTbGlkZUNsYXNzZXMoc3BlYykge1xuICB2YXIgc2xpY2tBY3RpdmUsIHNsaWNrQ2VudGVyLCBzbGlja0Nsb25lZDtcbiAgdmFyIGNlbnRlck9mZnNldCwgaW5kZXg7XG4gIGlmIChzcGVjLnJ0bCkge1xuICAgIGluZGV4ID0gc3BlYy5zbGlkZUNvdW50IC0gMSAtIHNwZWMuaW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgaW5kZXggPSBzcGVjLmluZGV4O1xuICB9XG4gIHNsaWNrQ2xvbmVkID0gaW5kZXggPCAwIHx8IGluZGV4ID49IHNwZWMuc2xpZGVDb3VudDtcbiAgaWYgKHNwZWMuY2VudGVyTW9kZSkge1xuICAgIGNlbnRlck9mZnNldCA9IE1hdGguZmxvb3Ioc3BlYy5zbGlkZXNUb1Nob3cgLyAyKTtcbiAgICBzbGlja0NlbnRlciA9IChpbmRleCAtIHNwZWMuY3VycmVudFNsaWRlKSAlIHNwZWMuc2xpZGVDb3VudCA9PT0gMDtcbiAgICBpZiAoaW5kZXggPiBzcGVjLmN1cnJlbnRTbGlkZSAtIGNlbnRlck9mZnNldCAtIDEgJiYgaW5kZXggPD0gc3BlYy5jdXJyZW50U2xpZGUgKyBjZW50ZXJPZmZzZXQpIHtcbiAgICAgIHNsaWNrQWN0aXZlID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2xpY2tBY3RpdmUgPSBzcGVjLmN1cnJlbnRTbGlkZSA8PSBpbmRleCAmJiBpbmRleCA8IHNwZWMuY3VycmVudFNsaWRlICsgc3BlYy5zbGlkZXNUb1Nob3c7XG4gIH1cbiAgdmFyIGZvY3VzZWRTbGlkZTtcbiAgaWYgKHNwZWMudGFyZ2V0U2xpZGUgPCAwKSB7XG4gICAgZm9jdXNlZFNsaWRlID0gc3BlYy50YXJnZXRTbGlkZSArIHNwZWMuc2xpZGVDb3VudDtcbiAgfSBlbHNlIGlmIChzcGVjLnRhcmdldFNsaWRlID49IHNwZWMuc2xpZGVDb3VudCkge1xuICAgIGZvY3VzZWRTbGlkZSA9IHNwZWMudGFyZ2V0U2xpZGUgLSBzcGVjLnNsaWRlQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgZm9jdXNlZFNsaWRlID0gc3BlYy50YXJnZXRTbGlkZTtcbiAgfVxuICB2YXIgc2xpY2tDdXJyZW50ID0gaW5kZXggPT09IGZvY3VzZWRTbGlkZTtcbiAgcmV0dXJuIHtcbiAgICBcInNsaWNrLXNsaWRlXCI6IHRydWUsXG4gICAgXCJzbGljay1hY3RpdmVcIjogc2xpY2tBY3RpdmUsXG4gICAgXCJzbGljay1jZW50ZXJcIjogc2xpY2tDZW50ZXIsXG4gICAgXCJzbGljay1jbG9uZWRcIjogc2xpY2tDbG9uZWQsXG4gICAgXCJzbGljay1jdXJyZW50XCI6IHNsaWNrQ3VycmVudCAvLyBkdWJpb3VzIGluIGNhc2Ugb2YgUlRMXG4gIH07XG59O1xudmFyIGdldFNsaWRlU3R5bGUgPSBmdW5jdGlvbiBnZXRTbGlkZVN0eWxlKHNwZWMpIHtcbiAgdmFyIHN0eWxlID0ge307XG4gIGlmIChzcGVjLnZhcmlhYmxlV2lkdGggPT09IHVuZGVmaW5lZCB8fCBzcGVjLnZhcmlhYmxlV2lkdGggPT09IGZhbHNlKSB7XG4gICAgc3R5bGUud2lkdGggPSBzcGVjLnNsaWRlV2lkdGg7XG4gIH1cbiAgaWYgKHNwZWMuZmFkZSkge1xuICAgIHN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgIGlmIChzcGVjLnZlcnRpY2FsKSB7XG4gICAgICBzdHlsZS50b3AgPSAtc3BlYy5pbmRleCAqIHBhcnNlSW50KHNwZWMuc2xpZGVIZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5sZWZ0ID0gLXNwZWMuaW5kZXggKiBwYXJzZUludChzcGVjLnNsaWRlV2lkdGgpO1xuICAgIH1cbiAgICBzdHlsZS5vcGFjaXR5ID0gc3BlYy5jdXJyZW50U2xpZGUgPT09IHNwZWMuaW5kZXggPyAxIDogMDtcbiAgICBzdHlsZS56SW5kZXggPSBzcGVjLmN1cnJlbnRTbGlkZSA9PT0gc3BlYy5pbmRleCA/IDk5OSA6IDk5ODtcbiAgICBpZiAoc3BlYy51c2VDU1MpIHtcbiAgICAgIHN0eWxlLnRyYW5zaXRpb24gPSBcIm9wYWNpdHkgXCIgKyBzcGVjLnNwZWVkICsgXCJtcyBcIiArIHNwZWMuY3NzRWFzZSArIFwiLCBcIiArIFwidmlzaWJpbGl0eSBcIiArIHNwZWMuc3BlZWQgKyBcIm1zIFwiICsgc3BlYy5jc3NFYXNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGU7XG59O1xudmFyIGdldEtleSA9IGZ1bmN0aW9uIGdldEtleShjaGlsZCwgZmFsbGJhY2tLZXkpIHtcbiAgcmV0dXJuIGNoaWxkLmtleSB8fCBmYWxsYmFja0tleTtcbn07XG52YXIgcmVuZGVyU2xpZGVzID0gZnVuY3Rpb24gcmVuZGVyU2xpZGVzKHNwZWMpIHtcbiAgdmFyIGtleTtcbiAgdmFyIHNsaWRlcyA9IFtdO1xuICB2YXIgcHJlQ2xvbmVTbGlkZXMgPSBbXTtcbiAgdmFyIHBvc3RDbG9uZVNsaWRlcyA9IFtdO1xuICB2YXIgY2hpbGRyZW5Db3VudCA9IF9yZWFjdFtcImRlZmF1bHRcIl0uQ2hpbGRyZW4uY291bnQoc3BlYy5jaGlsZHJlbik7XG4gIHZhciBzdGFydEluZGV4ID0gKDAsIF9pbm5lclNsaWRlclV0aWxzLmxhenlTdGFydEluZGV4KShzcGVjKTtcbiAgdmFyIGVuZEluZGV4ID0gKDAsIF9pbm5lclNsaWRlclV0aWxzLmxhenlFbmRJbmRleCkoc3BlYyk7XG4gIF9yZWFjdFtcImRlZmF1bHRcIl0uQ2hpbGRyZW4uZm9yRWFjaChzcGVjLmNoaWxkcmVuLCBmdW5jdGlvbiAoZWxlbSwgaW5kZXgpIHtcbiAgICB2YXIgY2hpbGQ7XG4gICAgdmFyIGNoaWxkT25DbGlja09wdGlvbnMgPSB7XG4gICAgICBtZXNzYWdlOiBcImNoaWxkcmVuXCIsXG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICBzbGlkZXNUb1Njcm9sbDogc3BlYy5zbGlkZXNUb1Njcm9sbCxcbiAgICAgIGN1cnJlbnRTbGlkZTogc3BlYy5jdXJyZW50U2xpZGVcbiAgICB9O1xuXG4gICAgLy8gaW4gY2FzZSBvZiBsYXp5TG9hZCwgd2hldGhlciBvciBub3Qgd2Ugd2FudCB0byBmZXRjaCB0aGUgc2xpZGVcbiAgICBpZiAoIXNwZWMubGF6eUxvYWQgfHwgc3BlYy5sYXp5TG9hZCAmJiBzcGVjLmxhenlMb2FkZWRMaXN0LmluZGV4T2YoaW5kZXgpID49IDApIHtcbiAgICAgIGNoaWxkID0gZWxlbTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGQgPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwpO1xuICAgIH1cbiAgICB2YXIgY2hpbGRTdHlsZSA9IGdldFNsaWRlU3R5bGUoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzcGVjKSwge30sIHtcbiAgICAgIGluZGV4OiBpbmRleFxuICAgIH0pKTtcbiAgICB2YXIgc2xpZGVDbGFzcyA9IGNoaWxkLnByb3BzLmNsYXNzTmFtZSB8fCBcIlwiO1xuICAgIHZhciBzbGlkZUNsYXNzZXMgPSBnZXRTbGlkZUNsYXNzZXMoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzcGVjKSwge30sIHtcbiAgICAgIGluZGV4OiBpbmRleFxuICAgIH0pKTtcbiAgICAvLyBwdXNoIGEgY2xvbmVkIGVsZW1lbnQgb2YgdGhlIGRlc2lyZWQgc2xpZGVcbiAgICBzbGlkZXMucHVzaCggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICBrZXk6IFwib3JpZ2luYWxcIiArIGdldEtleShjaGlsZCwgaW5kZXgpLFxuICAgICAgXCJkYXRhLWluZGV4XCI6IGluZGV4LFxuICAgICAgY2xhc3NOYW1lOiAoMCwgX2NsYXNzbmFtZXNbXCJkZWZhdWx0XCJdKShzbGlkZUNsYXNzZXMsIHNsaWRlQ2xhc3MpLFxuICAgICAgdGFiSW5kZXg6IFwiLTFcIixcbiAgICAgIFwiYXJpYS1oaWRkZW5cIjogIXNsaWRlQ2xhc3Nlc1tcInNsaWNrLWFjdGl2ZVwiXSxcbiAgICAgIHN0eWxlOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBvdXRsaW5lOiBcIm5vbmVcIlxuICAgICAgfSwgY2hpbGQucHJvcHMuc3R5bGUgfHwge30pLCBjaGlsZFN0eWxlKSxcbiAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgICAgICBjaGlsZC5wcm9wcyAmJiBjaGlsZC5wcm9wcy5vbkNsaWNrICYmIGNoaWxkLnByb3BzLm9uQ2xpY2soZSk7XG4gICAgICAgIGlmIChzcGVjLmZvY3VzT25TZWxlY3QpIHtcbiAgICAgICAgICBzcGVjLmZvY3VzT25TZWxlY3QoY2hpbGRPbkNsaWNrT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICAvLyBpZiBzbGlkZSBuZWVkcyB0byBiZSBwcmVjbG9uZWQgb3IgcG9zdGNsb25lZFxuICAgIGlmIChzcGVjLmluZmluaXRlICYmIHNwZWMuZmFkZSA9PT0gZmFsc2UpIHtcbiAgICAgIHZhciBwcmVDbG9uZU5vID0gY2hpbGRyZW5Db3VudCAtIGluZGV4O1xuICAgICAgaWYgKHByZUNsb25lTm8gPD0gKDAsIF9pbm5lclNsaWRlclV0aWxzLmdldFByZUNsb25lcykoc3BlYykpIHtcbiAgICAgICAga2V5ID0gLXByZUNsb25lTm87XG4gICAgICAgIGlmIChrZXkgPj0gc3RhcnRJbmRleCkge1xuICAgICAgICAgIGNoaWxkID0gZWxlbTtcbiAgICAgICAgfVxuICAgICAgICBzbGlkZUNsYXNzZXMgPSBnZXRTbGlkZUNsYXNzZXMoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzcGVjKSwge30sIHtcbiAgICAgICAgICBpbmRleDoga2V5XG4gICAgICAgIH0pKTtcbiAgICAgICAgcHJlQ2xvbmVTbGlkZXMucHVzaCggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICAgICAga2V5OiBcInByZWNsb25lZFwiICsgZ2V0S2V5KGNoaWxkLCBrZXkpLFxuICAgICAgICAgIFwiZGF0YS1pbmRleFwiOiBrZXksXG4gICAgICAgICAgdGFiSW5kZXg6IFwiLTFcIixcbiAgICAgICAgICBjbGFzc05hbWU6ICgwLCBfY2xhc3NuYW1lc1tcImRlZmF1bHRcIl0pKHNsaWRlQ2xhc3Nlcywgc2xpZGVDbGFzcyksXG4gICAgICAgICAgXCJhcmlhLWhpZGRlblwiOiAhc2xpZGVDbGFzc2VzW1wic2xpY2stYWN0aXZlXCJdLFxuICAgICAgICAgIHN0eWxlOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGNoaWxkLnByb3BzLnN0eWxlIHx8IHt9KSwgY2hpbGRTdHlsZSksXG4gICAgICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgICAgICAgICBjaGlsZC5wcm9wcyAmJiBjaGlsZC5wcm9wcy5vbkNsaWNrICYmIGNoaWxkLnByb3BzLm9uQ2xpY2soZSk7XG4gICAgICAgICAgICBpZiAoc3BlYy5mb2N1c09uU2VsZWN0KSB7XG4gICAgICAgICAgICAgIHNwZWMuZm9jdXNPblNlbGVjdChjaGlsZE9uQ2xpY2tPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGtleSA9IGNoaWxkcmVuQ291bnQgKyBpbmRleDtcbiAgICAgIGlmIChrZXkgPCBlbmRJbmRleCkge1xuICAgICAgICBjaGlsZCA9IGVsZW07XG4gICAgICB9XG4gICAgICBzbGlkZUNsYXNzZXMgPSBnZXRTbGlkZUNsYXNzZXMoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzcGVjKSwge30sIHtcbiAgICAgICAgaW5kZXg6IGtleVxuICAgICAgfSkpO1xuICAgICAgcG9zdENsb25lU2xpZGVzLnB1c2goIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICBrZXk6IFwicG9zdGNsb25lZFwiICsgZ2V0S2V5KGNoaWxkLCBrZXkpLFxuICAgICAgICBcImRhdGEtaW5kZXhcIjoga2V5LFxuICAgICAgICB0YWJJbmRleDogXCItMVwiLFxuICAgICAgICBjbGFzc05hbWU6ICgwLCBfY2xhc3NuYW1lc1tcImRlZmF1bHRcIl0pKHNsaWRlQ2xhc3Nlcywgc2xpZGVDbGFzcyksXG4gICAgICAgIFwiYXJpYS1oaWRkZW5cIjogIXNsaWRlQ2xhc3Nlc1tcInNsaWNrLWFjdGl2ZVwiXSxcbiAgICAgICAgc3R5bGU6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY2hpbGQucHJvcHMuc3R5bGUgfHwge30pLCBjaGlsZFN0eWxlKSxcbiAgICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgICAgICAgY2hpbGQucHJvcHMgJiYgY2hpbGQucHJvcHMub25DbGljayAmJiBjaGlsZC5wcm9wcy5vbkNsaWNrKGUpO1xuICAgICAgICAgIGlmIChzcGVjLmZvY3VzT25TZWxlY3QpIHtcbiAgICAgICAgICAgIHNwZWMuZm9jdXNPblNlbGVjdChjaGlsZE9uQ2xpY2tPcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gIH0pO1xuICBpZiAoc3BlYy5ydGwpIHtcbiAgICByZXR1cm4gcHJlQ2xvbmVTbGlkZXMuY29uY2F0KHNsaWRlcywgcG9zdENsb25lU2xpZGVzKS5yZXZlcnNlKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByZUNsb25lU2xpZGVzLmNvbmNhdChzbGlkZXMsIHBvc3RDbG9uZVNsaWRlcyk7XG4gIH1cbn07XG52YXIgVHJhY2sgPSBleHBvcnRzLlRyYWNrID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkUHVyZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoVHJhY2ssIF9SZWFjdCRQdXJlQ29tcG9uZW50KTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihUcmFjayk7XG4gIGZ1bmN0aW9uIFRyYWNrKCkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhY2spO1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbC5hcHBseShfc3VwZXIsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJub2RlXCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJoYW5kbGVSZWZcIiwgZnVuY3Rpb24gKHJlZikge1xuICAgICAgX3RoaXMubm9kZSA9IHJlZjtcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFRyYWNrLCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIHNsaWRlcyA9IHJlbmRlclNsaWRlcyh0aGlzLnByb3BzKTtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIG9uTW91c2VFbnRlciA9IF90aGlzJHByb3BzLm9uTW91c2VFbnRlcixcbiAgICAgICAgb25Nb3VzZU92ZXIgPSBfdGhpcyRwcm9wcy5vbk1vdXNlT3ZlcixcbiAgICAgICAgb25Nb3VzZUxlYXZlID0gX3RoaXMkcHJvcHMub25Nb3VzZUxlYXZlO1xuICAgICAgdmFyIG1vdXNlRXZlbnRzID0ge1xuICAgICAgICBvbk1vdXNlRW50ZXI6IG9uTW91c2VFbnRlcixcbiAgICAgICAgb25Nb3VzZU92ZXI6IG9uTW91c2VPdmVyLFxuICAgICAgICBvbk1vdXNlTGVhdmU6IG9uTW91c2VMZWF2ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHtcbiAgICAgICAgcmVmOiB0aGlzLmhhbmRsZVJlZixcbiAgICAgICAgY2xhc3NOYW1lOiBcInNsaWNrLXRyYWNrXCIsXG4gICAgICAgIHN0eWxlOiB0aGlzLnByb3BzLnRyYWNrU3R5bGVcbiAgICAgIH0sIG1vdXNlRXZlbnRzKSwgc2xpZGVzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRyYWNrO1xufShfcmVhY3RbXCJkZWZhdWx0XCJdLlB1cmVDb21wb25lbnQpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-slick/lib/track.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-slick/lib/utils/innerSliderUtils.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-slick/lib/utils/innerSliderUtils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.checkSpecKeys = exports.checkNavigable = exports.changeSlide = exports.canUseDOM = exports.canGoNext = void 0;\nexports.clamp = clamp;\nexports.extractObject = void 0;\nexports.filterSettings = filterSettings;\nexports.validSettings = exports.swipeStart = exports.swipeMove = exports.swipeEnd = exports.slidesOnRight = exports.slidesOnLeft = exports.slideHandler = exports.siblingDirection = exports.safePreventDefault = exports.lazyStartIndex = exports.lazySlidesOnRight = exports.lazySlidesOnLeft = exports.lazyEndIndex = exports.keyHandler = exports.initializedState = exports.getWidth = exports.getTrackLeft = exports.getTrackCSS = exports.getTrackAnimateCSS = exports.getTotalSlides = exports.getSwipeDirection = exports.getSlideCount = exports.getRequiredLazySlides = exports.getPreClones = exports.getPostClones = exports.getOnDemandLazySlides = exports.getNavigableIndexes = exports.getHeight = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar _defaultProps = _interopRequireDefault(__webpack_require__(/*! ../default-props */ \"(app-pages-browser)/./node_modules/react-slick/lib/default-props.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction clamp(number, lowerBound, upperBound) {\n  return Math.max(lowerBound, Math.min(number, upperBound));\n}\nvar safePreventDefault = exports.safePreventDefault = function safePreventDefault(event) {\n  var passiveEvents = [\"onTouchStart\", \"onTouchMove\", \"onWheel\"];\n  if (!passiveEvents.includes(event._reactName)) {\n    event.preventDefault();\n  }\n};\nvar getOnDemandLazySlides = exports.getOnDemandLazySlides = function getOnDemandLazySlides(spec) {\n  var onDemandSlides = [];\n  var startIndex = lazyStartIndex(spec);\n  var endIndex = lazyEndIndex(spec);\n  for (var slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {\n    if (spec.lazyLoadedList.indexOf(slideIndex) < 0) {\n      onDemandSlides.push(slideIndex);\n    }\n  }\n  return onDemandSlides;\n};\n\n// return list of slides that need to be present\nvar getRequiredLazySlides = exports.getRequiredLazySlides = function getRequiredLazySlides(spec) {\n  var requiredSlides = [];\n  var startIndex = lazyStartIndex(spec);\n  var endIndex = lazyEndIndex(spec);\n  for (var slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {\n    requiredSlides.push(slideIndex);\n  }\n  return requiredSlides;\n};\n\n// startIndex that needs to be present\nvar lazyStartIndex = exports.lazyStartIndex = function lazyStartIndex(spec) {\n  return spec.currentSlide - lazySlidesOnLeft(spec);\n};\nvar lazyEndIndex = exports.lazyEndIndex = function lazyEndIndex(spec) {\n  return spec.currentSlide + lazySlidesOnRight(spec);\n};\nvar lazySlidesOnLeft = exports.lazySlidesOnLeft = function lazySlidesOnLeft(spec) {\n  return spec.centerMode ? Math.floor(spec.slidesToShow / 2) + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : 0;\n};\nvar lazySlidesOnRight = exports.lazySlidesOnRight = function lazySlidesOnRight(spec) {\n  return spec.centerMode ? Math.floor((spec.slidesToShow - 1) / 2) + 1 + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : spec.slidesToShow;\n};\n\n// get width of an element\nvar getWidth = exports.getWidth = function getWidth(elem) {\n  return elem && elem.offsetWidth || 0;\n};\nvar getHeight = exports.getHeight = function getHeight(elem) {\n  return elem && elem.offsetHeight || 0;\n};\nvar getSwipeDirection = exports.getSwipeDirection = function getSwipeDirection(touchObject) {\n  var verticalSwiping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var xDist, yDist, r, swipeAngle;\n  xDist = touchObject.startX - touchObject.curX;\n  yDist = touchObject.startY - touchObject.curY;\n  r = Math.atan2(yDist, xDist);\n  swipeAngle = Math.round(r * 180 / Math.PI);\n  if (swipeAngle < 0) {\n    swipeAngle = 360 - Math.abs(swipeAngle);\n  }\n  if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {\n    return \"left\";\n  }\n  if (swipeAngle >= 135 && swipeAngle <= 225) {\n    return \"right\";\n  }\n  if (verticalSwiping === true) {\n    if (swipeAngle >= 35 && swipeAngle <= 135) {\n      return \"up\";\n    } else {\n      return \"down\";\n    }\n  }\n  return \"vertical\";\n};\n\n// whether or not we can go next\nvar canGoNext = exports.canGoNext = function canGoNext(spec) {\n  var canGo = true;\n  if (!spec.infinite) {\n    if (spec.centerMode && spec.currentSlide >= spec.slideCount - 1) {\n      canGo = false;\n    } else if (spec.slideCount <= spec.slidesToShow || spec.currentSlide >= spec.slideCount - spec.slidesToShow) {\n      canGo = false;\n    }\n  }\n  return canGo;\n};\n\n// given an object and a list of keys, return new object with given keys\nvar extractObject = exports.extractObject = function extractObject(spec, keys) {\n  var newObject = {};\n  keys.forEach(function (key) {\n    return newObject[key] = spec[key];\n  });\n  return newObject;\n};\n\n// get initialized state\nvar initializedState = exports.initializedState = function initializedState(spec) {\n  // spec also contains listRef, trackRef\n  var slideCount = _react[\"default\"].Children.count(spec.children);\n  var listNode = spec.listRef;\n  var listWidth = Math.ceil(getWidth(listNode));\n  var trackNode = spec.trackRef && spec.trackRef.node;\n  var trackWidth = Math.ceil(getWidth(trackNode));\n  var slideWidth;\n  if (!spec.vertical) {\n    var centerPaddingAdj = spec.centerMode && parseInt(spec.centerPadding) * 2;\n    if (typeof spec.centerPadding === \"string\" && spec.centerPadding.slice(-1) === \"%\") {\n      centerPaddingAdj *= listWidth / 100;\n    }\n    slideWidth = Math.ceil((listWidth - centerPaddingAdj) / spec.slidesToShow);\n  } else {\n    slideWidth = listWidth;\n  }\n  var slideHeight = listNode && getHeight(listNode.querySelector('[data-index=\"0\"]'));\n  var listHeight = slideHeight * spec.slidesToShow;\n  var currentSlide = spec.currentSlide === undefined ? spec.initialSlide : spec.currentSlide;\n  if (spec.rtl && spec.currentSlide === undefined) {\n    currentSlide = slideCount - 1 - spec.initialSlide;\n  }\n  var lazyLoadedList = spec.lazyLoadedList || [];\n  var slidesToLoad = getOnDemandLazySlides(_objectSpread(_objectSpread({}, spec), {}, {\n    currentSlide: currentSlide,\n    lazyLoadedList: lazyLoadedList\n  }));\n  lazyLoadedList = lazyLoadedList.concat(slidesToLoad);\n  var state = {\n    slideCount: slideCount,\n    slideWidth: slideWidth,\n    listWidth: listWidth,\n    trackWidth: trackWidth,\n    currentSlide: currentSlide,\n    slideHeight: slideHeight,\n    listHeight: listHeight,\n    lazyLoadedList: lazyLoadedList\n  };\n  if (spec.autoplaying === null && spec.autoplay) {\n    state[\"autoplaying\"] = \"playing\";\n  }\n  return state;\n};\nvar slideHandler = exports.slideHandler = function slideHandler(spec) {\n  var waitForAnimate = spec.waitForAnimate,\n    animating = spec.animating,\n    fade = spec.fade,\n    infinite = spec.infinite,\n    index = spec.index,\n    slideCount = spec.slideCount,\n    lazyLoad = spec.lazyLoad,\n    currentSlide = spec.currentSlide,\n    centerMode = spec.centerMode,\n    slidesToScroll = spec.slidesToScroll,\n    slidesToShow = spec.slidesToShow,\n    useCSS = spec.useCSS;\n  var lazyLoadedList = spec.lazyLoadedList;\n  if (waitForAnimate && animating) return {};\n  var animationSlide = index,\n    finalSlide,\n    animationLeft,\n    finalLeft;\n  var state = {},\n    nextState = {};\n  var targetSlide = infinite ? index : clamp(index, 0, slideCount - 1);\n  if (fade) {\n    if (!infinite && (index < 0 || index >= slideCount)) return {};\n    if (index < 0) {\n      animationSlide = index + slideCount;\n    } else if (index >= slideCount) {\n      animationSlide = index - slideCount;\n    }\n    if (lazyLoad && lazyLoadedList.indexOf(animationSlide) < 0) {\n      lazyLoadedList = lazyLoadedList.concat(animationSlide);\n    }\n    state = {\n      animating: true,\n      currentSlide: animationSlide,\n      lazyLoadedList: lazyLoadedList,\n      targetSlide: animationSlide\n    };\n    nextState = {\n      animating: false,\n      targetSlide: animationSlide\n    };\n  } else {\n    finalSlide = animationSlide;\n    if (animationSlide < 0) {\n      finalSlide = animationSlide + slideCount;\n      if (!infinite) finalSlide = 0;else if (slideCount % slidesToScroll !== 0) finalSlide = slideCount - slideCount % slidesToScroll;\n    } else if (!canGoNext(spec) && animationSlide > currentSlide) {\n      animationSlide = finalSlide = currentSlide;\n    } else if (centerMode && animationSlide >= slideCount) {\n      animationSlide = infinite ? slideCount : slideCount - 1;\n      finalSlide = infinite ? 0 : slideCount - 1;\n    } else if (animationSlide >= slideCount) {\n      finalSlide = animationSlide - slideCount;\n      if (!infinite) finalSlide = slideCount - slidesToShow;else if (slideCount % slidesToScroll !== 0) finalSlide = 0;\n    }\n    if (!infinite && animationSlide + slidesToShow >= slideCount) {\n      finalSlide = slideCount - slidesToShow;\n    }\n    animationLeft = getTrackLeft(_objectSpread(_objectSpread({}, spec), {}, {\n      slideIndex: animationSlide\n    }));\n    finalLeft = getTrackLeft(_objectSpread(_objectSpread({}, spec), {}, {\n      slideIndex: finalSlide\n    }));\n    if (!infinite) {\n      if (animationLeft === finalLeft) animationSlide = finalSlide;\n      animationLeft = finalLeft;\n    }\n    if (lazyLoad) {\n      lazyLoadedList = lazyLoadedList.concat(getOnDemandLazySlides(_objectSpread(_objectSpread({}, spec), {}, {\n        currentSlide: animationSlide\n      })));\n    }\n    if (!useCSS) {\n      state = {\n        currentSlide: finalSlide,\n        trackStyle: getTrackCSS(_objectSpread(_objectSpread({}, spec), {}, {\n          left: finalLeft\n        })),\n        lazyLoadedList: lazyLoadedList,\n        targetSlide: targetSlide\n      };\n    } else {\n      state = {\n        animating: true,\n        currentSlide: finalSlide,\n        trackStyle: getTrackAnimateCSS(_objectSpread(_objectSpread({}, spec), {}, {\n          left: animationLeft\n        })),\n        lazyLoadedList: lazyLoadedList,\n        targetSlide: targetSlide\n      };\n      nextState = {\n        animating: false,\n        currentSlide: finalSlide,\n        trackStyle: getTrackCSS(_objectSpread(_objectSpread({}, spec), {}, {\n          left: finalLeft\n        })),\n        swipeLeft: null,\n        targetSlide: targetSlide\n      };\n    }\n  }\n  return {\n    state: state,\n    nextState: nextState\n  };\n};\nvar changeSlide = exports.changeSlide = function changeSlide(spec, options) {\n  var indexOffset, previousInt, slideOffset, unevenOffset, targetSlide;\n  var slidesToScroll = spec.slidesToScroll,\n    slidesToShow = spec.slidesToShow,\n    slideCount = spec.slideCount,\n    currentSlide = spec.currentSlide,\n    previousTargetSlide = spec.targetSlide,\n    lazyLoad = spec.lazyLoad,\n    infinite = spec.infinite;\n  unevenOffset = slideCount % slidesToScroll !== 0;\n  indexOffset = unevenOffset ? 0 : (slideCount - currentSlide) % slidesToScroll;\n  if (options.message === \"previous\") {\n    slideOffset = indexOffset === 0 ? slidesToScroll : slidesToShow - indexOffset;\n    targetSlide = currentSlide - slideOffset;\n    if (lazyLoad && !infinite) {\n      previousInt = currentSlide - slideOffset;\n      targetSlide = previousInt === -1 ? slideCount - 1 : previousInt;\n    }\n    if (!infinite) {\n      targetSlide = previousTargetSlide - slidesToScroll;\n    }\n  } else if (options.message === \"next\") {\n    slideOffset = indexOffset === 0 ? slidesToScroll : indexOffset;\n    targetSlide = currentSlide + slideOffset;\n    if (lazyLoad && !infinite) {\n      targetSlide = (currentSlide + slidesToScroll) % slideCount + indexOffset;\n    }\n    if (!infinite) {\n      targetSlide = previousTargetSlide + slidesToScroll;\n    }\n  } else if (options.message === \"dots\") {\n    // Click on dots\n    targetSlide = options.index * options.slidesToScroll;\n  } else if (options.message === \"children\") {\n    // Click on the slides\n    targetSlide = options.index;\n    if (infinite) {\n      var direction = siblingDirection(_objectSpread(_objectSpread({}, spec), {}, {\n        targetSlide: targetSlide\n      }));\n      if (targetSlide > options.currentSlide && direction === \"left\") {\n        targetSlide = targetSlide - slideCount;\n      } else if (targetSlide < options.currentSlide && direction === \"right\") {\n        targetSlide = targetSlide + slideCount;\n      }\n    }\n  } else if (options.message === \"index\") {\n    targetSlide = Number(options.index);\n  }\n  return targetSlide;\n};\nvar keyHandler = exports.keyHandler = function keyHandler(e, accessibility, rtl) {\n  if (e.target.tagName.match(\"TEXTAREA|INPUT|SELECT\") || !accessibility) return \"\";\n  if (e.keyCode === 37) return rtl ? \"next\" : \"previous\";\n  if (e.keyCode === 39) return rtl ? \"previous\" : \"next\";\n  return \"\";\n};\nvar swipeStart = exports.swipeStart = function swipeStart(e, swipe, draggable) {\n  e.target.tagName === \"IMG\" && safePreventDefault(e);\n  if (!swipe || !draggable && e.type.indexOf(\"mouse\") !== -1) return \"\";\n  return {\n    dragging: true,\n    touchObject: {\n      startX: e.touches ? e.touches[0].pageX : e.clientX,\n      startY: e.touches ? e.touches[0].pageY : e.clientY,\n      curX: e.touches ? e.touches[0].pageX : e.clientX,\n      curY: e.touches ? e.touches[0].pageY : e.clientY\n    }\n  };\n};\nvar swipeMove = exports.swipeMove = function swipeMove(e, spec) {\n  // spec also contains, trackRef and slideIndex\n  var scrolling = spec.scrolling,\n    animating = spec.animating,\n    vertical = spec.vertical,\n    swipeToSlide = spec.swipeToSlide,\n    verticalSwiping = spec.verticalSwiping,\n    rtl = spec.rtl,\n    currentSlide = spec.currentSlide,\n    edgeFriction = spec.edgeFriction,\n    edgeDragged = spec.edgeDragged,\n    onEdge = spec.onEdge,\n    swiped = spec.swiped,\n    swiping = spec.swiping,\n    slideCount = spec.slideCount,\n    slidesToScroll = spec.slidesToScroll,\n    infinite = spec.infinite,\n    touchObject = spec.touchObject,\n    swipeEvent = spec.swipeEvent,\n    listHeight = spec.listHeight,\n    listWidth = spec.listWidth;\n  if (scrolling) return;\n  if (animating) return safePreventDefault(e);\n  if (vertical && swipeToSlide && verticalSwiping) safePreventDefault(e);\n  var swipeLeft,\n    state = {};\n  var curLeft = getTrackLeft(spec);\n  touchObject.curX = e.touches ? e.touches[0].pageX : e.clientX;\n  touchObject.curY = e.touches ? e.touches[0].pageY : e.clientY;\n  touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2)));\n  var verticalSwipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2)));\n  if (!verticalSwiping && !swiping && verticalSwipeLength > 10) {\n    return {\n      scrolling: true\n    };\n  }\n  if (verticalSwiping) touchObject.swipeLength = verticalSwipeLength;\n  var positionOffset = (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1);\n  if (verticalSwiping) positionOffset = touchObject.curY > touchObject.startY ? 1 : -1;\n  var dotCount = Math.ceil(slideCount / slidesToScroll);\n  var swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping);\n  var touchSwipeLength = touchObject.swipeLength;\n  if (!infinite) {\n    if (currentSlide === 0 && (swipeDirection === \"right\" || swipeDirection === \"down\") || currentSlide + 1 >= dotCount && (swipeDirection === \"left\" || swipeDirection === \"up\") || !canGoNext(spec) && (swipeDirection === \"left\" || swipeDirection === \"up\")) {\n      touchSwipeLength = touchObject.swipeLength * edgeFriction;\n      if (edgeDragged === false && onEdge) {\n        onEdge(swipeDirection);\n        state[\"edgeDragged\"] = true;\n      }\n    }\n  }\n  if (!swiped && swipeEvent) {\n    swipeEvent(swipeDirection);\n    state[\"swiped\"] = true;\n  }\n  if (!vertical) {\n    if (!rtl) {\n      swipeLeft = curLeft + touchSwipeLength * positionOffset;\n    } else {\n      swipeLeft = curLeft - touchSwipeLength * positionOffset;\n    }\n  } else {\n    swipeLeft = curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset;\n  }\n  if (verticalSwiping) {\n    swipeLeft = curLeft + touchSwipeLength * positionOffset;\n  }\n  state = _objectSpread(_objectSpread({}, state), {}, {\n    touchObject: touchObject,\n    swipeLeft: swipeLeft,\n    trackStyle: getTrackCSS(_objectSpread(_objectSpread({}, spec), {}, {\n      left: swipeLeft\n    }))\n  });\n  if (Math.abs(touchObject.curX - touchObject.startX) < Math.abs(touchObject.curY - touchObject.startY) * 0.8) {\n    return state;\n  }\n  if (touchObject.swipeLength > 10) {\n    state[\"swiping\"] = true;\n    safePreventDefault(e);\n  }\n  return state;\n};\nvar swipeEnd = exports.swipeEnd = function swipeEnd(e, spec) {\n  var dragging = spec.dragging,\n    swipe = spec.swipe,\n    touchObject = spec.touchObject,\n    listWidth = spec.listWidth,\n    touchThreshold = spec.touchThreshold,\n    verticalSwiping = spec.verticalSwiping,\n    listHeight = spec.listHeight,\n    swipeToSlide = spec.swipeToSlide,\n    scrolling = spec.scrolling,\n    onSwipe = spec.onSwipe,\n    targetSlide = spec.targetSlide,\n    currentSlide = spec.currentSlide,\n    infinite = spec.infinite;\n  if (!dragging) {\n    if (swipe) safePreventDefault(e);\n    return {};\n  }\n  var minSwipe = verticalSwiping ? listHeight / touchThreshold : listWidth / touchThreshold;\n  var swipeDirection = getSwipeDirection(touchObject, verticalSwiping);\n  // reset the state of touch related state variables.\n  var state = {\n    dragging: false,\n    edgeDragged: false,\n    scrolling: false,\n    swiping: false,\n    swiped: false,\n    swipeLeft: null,\n    touchObject: {}\n  };\n  if (scrolling) {\n    return state;\n  }\n  if (!touchObject.swipeLength) {\n    return state;\n  }\n  if (touchObject.swipeLength > minSwipe) {\n    safePreventDefault(e);\n    if (onSwipe) {\n      onSwipe(swipeDirection);\n    }\n    var slideCount, newSlide;\n    var activeSlide = infinite ? currentSlide : targetSlide;\n    switch (swipeDirection) {\n      case \"left\":\n      case \"up\":\n        newSlide = activeSlide + getSlideCount(spec);\n        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;\n        state[\"currentDirection\"] = 0;\n        break;\n      case \"right\":\n      case \"down\":\n        newSlide = activeSlide - getSlideCount(spec);\n        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;\n        state[\"currentDirection\"] = 1;\n        break;\n      default:\n        slideCount = activeSlide;\n    }\n    state[\"triggerSlideHandler\"] = slideCount;\n  } else {\n    // Adjust the track back to it's original position.\n    var currentLeft = getTrackLeft(spec);\n    state[\"trackStyle\"] = getTrackAnimateCSS(_objectSpread(_objectSpread({}, spec), {}, {\n      left: currentLeft\n    }));\n  }\n  return state;\n};\nvar getNavigableIndexes = exports.getNavigableIndexes = function getNavigableIndexes(spec) {\n  var max = spec.infinite ? spec.slideCount * 2 : spec.slideCount;\n  var breakpoint = spec.infinite ? spec.slidesToShow * -1 : 0;\n  var counter = spec.infinite ? spec.slidesToShow * -1 : 0;\n  var indexes = [];\n  while (breakpoint < max) {\n    indexes.push(breakpoint);\n    breakpoint = counter + spec.slidesToScroll;\n    counter += Math.min(spec.slidesToScroll, spec.slidesToShow);\n  }\n  return indexes;\n};\nvar checkNavigable = exports.checkNavigable = function checkNavigable(spec, index) {\n  var navigables = getNavigableIndexes(spec);\n  var prevNavigable = 0;\n  if (index > navigables[navigables.length - 1]) {\n    index = navigables[navigables.length - 1];\n  } else {\n    for (var n in navigables) {\n      if (index < navigables[n]) {\n        index = prevNavigable;\n        break;\n      }\n      prevNavigable = navigables[n];\n    }\n  }\n  return index;\n};\nvar getSlideCount = exports.getSlideCount = function getSlideCount(spec) {\n  var centerOffset = spec.centerMode ? spec.slideWidth * Math.floor(spec.slidesToShow / 2) : 0;\n  if (spec.swipeToSlide) {\n    var swipedSlide;\n    var slickList = spec.listRef;\n    var slides = slickList.querySelectorAll && slickList.querySelectorAll(\".slick-slide\") || [];\n    Array.from(slides).every(function (slide) {\n      if (!spec.vertical) {\n        if (slide.offsetLeft - centerOffset + getWidth(slide) / 2 > spec.swipeLeft * -1) {\n          swipedSlide = slide;\n          return false;\n        }\n      } else {\n        if (slide.offsetTop + getHeight(slide) / 2 > spec.swipeLeft * -1) {\n          swipedSlide = slide;\n          return false;\n        }\n      }\n      return true;\n    });\n    if (!swipedSlide) {\n      return 0;\n    }\n    var currentIndex = spec.rtl === true ? spec.slideCount - spec.currentSlide : spec.currentSlide;\n    var slidesTraversed = Math.abs(swipedSlide.dataset.index - currentIndex) || 1;\n    return slidesTraversed;\n  } else {\n    return spec.slidesToScroll;\n  }\n};\nvar checkSpecKeys = exports.checkSpecKeys = function checkSpecKeys(spec, keysArray) {\n  return keysArray.reduce(function (value, key) {\n    return value && spec.hasOwnProperty(key);\n  }, true) ? null : console.error(\"Keys Missing:\", spec);\n};\nvar getTrackCSS = exports.getTrackCSS = function getTrackCSS(spec) {\n  checkSpecKeys(spec, [\"left\", \"variableWidth\", \"slideCount\", \"slidesToShow\", \"slideWidth\"]);\n  var trackWidth, trackHeight;\n  var trackChildren = spec.slideCount + 2 * spec.slidesToShow;\n  if (!spec.vertical) {\n    trackWidth = getTotalSlides(spec) * spec.slideWidth;\n  } else {\n    trackHeight = trackChildren * spec.slideHeight;\n  }\n  var style = {\n    opacity: 1,\n    transition: \"\",\n    WebkitTransition: \"\"\n  };\n  if (spec.useTransform) {\n    var WebkitTransform = !spec.vertical ? \"translate3d(\" + spec.left + \"px, 0px, 0px)\" : \"translate3d(0px, \" + spec.left + \"px, 0px)\";\n    var transform = !spec.vertical ? \"translate3d(\" + spec.left + \"px, 0px, 0px)\" : \"translate3d(0px, \" + spec.left + \"px, 0px)\";\n    var msTransform = !spec.vertical ? \"translateX(\" + spec.left + \"px)\" : \"translateY(\" + spec.left + \"px)\";\n    style = _objectSpread(_objectSpread({}, style), {}, {\n      WebkitTransform: WebkitTransform,\n      transform: transform,\n      msTransform: msTransform\n    });\n  } else {\n    if (spec.vertical) {\n      style[\"top\"] = spec.left;\n    } else {\n      style[\"left\"] = spec.left;\n    }\n  }\n  if (spec.fade) style = {\n    opacity: 1\n  };\n  if (trackWidth) style.width = trackWidth;\n  if (trackHeight) style.height = trackHeight;\n\n  // Fallback for IE8\n  if (window && !window.addEventListener && window.attachEvent) {\n    if (!spec.vertical) {\n      style.marginLeft = spec.left + \"px\";\n    } else {\n      style.marginTop = spec.left + \"px\";\n    }\n  }\n  return style;\n};\nvar getTrackAnimateCSS = exports.getTrackAnimateCSS = function getTrackAnimateCSS(spec) {\n  checkSpecKeys(spec, [\"left\", \"variableWidth\", \"slideCount\", \"slidesToShow\", \"slideWidth\", \"speed\", \"cssEase\"]);\n  var style = getTrackCSS(spec);\n  // useCSS is true by default so it can be undefined\n  if (spec.useTransform) {\n    style.WebkitTransition = \"-webkit-transform \" + spec.speed + \"ms \" + spec.cssEase;\n    style.transition = \"transform \" + spec.speed + \"ms \" + spec.cssEase;\n  } else {\n    if (spec.vertical) {\n      style.transition = \"top \" + spec.speed + \"ms \" + spec.cssEase;\n    } else {\n      style.transition = \"left \" + spec.speed + \"ms \" + spec.cssEase;\n    }\n  }\n  return style;\n};\nvar getTrackLeft = exports.getTrackLeft = function getTrackLeft(spec) {\n  if (spec.unslick) {\n    return 0;\n  }\n  checkSpecKeys(spec, [\"slideIndex\", \"trackRef\", \"infinite\", \"centerMode\", \"slideCount\", \"slidesToShow\", \"slidesToScroll\", \"slideWidth\", \"listWidth\", \"variableWidth\", \"slideHeight\"]);\n  var slideIndex = spec.slideIndex,\n    trackRef = spec.trackRef,\n    infinite = spec.infinite,\n    centerMode = spec.centerMode,\n    slideCount = spec.slideCount,\n    slidesToShow = spec.slidesToShow,\n    slidesToScroll = spec.slidesToScroll,\n    slideWidth = spec.slideWidth,\n    listWidth = spec.listWidth,\n    variableWidth = spec.variableWidth,\n    slideHeight = spec.slideHeight,\n    fade = spec.fade,\n    vertical = spec.vertical;\n  var slideOffset = 0;\n  var targetLeft;\n  var targetSlide;\n  var verticalOffset = 0;\n  if (fade || spec.slideCount === 1) {\n    return 0;\n  }\n  var slidesToOffset = 0;\n  if (infinite) {\n    slidesToOffset = -getPreClones(spec); // bring active slide to the beginning of visual area\n    // if next scroll doesn't have enough children, just reach till the end of original slides instead of shifting slidesToScroll children\n    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {\n      slidesToOffset = -(slideIndex > slideCount ? slidesToShow - (slideIndex - slideCount) : slideCount % slidesToScroll);\n    }\n    // shift current slide to center of the frame\n    if (centerMode) {\n      slidesToOffset += parseInt(slidesToShow / 2);\n    }\n  } else {\n    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {\n      slidesToOffset = slidesToShow - slideCount % slidesToScroll;\n    }\n    if (centerMode) {\n      slidesToOffset = parseInt(slidesToShow / 2);\n    }\n  }\n  slideOffset = slidesToOffset * slideWidth;\n  verticalOffset = slidesToOffset * slideHeight;\n  if (!vertical) {\n    targetLeft = slideIndex * slideWidth * -1 + slideOffset;\n  } else {\n    targetLeft = slideIndex * slideHeight * -1 + verticalOffset;\n  }\n  if (variableWidth === true) {\n    var targetSlideIndex;\n    var trackElem = trackRef && trackRef.node;\n    targetSlideIndex = slideIndex + getPreClones(spec);\n    targetSlide = trackElem && trackElem.childNodes[targetSlideIndex];\n    targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0;\n    if (centerMode === true) {\n      targetSlideIndex = infinite ? slideIndex + getPreClones(spec) : slideIndex;\n      targetSlide = trackElem && trackElem.children[targetSlideIndex];\n      targetLeft = 0;\n      for (var slide = 0; slide < targetSlideIndex; slide++) {\n        targetLeft -= trackElem && trackElem.children[slide] && trackElem.children[slide].offsetWidth;\n      }\n      targetLeft -= parseInt(spec.centerPadding);\n      targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2;\n    }\n  }\n  return targetLeft;\n};\nvar getPreClones = exports.getPreClones = function getPreClones(spec) {\n  if (spec.unslick || !spec.infinite) {\n    return 0;\n  }\n  if (spec.variableWidth) {\n    return spec.slideCount;\n  }\n  return spec.slidesToShow + (spec.centerMode ? 1 : 0);\n};\nvar getPostClones = exports.getPostClones = function getPostClones(spec) {\n  if (spec.unslick || !spec.infinite) {\n    return 0;\n  }\n  return spec.slideCount;\n};\nvar getTotalSlides = exports.getTotalSlides = function getTotalSlides(spec) {\n  return spec.slideCount === 1 ? 1 : getPreClones(spec) + spec.slideCount + getPostClones(spec);\n};\nvar siblingDirection = exports.siblingDirection = function siblingDirection(spec) {\n  if (spec.targetSlide > spec.currentSlide) {\n    if (spec.targetSlide > spec.currentSlide + slidesOnRight(spec)) {\n      return \"left\";\n    }\n    return \"right\";\n  } else {\n    if (spec.targetSlide < spec.currentSlide - slidesOnLeft(spec)) {\n      return \"right\";\n    }\n    return \"left\";\n  }\n};\nvar slidesOnRight = exports.slidesOnRight = function slidesOnRight(_ref) {\n  var slidesToShow = _ref.slidesToShow,\n    centerMode = _ref.centerMode,\n    rtl = _ref.rtl,\n    centerPadding = _ref.centerPadding;\n  // returns no of slides on the right of active slide\n  if (centerMode) {\n    var right = (slidesToShow - 1) / 2 + 1;\n    if (parseInt(centerPadding) > 0) right += 1;\n    if (rtl && slidesToShow % 2 === 0) right += 1;\n    return right;\n  }\n  if (rtl) {\n    return 0;\n  }\n  return slidesToShow - 1;\n};\nvar slidesOnLeft = exports.slidesOnLeft = function slidesOnLeft(_ref2) {\n  var slidesToShow = _ref2.slidesToShow,\n    centerMode = _ref2.centerMode,\n    rtl = _ref2.rtl,\n    centerPadding = _ref2.centerPadding;\n  // returns no of slides on the left of active slide\n  if (centerMode) {\n    var left = (slidesToShow - 1) / 2 + 1;\n    if (parseInt(centerPadding) > 0) left += 1;\n    if (!rtl && slidesToShow % 2 === 0) left += 1;\n    return left;\n  }\n  if (rtl) {\n    return slidesToShow - 1;\n  }\n  return 0;\n};\nvar canUseDOM = exports.canUseDOM = function canUseDOM() {\n  return !!(typeof window !== \"undefined\" && window.document && window.document.createElement);\n};\nvar validSettings = exports.validSettings = Object.keys(_defaultProps[\"default\"]);\nfunction filterSettings(settings) {\n  return validSettings.reduce(function (acc, settingName) {\n    if (settings.hasOwnProperty(settingName)) {\n      acc[settingName] = settings[settingName];\n    }\n    return acc;\n  }, {});\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvdXRpbHMvaW5uZXJTbGlkZXJVdGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixxQkFBcUIsR0FBRyxzQkFBc0IsR0FBRyxtQkFBbUIsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUI7QUFDNUcsYUFBYTtBQUNiLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIscUJBQXFCLEdBQUcsa0JBQWtCLEdBQUcsaUJBQWlCLEdBQUcsZ0JBQWdCLEdBQUcscUJBQXFCLEdBQUcsb0JBQW9CLEdBQUcsb0JBQW9CLEdBQUcsd0JBQXdCLEdBQUcsMEJBQTBCLEdBQUcsc0JBQXNCLEdBQUcseUJBQXlCLEdBQUcsd0JBQXdCLEdBQUcsb0JBQW9CLEdBQUcsa0JBQWtCLEdBQUcsd0JBQXdCLEdBQUcsZ0JBQWdCLEdBQUcsb0JBQW9CLEdBQUcsbUJBQW1CLEdBQUcsMEJBQTBCLEdBQUcsc0JBQXNCLEdBQUcseUJBQXlCLEdBQUcscUJBQXFCLEdBQUcsNkJBQTZCLEdBQUcsb0JBQW9CLEdBQUcscUJBQXFCLEdBQUcsNkJBQTZCLEdBQUcsMkJBQTJCLEdBQUcsaUJBQWlCO0FBQ2pyQixvQ0FBb0MsbUJBQU8sQ0FBQyxtRkFBTztBQUNuRCwyQ0FBMkMsbUJBQU8sQ0FBQyw2RkFBa0I7QUFDckUsdUNBQXVDLHVDQUF1QztBQUM5RSxzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUyx5QkFBeUIsd0JBQXdCLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLDBEQUEwRCwwQkFBMEI7QUFDcFAsNEJBQTRCLGdCQUFnQixzQkFBc0IsT0FBTyxrREFBa0Qsc0RBQXNELDhCQUE4QixtSkFBbUoscUVBQXFFLEtBQUs7QUFDNWEsNENBQTRDLDJCQUEyQixrQkFBa0Isa0NBQWtDLG9FQUFvRSxLQUFLLE9BQU8sb0JBQW9CO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2xpY2svbGliL3V0aWxzL2lubmVyU2xpZGVyVXRpbHMuanM/NzIwNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY2hlY2tTcGVjS2V5cyA9IGV4cG9ydHMuY2hlY2tOYXZpZ2FibGUgPSBleHBvcnRzLmNoYW5nZVNsaWRlID0gZXhwb3J0cy5jYW5Vc2VET00gPSBleHBvcnRzLmNhbkdvTmV4dCA9IHZvaWQgMDtcbmV4cG9ydHMuY2xhbXAgPSBjbGFtcDtcbmV4cG9ydHMuZXh0cmFjdE9iamVjdCA9IHZvaWQgMDtcbmV4cG9ydHMuZmlsdGVyU2V0dGluZ3MgPSBmaWx0ZXJTZXR0aW5ncztcbmV4cG9ydHMudmFsaWRTZXR0aW5ncyA9IGV4cG9ydHMuc3dpcGVTdGFydCA9IGV4cG9ydHMuc3dpcGVNb3ZlID0gZXhwb3J0cy5zd2lwZUVuZCA9IGV4cG9ydHMuc2xpZGVzT25SaWdodCA9IGV4cG9ydHMuc2xpZGVzT25MZWZ0ID0gZXhwb3J0cy5zbGlkZUhhbmRsZXIgPSBleHBvcnRzLnNpYmxpbmdEaXJlY3Rpb24gPSBleHBvcnRzLnNhZmVQcmV2ZW50RGVmYXVsdCA9IGV4cG9ydHMubGF6eVN0YXJ0SW5kZXggPSBleHBvcnRzLmxhenlTbGlkZXNPblJpZ2h0ID0gZXhwb3J0cy5sYXp5U2xpZGVzT25MZWZ0ID0gZXhwb3J0cy5sYXp5RW5kSW5kZXggPSBleHBvcnRzLmtleUhhbmRsZXIgPSBleHBvcnRzLmluaXRpYWxpemVkU3RhdGUgPSBleHBvcnRzLmdldFdpZHRoID0gZXhwb3J0cy5nZXRUcmFja0xlZnQgPSBleHBvcnRzLmdldFRyYWNrQ1NTID0gZXhwb3J0cy5nZXRUcmFja0FuaW1hdGVDU1MgPSBleHBvcnRzLmdldFRvdGFsU2xpZGVzID0gZXhwb3J0cy5nZXRTd2lwZURpcmVjdGlvbiA9IGV4cG9ydHMuZ2V0U2xpZGVDb3VudCA9IGV4cG9ydHMuZ2V0UmVxdWlyZWRMYXp5U2xpZGVzID0gZXhwb3J0cy5nZXRQcmVDbG9uZXMgPSBleHBvcnRzLmdldFBvc3RDbG9uZXMgPSBleHBvcnRzLmdldE9uRGVtYW5kTGF6eVNsaWRlcyA9IGV4cG9ydHMuZ2V0TmF2aWdhYmxlSW5kZXhlcyA9IGV4cG9ydHMuZ2V0SGVpZ2h0ID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfZGVmYXVsdFByb3BzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vZGVmYXVsdC1wcm9wc1wiKSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogU3RyaW5nKGkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gY2xhbXAobnVtYmVyLCBsb3dlckJvdW5kLCB1cHBlckJvdW5kKSB7XG4gIHJldHVybiBNYXRoLm1heChsb3dlckJvdW5kLCBNYXRoLm1pbihudW1iZXIsIHVwcGVyQm91bmQpKTtcbn1cbnZhciBzYWZlUHJldmVudERlZmF1bHQgPSBleHBvcnRzLnNhZmVQcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uIHNhZmVQcmV2ZW50RGVmYXVsdChldmVudCkge1xuICB2YXIgcGFzc2l2ZUV2ZW50cyA9IFtcIm9uVG91Y2hTdGFydFwiLCBcIm9uVG91Y2hNb3ZlXCIsIFwib25XaGVlbFwiXTtcbiAgaWYgKCFwYXNzaXZlRXZlbnRzLmluY2x1ZGVzKGV2ZW50Ll9yZWFjdE5hbWUpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxufTtcbnZhciBnZXRPbkRlbWFuZExhenlTbGlkZXMgPSBleHBvcnRzLmdldE9uRGVtYW5kTGF6eVNsaWRlcyA9IGZ1bmN0aW9uIGdldE9uRGVtYW5kTGF6eVNsaWRlcyhzcGVjKSB7XG4gIHZhciBvbkRlbWFuZFNsaWRlcyA9IFtdO1xuICB2YXIgc3RhcnRJbmRleCA9IGxhenlTdGFydEluZGV4KHNwZWMpO1xuICB2YXIgZW5kSW5kZXggPSBsYXp5RW5kSW5kZXgoc3BlYyk7XG4gIGZvciAodmFyIHNsaWRlSW5kZXggPSBzdGFydEluZGV4OyBzbGlkZUluZGV4IDwgZW5kSW5kZXg7IHNsaWRlSW5kZXgrKykge1xuICAgIGlmIChzcGVjLmxhenlMb2FkZWRMaXN0LmluZGV4T2Yoc2xpZGVJbmRleCkgPCAwKSB7XG4gICAgICBvbkRlbWFuZFNsaWRlcy5wdXNoKHNsaWRlSW5kZXgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb25EZW1hbmRTbGlkZXM7XG59O1xuXG4vLyByZXR1cm4gbGlzdCBvZiBzbGlkZXMgdGhhdCBuZWVkIHRvIGJlIHByZXNlbnRcbnZhciBnZXRSZXF1aXJlZExhenlTbGlkZXMgPSBleHBvcnRzLmdldFJlcXVpcmVkTGF6eVNsaWRlcyA9IGZ1bmN0aW9uIGdldFJlcXVpcmVkTGF6eVNsaWRlcyhzcGVjKSB7XG4gIHZhciByZXF1aXJlZFNsaWRlcyA9IFtdO1xuICB2YXIgc3RhcnRJbmRleCA9IGxhenlTdGFydEluZGV4KHNwZWMpO1xuICB2YXIgZW5kSW5kZXggPSBsYXp5RW5kSW5kZXgoc3BlYyk7XG4gIGZvciAodmFyIHNsaWRlSW5kZXggPSBzdGFydEluZGV4OyBzbGlkZUluZGV4IDwgZW5kSW5kZXg7IHNsaWRlSW5kZXgrKykge1xuICAgIHJlcXVpcmVkU2xpZGVzLnB1c2goc2xpZGVJbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlcXVpcmVkU2xpZGVzO1xufTtcblxuLy8gc3RhcnRJbmRleCB0aGF0IG5lZWRzIHRvIGJlIHByZXNlbnRcbnZhciBsYXp5U3RhcnRJbmRleCA9IGV4cG9ydHMubGF6eVN0YXJ0SW5kZXggPSBmdW5jdGlvbiBsYXp5U3RhcnRJbmRleChzcGVjKSB7XG4gIHJldHVybiBzcGVjLmN1cnJlbnRTbGlkZSAtIGxhenlTbGlkZXNPbkxlZnQoc3BlYyk7XG59O1xudmFyIGxhenlFbmRJbmRleCA9IGV4cG9ydHMubGF6eUVuZEluZGV4ID0gZnVuY3Rpb24gbGF6eUVuZEluZGV4KHNwZWMpIHtcbiAgcmV0dXJuIHNwZWMuY3VycmVudFNsaWRlICsgbGF6eVNsaWRlc09uUmlnaHQoc3BlYyk7XG59O1xudmFyIGxhenlTbGlkZXNPbkxlZnQgPSBleHBvcnRzLmxhenlTbGlkZXNPbkxlZnQgPSBmdW5jdGlvbiBsYXp5U2xpZGVzT25MZWZ0KHNwZWMpIHtcbiAgcmV0dXJuIHNwZWMuY2VudGVyTW9kZSA/IE1hdGguZmxvb3Ioc3BlYy5zbGlkZXNUb1Nob3cgLyAyKSArIChwYXJzZUludChzcGVjLmNlbnRlclBhZGRpbmcpID4gMCA/IDEgOiAwKSA6IDA7XG59O1xudmFyIGxhenlTbGlkZXNPblJpZ2h0ID0gZXhwb3J0cy5sYXp5U2xpZGVzT25SaWdodCA9IGZ1bmN0aW9uIGxhenlTbGlkZXNPblJpZ2h0KHNwZWMpIHtcbiAgcmV0dXJuIHNwZWMuY2VudGVyTW9kZSA/IE1hdGguZmxvb3IoKHNwZWMuc2xpZGVzVG9TaG93IC0gMSkgLyAyKSArIDEgKyAocGFyc2VJbnQoc3BlYy5jZW50ZXJQYWRkaW5nKSA+IDAgPyAxIDogMCkgOiBzcGVjLnNsaWRlc1RvU2hvdztcbn07XG5cbi8vIGdldCB3aWR0aCBvZiBhbiBlbGVtZW50XG52YXIgZ2V0V2lkdGggPSBleHBvcnRzLmdldFdpZHRoID0gZnVuY3Rpb24gZ2V0V2lkdGgoZWxlbSkge1xuICByZXR1cm4gZWxlbSAmJiBlbGVtLm9mZnNldFdpZHRoIHx8IDA7XG59O1xudmFyIGdldEhlaWdodCA9IGV4cG9ydHMuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gZ2V0SGVpZ2h0KGVsZW0pIHtcbiAgcmV0dXJuIGVsZW0gJiYgZWxlbS5vZmZzZXRIZWlnaHQgfHwgMDtcbn07XG52YXIgZ2V0U3dpcGVEaXJlY3Rpb24gPSBleHBvcnRzLmdldFN3aXBlRGlyZWN0aW9uID0gZnVuY3Rpb24gZ2V0U3dpcGVEaXJlY3Rpb24odG91Y2hPYmplY3QpIHtcbiAgdmFyIHZlcnRpY2FsU3dpcGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gIHZhciB4RGlzdCwgeURpc3QsIHIsIHN3aXBlQW5nbGU7XG4gIHhEaXN0ID0gdG91Y2hPYmplY3Quc3RhcnRYIC0gdG91Y2hPYmplY3QuY3VyWDtcbiAgeURpc3QgPSB0b3VjaE9iamVjdC5zdGFydFkgLSB0b3VjaE9iamVjdC5jdXJZO1xuICByID0gTWF0aC5hdGFuMih5RGlzdCwgeERpc3QpO1xuICBzd2lwZUFuZ2xlID0gTWF0aC5yb3VuZChyICogMTgwIC8gTWF0aC5QSSk7XG4gIGlmIChzd2lwZUFuZ2xlIDwgMCkge1xuICAgIHN3aXBlQW5nbGUgPSAzNjAgLSBNYXRoLmFicyhzd2lwZUFuZ2xlKTtcbiAgfVxuICBpZiAoc3dpcGVBbmdsZSA8PSA0NSAmJiBzd2lwZUFuZ2xlID49IDAgfHwgc3dpcGVBbmdsZSA8PSAzNjAgJiYgc3dpcGVBbmdsZSA+PSAzMTUpIHtcbiAgICByZXR1cm4gXCJsZWZ0XCI7XG4gIH1cbiAgaWYgKHN3aXBlQW5nbGUgPj0gMTM1ICYmIHN3aXBlQW5nbGUgPD0gMjI1KSB7XG4gICAgcmV0dXJuIFwicmlnaHRcIjtcbiAgfVxuICBpZiAodmVydGljYWxTd2lwaW5nID09PSB0cnVlKSB7XG4gICAgaWYgKHN3aXBlQW5nbGUgPj0gMzUgJiYgc3dpcGVBbmdsZSA8PSAxMzUpIHtcbiAgICAgIHJldHVybiBcInVwXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcImRvd25cIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFwidmVydGljYWxcIjtcbn07XG5cbi8vIHdoZXRoZXIgb3Igbm90IHdlIGNhbiBnbyBuZXh0XG52YXIgY2FuR29OZXh0ID0gZXhwb3J0cy5jYW5Hb05leHQgPSBmdW5jdGlvbiBjYW5Hb05leHQoc3BlYykge1xuICB2YXIgY2FuR28gPSB0cnVlO1xuICBpZiAoIXNwZWMuaW5maW5pdGUpIHtcbiAgICBpZiAoc3BlYy5jZW50ZXJNb2RlICYmIHNwZWMuY3VycmVudFNsaWRlID49IHNwZWMuc2xpZGVDb3VudCAtIDEpIHtcbiAgICAgIGNhbkdvID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChzcGVjLnNsaWRlQ291bnQgPD0gc3BlYy5zbGlkZXNUb1Nob3cgfHwgc3BlYy5jdXJyZW50U2xpZGUgPj0gc3BlYy5zbGlkZUNvdW50IC0gc3BlYy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgIGNhbkdvID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW5Hbztcbn07XG5cbi8vIGdpdmVuIGFuIG9iamVjdCBhbmQgYSBsaXN0IG9mIGtleXMsIHJldHVybiBuZXcgb2JqZWN0IHdpdGggZ2l2ZW4ga2V5c1xudmFyIGV4dHJhY3RPYmplY3QgPSBleHBvcnRzLmV4dHJhY3RPYmplY3QgPSBmdW5jdGlvbiBleHRyYWN0T2JqZWN0KHNwZWMsIGtleXMpIHtcbiAgdmFyIG5ld09iamVjdCA9IHt9O1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBuZXdPYmplY3Rba2V5XSA9IHNwZWNba2V5XTtcbiAgfSk7XG4gIHJldHVybiBuZXdPYmplY3Q7XG59O1xuXG4vLyBnZXQgaW5pdGlhbGl6ZWQgc3RhdGVcbnZhciBpbml0aWFsaXplZFN0YXRlID0gZXhwb3J0cy5pbml0aWFsaXplZFN0YXRlID0gZnVuY3Rpb24gaW5pdGlhbGl6ZWRTdGF0ZShzcGVjKSB7XG4gIC8vIHNwZWMgYWxzbyBjb250YWlucyBsaXN0UmVmLCB0cmFja1JlZlxuICB2YXIgc2xpZGVDb3VudCA9IF9yZWFjdFtcImRlZmF1bHRcIl0uQ2hpbGRyZW4uY291bnQoc3BlYy5jaGlsZHJlbik7XG4gIHZhciBsaXN0Tm9kZSA9IHNwZWMubGlzdFJlZjtcbiAgdmFyIGxpc3RXaWR0aCA9IE1hdGguY2VpbChnZXRXaWR0aChsaXN0Tm9kZSkpO1xuICB2YXIgdHJhY2tOb2RlID0gc3BlYy50cmFja1JlZiAmJiBzcGVjLnRyYWNrUmVmLm5vZGU7XG4gIHZhciB0cmFja1dpZHRoID0gTWF0aC5jZWlsKGdldFdpZHRoKHRyYWNrTm9kZSkpO1xuICB2YXIgc2xpZGVXaWR0aDtcbiAgaWYgKCFzcGVjLnZlcnRpY2FsKSB7XG4gICAgdmFyIGNlbnRlclBhZGRpbmdBZGogPSBzcGVjLmNlbnRlck1vZGUgJiYgcGFyc2VJbnQoc3BlYy5jZW50ZXJQYWRkaW5nKSAqIDI7XG4gICAgaWYgKHR5cGVvZiBzcGVjLmNlbnRlclBhZGRpbmcgPT09IFwic3RyaW5nXCIgJiYgc3BlYy5jZW50ZXJQYWRkaW5nLnNsaWNlKC0xKSA9PT0gXCIlXCIpIHtcbiAgICAgIGNlbnRlclBhZGRpbmdBZGogKj0gbGlzdFdpZHRoIC8gMTAwO1xuICAgIH1cbiAgICBzbGlkZVdpZHRoID0gTWF0aC5jZWlsKChsaXN0V2lkdGggLSBjZW50ZXJQYWRkaW5nQWRqKSAvIHNwZWMuc2xpZGVzVG9TaG93KTtcbiAgfSBlbHNlIHtcbiAgICBzbGlkZVdpZHRoID0gbGlzdFdpZHRoO1xuICB9XG4gIHZhciBzbGlkZUhlaWdodCA9IGxpc3ROb2RlICYmIGdldEhlaWdodChsaXN0Tm9kZS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pbmRleD1cIjBcIl0nKSk7XG4gIHZhciBsaXN0SGVpZ2h0ID0gc2xpZGVIZWlnaHQgKiBzcGVjLnNsaWRlc1RvU2hvdztcbiAgdmFyIGN1cnJlbnRTbGlkZSA9IHNwZWMuY3VycmVudFNsaWRlID09PSB1bmRlZmluZWQgPyBzcGVjLmluaXRpYWxTbGlkZSA6IHNwZWMuY3VycmVudFNsaWRlO1xuICBpZiAoc3BlYy5ydGwgJiYgc3BlYy5jdXJyZW50U2xpZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGN1cnJlbnRTbGlkZSA9IHNsaWRlQ291bnQgLSAxIC0gc3BlYy5pbml0aWFsU2xpZGU7XG4gIH1cbiAgdmFyIGxhenlMb2FkZWRMaXN0ID0gc3BlYy5sYXp5TG9hZGVkTGlzdCB8fCBbXTtcbiAgdmFyIHNsaWRlc1RvTG9hZCA9IGdldE9uRGVtYW5kTGF6eVNsaWRlcyhfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHNwZWMpLCB7fSwge1xuICAgIGN1cnJlbnRTbGlkZTogY3VycmVudFNsaWRlLFxuICAgIGxhenlMb2FkZWRMaXN0OiBsYXp5TG9hZGVkTGlzdFxuICB9KSk7XG4gIGxhenlMb2FkZWRMaXN0ID0gbGF6eUxvYWRlZExpc3QuY29uY2F0KHNsaWRlc1RvTG9hZCk7XG4gIHZhciBzdGF0ZSA9IHtcbiAgICBzbGlkZUNvdW50OiBzbGlkZUNvdW50LFxuICAgIHNsaWRlV2lkdGg6IHNsaWRlV2lkdGgsXG4gICAgbGlzdFdpZHRoOiBsaXN0V2lkdGgsXG4gICAgdHJhY2tXaWR0aDogdHJhY2tXaWR0aCxcbiAgICBjdXJyZW50U2xpZGU6IGN1cnJlbnRTbGlkZSxcbiAgICBzbGlkZUhlaWdodDogc2xpZGVIZWlnaHQsXG4gICAgbGlzdEhlaWdodDogbGlzdEhlaWdodCxcbiAgICBsYXp5TG9hZGVkTGlzdDogbGF6eUxvYWRlZExpc3RcbiAgfTtcbiAgaWYgKHNwZWMuYXV0b3BsYXlpbmcgPT09IG51bGwgJiYgc3BlYy5hdXRvcGxheSkge1xuICAgIHN0YXRlW1wiYXV0b3BsYXlpbmdcIl0gPSBcInBsYXlpbmdcIjtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59O1xudmFyIHNsaWRlSGFuZGxlciA9IGV4cG9ydHMuc2xpZGVIYW5kbGVyID0gZnVuY3Rpb24gc2xpZGVIYW5kbGVyKHNwZWMpIHtcbiAgdmFyIHdhaXRGb3JBbmltYXRlID0gc3BlYy53YWl0Rm9yQW5pbWF0ZSxcbiAgICBhbmltYXRpbmcgPSBzcGVjLmFuaW1hdGluZyxcbiAgICBmYWRlID0gc3BlYy5mYWRlLFxuICAgIGluZmluaXRlID0gc3BlYy5pbmZpbml0ZSxcbiAgICBpbmRleCA9IHNwZWMuaW5kZXgsXG4gICAgc2xpZGVDb3VudCA9IHNwZWMuc2xpZGVDb3VudCxcbiAgICBsYXp5TG9hZCA9IHNwZWMubGF6eUxvYWQsXG4gICAgY3VycmVudFNsaWRlID0gc3BlYy5jdXJyZW50U2xpZGUsXG4gICAgY2VudGVyTW9kZSA9IHNwZWMuY2VudGVyTW9kZSxcbiAgICBzbGlkZXNUb1Njcm9sbCA9IHNwZWMuc2xpZGVzVG9TY3JvbGwsXG4gICAgc2xpZGVzVG9TaG93ID0gc3BlYy5zbGlkZXNUb1Nob3csXG4gICAgdXNlQ1NTID0gc3BlYy51c2VDU1M7XG4gIHZhciBsYXp5TG9hZGVkTGlzdCA9IHNwZWMubGF6eUxvYWRlZExpc3Q7XG4gIGlmICh3YWl0Rm9yQW5pbWF0ZSAmJiBhbmltYXRpbmcpIHJldHVybiB7fTtcbiAgdmFyIGFuaW1hdGlvblNsaWRlID0gaW5kZXgsXG4gICAgZmluYWxTbGlkZSxcbiAgICBhbmltYXRpb25MZWZ0LFxuICAgIGZpbmFsTGVmdDtcbiAgdmFyIHN0YXRlID0ge30sXG4gICAgbmV4dFN0YXRlID0ge307XG4gIHZhciB0YXJnZXRTbGlkZSA9IGluZmluaXRlID8gaW5kZXggOiBjbGFtcChpbmRleCwgMCwgc2xpZGVDb3VudCAtIDEpO1xuICBpZiAoZmFkZSkge1xuICAgIGlmICghaW5maW5pdGUgJiYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzbGlkZUNvdW50KSkgcmV0dXJuIHt9O1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIGFuaW1hdGlvblNsaWRlID0gaW5kZXggKyBzbGlkZUNvdW50O1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPj0gc2xpZGVDb3VudCkge1xuICAgICAgYW5pbWF0aW9uU2xpZGUgPSBpbmRleCAtIHNsaWRlQ291bnQ7XG4gICAgfVxuICAgIGlmIChsYXp5TG9hZCAmJiBsYXp5TG9hZGVkTGlzdC5pbmRleE9mKGFuaW1hdGlvblNsaWRlKSA8IDApIHtcbiAgICAgIGxhenlMb2FkZWRMaXN0ID0gbGF6eUxvYWRlZExpc3QuY29uY2F0KGFuaW1hdGlvblNsaWRlKTtcbiAgICB9XG4gICAgc3RhdGUgPSB7XG4gICAgICBhbmltYXRpbmc6IHRydWUsXG4gICAgICBjdXJyZW50U2xpZGU6IGFuaW1hdGlvblNsaWRlLFxuICAgICAgbGF6eUxvYWRlZExpc3Q6IGxhenlMb2FkZWRMaXN0LFxuICAgICAgdGFyZ2V0U2xpZGU6IGFuaW1hdGlvblNsaWRlXG4gICAgfTtcbiAgICBuZXh0U3RhdGUgPSB7XG4gICAgICBhbmltYXRpbmc6IGZhbHNlLFxuICAgICAgdGFyZ2V0U2xpZGU6IGFuaW1hdGlvblNsaWRlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBmaW5hbFNsaWRlID0gYW5pbWF0aW9uU2xpZGU7XG4gICAgaWYgKGFuaW1hdGlvblNsaWRlIDwgMCkge1xuICAgICAgZmluYWxTbGlkZSA9IGFuaW1hdGlvblNsaWRlICsgc2xpZGVDb3VudDtcbiAgICAgIGlmICghaW5maW5pdGUpIGZpbmFsU2xpZGUgPSAwO2Vsc2UgaWYgKHNsaWRlQ291bnQgJSBzbGlkZXNUb1Njcm9sbCAhPT0gMCkgZmluYWxTbGlkZSA9IHNsaWRlQ291bnQgLSBzbGlkZUNvdW50ICUgc2xpZGVzVG9TY3JvbGw7XG4gICAgfSBlbHNlIGlmICghY2FuR29OZXh0KHNwZWMpICYmIGFuaW1hdGlvblNsaWRlID4gY3VycmVudFNsaWRlKSB7XG4gICAgICBhbmltYXRpb25TbGlkZSA9IGZpbmFsU2xpZGUgPSBjdXJyZW50U2xpZGU7XG4gICAgfSBlbHNlIGlmIChjZW50ZXJNb2RlICYmIGFuaW1hdGlvblNsaWRlID49IHNsaWRlQ291bnQpIHtcbiAgICAgIGFuaW1hdGlvblNsaWRlID0gaW5maW5pdGUgPyBzbGlkZUNvdW50IDogc2xpZGVDb3VudCAtIDE7XG4gICAgICBmaW5hbFNsaWRlID0gaW5maW5pdGUgPyAwIDogc2xpZGVDb3VudCAtIDE7XG4gICAgfSBlbHNlIGlmIChhbmltYXRpb25TbGlkZSA+PSBzbGlkZUNvdW50KSB7XG4gICAgICBmaW5hbFNsaWRlID0gYW5pbWF0aW9uU2xpZGUgLSBzbGlkZUNvdW50O1xuICAgICAgaWYgKCFpbmZpbml0ZSkgZmluYWxTbGlkZSA9IHNsaWRlQ291bnQgLSBzbGlkZXNUb1Nob3c7ZWxzZSBpZiAoc2xpZGVDb3VudCAlIHNsaWRlc1RvU2Nyb2xsICE9PSAwKSBmaW5hbFNsaWRlID0gMDtcbiAgICB9XG4gICAgaWYgKCFpbmZpbml0ZSAmJiBhbmltYXRpb25TbGlkZSArIHNsaWRlc1RvU2hvdyA+PSBzbGlkZUNvdW50KSB7XG4gICAgICBmaW5hbFNsaWRlID0gc2xpZGVDb3VudCAtIHNsaWRlc1RvU2hvdztcbiAgICB9XG4gICAgYW5pbWF0aW9uTGVmdCA9IGdldFRyYWNrTGVmdChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHNwZWMpLCB7fSwge1xuICAgICAgc2xpZGVJbmRleDogYW5pbWF0aW9uU2xpZGVcbiAgICB9KSk7XG4gICAgZmluYWxMZWZ0ID0gZ2V0VHJhY2tMZWZ0KF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3BlYyksIHt9LCB7XG4gICAgICBzbGlkZUluZGV4OiBmaW5hbFNsaWRlXG4gICAgfSkpO1xuICAgIGlmICghaW5maW5pdGUpIHtcbiAgICAgIGlmIChhbmltYXRpb25MZWZ0ID09PSBmaW5hbExlZnQpIGFuaW1hdGlvblNsaWRlID0gZmluYWxTbGlkZTtcbiAgICAgIGFuaW1hdGlvbkxlZnQgPSBmaW5hbExlZnQ7XG4gICAgfVxuICAgIGlmIChsYXp5TG9hZCkge1xuICAgICAgbGF6eUxvYWRlZExpc3QgPSBsYXp5TG9hZGVkTGlzdC5jb25jYXQoZ2V0T25EZW1hbmRMYXp5U2xpZGVzKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3BlYyksIHt9LCB7XG4gICAgICAgIGN1cnJlbnRTbGlkZTogYW5pbWF0aW9uU2xpZGVcbiAgICAgIH0pKSk7XG4gICAgfVxuICAgIGlmICghdXNlQ1NTKSB7XG4gICAgICBzdGF0ZSA9IHtcbiAgICAgICAgY3VycmVudFNsaWRlOiBmaW5hbFNsaWRlLFxuICAgICAgICB0cmFja1N0eWxlOiBnZXRUcmFja0NTUyhfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHNwZWMpLCB7fSwge1xuICAgICAgICAgIGxlZnQ6IGZpbmFsTGVmdFxuICAgICAgICB9KSksXG4gICAgICAgIGxhenlMb2FkZWRMaXN0OiBsYXp5TG9hZGVkTGlzdCxcbiAgICAgICAgdGFyZ2V0U2xpZGU6IHRhcmdldFNsaWRlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZSA9IHtcbiAgICAgICAgYW5pbWF0aW5nOiB0cnVlLFxuICAgICAgICBjdXJyZW50U2xpZGU6IGZpbmFsU2xpZGUsXG4gICAgICAgIHRyYWNrU3R5bGU6IGdldFRyYWNrQW5pbWF0ZUNTUyhfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHNwZWMpLCB7fSwge1xuICAgICAgICAgIGxlZnQ6IGFuaW1hdGlvbkxlZnRcbiAgICAgICAgfSkpLFxuICAgICAgICBsYXp5TG9hZGVkTGlzdDogbGF6eUxvYWRlZExpc3QsXG4gICAgICAgIHRhcmdldFNsaWRlOiB0YXJnZXRTbGlkZVxuICAgICAgfTtcbiAgICAgIG5leHRTdGF0ZSA9IHtcbiAgICAgICAgYW5pbWF0aW5nOiBmYWxzZSxcbiAgICAgICAgY3VycmVudFNsaWRlOiBmaW5hbFNsaWRlLFxuICAgICAgICB0cmFja1N0eWxlOiBnZXRUcmFja0NTUyhfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHNwZWMpLCB7fSwge1xuICAgICAgICAgIGxlZnQ6IGZpbmFsTGVmdFxuICAgICAgICB9KSksXG4gICAgICAgIHN3aXBlTGVmdDogbnVsbCxcbiAgICAgICAgdGFyZ2V0U2xpZGU6IHRhcmdldFNsaWRlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHN0YXRlOiBzdGF0ZSxcbiAgICBuZXh0U3RhdGU6IG5leHRTdGF0ZVxuICB9O1xufTtcbnZhciBjaGFuZ2VTbGlkZSA9IGV4cG9ydHMuY2hhbmdlU2xpZGUgPSBmdW5jdGlvbiBjaGFuZ2VTbGlkZShzcGVjLCBvcHRpb25zKSB7XG4gIHZhciBpbmRleE9mZnNldCwgcHJldmlvdXNJbnQsIHNsaWRlT2Zmc2V0LCB1bmV2ZW5PZmZzZXQsIHRhcmdldFNsaWRlO1xuICB2YXIgc2xpZGVzVG9TY3JvbGwgPSBzcGVjLnNsaWRlc1RvU2Nyb2xsLFxuICAgIHNsaWRlc1RvU2hvdyA9IHNwZWMuc2xpZGVzVG9TaG93LFxuICAgIHNsaWRlQ291bnQgPSBzcGVjLnNsaWRlQ291bnQsXG4gICAgY3VycmVudFNsaWRlID0gc3BlYy5jdXJyZW50U2xpZGUsXG4gICAgcHJldmlvdXNUYXJnZXRTbGlkZSA9IHNwZWMudGFyZ2V0U2xpZGUsXG4gICAgbGF6eUxvYWQgPSBzcGVjLmxhenlMb2FkLFxuICAgIGluZmluaXRlID0gc3BlYy5pbmZpbml0ZTtcbiAgdW5ldmVuT2Zmc2V0ID0gc2xpZGVDb3VudCAlIHNsaWRlc1RvU2Nyb2xsICE9PSAwO1xuICBpbmRleE9mZnNldCA9IHVuZXZlbk9mZnNldCA/IDAgOiAoc2xpZGVDb3VudCAtIGN1cnJlbnRTbGlkZSkgJSBzbGlkZXNUb1Njcm9sbDtcbiAgaWYgKG9wdGlvbnMubWVzc2FnZSA9PT0gXCJwcmV2aW91c1wiKSB7XG4gICAgc2xpZGVPZmZzZXQgPSBpbmRleE9mZnNldCA9PT0gMCA/IHNsaWRlc1RvU2Nyb2xsIDogc2xpZGVzVG9TaG93IC0gaW5kZXhPZmZzZXQ7XG4gICAgdGFyZ2V0U2xpZGUgPSBjdXJyZW50U2xpZGUgLSBzbGlkZU9mZnNldDtcbiAgICBpZiAobGF6eUxvYWQgJiYgIWluZmluaXRlKSB7XG4gICAgICBwcmV2aW91c0ludCA9IGN1cnJlbnRTbGlkZSAtIHNsaWRlT2Zmc2V0O1xuICAgICAgdGFyZ2V0U2xpZGUgPSBwcmV2aW91c0ludCA9PT0gLTEgPyBzbGlkZUNvdW50IC0gMSA6IHByZXZpb3VzSW50O1xuICAgIH1cbiAgICBpZiAoIWluZmluaXRlKSB7XG4gICAgICB0YXJnZXRTbGlkZSA9IHByZXZpb3VzVGFyZ2V0U2xpZGUgLSBzbGlkZXNUb1Njcm9sbDtcbiAgICB9XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5tZXNzYWdlID09PSBcIm5leHRcIikge1xuICAgIHNsaWRlT2Zmc2V0ID0gaW5kZXhPZmZzZXQgPT09IDAgPyBzbGlkZXNUb1Njcm9sbCA6IGluZGV4T2Zmc2V0O1xuICAgIHRhcmdldFNsaWRlID0gY3VycmVudFNsaWRlICsgc2xpZGVPZmZzZXQ7XG4gICAgaWYgKGxhenlMb2FkICYmICFpbmZpbml0ZSkge1xuICAgICAgdGFyZ2V0U2xpZGUgPSAoY3VycmVudFNsaWRlICsgc2xpZGVzVG9TY3JvbGwpICUgc2xpZGVDb3VudCArIGluZGV4T2Zmc2V0O1xuICAgIH1cbiAgICBpZiAoIWluZmluaXRlKSB7XG4gICAgICB0YXJnZXRTbGlkZSA9IHByZXZpb3VzVGFyZ2V0U2xpZGUgKyBzbGlkZXNUb1Njcm9sbDtcbiAgICB9XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5tZXNzYWdlID09PSBcImRvdHNcIikge1xuICAgIC8vIENsaWNrIG9uIGRvdHNcbiAgICB0YXJnZXRTbGlkZSA9IG9wdGlvbnMuaW5kZXggKiBvcHRpb25zLnNsaWRlc1RvU2Nyb2xsO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMubWVzc2FnZSA9PT0gXCJjaGlsZHJlblwiKSB7XG4gICAgLy8gQ2xpY2sgb24gdGhlIHNsaWRlc1xuICAgIHRhcmdldFNsaWRlID0gb3B0aW9ucy5pbmRleDtcbiAgICBpZiAoaW5maW5pdGUpIHtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSBzaWJsaW5nRGlyZWN0aW9uKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3BlYyksIHt9LCB7XG4gICAgICAgIHRhcmdldFNsaWRlOiB0YXJnZXRTbGlkZVxuICAgICAgfSkpO1xuICAgICAgaWYgKHRhcmdldFNsaWRlID4gb3B0aW9ucy5jdXJyZW50U2xpZGUgJiYgZGlyZWN0aW9uID09PSBcImxlZnRcIikge1xuICAgICAgICB0YXJnZXRTbGlkZSA9IHRhcmdldFNsaWRlIC0gc2xpZGVDb3VudDtcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0U2xpZGUgPCBvcHRpb25zLmN1cnJlbnRTbGlkZSAmJiBkaXJlY3Rpb24gPT09IFwicmlnaHRcIikge1xuICAgICAgICB0YXJnZXRTbGlkZSA9IHRhcmdldFNsaWRlICsgc2xpZGVDb3VudDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5tZXNzYWdlID09PSBcImluZGV4XCIpIHtcbiAgICB0YXJnZXRTbGlkZSA9IE51bWJlcihvcHRpb25zLmluZGV4KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0U2xpZGU7XG59O1xudmFyIGtleUhhbmRsZXIgPSBleHBvcnRzLmtleUhhbmRsZXIgPSBmdW5jdGlvbiBrZXlIYW5kbGVyKGUsIGFjY2Vzc2liaWxpdHksIHJ0bCkge1xuICBpZiAoZS50YXJnZXQudGFnTmFtZS5tYXRjaChcIlRFWFRBUkVBfElOUFVUfFNFTEVDVFwiKSB8fCAhYWNjZXNzaWJpbGl0eSkgcmV0dXJuIFwiXCI7XG4gIGlmIChlLmtleUNvZGUgPT09IDM3KSByZXR1cm4gcnRsID8gXCJuZXh0XCIgOiBcInByZXZpb3VzXCI7XG4gIGlmIChlLmtleUNvZGUgPT09IDM5KSByZXR1cm4gcnRsID8gXCJwcmV2aW91c1wiIDogXCJuZXh0XCI7XG4gIHJldHVybiBcIlwiO1xufTtcbnZhciBzd2lwZVN0YXJ0ID0gZXhwb3J0cy5zd2lwZVN0YXJ0ID0gZnVuY3Rpb24gc3dpcGVTdGFydChlLCBzd2lwZSwgZHJhZ2dhYmxlKSB7XG4gIGUudGFyZ2V0LnRhZ05hbWUgPT09IFwiSU1HXCIgJiYgc2FmZVByZXZlbnREZWZhdWx0KGUpO1xuICBpZiAoIXN3aXBlIHx8ICFkcmFnZ2FibGUgJiYgZS50eXBlLmluZGV4T2YoXCJtb3VzZVwiKSAhPT0gLTEpIHJldHVybiBcIlwiO1xuICByZXR1cm4ge1xuICAgIGRyYWdnaW5nOiB0cnVlLFxuICAgIHRvdWNoT2JqZWN0OiB7XG4gICAgICBzdGFydFg6IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXS5wYWdlWCA6IGUuY2xpZW50WCxcbiAgICAgIHN0YXJ0WTogZS50b3VjaGVzID8gZS50b3VjaGVzWzBdLnBhZ2VZIDogZS5jbGllbnRZLFxuICAgICAgY3VyWDogZS50b3VjaGVzID8gZS50b3VjaGVzWzBdLnBhZ2VYIDogZS5jbGllbnRYLFxuICAgICAgY3VyWTogZS50b3VjaGVzID8gZS50b3VjaGVzWzBdLnBhZ2VZIDogZS5jbGllbnRZXG4gICAgfVxuICB9O1xufTtcbnZhciBzd2lwZU1vdmUgPSBleHBvcnRzLnN3aXBlTW92ZSA9IGZ1bmN0aW9uIHN3aXBlTW92ZShlLCBzcGVjKSB7XG4gIC8vIHNwZWMgYWxzbyBjb250YWlucywgdHJhY2tSZWYgYW5kIHNsaWRlSW5kZXhcbiAgdmFyIHNjcm9sbGluZyA9IHNwZWMuc2Nyb2xsaW5nLFxuICAgIGFuaW1hdGluZyA9IHNwZWMuYW5pbWF0aW5nLFxuICAgIHZlcnRpY2FsID0gc3BlYy52ZXJ0aWNhbCxcbiAgICBzd2lwZVRvU2xpZGUgPSBzcGVjLnN3aXBlVG9TbGlkZSxcbiAgICB2ZXJ0aWNhbFN3aXBpbmcgPSBzcGVjLnZlcnRpY2FsU3dpcGluZyxcbiAgICBydGwgPSBzcGVjLnJ0bCxcbiAgICBjdXJyZW50U2xpZGUgPSBzcGVjLmN1cnJlbnRTbGlkZSxcbiAgICBlZGdlRnJpY3Rpb24gPSBzcGVjLmVkZ2VGcmljdGlvbixcbiAgICBlZGdlRHJhZ2dlZCA9IHNwZWMuZWRnZURyYWdnZWQsXG4gICAgb25FZGdlID0gc3BlYy5vbkVkZ2UsXG4gICAgc3dpcGVkID0gc3BlYy5zd2lwZWQsXG4gICAgc3dpcGluZyA9IHNwZWMuc3dpcGluZyxcbiAgICBzbGlkZUNvdW50ID0gc3BlYy5zbGlkZUNvdW50LFxuICAgIHNsaWRlc1RvU2Nyb2xsID0gc3BlYy5zbGlkZXNUb1Njcm9sbCxcbiAgICBpbmZpbml0ZSA9IHNwZWMuaW5maW5pdGUsXG4gICAgdG91Y2hPYmplY3QgPSBzcGVjLnRvdWNoT2JqZWN0LFxuICAgIHN3aXBlRXZlbnQgPSBzcGVjLnN3aXBlRXZlbnQsXG4gICAgbGlzdEhlaWdodCA9IHNwZWMubGlzdEhlaWdodCxcbiAgICBsaXN0V2lkdGggPSBzcGVjLmxpc3RXaWR0aDtcbiAgaWYgKHNjcm9sbGluZykgcmV0dXJuO1xuICBpZiAoYW5pbWF0aW5nKSByZXR1cm4gc2FmZVByZXZlbnREZWZhdWx0KGUpO1xuICBpZiAodmVydGljYWwgJiYgc3dpcGVUb1NsaWRlICYmIHZlcnRpY2FsU3dpcGluZykgc2FmZVByZXZlbnREZWZhdWx0KGUpO1xuICB2YXIgc3dpcGVMZWZ0LFxuICAgIHN0YXRlID0ge307XG4gIHZhciBjdXJMZWZ0ID0gZ2V0VHJhY2tMZWZ0KHNwZWMpO1xuICB0b3VjaE9iamVjdC5jdXJYID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdLnBhZ2VYIDogZS5jbGllbnRYO1xuICB0b3VjaE9iamVjdC5jdXJZID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdLnBhZ2VZIDogZS5jbGllbnRZO1xuICB0b3VjaE9iamVjdC5zd2lwZUxlbmd0aCA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KE1hdGgucG93KHRvdWNoT2JqZWN0LmN1clggLSB0b3VjaE9iamVjdC5zdGFydFgsIDIpKSk7XG4gIHZhciB2ZXJ0aWNhbFN3aXBlTGVuZ3RoID0gTWF0aC5yb3VuZChNYXRoLnNxcnQoTWF0aC5wb3codG91Y2hPYmplY3QuY3VyWSAtIHRvdWNoT2JqZWN0LnN0YXJ0WSwgMikpKTtcbiAgaWYgKCF2ZXJ0aWNhbFN3aXBpbmcgJiYgIXN3aXBpbmcgJiYgdmVydGljYWxTd2lwZUxlbmd0aCA+IDEwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcm9sbGluZzogdHJ1ZVxuICAgIH07XG4gIH1cbiAgaWYgKHZlcnRpY2FsU3dpcGluZykgdG91Y2hPYmplY3Quc3dpcGVMZW5ndGggPSB2ZXJ0aWNhbFN3aXBlTGVuZ3RoO1xuICB2YXIgcG9zaXRpb25PZmZzZXQgPSAoIXJ0bCA/IDEgOiAtMSkgKiAodG91Y2hPYmplY3QuY3VyWCA+IHRvdWNoT2JqZWN0LnN0YXJ0WCA/IDEgOiAtMSk7XG4gIGlmICh2ZXJ0aWNhbFN3aXBpbmcpIHBvc2l0aW9uT2Zmc2V0ID0gdG91Y2hPYmplY3QuY3VyWSA+IHRvdWNoT2JqZWN0LnN0YXJ0WSA/IDEgOiAtMTtcbiAgdmFyIGRvdENvdW50ID0gTWF0aC5jZWlsKHNsaWRlQ291bnQgLyBzbGlkZXNUb1Njcm9sbCk7XG4gIHZhciBzd2lwZURpcmVjdGlvbiA9IGdldFN3aXBlRGlyZWN0aW9uKHNwZWMudG91Y2hPYmplY3QsIHZlcnRpY2FsU3dpcGluZyk7XG4gIHZhciB0b3VjaFN3aXBlTGVuZ3RoID0gdG91Y2hPYmplY3Quc3dpcGVMZW5ndGg7XG4gIGlmICghaW5maW5pdGUpIHtcbiAgICBpZiAoY3VycmVudFNsaWRlID09PSAwICYmIChzd2lwZURpcmVjdGlvbiA9PT0gXCJyaWdodFwiIHx8IHN3aXBlRGlyZWN0aW9uID09PSBcImRvd25cIikgfHwgY3VycmVudFNsaWRlICsgMSA+PSBkb3RDb3VudCAmJiAoc3dpcGVEaXJlY3Rpb24gPT09IFwibGVmdFwiIHx8IHN3aXBlRGlyZWN0aW9uID09PSBcInVwXCIpIHx8ICFjYW5Hb05leHQoc3BlYykgJiYgKHN3aXBlRGlyZWN0aW9uID09PSBcImxlZnRcIiB8fCBzd2lwZURpcmVjdGlvbiA9PT0gXCJ1cFwiKSkge1xuICAgICAgdG91Y2hTd2lwZUxlbmd0aCA9IHRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoICogZWRnZUZyaWN0aW9uO1xuICAgICAgaWYgKGVkZ2VEcmFnZ2VkID09PSBmYWxzZSAmJiBvbkVkZ2UpIHtcbiAgICAgICAgb25FZGdlKHN3aXBlRGlyZWN0aW9uKTtcbiAgICAgICAgc3RhdGVbXCJlZGdlRHJhZ2dlZFwiXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghc3dpcGVkICYmIHN3aXBlRXZlbnQpIHtcbiAgICBzd2lwZUV2ZW50KHN3aXBlRGlyZWN0aW9uKTtcbiAgICBzdGF0ZVtcInN3aXBlZFwiXSA9IHRydWU7XG4gIH1cbiAgaWYgKCF2ZXJ0aWNhbCkge1xuICAgIGlmICghcnRsKSB7XG4gICAgICBzd2lwZUxlZnQgPSBjdXJMZWZ0ICsgdG91Y2hTd2lwZUxlbmd0aCAqIHBvc2l0aW9uT2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2lwZUxlZnQgPSBjdXJMZWZ0IC0gdG91Y2hTd2lwZUxlbmd0aCAqIHBvc2l0aW9uT2Zmc2V0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzd2lwZUxlZnQgPSBjdXJMZWZ0ICsgdG91Y2hTd2lwZUxlbmd0aCAqIChsaXN0SGVpZ2h0IC8gbGlzdFdpZHRoKSAqIHBvc2l0aW9uT2Zmc2V0O1xuICB9XG4gIGlmICh2ZXJ0aWNhbFN3aXBpbmcpIHtcbiAgICBzd2lwZUxlZnQgPSBjdXJMZWZ0ICsgdG91Y2hTd2lwZUxlbmd0aCAqIHBvc2l0aW9uT2Zmc2V0O1xuICB9XG4gIHN0YXRlID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzdGF0ZSksIHt9LCB7XG4gICAgdG91Y2hPYmplY3Q6IHRvdWNoT2JqZWN0LFxuICAgIHN3aXBlTGVmdDogc3dpcGVMZWZ0LFxuICAgIHRyYWNrU3R5bGU6IGdldFRyYWNrQ1NTKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3BlYyksIHt9LCB7XG4gICAgICBsZWZ0OiBzd2lwZUxlZnRcbiAgICB9KSlcbiAgfSk7XG4gIGlmIChNYXRoLmFicyh0b3VjaE9iamVjdC5jdXJYIC0gdG91Y2hPYmplY3Quc3RhcnRYKSA8IE1hdGguYWJzKHRvdWNoT2JqZWN0LmN1clkgLSB0b3VjaE9iamVjdC5zdGFydFkpICogMC44KSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGlmICh0b3VjaE9iamVjdC5zd2lwZUxlbmd0aCA+IDEwKSB7XG4gICAgc3RhdGVbXCJzd2lwaW5nXCJdID0gdHJ1ZTtcbiAgICBzYWZlUHJldmVudERlZmF1bHQoZSk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufTtcbnZhciBzd2lwZUVuZCA9IGV4cG9ydHMuc3dpcGVFbmQgPSBmdW5jdGlvbiBzd2lwZUVuZChlLCBzcGVjKSB7XG4gIHZhciBkcmFnZ2luZyA9IHNwZWMuZHJhZ2dpbmcsXG4gICAgc3dpcGUgPSBzcGVjLnN3aXBlLFxuICAgIHRvdWNoT2JqZWN0ID0gc3BlYy50b3VjaE9iamVjdCxcbiAgICBsaXN0V2lkdGggPSBzcGVjLmxpc3RXaWR0aCxcbiAgICB0b3VjaFRocmVzaG9sZCA9IHNwZWMudG91Y2hUaHJlc2hvbGQsXG4gICAgdmVydGljYWxTd2lwaW5nID0gc3BlYy52ZXJ0aWNhbFN3aXBpbmcsXG4gICAgbGlzdEhlaWdodCA9IHNwZWMubGlzdEhlaWdodCxcbiAgICBzd2lwZVRvU2xpZGUgPSBzcGVjLnN3aXBlVG9TbGlkZSxcbiAgICBzY3JvbGxpbmcgPSBzcGVjLnNjcm9sbGluZyxcbiAgICBvblN3aXBlID0gc3BlYy5vblN3aXBlLFxuICAgIHRhcmdldFNsaWRlID0gc3BlYy50YXJnZXRTbGlkZSxcbiAgICBjdXJyZW50U2xpZGUgPSBzcGVjLmN1cnJlbnRTbGlkZSxcbiAgICBpbmZpbml0ZSA9IHNwZWMuaW5maW5pdGU7XG4gIGlmICghZHJhZ2dpbmcpIHtcbiAgICBpZiAoc3dpcGUpIHNhZmVQcmV2ZW50RGVmYXVsdChlKTtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgdmFyIG1pblN3aXBlID0gdmVydGljYWxTd2lwaW5nID8gbGlzdEhlaWdodCAvIHRvdWNoVGhyZXNob2xkIDogbGlzdFdpZHRoIC8gdG91Y2hUaHJlc2hvbGQ7XG4gIHZhciBzd2lwZURpcmVjdGlvbiA9IGdldFN3aXBlRGlyZWN0aW9uKHRvdWNoT2JqZWN0LCB2ZXJ0aWNhbFN3aXBpbmcpO1xuICAvLyByZXNldCB0aGUgc3RhdGUgb2YgdG91Y2ggcmVsYXRlZCBzdGF0ZSB2YXJpYWJsZXMuXG4gIHZhciBzdGF0ZSA9IHtcbiAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgZWRnZURyYWdnZWQ6IGZhbHNlLFxuICAgIHNjcm9sbGluZzogZmFsc2UsXG4gICAgc3dpcGluZzogZmFsc2UsXG4gICAgc3dpcGVkOiBmYWxzZSxcbiAgICBzd2lwZUxlZnQ6IG51bGwsXG4gICAgdG91Y2hPYmplY3Q6IHt9XG4gIH07XG4gIGlmIChzY3JvbGxpbmcpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgaWYgKCF0b3VjaE9iamVjdC5zd2lwZUxlbmd0aCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBpZiAodG91Y2hPYmplY3Quc3dpcGVMZW5ndGggPiBtaW5Td2lwZSkge1xuICAgIHNhZmVQcmV2ZW50RGVmYXVsdChlKTtcbiAgICBpZiAob25Td2lwZSkge1xuICAgICAgb25Td2lwZShzd2lwZURpcmVjdGlvbik7XG4gICAgfVxuICAgIHZhciBzbGlkZUNvdW50LCBuZXdTbGlkZTtcbiAgICB2YXIgYWN0aXZlU2xpZGUgPSBpbmZpbml0ZSA/IGN1cnJlbnRTbGlkZSA6IHRhcmdldFNsaWRlO1xuICAgIHN3aXRjaCAoc3dpcGVEaXJlY3Rpb24pIHtcbiAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICBjYXNlIFwidXBcIjpcbiAgICAgICAgbmV3U2xpZGUgPSBhY3RpdmVTbGlkZSArIGdldFNsaWRlQ291bnQoc3BlYyk7XG4gICAgICAgIHNsaWRlQ291bnQgPSBzd2lwZVRvU2xpZGUgPyBjaGVja05hdmlnYWJsZShzcGVjLCBuZXdTbGlkZSkgOiBuZXdTbGlkZTtcbiAgICAgICAgc3RhdGVbXCJjdXJyZW50RGlyZWN0aW9uXCJdID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgIGNhc2UgXCJkb3duXCI6XG4gICAgICAgIG5ld1NsaWRlID0gYWN0aXZlU2xpZGUgLSBnZXRTbGlkZUNvdW50KHNwZWMpO1xuICAgICAgICBzbGlkZUNvdW50ID0gc3dpcGVUb1NsaWRlID8gY2hlY2tOYXZpZ2FibGUoc3BlYywgbmV3U2xpZGUpIDogbmV3U2xpZGU7XG4gICAgICAgIHN0YXRlW1wiY3VycmVudERpcmVjdGlvblwiXSA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc2xpZGVDb3VudCA9IGFjdGl2ZVNsaWRlO1xuICAgIH1cbiAgICBzdGF0ZVtcInRyaWdnZXJTbGlkZUhhbmRsZXJcIl0gPSBzbGlkZUNvdW50O1xuICB9IGVsc2Uge1xuICAgIC8vIEFkanVzdCB0aGUgdHJhY2sgYmFjayB0byBpdCdzIG9yaWdpbmFsIHBvc2l0aW9uLlxuICAgIHZhciBjdXJyZW50TGVmdCA9IGdldFRyYWNrTGVmdChzcGVjKTtcbiAgICBzdGF0ZVtcInRyYWNrU3R5bGVcIl0gPSBnZXRUcmFja0FuaW1hdGVDU1MoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzcGVjKSwge30sIHtcbiAgICAgIGxlZnQ6IGN1cnJlbnRMZWZ0XG4gICAgfSkpO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn07XG52YXIgZ2V0TmF2aWdhYmxlSW5kZXhlcyA9IGV4cG9ydHMuZ2V0TmF2aWdhYmxlSW5kZXhlcyA9IGZ1bmN0aW9uIGdldE5hdmlnYWJsZUluZGV4ZXMoc3BlYykge1xuICB2YXIgbWF4ID0gc3BlYy5pbmZpbml0ZSA/IHNwZWMuc2xpZGVDb3VudCAqIDIgOiBzcGVjLnNsaWRlQ291bnQ7XG4gIHZhciBicmVha3BvaW50ID0gc3BlYy5pbmZpbml0ZSA/IHNwZWMuc2xpZGVzVG9TaG93ICogLTEgOiAwO1xuICB2YXIgY291bnRlciA9IHNwZWMuaW5maW5pdGUgPyBzcGVjLnNsaWRlc1RvU2hvdyAqIC0xIDogMDtcbiAgdmFyIGluZGV4ZXMgPSBbXTtcbiAgd2hpbGUgKGJyZWFrcG9pbnQgPCBtYXgpIHtcbiAgICBpbmRleGVzLnB1c2goYnJlYWtwb2ludCk7XG4gICAgYnJlYWtwb2ludCA9IGNvdW50ZXIgKyBzcGVjLnNsaWRlc1RvU2Nyb2xsO1xuICAgIGNvdW50ZXIgKz0gTWF0aC5taW4oc3BlYy5zbGlkZXNUb1Njcm9sbCwgc3BlYy5zbGlkZXNUb1Nob3cpO1xuICB9XG4gIHJldHVybiBpbmRleGVzO1xufTtcbnZhciBjaGVja05hdmlnYWJsZSA9IGV4cG9ydHMuY2hlY2tOYXZpZ2FibGUgPSBmdW5jdGlvbiBjaGVja05hdmlnYWJsZShzcGVjLCBpbmRleCkge1xuICB2YXIgbmF2aWdhYmxlcyA9IGdldE5hdmlnYWJsZUluZGV4ZXMoc3BlYyk7XG4gIHZhciBwcmV2TmF2aWdhYmxlID0gMDtcbiAgaWYgKGluZGV4ID4gbmF2aWdhYmxlc1tuYXZpZ2FibGVzLmxlbmd0aCAtIDFdKSB7XG4gICAgaW5kZXggPSBuYXZpZ2FibGVzW25hdmlnYWJsZXMubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgbiBpbiBuYXZpZ2FibGVzKSB7XG4gICAgICBpZiAoaW5kZXggPCBuYXZpZ2FibGVzW25dKSB7XG4gICAgICAgIGluZGV4ID0gcHJldk5hdmlnYWJsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBwcmV2TmF2aWdhYmxlID0gbmF2aWdhYmxlc1tuXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZGV4O1xufTtcbnZhciBnZXRTbGlkZUNvdW50ID0gZXhwb3J0cy5nZXRTbGlkZUNvdW50ID0gZnVuY3Rpb24gZ2V0U2xpZGVDb3VudChzcGVjKSB7XG4gIHZhciBjZW50ZXJPZmZzZXQgPSBzcGVjLmNlbnRlck1vZGUgPyBzcGVjLnNsaWRlV2lkdGggKiBNYXRoLmZsb29yKHNwZWMuc2xpZGVzVG9TaG93IC8gMikgOiAwO1xuICBpZiAoc3BlYy5zd2lwZVRvU2xpZGUpIHtcbiAgICB2YXIgc3dpcGVkU2xpZGU7XG4gICAgdmFyIHNsaWNrTGlzdCA9IHNwZWMubGlzdFJlZjtcbiAgICB2YXIgc2xpZGVzID0gc2xpY2tMaXN0LnF1ZXJ5U2VsZWN0b3JBbGwgJiYgc2xpY2tMaXN0LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuc2xpY2stc2xpZGVcIikgfHwgW107XG4gICAgQXJyYXkuZnJvbShzbGlkZXMpLmV2ZXJ5KGZ1bmN0aW9uIChzbGlkZSkge1xuICAgICAgaWYgKCFzcGVjLnZlcnRpY2FsKSB7XG4gICAgICAgIGlmIChzbGlkZS5vZmZzZXRMZWZ0IC0gY2VudGVyT2Zmc2V0ICsgZ2V0V2lkdGgoc2xpZGUpIC8gMiA+IHNwZWMuc3dpcGVMZWZ0ICogLTEpIHtcbiAgICAgICAgICBzd2lwZWRTbGlkZSA9IHNsaWRlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNsaWRlLm9mZnNldFRvcCArIGdldEhlaWdodChzbGlkZSkgLyAyID4gc3BlYy5zd2lwZUxlZnQgKiAtMSkge1xuICAgICAgICAgIHN3aXBlZFNsaWRlID0gc2xpZGU7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBpZiAoIXN3aXBlZFNsaWRlKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnRJbmRleCA9IHNwZWMucnRsID09PSB0cnVlID8gc3BlYy5zbGlkZUNvdW50IC0gc3BlYy5jdXJyZW50U2xpZGUgOiBzcGVjLmN1cnJlbnRTbGlkZTtcbiAgICB2YXIgc2xpZGVzVHJhdmVyc2VkID0gTWF0aC5hYnMoc3dpcGVkU2xpZGUuZGF0YXNldC5pbmRleCAtIGN1cnJlbnRJbmRleCkgfHwgMTtcbiAgICByZXR1cm4gc2xpZGVzVHJhdmVyc2VkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzcGVjLnNsaWRlc1RvU2Nyb2xsO1xuICB9XG59O1xudmFyIGNoZWNrU3BlY0tleXMgPSBleHBvcnRzLmNoZWNrU3BlY0tleXMgPSBmdW5jdGlvbiBjaGVja1NwZWNLZXlzKHNwZWMsIGtleXNBcnJheSkge1xuICByZXR1cm4ga2V5c0FycmF5LnJlZHVjZShmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiBzcGVjLmhhc093blByb3BlcnR5KGtleSk7XG4gIH0sIHRydWUpID8gbnVsbCA6IGNvbnNvbGUuZXJyb3IoXCJLZXlzIE1pc3Npbmc6XCIsIHNwZWMpO1xufTtcbnZhciBnZXRUcmFja0NTUyA9IGV4cG9ydHMuZ2V0VHJhY2tDU1MgPSBmdW5jdGlvbiBnZXRUcmFja0NTUyhzcGVjKSB7XG4gIGNoZWNrU3BlY0tleXMoc3BlYywgW1wibGVmdFwiLCBcInZhcmlhYmxlV2lkdGhcIiwgXCJzbGlkZUNvdW50XCIsIFwic2xpZGVzVG9TaG93XCIsIFwic2xpZGVXaWR0aFwiXSk7XG4gIHZhciB0cmFja1dpZHRoLCB0cmFja0hlaWdodDtcbiAgdmFyIHRyYWNrQ2hpbGRyZW4gPSBzcGVjLnNsaWRlQ291bnQgKyAyICogc3BlYy5zbGlkZXNUb1Nob3c7XG4gIGlmICghc3BlYy52ZXJ0aWNhbCkge1xuICAgIHRyYWNrV2lkdGggPSBnZXRUb3RhbFNsaWRlcyhzcGVjKSAqIHNwZWMuc2xpZGVXaWR0aDtcbiAgfSBlbHNlIHtcbiAgICB0cmFja0hlaWdodCA9IHRyYWNrQ2hpbGRyZW4gKiBzcGVjLnNsaWRlSGVpZ2h0O1xuICB9XG4gIHZhciBzdHlsZSA9IHtcbiAgICBvcGFjaXR5OiAxLFxuICAgIHRyYW5zaXRpb246IFwiXCIsXG4gICAgV2Via2l0VHJhbnNpdGlvbjogXCJcIlxuICB9O1xuICBpZiAoc3BlYy51c2VUcmFuc2Zvcm0pIHtcbiAgICB2YXIgV2Via2l0VHJhbnNmb3JtID0gIXNwZWMudmVydGljYWwgPyBcInRyYW5zbGF0ZTNkKFwiICsgc3BlYy5sZWZ0ICsgXCJweCwgMHB4LCAwcHgpXCIgOiBcInRyYW5zbGF0ZTNkKDBweCwgXCIgKyBzcGVjLmxlZnQgKyBcInB4LCAwcHgpXCI7XG4gICAgdmFyIHRyYW5zZm9ybSA9ICFzcGVjLnZlcnRpY2FsID8gXCJ0cmFuc2xhdGUzZChcIiArIHNwZWMubGVmdCArIFwicHgsIDBweCwgMHB4KVwiIDogXCJ0cmFuc2xhdGUzZCgwcHgsIFwiICsgc3BlYy5sZWZ0ICsgXCJweCwgMHB4KVwiO1xuICAgIHZhciBtc1RyYW5zZm9ybSA9ICFzcGVjLnZlcnRpY2FsID8gXCJ0cmFuc2xhdGVYKFwiICsgc3BlYy5sZWZ0ICsgXCJweClcIiA6IFwidHJhbnNsYXRlWShcIiArIHNwZWMubGVmdCArIFwicHgpXCI7XG4gICAgc3R5bGUgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0eWxlKSwge30sIHtcbiAgICAgIFdlYmtpdFRyYW5zZm9ybTogV2Via2l0VHJhbnNmb3JtLFxuICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICBtc1RyYW5zZm9ybTogbXNUcmFuc2Zvcm1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoc3BlYy52ZXJ0aWNhbCkge1xuICAgICAgc3R5bGVbXCJ0b3BcIl0gPSBzcGVjLmxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlW1wibGVmdFwiXSA9IHNwZWMubGVmdDtcbiAgICB9XG4gIH1cbiAgaWYgKHNwZWMuZmFkZSkgc3R5bGUgPSB7XG4gICAgb3BhY2l0eTogMVxuICB9O1xuICBpZiAodHJhY2tXaWR0aCkgc3R5bGUud2lkdGggPSB0cmFja1dpZHRoO1xuICBpZiAodHJhY2tIZWlnaHQpIHN0eWxlLmhlaWdodCA9IHRyYWNrSGVpZ2h0O1xuXG4gIC8vIEZhbGxiYWNrIGZvciBJRThcbiAgaWYgKHdpbmRvdyAmJiAhd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgJiYgd2luZG93LmF0dGFjaEV2ZW50KSB7XG4gICAgaWYgKCFzcGVjLnZlcnRpY2FsKSB7XG4gICAgICBzdHlsZS5tYXJnaW5MZWZ0ID0gc3BlYy5sZWZ0ICsgXCJweFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5tYXJnaW5Ub3AgPSBzcGVjLmxlZnQgKyBcInB4XCI7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZTtcbn07XG52YXIgZ2V0VHJhY2tBbmltYXRlQ1NTID0gZXhwb3J0cy5nZXRUcmFja0FuaW1hdGVDU1MgPSBmdW5jdGlvbiBnZXRUcmFja0FuaW1hdGVDU1Moc3BlYykge1xuICBjaGVja1NwZWNLZXlzKHNwZWMsIFtcImxlZnRcIiwgXCJ2YXJpYWJsZVdpZHRoXCIsIFwic2xpZGVDb3VudFwiLCBcInNsaWRlc1RvU2hvd1wiLCBcInNsaWRlV2lkdGhcIiwgXCJzcGVlZFwiLCBcImNzc0Vhc2VcIl0pO1xuICB2YXIgc3R5bGUgPSBnZXRUcmFja0NTUyhzcGVjKTtcbiAgLy8gdXNlQ1NTIGlzIHRydWUgYnkgZGVmYXVsdCBzbyBpdCBjYW4gYmUgdW5kZWZpbmVkXG4gIGlmIChzcGVjLnVzZVRyYW5zZm9ybSkge1xuICAgIHN0eWxlLldlYmtpdFRyYW5zaXRpb24gPSBcIi13ZWJraXQtdHJhbnNmb3JtIFwiICsgc3BlYy5zcGVlZCArIFwibXMgXCIgKyBzcGVjLmNzc0Vhc2U7XG4gICAgc3R5bGUudHJhbnNpdGlvbiA9IFwidHJhbnNmb3JtIFwiICsgc3BlYy5zcGVlZCArIFwibXMgXCIgKyBzcGVjLmNzc0Vhc2U7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNwZWMudmVydGljYWwpIHtcbiAgICAgIHN0eWxlLnRyYW5zaXRpb24gPSBcInRvcCBcIiArIHNwZWMuc3BlZWQgKyBcIm1zIFwiICsgc3BlYy5jc3NFYXNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS50cmFuc2l0aW9uID0gXCJsZWZ0IFwiICsgc3BlYy5zcGVlZCArIFwibXMgXCIgKyBzcGVjLmNzc0Vhc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZTtcbn07XG52YXIgZ2V0VHJhY2tMZWZ0ID0gZXhwb3J0cy5nZXRUcmFja0xlZnQgPSBmdW5jdGlvbiBnZXRUcmFja0xlZnQoc3BlYykge1xuICBpZiAoc3BlYy51bnNsaWNrKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY2hlY2tTcGVjS2V5cyhzcGVjLCBbXCJzbGlkZUluZGV4XCIsIFwidHJhY2tSZWZcIiwgXCJpbmZpbml0ZVwiLCBcImNlbnRlck1vZGVcIiwgXCJzbGlkZUNvdW50XCIsIFwic2xpZGVzVG9TaG93XCIsIFwic2xpZGVzVG9TY3JvbGxcIiwgXCJzbGlkZVdpZHRoXCIsIFwibGlzdFdpZHRoXCIsIFwidmFyaWFibGVXaWR0aFwiLCBcInNsaWRlSGVpZ2h0XCJdKTtcbiAgdmFyIHNsaWRlSW5kZXggPSBzcGVjLnNsaWRlSW5kZXgsXG4gICAgdHJhY2tSZWYgPSBzcGVjLnRyYWNrUmVmLFxuICAgIGluZmluaXRlID0gc3BlYy5pbmZpbml0ZSxcbiAgICBjZW50ZXJNb2RlID0gc3BlYy5jZW50ZXJNb2RlLFxuICAgIHNsaWRlQ291bnQgPSBzcGVjLnNsaWRlQ291bnQsXG4gICAgc2xpZGVzVG9TaG93ID0gc3BlYy5zbGlkZXNUb1Nob3csXG4gICAgc2xpZGVzVG9TY3JvbGwgPSBzcGVjLnNsaWRlc1RvU2Nyb2xsLFxuICAgIHNsaWRlV2lkdGggPSBzcGVjLnNsaWRlV2lkdGgsXG4gICAgbGlzdFdpZHRoID0gc3BlYy5saXN0V2lkdGgsXG4gICAgdmFyaWFibGVXaWR0aCA9IHNwZWMudmFyaWFibGVXaWR0aCxcbiAgICBzbGlkZUhlaWdodCA9IHNwZWMuc2xpZGVIZWlnaHQsXG4gICAgZmFkZSA9IHNwZWMuZmFkZSxcbiAgICB2ZXJ0aWNhbCA9IHNwZWMudmVydGljYWw7XG4gIHZhciBzbGlkZU9mZnNldCA9IDA7XG4gIHZhciB0YXJnZXRMZWZ0O1xuICB2YXIgdGFyZ2V0U2xpZGU7XG4gIHZhciB2ZXJ0aWNhbE9mZnNldCA9IDA7XG4gIGlmIChmYWRlIHx8IHNwZWMuc2xpZGVDb3VudCA9PT0gMSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciBzbGlkZXNUb09mZnNldCA9IDA7XG4gIGlmIChpbmZpbml0ZSkge1xuICAgIHNsaWRlc1RvT2Zmc2V0ID0gLWdldFByZUNsb25lcyhzcGVjKTsgLy8gYnJpbmcgYWN0aXZlIHNsaWRlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdmlzdWFsIGFyZWFcbiAgICAvLyBpZiBuZXh0IHNjcm9sbCBkb2Vzbid0IGhhdmUgZW5vdWdoIGNoaWxkcmVuLCBqdXN0IHJlYWNoIHRpbGwgdGhlIGVuZCBvZiBvcmlnaW5hbCBzbGlkZXMgaW5zdGVhZCBvZiBzaGlmdGluZyBzbGlkZXNUb1Njcm9sbCBjaGlsZHJlblxuICAgIGlmIChzbGlkZUNvdW50ICUgc2xpZGVzVG9TY3JvbGwgIT09IDAgJiYgc2xpZGVJbmRleCArIHNsaWRlc1RvU2Nyb2xsID4gc2xpZGVDb3VudCkge1xuICAgICAgc2xpZGVzVG9PZmZzZXQgPSAtKHNsaWRlSW5kZXggPiBzbGlkZUNvdW50ID8gc2xpZGVzVG9TaG93IC0gKHNsaWRlSW5kZXggLSBzbGlkZUNvdW50KSA6IHNsaWRlQ291bnQgJSBzbGlkZXNUb1Njcm9sbCk7XG4gICAgfVxuICAgIC8vIHNoaWZ0IGN1cnJlbnQgc2xpZGUgdG8gY2VudGVyIG9mIHRoZSBmcmFtZVxuICAgIGlmIChjZW50ZXJNb2RlKSB7XG4gICAgICBzbGlkZXNUb09mZnNldCArPSBwYXJzZUludChzbGlkZXNUb1Nob3cgLyAyKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNsaWRlQ291bnQgJSBzbGlkZXNUb1Njcm9sbCAhPT0gMCAmJiBzbGlkZUluZGV4ICsgc2xpZGVzVG9TY3JvbGwgPiBzbGlkZUNvdW50KSB7XG4gICAgICBzbGlkZXNUb09mZnNldCA9IHNsaWRlc1RvU2hvdyAtIHNsaWRlQ291bnQgJSBzbGlkZXNUb1Njcm9sbDtcbiAgICB9XG4gICAgaWYgKGNlbnRlck1vZGUpIHtcbiAgICAgIHNsaWRlc1RvT2Zmc2V0ID0gcGFyc2VJbnQoc2xpZGVzVG9TaG93IC8gMik7XG4gICAgfVxuICB9XG4gIHNsaWRlT2Zmc2V0ID0gc2xpZGVzVG9PZmZzZXQgKiBzbGlkZVdpZHRoO1xuICB2ZXJ0aWNhbE9mZnNldCA9IHNsaWRlc1RvT2Zmc2V0ICogc2xpZGVIZWlnaHQ7XG4gIGlmICghdmVydGljYWwpIHtcbiAgICB0YXJnZXRMZWZ0ID0gc2xpZGVJbmRleCAqIHNsaWRlV2lkdGggKiAtMSArIHNsaWRlT2Zmc2V0O1xuICB9IGVsc2Uge1xuICAgIHRhcmdldExlZnQgPSBzbGlkZUluZGV4ICogc2xpZGVIZWlnaHQgKiAtMSArIHZlcnRpY2FsT2Zmc2V0O1xuICB9XG4gIGlmICh2YXJpYWJsZVdpZHRoID09PSB0cnVlKSB7XG4gICAgdmFyIHRhcmdldFNsaWRlSW5kZXg7XG4gICAgdmFyIHRyYWNrRWxlbSA9IHRyYWNrUmVmICYmIHRyYWNrUmVmLm5vZGU7XG4gICAgdGFyZ2V0U2xpZGVJbmRleCA9IHNsaWRlSW5kZXggKyBnZXRQcmVDbG9uZXMoc3BlYyk7XG4gICAgdGFyZ2V0U2xpZGUgPSB0cmFja0VsZW0gJiYgdHJhY2tFbGVtLmNoaWxkTm9kZXNbdGFyZ2V0U2xpZGVJbmRleF07XG4gICAgdGFyZ2V0TGVmdCA9IHRhcmdldFNsaWRlID8gdGFyZ2V0U2xpZGUub2Zmc2V0TGVmdCAqIC0xIDogMDtcbiAgICBpZiAoY2VudGVyTW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgdGFyZ2V0U2xpZGVJbmRleCA9IGluZmluaXRlID8gc2xpZGVJbmRleCArIGdldFByZUNsb25lcyhzcGVjKSA6IHNsaWRlSW5kZXg7XG4gICAgICB0YXJnZXRTbGlkZSA9IHRyYWNrRWxlbSAmJiB0cmFja0VsZW0uY2hpbGRyZW5bdGFyZ2V0U2xpZGVJbmRleF07XG4gICAgICB0YXJnZXRMZWZ0ID0gMDtcbiAgICAgIGZvciAodmFyIHNsaWRlID0gMDsgc2xpZGUgPCB0YXJnZXRTbGlkZUluZGV4OyBzbGlkZSsrKSB7XG4gICAgICAgIHRhcmdldExlZnQgLT0gdHJhY2tFbGVtICYmIHRyYWNrRWxlbS5jaGlsZHJlbltzbGlkZV0gJiYgdHJhY2tFbGVtLmNoaWxkcmVuW3NsaWRlXS5vZmZzZXRXaWR0aDtcbiAgICAgIH1cbiAgICAgIHRhcmdldExlZnQgLT0gcGFyc2VJbnQoc3BlYy5jZW50ZXJQYWRkaW5nKTtcbiAgICAgIHRhcmdldExlZnQgKz0gdGFyZ2V0U2xpZGUgJiYgKGxpc3RXaWR0aCAtIHRhcmdldFNsaWRlLm9mZnNldFdpZHRoKSAvIDI7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXRMZWZ0O1xufTtcbnZhciBnZXRQcmVDbG9uZXMgPSBleHBvcnRzLmdldFByZUNsb25lcyA9IGZ1bmN0aW9uIGdldFByZUNsb25lcyhzcGVjKSB7XG4gIGlmIChzcGVjLnVuc2xpY2sgfHwgIXNwZWMuaW5maW5pdGUpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoc3BlYy52YXJpYWJsZVdpZHRoKSB7XG4gICAgcmV0dXJuIHNwZWMuc2xpZGVDb3VudDtcbiAgfVxuICByZXR1cm4gc3BlYy5zbGlkZXNUb1Nob3cgKyAoc3BlYy5jZW50ZXJNb2RlID8gMSA6IDApO1xufTtcbnZhciBnZXRQb3N0Q2xvbmVzID0gZXhwb3J0cy5nZXRQb3N0Q2xvbmVzID0gZnVuY3Rpb24gZ2V0UG9zdENsb25lcyhzcGVjKSB7XG4gIGlmIChzcGVjLnVuc2xpY2sgfHwgIXNwZWMuaW5maW5pdGUpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3BlYy5zbGlkZUNvdW50O1xufTtcbnZhciBnZXRUb3RhbFNsaWRlcyA9IGV4cG9ydHMuZ2V0VG90YWxTbGlkZXMgPSBmdW5jdGlvbiBnZXRUb3RhbFNsaWRlcyhzcGVjKSB7XG4gIHJldHVybiBzcGVjLnNsaWRlQ291bnQgPT09IDEgPyAxIDogZ2V0UHJlQ2xvbmVzKHNwZWMpICsgc3BlYy5zbGlkZUNvdW50ICsgZ2V0UG9zdENsb25lcyhzcGVjKTtcbn07XG52YXIgc2libGluZ0RpcmVjdGlvbiA9IGV4cG9ydHMuc2libGluZ0RpcmVjdGlvbiA9IGZ1bmN0aW9uIHNpYmxpbmdEaXJlY3Rpb24oc3BlYykge1xuICBpZiAoc3BlYy50YXJnZXRTbGlkZSA+IHNwZWMuY3VycmVudFNsaWRlKSB7XG4gICAgaWYgKHNwZWMudGFyZ2V0U2xpZGUgPiBzcGVjLmN1cnJlbnRTbGlkZSArIHNsaWRlc09uUmlnaHQoc3BlYykpIHtcbiAgICAgIHJldHVybiBcImxlZnRcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwicmlnaHRcIjtcbiAgfSBlbHNlIHtcbiAgICBpZiAoc3BlYy50YXJnZXRTbGlkZSA8IHNwZWMuY3VycmVudFNsaWRlIC0gc2xpZGVzT25MZWZ0KHNwZWMpKSB7XG4gICAgICByZXR1cm4gXCJyaWdodFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJsZWZ0XCI7XG4gIH1cbn07XG52YXIgc2xpZGVzT25SaWdodCA9IGV4cG9ydHMuc2xpZGVzT25SaWdodCA9IGZ1bmN0aW9uIHNsaWRlc09uUmlnaHQoX3JlZikge1xuICB2YXIgc2xpZGVzVG9TaG93ID0gX3JlZi5zbGlkZXNUb1Nob3csXG4gICAgY2VudGVyTW9kZSA9IF9yZWYuY2VudGVyTW9kZSxcbiAgICBydGwgPSBfcmVmLnJ0bCxcbiAgICBjZW50ZXJQYWRkaW5nID0gX3JlZi5jZW50ZXJQYWRkaW5nO1xuICAvLyByZXR1cm5zIG5vIG9mIHNsaWRlcyBvbiB0aGUgcmlnaHQgb2YgYWN0aXZlIHNsaWRlXG4gIGlmIChjZW50ZXJNb2RlKSB7XG4gICAgdmFyIHJpZ2h0ID0gKHNsaWRlc1RvU2hvdyAtIDEpIC8gMiArIDE7XG4gICAgaWYgKHBhcnNlSW50KGNlbnRlclBhZGRpbmcpID4gMCkgcmlnaHQgKz0gMTtcbiAgICBpZiAocnRsICYmIHNsaWRlc1RvU2hvdyAlIDIgPT09IDApIHJpZ2h0ICs9IDE7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9XG4gIGlmIChydGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc2xpZGVzVG9TaG93IC0gMTtcbn07XG52YXIgc2xpZGVzT25MZWZ0ID0gZXhwb3J0cy5zbGlkZXNPbkxlZnQgPSBmdW5jdGlvbiBzbGlkZXNPbkxlZnQoX3JlZjIpIHtcbiAgdmFyIHNsaWRlc1RvU2hvdyA9IF9yZWYyLnNsaWRlc1RvU2hvdyxcbiAgICBjZW50ZXJNb2RlID0gX3JlZjIuY2VudGVyTW9kZSxcbiAgICBydGwgPSBfcmVmMi5ydGwsXG4gICAgY2VudGVyUGFkZGluZyA9IF9yZWYyLmNlbnRlclBhZGRpbmc7XG4gIC8vIHJldHVybnMgbm8gb2Ygc2xpZGVzIG9uIHRoZSBsZWZ0IG9mIGFjdGl2ZSBzbGlkZVxuICBpZiAoY2VudGVyTW9kZSkge1xuICAgIHZhciBsZWZ0ID0gKHNsaWRlc1RvU2hvdyAtIDEpIC8gMiArIDE7XG4gICAgaWYgKHBhcnNlSW50KGNlbnRlclBhZGRpbmcpID4gMCkgbGVmdCArPSAxO1xuICAgIGlmICghcnRsICYmIHNsaWRlc1RvU2hvdyAlIDIgPT09IDApIGxlZnQgKz0gMTtcbiAgICByZXR1cm4gbGVmdDtcbiAgfVxuICBpZiAocnRsKSB7XG4gICAgcmV0dXJuIHNsaWRlc1RvU2hvdyAtIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xudmFyIGNhblVzZURPTSA9IGV4cG9ydHMuY2FuVXNlRE9NID0gZnVuY3Rpb24gY2FuVXNlRE9NKCkge1xuICByZXR1cm4gISEodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xufTtcbnZhciB2YWxpZFNldHRpbmdzID0gZXhwb3J0cy52YWxpZFNldHRpbmdzID0gT2JqZWN0LmtleXMoX2RlZmF1bHRQcm9wc1tcImRlZmF1bHRcIl0pO1xuZnVuY3Rpb24gZmlsdGVyU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgcmV0dXJuIHZhbGlkU2V0dGluZ3MucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHNldHRpbmdOYW1lKSB7XG4gICAgaWYgKHNldHRpbmdzLmhhc093blByb3BlcnR5KHNldHRpbmdOYW1lKSkge1xuICAgICAgYWNjW3NldHRpbmdOYW1lXSA9IHNldHRpbmdzW3NldHRpbmdOYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-slick/lib/utils/innerSliderUtils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js":
/*!*************************************************************************!*\
  !*** ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\r\n/* eslint-disable require-jsdoc, valid-jsdoc */\r\nvar MapShim = (function () {\r\n    if (typeof Map !== 'undefined') {\r\n        return Map;\r\n    }\r\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        var result = -1;\r\n        arr.some(function (entry, index) {\r\n            if (entry[0] === key) {\r\n                result = index;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        return result;\r\n    }\r\n    return /** @class */ (function () {\r\n        function class_1() {\r\n            this.__entries__ = [];\r\n        }\r\n        Object.defineProperty(class_1.prototype, \"size\", {\r\n            /**\r\n             * @returns {boolean}\r\n             */\r\n            get: function () {\r\n                return this.__entries__.length;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\r\n        class_1.prototype.get = function (key) {\r\n            var index = getIndex(this.__entries__, key);\r\n            var entry = this.__entries__[index];\r\n            return entry && entry[1];\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.set = function (key, value) {\r\n            var index = getIndex(this.__entries__, key);\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            }\r\n            else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.delete = function (key) {\r\n            var entries = this.__entries__;\r\n            var index = getIndex(entries, key);\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.has = function (key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        };\r\n        /**\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.clear = function () {\r\n            this.__entries__.splice(0);\r\n        };\r\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.forEach = function (callback, ctx) {\r\n            if (ctx === void 0) { ctx = null; }\r\n            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\r\n                var entry = _a[_i];\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        };\r\n        return class_1;\r\n    }());\r\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\r\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\r\nvar global$1 = (function () {\r\n    if (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.Math === Math) {\r\n        return __webpack_require__.g;\r\n    }\r\n    if (typeof self !== 'undefined' && self.Math === Math) {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined' && window.Math === Math) {\r\n        return window;\r\n    }\r\n    // eslint-disable-next-line no-new-func\r\n    return Function('return this')();\r\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\r\nvar requestAnimationFrame$1 = (function () {\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        // It's required to use a bounded function because IE sometimes throws\r\n        // an \"Invalid calling object\" error if rAF is invoked without the global\r\n        // object on the left hand side.\r\n        return requestAnimationFrame.bind(global$1);\r\n    }\r\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\r\n})();\n\n// Defines minimum timeout before adding a trailing call.\r\nvar trailingTimeout = 2;\r\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nfunction throttle (callback, delay) {\r\n    var leadingCall = false, trailingCall = false, lastCallTime = 0;\r\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function resolvePending() {\r\n        if (leadingCall) {\r\n            leadingCall = false;\r\n            callback();\r\n        }\r\n        if (trailingCall) {\r\n            proxy();\r\n        }\r\n    }\r\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function timeoutCallback() {\r\n        requestAnimationFrame$1(resolvePending);\r\n    }\r\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function proxy() {\r\n        var timeStamp = Date.now();\r\n        if (leadingCall) {\r\n            // Reject immediately following calls.\r\n            if (timeStamp - lastCallTime < trailingTimeout) {\r\n                return;\r\n            }\r\n            // Schedule new call to be in invoked when the pending one is resolved.\r\n            // This is important for \"transitions\" which never actually start\r\n            // immediately so there is a chance that we might miss one if change\r\n            // happens amids the pending invocation.\r\n            trailingCall = true;\r\n        }\r\n        else {\r\n            leadingCall = true;\r\n            trailingCall = false;\r\n            setTimeout(timeoutCallback, delay);\r\n        }\r\n        lastCallTime = timeStamp;\r\n    }\r\n    return proxy;\r\n}\n\n// Minimum delay before invoking the update of observers.\r\nvar REFRESH_DELAY = 20;\r\n// A list of substrings of CSS properties used to find transition events that\r\n// might affect dimensions of observed elements.\r\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\r\n// Check if MutationObserver is available.\r\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\r\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\r\nvar ResizeObserverController = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @private\r\n     */\r\n    function ResizeObserverController() {\r\n        /**\r\n         * Indicates whether DOM listeners have been added.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.connected_ = false;\r\n        /**\r\n         * Tells that controller has subscribed for Mutation Events.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.mutationEventsAdded_ = false;\r\n        /**\r\n         * Keeps reference to the instance of MutationObserver.\r\n         *\r\n         * @private {MutationObserver}\r\n         */\r\n        this.mutationsObserver_ = null;\r\n        /**\r\n         * A list of connected observers.\r\n         *\r\n         * @private {Array<ResizeObserverSPI>}\r\n         */\r\n        this.observers_ = [];\r\n        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\r\n        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\r\n    }\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be added.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.addObserver = function (observer) {\r\n        if (!~this.observers_.indexOf(observer)) {\r\n            this.observers_.push(observer);\r\n        }\r\n        // Add listeners if they haven't been added yet.\r\n        if (!this.connected_) {\r\n            this.connect_();\r\n        }\r\n    };\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.removeObserver = function (observer) {\r\n        var observers = this.observers_;\r\n        var index = observers.indexOf(observer);\r\n        // Remove observer if it's present in registry.\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n        // Remove listeners if controller has no connected observers.\r\n        if (!observers.length && this.connected_) {\r\n            this.disconnect_();\r\n        }\r\n    };\r\n    /**\r\n     * Invokes the update of observers. It will continue running updates insofar\r\n     * it detects changes.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.refresh = function () {\r\n        var changesDetected = this.updateObservers_();\r\n        // Continue running updates if changes have been detected as there might\r\n        // be future ones caused by CSS transitions.\r\n        if (changesDetected) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n     *      dimensions of it's elements.\r\n     */\r\n    ResizeObserverController.prototype.updateObservers_ = function () {\r\n        // Collect observers that have active observations.\r\n        var activeObservers = this.observers_.filter(function (observer) {\r\n            return observer.gatherActive(), observer.hasActive();\r\n        });\r\n        // Deliver notifications in a separate cycle in order to avoid any\r\n        // collisions between observers, e.g. when multiple instances of\r\n        // ResizeObserver are tracking the same element and the callback of one\r\n        // of them changes content dimensions of the observed target. Sometimes\r\n        // this may result in notifications being blocked for the rest of observers.\r\n        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\r\n        return activeObservers.length > 0;\r\n    };\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.connect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already added.\r\n        if (!isBrowser || this.connected_) {\r\n            return;\r\n        }\r\n        // Subscription to the \"Transitionend\" event is used as a workaround for\r\n        // delayed transitions. This way it's possible to capture at least the\r\n        // final state of an element.\r\n        document.addEventListener('transitionend', this.onTransitionEnd_);\r\n        window.addEventListener('resize', this.refresh);\r\n        if (mutationObserverSupported) {\r\n            this.mutationsObserver_ = new MutationObserver(this.refresh);\r\n            this.mutationsObserver_.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n        else {\r\n            document.addEventListener('DOMSubtreeModified', this.refresh);\r\n            this.mutationEventsAdded_ = true;\r\n        }\r\n        this.connected_ = true;\r\n    };\r\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.disconnect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already removed.\r\n        if (!isBrowser || !this.connected_) {\r\n            return;\r\n        }\r\n        document.removeEventListener('transitionend', this.onTransitionEnd_);\r\n        window.removeEventListener('resize', this.refresh);\r\n        if (this.mutationsObserver_) {\r\n            this.mutationsObserver_.disconnect();\r\n        }\r\n        if (this.mutationEventsAdded_) {\r\n            document.removeEventListener('DOMSubtreeModified', this.refresh);\r\n        }\r\n        this.mutationsObserver_ = null;\r\n        this.mutationEventsAdded_ = false;\r\n        this.connected_ = false;\r\n    };\r\n    /**\r\n     * \"Transitionend\" event handler.\r\n     *\r\n     * @private\r\n     * @param {TransitionEvent} event\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\r\n        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;\r\n        // Detect whether transition may affect dimensions of an element.\r\n        var isReflowProperty = transitionKeys.some(function (key) {\r\n            return !!~propertyName.indexOf(key);\r\n        });\r\n        if (isReflowProperty) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Returns instance of the ResizeObserverController.\r\n     *\r\n     * @returns {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.getInstance = function () {\r\n        if (!this.instance_) {\r\n            this.instance_ = new ResizeObserverController();\r\n        }\r\n        return this.instance_;\r\n    };\r\n    /**\r\n     * Holds reference to the controller's instance.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.instance_ = null;\r\n    return ResizeObserverController;\r\n}());\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\r\nvar defineConfigurable = (function (target, props) {\r\n    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        Object.defineProperty(target, key, {\r\n            value: props[key],\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return target;\r\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\r\nvar getWindowOf = (function (target) {\r\n    // Assume that the element is an instance of Node, which means that it\r\n    // has the \"ownerDocument\" property from which we can retrieve a\r\n    // corresponding global object.\r\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\r\n    // Return the local global object if it's not possible extract one from\r\n    // provided element.\r\n    return ownerGlobal || global$1;\r\n});\n\n// Placeholder of an empty content rectangle.\r\nvar emptyRect = createRectInit(0, 0, 0, 0);\r\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\r\nfunction toFloat(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\r\nfunction getBordersSize(styles) {\r\n    var positions = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        positions[_i - 1] = arguments[_i];\r\n    }\r\n    return positions.reduce(function (size, position) {\r\n        var value = styles['border-' + position + '-width'];\r\n        return size + toFloat(value);\r\n    }, 0);\r\n}\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    var positions = ['top', 'right', 'bottom', 'left'];\r\n    var paddings = {};\r\n    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\r\n        var position = positions_1[_i];\r\n        var value = styles['padding-' + position];\r\n        paddings[position] = toFloat(value);\r\n    }\r\n    return paddings;\r\n}\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    var bbox = target.getBBox();\r\n    return createRectInit(0, 0, bbox.width, bbox.height);\r\n}\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\r\n    // By this condition we can catch all non-replaced inline, hidden and\r\n    // detached elements. Though elements with width & height properties less\r\n    // than 0.5 will be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n    var styles = getWindowOf(target).getComputedStyle(target);\r\n    var paddings = getPaddings(styles);\r\n    var horizPad = paddings.left + paddings.right;\r\n    var vertPad = paddings.top + paddings.bottom;\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    var width = toFloat(styles.width), height = toFloat(styles.height);\r\n    // Width & height include paddings and borders when the 'border-box' box\r\n    // model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\r\n        // properties then it's either IE, and thus we don't need to subtract\r\n        // anything, or an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n    // Following steps can't be applied to the document's root element as its\r\n    // client[Width/Height] properties represent viewport area of the window.\r\n    // Besides, it's as well not necessary as the <html> itself neither has\r\n    // rendered scroll bars nor it can be clipped.\r\n    if (!isDocumentElement(target)) {\r\n        // In some browsers (only in Firefox, actually) CSS width & height\r\n        // include scroll bars size which can be removed at this step as scroll\r\n        // bars are the only difference between rounded dimensions + paddings\r\n        // and \"client\" properties, though that is not always true in Chrome.\r\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n        // Chrome has a rather weird rounding of \"client\" properties.\r\n        // E.g. for an element with content width of 314.2px it sometimes gives\r\n        // the client width of 315px and for the width of 314.7px it may give\r\n        // 314px. And it doesn't happen all the time. So just ignore this delta\r\n        // as a non-relevant.\r\n        if (Math.abs(vertScrollbar) !== 1) {\r\n            width -= vertScrollbar;\r\n        }\r\n        if (Math.abs(horizScrollbar) !== 1) {\r\n            height -= horizScrollbar;\r\n        }\r\n    }\r\n    return createRectInit(paddings.left, paddings.top, width, height);\r\n}\r\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nvar isSVGGraphicsElement = (function () {\r\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\r\n    // interface.\r\n    if (typeof SVGGraphicsElement !== 'undefined') {\r\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\r\n    }\r\n    // If it's so, then check that element is at least an instance of the\r\n    // SVGElement and that it has the \"getBBox\" method.\r\n    // eslint-disable-next-line no-extra-parens\r\n    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&\r\n        typeof target.getBBox === 'function'); };\r\n})();\r\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === getWindowOf(target).document.documentElement;\r\n}\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getContentRect(target) {\r\n    if (!isBrowser) {\r\n        return emptyRect;\r\n    }\r\n    if (isSVGGraphicsElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n    return getHTMLElementContentRect(target);\r\n}\r\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\r\nfunction createReadOnlyRect(_a) {\r\n    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\r\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\r\n    var rect = Object.create(Constr.prototype);\r\n    // Rectangle's properties are not writable and non-enumerable.\r\n    defineConfigurable(rect, {\r\n        x: x, y: y, width: width, height: height,\r\n        top: y,\r\n        right: x + width,\r\n        bottom: height + y,\r\n        left: x\r\n    });\r\n    return rect;\r\n}\r\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction createRectInit(x, y, width, height) {\r\n    return { x: x, y: y, width: width, height: height };\r\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\r\nvar ResizeObservation = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    function ResizeObservation(target) {\r\n        /**\r\n         * Broadcasted width of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastWidth = 0;\r\n        /**\r\n         * Broadcasted height of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastHeight = 0;\r\n        /**\r\n         * Reference to the last observed content rectangle.\r\n         *\r\n         * @private {DOMRectInit}\r\n         */\r\n        this.contentRect_ = createRectInit(0, 0, 0, 0);\r\n        this.target = target;\r\n    }\r\n    /**\r\n     * Updates content rectangle and tells whether it's width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObservation.prototype.isActive = function () {\r\n        var rect = getContentRect(this.target);\r\n        this.contentRect_ = rect;\r\n        return (rect.width !== this.broadcastWidth ||\r\n            rect.height !== this.broadcastHeight);\r\n    };\r\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {DOMRectInit} Last observed content rectangle.\r\n     */\r\n    ResizeObservation.prototype.broadcastRect = function () {\r\n        var rect = this.contentRect_;\r\n        this.broadcastWidth = rect.width;\r\n        this.broadcastHeight = rect.height;\r\n        return rect;\r\n    };\r\n    return ResizeObservation;\r\n}());\n\nvar ResizeObserverEntry = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n     */\r\n    function ResizeObserverEntry(target, rectInit) {\r\n        var contentRect = createReadOnlyRect(rectInit);\r\n        // According to the specification following properties are not writable\r\n        // and are also not enumerable in the native implementation.\r\n        //\r\n        // Property accessors are not being used as they'd require to define a\r\n        // private WeakMap storage which may cause memory leaks in browsers that\r\n        // don't support this type of collections.\r\n        defineConfigurable(this, { target: target, contentRect: contentRect });\r\n    }\r\n    return ResizeObserverEntry;\r\n}());\n\nvar ResizeObserverSPI = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n     *      when one of the observed elements changes it's content dimensions.\r\n     * @param {ResizeObserverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} callbackCtx - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */\r\n    function ResizeObserverSPI(callback, controller, callbackCtx) {\r\n        /**\r\n         * Collection of resize observations that have detected changes in dimensions\r\n         * of elements.\r\n         *\r\n         * @private {Array<ResizeObservation>}\r\n         */\r\n        this.activeObservations_ = [];\r\n        /**\r\n         * Registry of the ResizeObservation instances.\r\n         *\r\n         * @private {Map<Element, ResizeObservation>}\r\n         */\r\n        this.observations_ = new MapShim();\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n        }\r\n        this.callback_ = callback;\r\n        this.controller_ = controller;\r\n        this.callbackCtx_ = callbackCtx;\r\n    }\r\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.observe = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is already being observed.\r\n        if (observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.set(target, new ResizeObservation(target));\r\n        this.controller_.addObserver(this);\r\n        // Force the update of observations.\r\n        this.controller_.refresh();\r\n    };\r\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.unobserve = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is not being observed.\r\n        if (!observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.delete(target);\r\n        if (!observations.size) {\r\n            this.controller_.removeObserver(this);\r\n        }\r\n    };\r\n    /**\r\n     * Stops observing all elements.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.disconnect = function () {\r\n        this.clearActive();\r\n        this.observations_.clear();\r\n        this.controller_.removeObserver(this);\r\n    };\r\n    /**\r\n     * Collects observation instances the associated element of which has changed\r\n     * it's content rectangle.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.gatherActive = function () {\r\n        var _this = this;\r\n        this.clearActive();\r\n        this.observations_.forEach(function (observation) {\r\n            if (observation.isActive()) {\r\n                _this.activeObservations_.push(observation);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.broadcastActive = function () {\r\n        // Do nothing if observer doesn't have active observations.\r\n        if (!this.hasActive()) {\r\n            return;\r\n        }\r\n        var ctx = this.callbackCtx_;\r\n        // Create ResizeObserverEntry instance for every active observation.\r\n        var entries = this.activeObservations_.map(function (observation) {\r\n            return new ResizeObserverEntry(observation.target, observation.broadcastRect());\r\n        });\r\n        this.callback_.call(ctx, entries, ctx);\r\n        this.clearActive();\r\n    };\r\n    /**\r\n     * Clears the collection of active observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.clearActive = function () {\r\n        this.activeObservations_.splice(0);\r\n    };\r\n    /**\r\n     * Tells whether observer has active observations.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObserverSPI.prototype.hasActive = function () {\r\n        return this.activeObservations_.length > 0;\r\n    };\r\n    return ResizeObserverSPI;\r\n}());\n\n// Registry of internal observers. If WeakMap is not available use current shim\r\n// for the Map collection as it has all required methods and because WeakMap\r\n// can't be fully polyfilled anyway.\r\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\r\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\r\nvar ResizeObserver = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n     *      dimensions of the observed elements change.\r\n     */\r\n    function ResizeObserver(callback) {\r\n        if (!(this instanceof ResizeObserver)) {\r\n            throw new TypeError('Cannot call a class as a function.');\r\n        }\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        var controller = ResizeObserverController.getInstance();\r\n        var observer = new ResizeObserverSPI(callback, controller, this);\r\n        observers.set(this, observer);\r\n    }\r\n    return ResizeObserver;\r\n}());\r\n// Expose public methods of ResizeObserver.\r\n[\r\n    'observe',\r\n    'unobserve',\r\n    'disconnect'\r\n].forEach(function (method) {\r\n    ResizeObserver.prototype[method] = function () {\r\n        var _a;\r\n        return (_a = observers.get(this))[method].apply(_a, arguments);\r\n    };\r\n});\n\nvar index = (function () {\r\n    // Export existing implementation if available.\r\n    if (typeof global$1.ResizeObserver !== 'undefined') {\r\n        return global$1.ResizeObserver;\r\n    }\r\n    return ResizeObserver;\r\n})();\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwvZGlzdC9SZXNpemVPYnNlcnZlci5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsbUJBQW1CLEdBQUc7QUFDdEIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEdBQUc7QUFDdEIsbUJBQW1CLEdBQUc7QUFDdEIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsR0FBRztBQUN0QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEdBQUc7QUFDdEIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCLG1CQUFtQixHQUFHO0FBQ3RCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLG9EQUFvRCxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVB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VDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGlFQUFlLEtBQUssRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVzaXplLW9ic2VydmVyLXBvbHlmaWxsL2Rpc3QvUmVzaXplT2JzZXJ2ZXIuZXMuanM/Zjg2YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQSBjb2xsZWN0aW9uIG9mIHNoaW1zIHRoYXQgcHJvdmlkZSBtaW5pbWFsIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIEVTNiBjb2xsZWN0aW9ucy5cclxuICpcclxuICogVGhlc2UgaW1wbGVtZW50YXRpb25zIGFyZSBub3QgbWVhbnQgdG8gYmUgdXNlZCBvdXRzaWRlIG9mIHRoZSBSZXNpemVPYnNlcnZlclxyXG4gKiBtb2R1bGVzIGFzIHRoZXkgY292ZXIgb25seSBhIGxpbWl0ZWQgcmFuZ2Ugb2YgdXNlIGNhc2VzLlxyXG4gKi9cclxuLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1qc2RvYywgdmFsaWQtanNkb2MgKi9cclxudmFyIE1hcFNoaW0gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hcDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBpbmRleCBpbiBwcm92aWRlZCBhcnJheSB0aGF0IG1hdGNoZXMgdGhlIHNwZWNpZmllZCBrZXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheTxBcnJheT59IGFyclxyXG4gICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldEluZGV4KGFyciwga2V5KSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IC0xO1xyXG4gICAgICAgIGFyci5zb21lKGZ1bmN0aW9uIChlbnRyeSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgaWYgKGVudHJ5WzBdID09PSBrZXkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX18gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzXzEucHJvdG90eXBlLCBcInNpemVcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZW50cmllc19fLmxlbmd0aDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuX19lbnRyaWVzX19baW5kZXhdO1xyXG4gICAgICAgICAgICByZXR1cm4gZW50cnkgJiYgZW50cnlbMV07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleCh0aGlzLl9fZW50cmllc19fLCBrZXkpO1xyXG4gICAgICAgICAgICBpZiAofmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZW50cmllc19fW2luZGV4XVsxXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfXy5wdXNoKFtrZXksIHZhbHVlXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB2YXIgZW50cmllcyA9IHRoaXMuX19lbnRyaWVzX187XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KGVudHJpZXMsIGtleSk7XHJcbiAgICAgICAgICAgIGlmICh+aW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGVudHJpZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIX5nZXRJbmRleCh0aGlzLl9fZW50cmllc19fLCBrZXkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX18uc3BsaWNlKDApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgICAgICAgKiBAcGFyYW0geyp9IFtjdHg9bnVsbF1cclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjdHgpIHtcclxuICAgICAgICAgICAgaWYgKGN0eCA9PT0gdm9pZCAwKSB7IGN0eCA9IG51bGw7IH1cclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX19lbnRyaWVzX187IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKGN0eCwgZW50cnlbMV0sIGVudHJ5WzBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGNsYXNzXzE7XHJcbiAgICB9KCkpO1xyXG59KSgpO1xuXG4vKipcclxuICogRGV0ZWN0cyB3aGV0aGVyIHdpbmRvdyBhbmQgZG9jdW1lbnQgb2JqZWN0cyBhcmUgYXZhaWxhYmxlIGluIGN1cnJlbnQgZW52aXJvbm1lbnQuXHJcbiAqL1xyXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgPT09IGRvY3VtZW50O1xuXG4vLyBSZXR1cm5zIGdsb2JhbCBvYmplY3Qgb2YgYSBjdXJyZW50IGVudmlyb25tZW50LlxyXG52YXIgZ2xvYmFsJDEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC5NYXRoID09PSBNYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09PSBNYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT09IE1hdGgpIHtcclxuICAgICAgICByZXR1cm4gd2luZG93O1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXHJcbiAgICByZXR1cm4gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcclxufSkoKTtcblxuLyoqXHJcbiAqIEEgc2hpbSBmb3IgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSB3aGljaCBmYWxscyBiYWNrIHRvIHRoZSBzZXRUaW1lb3V0IGlmXHJcbiAqIGZpcnN0IG9uZSBpcyBub3Qgc3VwcG9ydGVkLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXF1ZXN0cycgaWRlbnRpZmllci5cclxuICovXHJcbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIC8vIEl0J3MgcmVxdWlyZWQgdG8gdXNlIGEgYm91bmRlZCBmdW5jdGlvbiBiZWNhdXNlIElFIHNvbWV0aW1lcyB0aHJvd3NcclxuICAgICAgICAvLyBhbiBcIkludmFsaWQgY2FsbGluZyBvYmplY3RcIiBlcnJvciBpZiByQUYgaXMgaW52b2tlZCB3aXRob3V0IHRoZSBnbG9iYWxcclxuICAgICAgICAvLyBvYmplY3Qgb24gdGhlIGxlZnQgaGFuZCBzaWRlLlxyXG4gICAgICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZChnbG9iYWwkMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGxiYWNrKERhdGUubm93KCkpOyB9LCAxMDAwIC8gNjApOyB9O1xyXG59KSgpO1xuXG4vLyBEZWZpbmVzIG1pbmltdW0gdGltZW91dCBiZWZvcmUgYWRkaW5nIGEgdHJhaWxpbmcgY2FsbC5cclxudmFyIHRyYWlsaW5nVGltZW91dCA9IDI7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgd3JhcHBlciBmdW5jdGlvbiB3aGljaCBlbnN1cmVzIHRoYXQgcHJvdmlkZWQgY2FsbGJhY2sgd2lsbCBiZVxyXG4gKiBpbnZva2VkIG9ubHkgb25jZSBkdXJpbmcgdGhlIHNwZWNpZmllZCBkZWxheSBwZXJpb2QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgZGVsYXkgcGVyaW9kLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgLSBEZWxheSBhZnRlciB3aGljaCB0byBpbnZva2UgY2FsbGJhY2suXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cclxuICovXHJcbmZ1bmN0aW9uIHRocm90dGxlIChjYWxsYmFjaywgZGVsYXkpIHtcclxuICAgIHZhciBsZWFkaW5nQ2FsbCA9IGZhbHNlLCB0cmFpbGluZ0NhbGwgPSBmYWxzZSwgbGFzdENhbGxUaW1lID0gMDtcclxuICAgIC8qKlxyXG4gICAgICogSW52b2tlcyB0aGUgb3JpZ2luYWwgY2FsbGJhY2sgZnVuY3Rpb24gYW5kIHNjaGVkdWxlcyBuZXcgaW52b2NhdGlvbiBpZlxyXG4gICAgICogdGhlIFwicHJveHlcIiB3YXMgY2FsbGVkIGR1cmluZyBjdXJyZW50IHJlcXVlc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJlc29sdmVQZW5kaW5nKCkge1xyXG4gICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xyXG4gICAgICAgICAgICBsZWFkaW5nQ2FsbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHJhaWxpbmdDYWxsKSB7XHJcbiAgICAgICAgICAgIHByb3h5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayBpbnZva2VkIGFmdGVyIHRoZSBzcGVjaWZpZWQgZGVsYXkuIEl0IHdpbGwgZnVydGhlciBwb3N0cG9uZVxyXG4gICAgICogaW52b2NhdGlvbiBvZiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gZGVsZWdhdGluZyBpdCB0byB0aGVcclxuICAgICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdGltZW91dENhbGxiYWNrKCkge1xyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxKHJlc29sdmVQZW5kaW5nKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2NoZWR1bGVzIGludm9jYXRpb24gb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBwcm94eSgpIHtcclxuICAgICAgICB2YXIgdGltZVN0YW1wID0gRGF0ZS5ub3coKTtcclxuICAgICAgICBpZiAobGVhZGluZ0NhbGwpIHtcclxuICAgICAgICAgICAgLy8gUmVqZWN0IGltbWVkaWF0ZWx5IGZvbGxvd2luZyBjYWxscy5cclxuICAgICAgICAgICAgaWYgKHRpbWVTdGFtcCAtIGxhc3RDYWxsVGltZSA8IHRyYWlsaW5nVGltZW91dCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIG5ldyBjYWxsIHRvIGJlIGluIGludm9rZWQgd2hlbiB0aGUgcGVuZGluZyBvbmUgaXMgcmVzb2x2ZWQuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGZvciBcInRyYW5zaXRpb25zXCIgd2hpY2ggbmV2ZXIgYWN0dWFsbHkgc3RhcnRcclxuICAgICAgICAgICAgLy8gaW1tZWRpYXRlbHkgc28gdGhlcmUgaXMgYSBjaGFuY2UgdGhhdCB3ZSBtaWdodCBtaXNzIG9uZSBpZiBjaGFuZ2VcclxuICAgICAgICAgICAgLy8gaGFwcGVucyBhbWlkcyB0aGUgcGVuZGluZyBpbnZvY2F0aW9uLlxyXG4gICAgICAgICAgICB0cmFpbGluZ0NhbGwgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGVhZGluZ0NhbGwgPSB0cnVlO1xyXG4gICAgICAgICAgICB0cmFpbGluZ0NhbGwgPSBmYWxzZTtcclxuICAgICAgICAgICAgc2V0VGltZW91dCh0aW1lb3V0Q2FsbGJhY2ssIGRlbGF5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGFzdENhbGxUaW1lID0gdGltZVN0YW1wO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb3h5O1xyXG59XG5cbi8vIE1pbmltdW0gZGVsYXkgYmVmb3JlIGludm9raW5nIHRoZSB1cGRhdGUgb2Ygb2JzZXJ2ZXJzLlxyXG52YXIgUkVGUkVTSF9ERUxBWSA9IDIwO1xyXG4vLyBBIGxpc3Qgb2Ygc3Vic3RyaW5ncyBvZiBDU1MgcHJvcGVydGllcyB1c2VkIHRvIGZpbmQgdHJhbnNpdGlvbiBldmVudHMgdGhhdFxyXG4vLyBtaWdodCBhZmZlY3QgZGltZW5zaW9ucyBvZiBvYnNlcnZlZCBlbGVtZW50cy5cclxudmFyIHRyYW5zaXRpb25LZXlzID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ3NpemUnLCAnd2VpZ2h0J107XHJcbi8vIENoZWNrIGlmIE11dGF0aW9uT2JzZXJ2ZXIgaXMgYXZhaWxhYmxlLlxyXG52YXIgbXV0YXRpb25PYnNlcnZlclN1cHBvcnRlZCA9IHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJztcclxuLyoqXHJcbiAqIFNpbmdsZXRvbiBjb250cm9sbGVyIGNsYXNzIHdoaWNoIGhhbmRsZXMgdXBkYXRlcyBvZiBSZXNpemVPYnNlcnZlciBpbnN0YW5jZXMuXHJcbiAqL1xyXG52YXIgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgRE9NIGxpc3RlbmVycyBoYXZlIGJlZW4gYWRkZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbm5lY3RlZF8gPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZWxscyB0aGF0IGNvbnRyb2xsZXIgaGFzIHN1YnNjcmliZWQgZm9yIE11dGF0aW9uIEV2ZW50cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBLZWVwcyByZWZlcmVuY2UgdG8gdGhlIGluc3RhbmNlIG9mIE11dGF0aW9uT2JzZXJ2ZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7TXV0YXRpb25PYnNlcnZlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXyA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBsaXN0IG9mIGNvbm5lY3RlZCBvYnNlcnZlcnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7QXJyYXk8UmVzaXplT2JzZXJ2ZXJTUEk+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzXyA9IFtdO1xyXG4gICAgICAgIHRoaXMub25UcmFuc2l0aW9uRW5kXyA9IHRoaXMub25UcmFuc2l0aW9uRW5kXy5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMucmVmcmVzaCA9IHRocm90dGxlKHRoaXMucmVmcmVzaC5iaW5kKHRoaXMpLCBSRUZSRVNIX0RFTEFZKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBvYnNlcnZlciB0byBvYnNlcnZlcnMgbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyU1BJfSBvYnNlcnZlciAtIE9ic2VydmVyIHRvIGJlIGFkZGVkLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUuYWRkT2JzZXJ2ZXIgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICBpZiAoIX50aGlzLm9ic2VydmVyc18uaW5kZXhPZihvYnNlcnZlcikpIHtcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnNfLnB1c2gob2JzZXJ2ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBZGQgbGlzdGVuZXJzIGlmIHRoZXkgaGF2ZW4ndCBiZWVuIGFkZGVkIHlldC5cclxuICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBvYnNlcnZlciBmcm9tIG9ic2VydmVycyBsaXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJTUEl9IG9ic2VydmVyIC0gT2JzZXJ2ZXIgdG8gYmUgcmVtb3ZlZC5cclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLnJlbW92ZU9ic2VydmVyID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzXztcclxuICAgICAgICB2YXIgaW5kZXggPSBvYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlcik7XHJcbiAgICAgICAgLy8gUmVtb3ZlIG9ic2VydmVyIGlmIGl0J3MgcHJlc2VudCBpbiByZWdpc3RyeS5cclxuICAgICAgICBpZiAofmluZGV4KSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1vdmUgbGlzdGVuZXJzIGlmIGNvbnRyb2xsZXIgaGFzIG5vIGNvbm5lY3RlZCBvYnNlcnZlcnMuXHJcbiAgICAgICAgaWYgKCFvYnNlcnZlcnMubGVuZ3RoICYmIHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSW52b2tlcyB0aGUgdXBkYXRlIG9mIG9ic2VydmVycy4gSXQgd2lsbCBjb250aW51ZSBydW5uaW5nIHVwZGF0ZXMgaW5zb2ZhclxyXG4gICAgICogaXQgZGV0ZWN0cyBjaGFuZ2VzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNoYW5nZXNEZXRlY3RlZCA9IHRoaXMudXBkYXRlT2JzZXJ2ZXJzXygpO1xyXG4gICAgICAgIC8vIENvbnRpbnVlIHJ1bm5pbmcgdXBkYXRlcyBpZiBjaGFuZ2VzIGhhdmUgYmVlbiBkZXRlY3RlZCBhcyB0aGVyZSBtaWdodFxyXG4gICAgICAgIC8vIGJlIGZ1dHVyZSBvbmVzIGNhdXNlZCBieSBDU1MgdHJhbnNpdGlvbnMuXHJcbiAgICAgICAgaWYgKGNoYW5nZXNEZXRlY3RlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIGV2ZXJ5IG9ic2VydmVyIGZyb20gb2JzZXJ2ZXJzIGxpc3QgYW5kIG5vdGlmaWVzIHRoZW0gb2YgcXVldWVkXHJcbiAgICAgKiBlbnRyaWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBcInRydWVcIiBpZiBhbnkgb2JzZXJ2ZXIgaGFzIGRldGVjdGVkIGNoYW5nZXMgaW5cclxuICAgICAqICAgICAgZGltZW5zaW9ucyBvZiBpdCdzIGVsZW1lbnRzLlxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZU9ic2VydmVyc18gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gQ29sbGVjdCBvYnNlcnZlcnMgdGhhdCBoYXZlIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgICAgdmFyIGFjdGl2ZU9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzXy5maWx0ZXIoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5nYXRoZXJBY3RpdmUoKSwgb2JzZXJ2ZXIuaGFzQWN0aXZlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gRGVsaXZlciBub3RpZmljYXRpb25zIGluIGEgc2VwYXJhdGUgY3ljbGUgaW4gb3JkZXIgdG8gYXZvaWQgYW55XHJcbiAgICAgICAgLy8gY29sbGlzaW9ucyBiZXR3ZWVuIG9ic2VydmVycywgZS5nLiB3aGVuIG11bHRpcGxlIGluc3RhbmNlcyBvZlxyXG4gICAgICAgIC8vIFJlc2l6ZU9ic2VydmVyIGFyZSB0cmFja2luZyB0aGUgc2FtZSBlbGVtZW50IGFuZCB0aGUgY2FsbGJhY2sgb2Ygb25lXHJcbiAgICAgICAgLy8gb2YgdGhlbSBjaGFuZ2VzIGNvbnRlbnQgZGltZW5zaW9ucyBvZiB0aGUgb2JzZXJ2ZWQgdGFyZ2V0LiBTb21ldGltZXNcclxuICAgICAgICAvLyB0aGlzIG1heSByZXN1bHQgaW4gbm90aWZpY2F0aW9ucyBiZWluZyBibG9ja2VkIGZvciB0aGUgcmVzdCBvZiBvYnNlcnZlcnMuXHJcbiAgICAgICAgYWN0aXZlT2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmVyKSB7IHJldHVybiBvYnNlcnZlci5icm9hZGNhc3RBY3RpdmUoKTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIGFjdGl2ZU9ic2VydmVycy5sZW5ndGggPiAwO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgRE9NIGxpc3RlbmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUuY29ubmVjdF8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBydW5uaW5nIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQgb3IgaWYgbGlzdGVuZXJzXHJcbiAgICAgICAgLy8gaGF2ZSBiZWVuIGFscmVhZHkgYWRkZWQuXHJcbiAgICAgICAgaWYgKCFpc0Jyb3dzZXIgfHwgdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU3Vic2NyaXB0aW9uIHRvIHRoZSBcIlRyYW5zaXRpb25lbmRcIiBldmVudCBpcyB1c2VkIGFzIGEgd29ya2Fyb3VuZCBmb3JcclxuICAgICAgICAvLyBkZWxheWVkIHRyYW5zaXRpb25zLiBUaGlzIHdheSBpdCdzIHBvc3NpYmxlIHRvIGNhcHR1cmUgYXQgbGVhc3QgdGhlXHJcbiAgICAgICAgLy8gZmluYWwgc3RhdGUgb2YgYW4gZWxlbWVudC5cclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy5vblRyYW5zaXRpb25FbmRfKTtcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICBpZiAobXV0YXRpb25PYnNlcnZlclN1cHBvcnRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXyA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfLm9ic2VydmUoZG9jdW1lbnQsIHtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgc3VidHJlZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTVN1YnRyZWVNb2RpZmllZCcsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbm5lY3RlZF8gPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBET00gbGlzdGVuZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5kaXNjb25uZWN0XyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHJ1bm5pbmcgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudCBvciBpZiBsaXN0ZW5lcnNcclxuICAgICAgICAvLyBoYXZlIGJlZW4gYWxyZWFkeSByZW1vdmVkLlxyXG4gICAgICAgIGlmICghaXNCcm93c2VyIHx8ICF0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy5vblRyYW5zaXRpb25FbmRfKTtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICBpZiAodGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8pIHtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8uZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXykge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01TdWJ0cmVlTW9kaWZpZWQnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogXCJUcmFuc2l0aW9uZW5kXCIgZXZlbnQgaGFuZGxlci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtUcmFuc2l0aW9uRXZlbnR9IGV2ZW50XHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5vblRyYW5zaXRpb25FbmRfID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EucHJvcGVydHlOYW1lLCBwcm9wZXJ0eU5hbWUgPSBfYiA9PT0gdm9pZCAwID8gJycgOiBfYjtcclxuICAgICAgICAvLyBEZXRlY3Qgd2hldGhlciB0cmFuc2l0aW9uIG1heSBhZmZlY3QgZGltZW5zaW9ucyBvZiBhbiBlbGVtZW50LlxyXG4gICAgICAgIHZhciBpc1JlZmxvd1Byb3BlcnR5ID0gdHJhbnNpdGlvbktleXMuc29tZShmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIX5wcm9wZXJ0eU5hbWUuaW5kZXhPZihrZXkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChpc1JlZmxvd1Byb3BlcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaW5zdGFuY2Ugb2YgdGhlIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmluc3RhbmNlXykge1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlXyA9IG5ldyBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VfO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSG9sZHMgcmVmZXJlbmNlIHRvIHRoZSBjb250cm9sbGVyJ3MgaW5zdGFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGUge1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlcn1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmluc3RhbmNlXyA9IG51bGw7XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyO1xyXG59KCkpO1xuXG4vKipcclxuICogRGVmaW5lcyBub24td3JpdGFibGUvZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHRoZSBwcm92aWRlZCB0YXJnZXQgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IC0gT2JqZWN0IGZvciB3aGljaCB0byBkZWZpbmUgcHJvcGVydGllcy5cclxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gUHJvcGVydGllcyB0byBiZSBkZWZpbmVkLlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUYXJnZXQgb2JqZWN0LlxyXG4gKi9cclxudmFyIGRlZmluZUNvbmZpZ3VyYWJsZSA9IChmdW5jdGlvbiAodGFyZ2V0LCBwcm9wcykge1xyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKHByb3BzKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIga2V5ID0gX2FbX2ldO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xyXG4gICAgICAgICAgICB2YWx1ZTogcHJvcHNba2V5XSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59KTtcblxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGdsb2JhbCBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcclxuICogQHJldHVybnMge09iamVjdH1cclxuICovXHJcbnZhciBnZXRXaW5kb3dPZiA9IChmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAvLyBBc3N1bWUgdGhhdCB0aGUgZWxlbWVudCBpcyBhbiBpbnN0YW5jZSBvZiBOb2RlLCB3aGljaCBtZWFucyB0aGF0IGl0XHJcbiAgICAvLyBoYXMgdGhlIFwib3duZXJEb2N1bWVudFwiIHByb3BlcnR5IGZyb20gd2hpY2ggd2UgY2FuIHJldHJpZXZlIGFcclxuICAgIC8vIGNvcnJlc3BvbmRpbmcgZ2xvYmFsIG9iamVjdC5cclxuICAgIHZhciBvd25lckdsb2JhbCA9IHRhcmdldCAmJiB0YXJnZXQub3duZXJEb2N1bWVudCAmJiB0YXJnZXQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcclxuICAgIC8vIFJldHVybiB0aGUgbG9jYWwgZ2xvYmFsIG9iamVjdCBpZiBpdCdzIG5vdCBwb3NzaWJsZSBleHRyYWN0IG9uZSBmcm9tXHJcbiAgICAvLyBwcm92aWRlZCBlbGVtZW50LlxyXG4gICAgcmV0dXJuIG93bmVyR2xvYmFsIHx8IGdsb2JhbCQxO1xyXG59KTtcblxuLy8gUGxhY2Vob2xkZXIgb2YgYW4gZW1wdHkgY29udGVudCByZWN0YW5nbGUuXHJcbnZhciBlbXB0eVJlY3QgPSBjcmVhdGVSZWN0SW5pdCgwLCAwLCAwLCAwKTtcclxuLyoqXHJcbiAqIENvbnZlcnRzIHByb3ZpZGVkIHN0cmluZyB0byBhIG51bWJlci5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuZnVuY3Rpb24gdG9GbG9hdCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpIHx8IDA7XHJcbn1cclxuLyoqXHJcbiAqIEV4dHJhY3RzIGJvcmRlcnMgc2l6ZSBmcm9tIHByb3ZpZGVkIHN0eWxlcy5cclxuICpcclxuICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZXNcclxuICogQHBhcmFtIHsuLi5zdHJpbmd9IHBvc2l0aW9ucyAtIEJvcmRlcnMgcG9zaXRpb25zICh0b3AsIHJpZ2h0LCAuLi4pXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRCb3JkZXJzU2l6ZShzdHlsZXMpIHtcclxuICAgIHZhciBwb3NpdGlvbnMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgcG9zaXRpb25zW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBvc2l0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKHNpemUsIHBvc2l0aW9uKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVzWydib3JkZXItJyArIHBvc2l0aW9uICsgJy13aWR0aCddO1xyXG4gICAgICAgIHJldHVybiBzaXplICsgdG9GbG9hdCh2YWx1ZSk7XHJcbiAgICB9LCAwKTtcclxufVxyXG4vKipcclxuICogRXh0cmFjdHMgcGFkZGluZ3Mgc2l6ZXMgZnJvbSBwcm92aWRlZCBzdHlsZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IFBhZGRpbmdzIGJveC5cclxuICovXHJcbmZ1bmN0aW9uIGdldFBhZGRpbmdzKHN0eWxlcykge1xyXG4gICAgdmFyIHBvc2l0aW9ucyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J107XHJcbiAgICB2YXIgcGFkZGluZ3MgPSB7fTtcclxuICAgIGZvciAodmFyIF9pID0gMCwgcG9zaXRpb25zXzEgPSBwb3NpdGlvbnM7IF9pIDwgcG9zaXRpb25zXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gcG9zaXRpb25zXzFbX2ldO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlc1sncGFkZGluZy0nICsgcG9zaXRpb25dO1xyXG4gICAgICAgIHBhZGRpbmdzW3Bvc2l0aW9uXSA9IHRvRmxvYXQodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhZGRpbmdzO1xyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHByb3ZpZGVkIFNWRyBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NWR0dyYXBoaWNzRWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCBjb250ZW50IHJlY3RhbmdsZSBvZiB3aGljaCBuZWVkc1xyXG4gKiAgICAgIHRvIGJlIGNhbGN1bGF0ZWQuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICovXHJcbmZ1bmN0aW9uIGdldFNWR0NvbnRlbnRSZWN0KHRhcmdldCkge1xyXG4gICAgdmFyIGJib3ggPSB0YXJnZXQuZ2V0QkJveCgpO1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlY3RJbml0KDAsIDAsIGJib3gud2lkdGgsIGJib3guaGVpZ2h0KTtcclxufVxyXG4vKipcclxuICogQ2FsY3VsYXRlcyBjb250ZW50IHJlY3RhbmdsZSBvZiBwcm92aWRlZCBIVE1MRWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCBmb3Igd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSBjb250ZW50IHJlY3RhbmdsZS5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SFRNTEVsZW1lbnRDb250ZW50UmVjdCh0YXJnZXQpIHtcclxuICAgIC8vIENsaWVudCB3aWR0aCAmIGhlaWdodCBwcm9wZXJ0aWVzIGNhbid0IGJlXHJcbiAgICAvLyB1c2VkIGV4Y2x1c2l2ZWx5IGFzIHRoZXkgcHJvdmlkZSByb3VuZGVkIHZhbHVlcy5cclxuICAgIHZhciBjbGllbnRXaWR0aCA9IHRhcmdldC5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0ID0gdGFyZ2V0LmNsaWVudEhlaWdodDtcclxuICAgIC8vIEJ5IHRoaXMgY29uZGl0aW9uIHdlIGNhbiBjYXRjaCBhbGwgbm9uLXJlcGxhY2VkIGlubGluZSwgaGlkZGVuIGFuZFxyXG4gICAgLy8gZGV0YWNoZWQgZWxlbWVudHMuIFRob3VnaCBlbGVtZW50cyB3aXRoIHdpZHRoICYgaGVpZ2h0IHByb3BlcnRpZXMgbGVzc1xyXG4gICAgLy8gdGhhbiAwLjUgd2lsbCBiZSBkaXNjYXJkZWQgYXMgd2VsbC5cclxuICAgIC8vXHJcbiAgICAvLyBXaXRob3V0IGl0IHdlIHdvdWxkIG5lZWQgdG8gaW1wbGVtZW50IHNlcGFyYXRlIG1ldGhvZHMgZm9yIGVhY2ggb2ZcclxuICAgIC8vIHRob3NlIGNhc2VzIGFuZCBpdCdzIG5vdCBwb3NzaWJsZSB0byBwZXJmb3JtIGEgcHJlY2lzZSBhbmQgcGVyZm9ybWFuY2VcclxuICAgIC8vIGVmZmVjdGl2ZSB0ZXN0IGZvciBoaWRkZW4gZWxlbWVudHMuIEUuZy4gZXZlbiBqUXVlcnkncyAnOnZpc2libGUnIGZpbHRlclxyXG4gICAgLy8gZ2l2ZXMgd3JvbmcgcmVzdWx0cyBmb3IgZWxlbWVudHMgd2l0aCB3aWR0aCAmIGhlaWdodCBsZXNzIHRoYW4gMC41LlxyXG4gICAgaWYgKCFjbGllbnRXaWR0aCAmJiAhY2xpZW50SGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIGVtcHR5UmVjdDtcclxuICAgIH1cclxuICAgIHZhciBzdHlsZXMgPSBnZXRXaW5kb3dPZih0YXJnZXQpLmdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcclxuICAgIHZhciBwYWRkaW5ncyA9IGdldFBhZGRpbmdzKHN0eWxlcyk7XHJcbiAgICB2YXIgaG9yaXpQYWQgPSBwYWRkaW5ncy5sZWZ0ICsgcGFkZGluZ3MucmlnaHQ7XHJcbiAgICB2YXIgdmVydFBhZCA9IHBhZGRpbmdzLnRvcCArIHBhZGRpbmdzLmJvdHRvbTtcclxuICAgIC8vIENvbXB1dGVkIHN0eWxlcyBvZiB3aWR0aCAmIGhlaWdodCBhcmUgYmVpbmcgdXNlZCBiZWNhdXNlIHRoZXkgYXJlIHRoZVxyXG4gICAgLy8gb25seSBkaW1lbnNpb25zIGF2YWlsYWJsZSB0byBKUyB0aGF0IGNvbnRhaW4gbm9uLXJvdW5kZWQgdmFsdWVzLiBJdCBjb3VsZFxyXG4gICAgLy8gYmUgcG9zc2libGUgdG8gdXRpbGl6ZSB0aGUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlmIG9ubHkgaXQncyBkYXRhIHdhc24ndFxyXG4gICAgLy8gYWZmZWN0ZWQgYnkgQ1NTIHRyYW5zZm9ybWF0aW9ucyBsZXQgYWxvbmUgcGFkZGluZ3MsIGJvcmRlcnMgYW5kIHNjcm9sbCBiYXJzLlxyXG4gICAgdmFyIHdpZHRoID0gdG9GbG9hdChzdHlsZXMud2lkdGgpLCBoZWlnaHQgPSB0b0Zsb2F0KHN0eWxlcy5oZWlnaHQpO1xyXG4gICAgLy8gV2lkdGggJiBoZWlnaHQgaW5jbHVkZSBwYWRkaW5ncyBhbmQgYm9yZGVycyB3aGVuIHRoZSAnYm9yZGVyLWJveCcgYm94XHJcbiAgICAvLyBtb2RlbCBpcyBhcHBsaWVkIChleGNlcHQgZm9yIElFKS5cclxuICAgIGlmIChzdHlsZXMuYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCcpIHtcclxuICAgICAgICAvLyBGb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgcmVxdWlyZWQgdG8gaGFuZGxlIEludGVybmV0IEV4cGxvcmVyIHdoaWNoXHJcbiAgICAgICAgLy8gZG9lc24ndCBpbmNsdWRlIHBhZGRpbmdzIGFuZCBib3JkZXJzIHRvIGNvbXB1dGVkIENTUyBkaW1lbnNpb25zLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gV2UgY2FuIHNheSB0aGF0IGlmIENTUyBkaW1lbnNpb25zICsgcGFkZGluZ3MgYXJlIGVxdWFsIHRvIHRoZSBcImNsaWVudFwiXHJcbiAgICAgICAgLy8gcHJvcGVydGllcyB0aGVuIGl0J3MgZWl0aGVyIElFLCBhbmQgdGh1cyB3ZSBkb24ndCBuZWVkIHRvIHN1YnRyYWN0XHJcbiAgICAgICAgLy8gYW55dGhpbmcsIG9yIGFuIGVsZW1lbnQgbWVyZWx5IGRvZXNuJ3QgaGF2ZSBwYWRkaW5ncy9ib3JkZXJzIHN0eWxlcy5cclxuICAgICAgICBpZiAoTWF0aC5yb3VuZCh3aWR0aCArIGhvcml6UGFkKSAhPT0gY2xpZW50V2lkdGgpIHtcclxuICAgICAgICAgICAgd2lkdGggLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAnbGVmdCcsICdyaWdodCcpICsgaG9yaXpQYWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChNYXRoLnJvdW5kKGhlaWdodCArIHZlcnRQYWQpICE9PSBjbGllbnRIZWlnaHQpIHtcclxuICAgICAgICAgICAgaGVpZ2h0IC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3RvcCcsICdib3R0b20nKSArIHZlcnRQYWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gRm9sbG93aW5nIHN0ZXBzIGNhbid0IGJlIGFwcGxpZWQgdG8gdGhlIGRvY3VtZW50J3Mgcm9vdCBlbGVtZW50IGFzIGl0c1xyXG4gICAgLy8gY2xpZW50W1dpZHRoL0hlaWdodF0gcHJvcGVydGllcyByZXByZXNlbnQgdmlld3BvcnQgYXJlYSBvZiB0aGUgd2luZG93LlxyXG4gICAgLy8gQmVzaWRlcywgaXQncyBhcyB3ZWxsIG5vdCBuZWNlc3NhcnkgYXMgdGhlIDxodG1sPiBpdHNlbGYgbmVpdGhlciBoYXNcclxuICAgIC8vIHJlbmRlcmVkIHNjcm9sbCBiYXJzIG5vciBpdCBjYW4gYmUgY2xpcHBlZC5cclxuICAgIGlmICghaXNEb2N1bWVudEVsZW1lbnQodGFyZ2V0KSkge1xyXG4gICAgICAgIC8vIEluIHNvbWUgYnJvd3NlcnMgKG9ubHkgaW4gRmlyZWZveCwgYWN0dWFsbHkpIENTUyB3aWR0aCAmIGhlaWdodFxyXG4gICAgICAgIC8vIGluY2x1ZGUgc2Nyb2xsIGJhcnMgc2l6ZSB3aGljaCBjYW4gYmUgcmVtb3ZlZCBhdCB0aGlzIHN0ZXAgYXMgc2Nyb2xsXHJcbiAgICAgICAgLy8gYmFycyBhcmUgdGhlIG9ubHkgZGlmZmVyZW5jZSBiZXR3ZWVuIHJvdW5kZWQgZGltZW5zaW9ucyArIHBhZGRpbmdzXHJcbiAgICAgICAgLy8gYW5kIFwiY2xpZW50XCIgcHJvcGVydGllcywgdGhvdWdoIHRoYXQgaXMgbm90IGFsd2F5cyB0cnVlIGluIENocm9tZS5cclxuICAgICAgICB2YXIgdmVydFNjcm9sbGJhciA9IE1hdGgucm91bmQod2lkdGggKyBob3JpelBhZCkgLSBjbGllbnRXaWR0aDtcclxuICAgICAgICB2YXIgaG9yaXpTY3JvbGxiYXIgPSBNYXRoLnJvdW5kKGhlaWdodCArIHZlcnRQYWQpIC0gY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgIC8vIENocm9tZSBoYXMgYSByYXRoZXIgd2VpcmQgcm91bmRpbmcgb2YgXCJjbGllbnRcIiBwcm9wZXJ0aWVzLlxyXG4gICAgICAgIC8vIEUuZy4gZm9yIGFuIGVsZW1lbnQgd2l0aCBjb250ZW50IHdpZHRoIG9mIDMxNC4ycHggaXQgc29tZXRpbWVzIGdpdmVzXHJcbiAgICAgICAgLy8gdGhlIGNsaWVudCB3aWR0aCBvZiAzMTVweCBhbmQgZm9yIHRoZSB3aWR0aCBvZiAzMTQuN3B4IGl0IG1heSBnaXZlXHJcbiAgICAgICAgLy8gMzE0cHguIEFuZCBpdCBkb2Vzbid0IGhhcHBlbiBhbGwgdGhlIHRpbWUuIFNvIGp1c3QgaWdub3JlIHRoaXMgZGVsdGFcclxuICAgICAgICAvLyBhcyBhIG5vbi1yZWxldmFudC5cclxuICAgICAgICBpZiAoTWF0aC5hYnModmVydFNjcm9sbGJhcikgIT09IDEpIHtcclxuICAgICAgICAgICAgd2lkdGggLT0gdmVydFNjcm9sbGJhcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKE1hdGguYWJzKGhvcml6U2Nyb2xsYmFyKSAhPT0gMSkge1xyXG4gICAgICAgICAgICBoZWlnaHQgLT0gaG9yaXpTY3JvbGxiYXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZVJlY3RJbml0KHBhZGRpbmdzLmxlZnQsIHBhZGRpbmdzLnRvcCwgd2lkdGgsIGhlaWdodCk7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIHByb3ZpZGVkIGVsZW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIFNWR0dyYXBoaWNzRWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIGNoZWNrZWQuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxudmFyIGlzU1ZHR3JhcGhpY3NFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIFNvbWUgYnJvd3NlcnMsIG5hbWVseSBJRSBhbmQgRWRnZSwgZG9uJ3QgaGF2ZSB0aGUgU1ZHR3JhcGhpY3NFbGVtZW50XHJcbiAgICAvLyBpbnRlcmZhY2UuXHJcbiAgICBpZiAodHlwZW9mIFNWR0dyYXBoaWNzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5TVkdHcmFwaGljc0VsZW1lbnQ7IH07XHJcbiAgICB9XHJcbiAgICAvLyBJZiBpdCdzIHNvLCB0aGVuIGNoZWNrIHRoYXQgZWxlbWVudCBpcyBhdCBsZWFzdCBhbiBpbnN0YW5jZSBvZiB0aGVcclxuICAgIC8vIFNWR0VsZW1lbnQgYW5kIHRoYXQgaXQgaGFzIHRoZSBcImdldEJCb3hcIiBtZXRob2QuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0cmEtcGFyZW5zXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gKHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuU1ZHRWxlbWVudCAmJlxyXG4gICAgICAgIHR5cGVvZiB0YXJnZXQuZ2V0QkJveCA9PT0gJ2Z1bmN0aW9uJyk7IH07XHJcbn0pKCk7XHJcbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciBwcm92aWRlZCBlbGVtZW50IGlzIGEgZG9jdW1lbnQgZWxlbWVudCAoPGh0bWw+KS5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIGNoZWNrZWQuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gaXNEb2N1bWVudEVsZW1lbnQodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gdGFyZ2V0ID09PSBnZXRXaW5kb3dPZih0YXJnZXQpLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxufVxyXG4vKipcclxuICogQ2FsY3VsYXRlcyBhbiBhcHByb3ByaWF0ZSBjb250ZW50IHJlY3RhbmdsZSBmb3IgcHJvdmlkZWQgaHRtbCBvciBzdmcgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHdoaWNoIG5lZWRzIHRvIGJlIGNhbGN1bGF0ZWQuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICovXHJcbmZ1bmN0aW9uIGdldENvbnRlbnRSZWN0KHRhcmdldCkge1xyXG4gICAgaWYgKCFpc0Jyb3dzZXIpIHtcclxuICAgICAgICByZXR1cm4gZW1wdHlSZWN0O1xyXG4gICAgfVxyXG4gICAgaWYgKGlzU1ZHR3JhcGhpY3NFbGVtZW50KHRhcmdldCkpIHtcclxuICAgICAgICByZXR1cm4gZ2V0U1ZHQ29udGVudFJlY3QodGFyZ2V0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBnZXRIVE1MRWxlbWVudENvbnRlbnRSZWN0KHRhcmdldCk7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgcmVjdGFuZ2xlIHdpdGggYW4gaW50ZXJmYWNlIG9mIHRoZSBET01SZWN0UmVhZE9ubHkuXHJcbiAqIFNwZWM6IGh0dHBzOi8vZHJhZnRzLmZ4dGYub3JnL2dlb21ldHJ5LyNkb21yZWN0cmVhZG9ubHlcclxuICpcclxuICogQHBhcmFtIHtET01SZWN0SW5pdH0gcmVjdEluaXQgLSBPYmplY3Qgd2l0aCByZWN0YW5nbGUncyB4L3kgY29vcmRpbmF0ZXMgYW5kIGRpbWVuc2lvbnMuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0UmVhZE9ubHl9XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVSZWFkT25seVJlY3QoX2EpIHtcclxuICAgIHZhciB4ID0gX2EueCwgeSA9IF9hLnksIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcclxuICAgIC8vIElmIERPTVJlY3RSZWFkT25seSBpcyBhdmFpbGFibGUgdXNlIGl0IGFzIGEgcHJvdG90eXBlIGZvciB0aGUgcmVjdGFuZ2xlLlxyXG4gICAgdmFyIENvbnN0ciA9IHR5cGVvZiBET01SZWN0UmVhZE9ubHkgIT09ICd1bmRlZmluZWQnID8gRE9NUmVjdFJlYWRPbmx5IDogT2JqZWN0O1xyXG4gICAgdmFyIHJlY3QgPSBPYmplY3QuY3JlYXRlKENvbnN0ci5wcm90b3R5cGUpO1xyXG4gICAgLy8gUmVjdGFuZ2xlJ3MgcHJvcGVydGllcyBhcmUgbm90IHdyaXRhYmxlIGFuZCBub24tZW51bWVyYWJsZS5cclxuICAgIGRlZmluZUNvbmZpZ3VyYWJsZShyZWN0LCB7XHJcbiAgICAgICAgeDogeCwgeTogeSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICB0b3A6IHksXHJcbiAgICAgICAgcmlnaHQ6IHggKyB3aWR0aCxcclxuICAgICAgICBib3R0b206IGhlaWdodCArIHksXHJcbiAgICAgICAgbGVmdDogeFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVjdDtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBET01SZWN0SW5pdCBvYmplY3QgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGRpbWVuc2lvbnMgYW5kIHRoZSB4L3kgY29vcmRpbmF0ZXMuXHJcbiAqIFNwZWM6IGh0dHBzOi8vZHJhZnRzLmZ4dGYub3JnL2dlb21ldHJ5LyNkaWN0ZGVmLWRvbXJlY3Rpbml0XHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gWCBjb29yZGluYXRlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0geSAtIFkgY29vcmRpbmF0ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gUmVjdGFuZ2xlJ3Mgd2lkdGguXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBSZWN0YW5nbGUncyBoZWlnaHQuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlY3RJbml0KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIHJldHVybiB7IHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcclxufVxuXG4vKipcclxuICogQ2xhc3MgdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgY29tcHV0YXRpb25zIG9mIHRoZSBjb250ZW50IHJlY3RhbmdsZSBvZlxyXG4gKiBwcm92aWRlZCBET00gZWxlbWVudCBhbmQgZm9yIGtlZXBpbmcgdHJhY2sgb2YgaXQncyBjaGFuZ2VzLlxyXG4gKi9cclxudmFyIFJlc2l6ZU9ic2VydmF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBvYnNlcnZlZC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0KSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnJvYWRjYXN0ZWQgd2lkdGggb2YgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0V2lkdGggPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJyb2FkY2FzdGVkIGhlaWdodCBvZiBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RIZWlnaHQgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgbGFzdCBvYnNlcnZlZCBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtET01SZWN0SW5pdH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbnRlbnRSZWN0XyA9IGNyZWF0ZVJlY3RJbml0KDAsIDAsIDAsIDApO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIGNvbnRlbnQgcmVjdGFuZ2xlIGFuZCB0ZWxscyB3aGV0aGVyIGl0J3Mgd2lkdGggb3IgaGVpZ2h0IHByb3BlcnRpZXNcclxuICAgICAqIGhhdmUgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBicm9hZGNhc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmF0aW9uLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IGdldENvbnRlbnRSZWN0KHRoaXMudGFyZ2V0KTtcclxuICAgICAgICB0aGlzLmNvbnRlbnRSZWN0XyA9IHJlY3Q7XHJcbiAgICAgICAgcmV0dXJuIChyZWN0LndpZHRoICE9PSB0aGlzLmJyb2FkY2FzdFdpZHRoIHx8XHJcbiAgICAgICAgICAgIHJlY3QuaGVpZ2h0ICE9PSB0aGlzLmJyb2FkY2FzdEhlaWdodCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzICdicm9hZGNhc3RXaWR0aCcgYW5kICdicm9hZGNhc3RIZWlnaHQnIHByb3BlcnRpZXMgd2l0aCBhIGRhdGFcclxuICAgICAqIGZyb20gdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydGllcyBvZiB0aGUgbGFzdCBvYnNlcnZlZCBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9IExhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmF0aW9uLnByb3RvdHlwZS5icm9hZGNhc3RSZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5jb250ZW50UmVjdF87XHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RXaWR0aCA9IHJlY3Qud2lkdGg7XHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RIZWlnaHQgPSByZWN0LmhlaWdodDtcclxuICAgICAgICByZXR1cm4gcmVjdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2YXRpb247XHJcbn0oKSk7XG5cbnZhciBSZXNpemVPYnNlcnZlckVudHJ5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyRW50cnkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRoYXQgaXMgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgKiBAcGFyYW0ge0RPTVJlY3RJbml0fSByZWN0SW5pdCAtIERhdGEgb2YgdGhlIGVsZW1lbnQncyBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXJFbnRyeSh0YXJnZXQsIHJlY3RJbml0KSB7XHJcbiAgICAgICAgdmFyIGNvbnRlbnRSZWN0ID0gY3JlYXRlUmVhZE9ubHlSZWN0KHJlY3RJbml0KTtcclxuICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmljYXRpb24gZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIG5vdCB3cml0YWJsZVxyXG4gICAgICAgIC8vIGFuZCBhcmUgYWxzbyBub3QgZW51bWVyYWJsZSBpbiB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gUHJvcGVydHkgYWNjZXNzb3JzIGFyZSBub3QgYmVpbmcgdXNlZCBhcyB0aGV5J2QgcmVxdWlyZSB0byBkZWZpbmUgYVxyXG4gICAgICAgIC8vIHByaXZhdGUgV2Vha01hcCBzdG9yYWdlIHdoaWNoIG1heSBjYXVzZSBtZW1vcnkgbGVha3MgaW4gYnJvd3NlcnMgdGhhdFxyXG4gICAgICAgIC8vIGRvbid0IHN1cHBvcnQgdGhpcyB0eXBlIG9mIGNvbGxlY3Rpb25zLlxyXG4gICAgICAgIGRlZmluZUNvbmZpZ3VyYWJsZSh0aGlzLCB7IHRhcmdldDogdGFyZ2V0LCBjb250ZW50UmVjdDogY29udGVudFJlY3QgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJFbnRyeTtcclxufSgpKTtcblxudmFyIFJlc2l6ZU9ic2VydmVyU1BJID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGludm9rZWRcclxuICAgICAqICAgICAgd2hlbiBvbmUgb2YgdGhlIG9ic2VydmVkIGVsZW1lbnRzIGNoYW5nZXMgaXQncyBjb250ZW50IGRpbWVuc2lvbnMuXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlcn0gY29udHJvbGxlciAtIENvbnRyb2xsZXIgaW5zdGFuY2Ugd2hpY2hcclxuICAgICAqICAgICAgaXMgcmVzcG9uc2libGUgZm9yIHRoZSB1cGRhdGVzIG9mIG9ic2VydmVyLlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlcn0gY2FsbGJhY2tDdHggLSBSZWZlcmVuY2UgdG8gdGhlIHB1YmxpY1xyXG4gICAgICogICAgICBSZXNpemVPYnNlcnZlciBpbnN0YW5jZSB3aGljaCB3aWxsIGJlIHBhc3NlZCB0byBjYWxsYmFjayBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXJTUEkoY2FsbGJhY2ssIGNvbnRyb2xsZXIsIGNhbGxiYWNrQ3R4KSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29sbGVjdGlvbiBvZiByZXNpemUgb2JzZXJ2YXRpb25zIHRoYXQgaGF2ZSBkZXRlY3RlZCBjaGFuZ2VzIGluIGRpbWVuc2lvbnNcclxuICAgICAgICAgKiBvZiBlbGVtZW50cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtBcnJheTxSZXNpemVPYnNlcnZhdGlvbj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVnaXN0cnkgb2YgdGhlIFJlc2l6ZU9ic2VydmF0aW9uIGluc3RhbmNlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtNYXA8RWxlbWVudCwgUmVzaXplT2JzZXJ2YXRpb24+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YXRpb25zXyA9IG5ldyBNYXBTaGltKCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgY2FsbGJhY2sgcHJvdmlkZWQgYXMgcGFyYW1ldGVyIDEgaXMgbm90IGEgZnVuY3Rpb24uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tfID0gY2FsbGJhY2s7XHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyXyA9IGNvbnRyb2xsZXI7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja0N0eF8gPSBjYWxsYmFja0N0eDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIG9ic2VydmluZyBwcm92aWRlZCBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBvYnNlcnZlZC5cclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHRoZSBFbGVtZW50IGludGVyZmFjZS5cclxuICAgICAgICBpZiAodHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnIHx8ICEoRWxlbWVudCBpbnN0YW5jZW9mIE9iamVjdCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLkVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlIFwiRWxlbWVudFwiLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb2JzZXJ2YXRpb25zID0gdGhpcy5vYnNlcnZhdGlvbnNfO1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgZWxlbWVudCBpcyBhbHJlYWR5IGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgIGlmIChvYnNlcnZhdGlvbnMuaGFzKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYnNlcnZhdGlvbnMuc2V0KHRhcmdldCwgbmV3IFJlc2l6ZU9ic2VydmF0aW9uKHRhcmdldCkpO1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlcl8uYWRkT2JzZXJ2ZXIodGhpcyk7XHJcbiAgICAgICAgLy8gRm9yY2UgdGhlIHVwZGF0ZSBvZiBvYnNlcnZhdGlvbnMuXHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyXy5yZWZyZXNoKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyBvYnNlcnZpbmcgcHJvdmlkZWQgZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gc3RvcCBvYnNlcnZpbmcuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLnVub2JzZXJ2ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHRoZSBFbGVtZW50IGludGVyZmFjZS5cclxuICAgICAgICBpZiAodHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnIHx8ICEoRWxlbWVudCBpbnN0YW5jZW9mIE9iamVjdCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLkVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlIFwiRWxlbWVudFwiLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb2JzZXJ2YXRpb25zID0gdGhpcy5vYnNlcnZhdGlvbnNfO1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgZWxlbWVudCBpcyBub3QgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgICAgaWYgKCFvYnNlcnZhdGlvbnMuaGFzKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYnNlcnZhdGlvbnMuZGVsZXRlKHRhcmdldCk7XHJcbiAgICAgICAgaWYgKCFvYnNlcnZhdGlvbnMuc2l6ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLnJlbW92ZU9ic2VydmVyKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIG9ic2VydmluZyBhbGwgZWxlbWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXJBY3RpdmUoKTtcclxuICAgICAgICB0aGlzLm9ic2VydmF0aW9uc18uY2xlYXIoKTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLnJlbW92ZU9ic2VydmVyKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29sbGVjdHMgb2JzZXJ2YXRpb24gaW5zdGFuY2VzIHRoZSBhc3NvY2lhdGVkIGVsZW1lbnQgb2Ygd2hpY2ggaGFzIGNoYW5nZWRcclxuICAgICAqIGl0J3MgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5nYXRoZXJBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZhdGlvbnNfLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChvYnNlcnZhdGlvbi5pc0FjdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLnB1c2gob2JzZXJ2YXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2VzIGluaXRpYWwgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBhIGxpc3Qgb2YgUmVzaXplT2JzZXJ2ZXJFbnRyeVxyXG4gICAgICogaW5zdGFuY2VzIGNvbGxlY3RlZCBmcm9tIGFjdGl2ZSByZXNpemUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuYnJvYWRjYXN0QWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgb2JzZXJ2ZXIgZG9lc24ndCBoYXZlIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgICAgaWYgKCF0aGlzLmhhc0FjdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuY2FsbGJhY2tDdHhfO1xyXG4gICAgICAgIC8vIENyZWF0ZSBSZXNpemVPYnNlcnZlckVudHJ5IGluc3RhbmNlIGZvciBldmVyeSBhY3RpdmUgb2JzZXJ2YXRpb24uXHJcbiAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18ubWFwKGZ1bmN0aW9uIChvYnNlcnZhdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc2l6ZU9ic2VydmVyRW50cnkob2JzZXJ2YXRpb24udGFyZ2V0LCBvYnNlcnZhdGlvbi5icm9hZGNhc3RSZWN0KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tfLmNhbGwoY3R4LCBlbnRyaWVzLCBjdHgpO1xyXG4gICAgICAgIHRoaXMuY2xlYXJBY3RpdmUoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGUgY29sbGVjdGlvbiBvZiBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuY2xlYXJBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLnNwbGljZSgwKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHdoZXRoZXIgb2JzZXJ2ZXIgaGFzIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5oYXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5sZW5ndGggPiAwO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlclNQSTtcclxufSgpKTtcblxuLy8gUmVnaXN0cnkgb2YgaW50ZXJuYWwgb2JzZXJ2ZXJzLiBJZiBXZWFrTWFwIGlzIG5vdCBhdmFpbGFibGUgdXNlIGN1cnJlbnQgc2hpbVxyXG4vLyBmb3IgdGhlIE1hcCBjb2xsZWN0aW9uIGFzIGl0IGhhcyBhbGwgcmVxdWlyZWQgbWV0aG9kcyBhbmQgYmVjYXVzZSBXZWFrTWFwXHJcbi8vIGNhbid0IGJlIGZ1bGx5IHBvbHlmaWxsZWQgYW55d2F5LlxyXG52YXIgb2JzZXJ2ZXJzID0gdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnID8gbmV3IFdlYWtNYXAoKSA6IG5ldyBNYXBTaGltKCk7XHJcbi8qKlxyXG4gKiBSZXNpemVPYnNlcnZlciBBUEkuIEVuY2Fwc3VsYXRlcyB0aGUgUmVzaXplT2JzZXJ2ZXIgU1BJIGltcGxlbWVudGF0aW9uXHJcbiAqIGV4cG9zaW5nIG9ubHkgdGhvc2UgbWV0aG9kcyBhbmQgcHJvcGVydGllcyB0aGF0IGFyZSBkZWZpbmVkIGluIHRoZSBzcGVjLlxyXG4gKi9cclxudmFyIFJlc2l6ZU9ic2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayB0aGF0IGlzIGludm9rZWQgd2hlblxyXG4gICAgICogICAgICBkaW1lbnNpb25zIG9mIHRoZSBvYnNlcnZlZCBlbGVtZW50cyBjaGFuZ2UuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlc2l6ZU9ic2VydmVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb250cm9sbGVyID0gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgdmFyIG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyU1BJKGNhbGxiYWNrLCBjb250cm9sbGVyLCB0aGlzKTtcclxuICAgICAgICBvYnNlcnZlcnMuc2V0KHRoaXMsIG9ic2VydmVyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlcjtcclxufSgpKTtcclxuLy8gRXhwb3NlIHB1YmxpYyBtZXRob2RzIG9mIFJlc2l6ZU9ic2VydmVyLlxyXG5bXHJcbiAgICAnb2JzZXJ2ZScsXHJcbiAgICAndW5vYnNlcnZlJyxcclxuICAgICdkaXNjb25uZWN0J1xyXG5dLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xyXG4gICAgUmVzaXplT2JzZXJ2ZXIucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoX2EgPSBvYnNlcnZlcnMuZ2V0KHRoaXMpKVttZXRob2RdLmFwcGx5KF9hLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxufSk7XG5cbnZhciBpbmRleCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBFeHBvcnQgZXhpc3RpbmcgaW1wbGVtZW50YXRpb24gaWYgYXZhaWxhYmxlLlxyXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwkMS5SZXNpemVPYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gZ2xvYmFsJDEuUmVzaXplT2JzZXJ2ZXI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXI7XHJcbn0pKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGluZGV4O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/string-convert/camel2hyphen.js":
/*!*****************************************************!*\
  !*** ./node_modules/string-convert/camel2hyphen.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var camel2hyphen = function (str) {\n  return str\n          .replace(/[A-Z]/g, function (match) {\n            return '-' + match.toLowerCase();\n          })\n          .toLowerCase();\n};\n\nmodule.exports = camel2hyphen;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHJpbmctY29udmVydC9jYW1lbDJoeXBoZW4uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc3RyaW5nLWNvbnZlcnQvY2FtZWwyaHlwaGVuLmpzPzQwOTUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNhbWVsMmh5cGhlbiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAgICAgICAgIC5yZXBsYWNlKC9bQS1aXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiAnLScgKyBtYXRjaC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnRvTG93ZXJDYXNlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsMmh5cGhlbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/string-convert/camel2hyphen.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/slick-carousel/slick/slick-theme.css":
/*!***********************************************************!*\
  !*** ./node_modules/slick-carousel/slick/slick-theme.css ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"8a04c6cffc18\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zbGljay1jYXJvdXNlbC9zbGljay9zbGljay10aGVtZS5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zbGljay1jYXJvdXNlbC9zbGljay9zbGljay10aGVtZS5jc3M/NmIxYSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjhhMDRjNmNmZmMxOFwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/slick-carousel/slick/slick-theme.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/slick-carousel/slick/slick.css":
/*!*****************************************************!*\
  !*** ./node_modules/slick-carousel/slick/slick.css ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"b955e83ce723\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zbGljay1jYXJvdXNlbC9zbGljay9zbGljay5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zbGljay1jYXJvdXNlbC9zbGljay9zbGljay5jc3M/N2Y5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImI5NTVlODNjZTcyM1wiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/slick-carousel/slick/slick.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/login.tsx":
/*!***********************!*\
  !*** ./app/login.tsx ***!
  \***********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_LoginPage_page__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/LoginPage/page */ \"(app-pages-browser)/./components/LoginPage/page.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ var _this = undefined;\n\n\n // Importando LoginPage\nvar Login = function(param) {\n    var onSignUpClick = param.onSignUpClick;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_LoginPage_page__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                onSignUpClick: onSignUpClick\n            }, void 0, false, {\n                fileName: \"/home/ianov/game3/trump-cards/app/login.tsx\",\n                lineNumber: 8,\n                columnNumber: 7\n            }, _this),\n            \" \"\n        ]\n    }, void 0, true, {\n        fileName: \"/home/ianov/game3/trump-cards/app/login.tsx\",\n        lineNumber: 7,\n        columnNumber: 5\n    }, _this);\n};\n_c = Login;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Login);\nvar _c;\n$RefreshReg$(_c, \"Login\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9sb2dpbi50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUMwQjtBQUMwQixDQUFDLHVCQUF1QjtBQUU1RSxJQUFNRSxRQUFpRDtRQUFHQyxzQkFBQUE7SUFDeEQscUJBQ0UsOERBQUNDOzswQkFDQyw4REFBQ0gsa0VBQVNBO2dCQUFDRSxlQUFlQTs7Ozs7O1lBQWlCOzs7Ozs7O0FBR2pEO0tBTk1EO0FBUU4saUVBQWVBLEtBQUtBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2xvZ2luLnRzeD8xMzBiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiOyBcbmltcG9ydCBMb2dpblBhZ2UgZnJvbSBcIkAvY29tcG9uZW50cy9Mb2dpblBhZ2UvcGFnZVwiOyAvLyBJbXBvcnRhbmRvIExvZ2luUGFnZVxuXG5jb25zdCBMb2dpbjogUmVhY3QuRkM8eyBvblNpZ25VcENsaWNrOiAoKSA9PiB2b2lkIH0+ID0gKHsgb25TaWduVXBDbGljayB9KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdj5cbiAgICAgIDxMb2dpblBhZ2Ugb25TaWduVXBDbGljaz17b25TaWduVXBDbGlja30gLz4gey8qIFBhc3NhIGEgZnVuw6fDo28gcGFyYSBvIExvZ2luUGFnZSAqL31cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IExvZ2luO1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwiTG9naW5QYWdlIiwiTG9naW4iLCJvblNpZ25VcENsaWNrIiwiZGl2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/login.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/page.tsx":
/*!**********************!*\
  !*** ./app/page.tsx ***!
  \**********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_sliced_to_array.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _login__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./login */ \"(app-pages-browser)/./app/login.tsx\");\n/* harmony import */ var _components_Navigation_page__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/Navigation/page */ \"(app-pages-browser)/./components/Navigation/page.tsx\");\n/* harmony import */ var slick_carousel_slick_slick_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! slick-carousel/slick/slick.css */ \"(app-pages-browser)/./node_modules/slick-carousel/slick/slick.css\");\n/* harmony import */ var slick_carousel_slick_slick_theme_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! slick-carousel/slick/slick-theme.css */ \"(app-pages-browser)/./node_modules/slick-carousel/slick/slick-theme.css\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _this = undefined;\n\nvar _s = $RefreshSig$();\n // Importa useState\n // Importando a página de login\n\n\n\nvar HomePage = function() {\n    _s();\n    var _useState = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_6__._)((0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"login\"), 2), currentPage = _useState[0], setCurrentPage = _useState[1]; // Estado para controlar a página atual\n    var handleSignUpClick = function() {\n        setCurrentPage(\"navigation\"); // Muda a página atual para Navigation\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-col items-center justify-center h-screen bg-gray-100\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                className: \"text-4xl font-bold mb-8\",\n                children: \"Bem-vindo ao Jogo\"\n            }, void 0, false, {\n                fileName: \"/home/ianov/game3/trump-cards/app/page.tsx\",\n                lineNumber: 19,\n                columnNumber: 7\n            }, _this),\n            currentPage === \"login\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_login__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                onSignUpClick: handleSignUpClick\n            }, void 0, false, {\n                fileName: \"/home/ianov/game3/trump-cards/app/page.tsx\",\n                lineNumber: 21,\n                columnNumber: 35\n            }, _this),\n            \" \",\n            currentPage === \"navigation\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Navigation_page__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {}, void 0, false, {\n                fileName: \"/home/ianov/game3/trump-cards/app/page.tsx\",\n                lineNumber: 22,\n                columnNumber: 40\n            }, _this),\n            \" \"\n        ]\n    }, void 0, true, {\n        fileName: \"/home/ianov/game3/trump-cards/app/page.tsx\",\n        lineNumber: 18,\n        columnNumber: 5\n    }, _this);\n};\n_s(HomePage, \"P9Bnfc9p2IOrtaNFP/H3hNK91Q8=\");\n_c = HomePage;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HomePage);\nvar _c;\n$RefreshReg$(_c, \"HomePage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQ3dDLENBQUMsbUJBQW1CO0FBQ2hDLENBQUMsK0JBQStCO0FBQ0Y7QUFDbEI7QUFDTTtBQUk5QyxJQUFNSSxXQUFxQjs7SUFDekIsSUFBc0NILFlBQUFBLCtEQUFBQSxDQUFBQSwrQ0FBUUEsQ0FBQyxjQUF4Q0ksY0FBK0JKLGNBQWxCSyxpQkFBa0JMLGNBQW1CLHVDQUF1QztJQUVoRyxJQUFNTSxvQkFBb0I7UUFDeEJELGVBQWUsZUFBZSxzQ0FBc0M7SUFDdEU7SUFFQSxxQkFDRSw4REFBQ0U7UUFBSUMsV0FBVTs7MEJBQ2IsOERBQUNDO2dCQUFHRCxXQUFVOzBCQUEwQjs7Ozs7O1lBRXZDSixnQkFBZ0IseUJBQVcsOERBQUNILDhDQUFLQTtnQkFBQ1MsZUFBZUo7Ozs7OztZQUFzQjtZQUN2RUYsZ0JBQWdCLDhCQUFnQiw4REFBQ0YsbUVBQWNBOzs7OztZQUFJOzs7Ozs7O0FBRzFEO0dBZk1DO0tBQUFBO0FBaUJOLGlFQUFlQSxRQUFRQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9wYWdlLnRzeD83NjAzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7IC8vIEltcG9ydGEgdXNlU3RhdGVcbmltcG9ydCBMb2dpbiBmcm9tIFwiLi9sb2dpblwiOyAvLyBJbXBvcnRhbmRvIGEgcMOhZ2luYSBkZSBsb2dpblxuaW1wb3J0IE5hdmlnYXRpb25QYWdlIGZyb20gXCJAL2NvbXBvbmVudHMvTmF2aWdhdGlvbi9wYWdlXCI7XG5pbXBvcnQgXCJzbGljay1jYXJvdXNlbC9zbGljay9zbGljay5jc3NcIjtcbmltcG9ydCBcInNsaWNrLWNhcm91c2VsL3NsaWNrL3NsaWNrLXRoZW1lLmNzc1wiO1xuaW1wb3J0IHsgcmVnaXN0ZXJVc2VyIH0gZnJvbSBcIkAvbGliL3NlcnZpY2VzL2F1dGhTZXJ2aWNlXCI7IC8vIFZlcmlmaXF1ZSBzZSBvIGNhbWluaG8gZXN0w6EgY29ycmV0b1xuXG5cbmNvbnN0IEhvbWVQYWdlOiBSZWFjdC5GQyA9ICgpID0+IHtcbiAgY29uc3QgW2N1cnJlbnRQYWdlLCBzZXRDdXJyZW50UGFnZV0gPSB1c2VTdGF0ZShcImxvZ2luXCIpOyAvLyBFc3RhZG8gcGFyYSBjb250cm9sYXIgYSBww6FnaW5hIGF0dWFsXG5cbiAgY29uc3QgaGFuZGxlU2lnblVwQ2xpY2sgPSAoKSA9PiB7XG4gICAgc2V0Q3VycmVudFBhZ2UoXCJuYXZpZ2F0aW9uXCIpOyAvLyBNdWRhIGEgcMOhZ2luYSBhdHVhbCBwYXJhIE5hdmlnYXRpb25cbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgaC1zY3JlZW4gYmctZ3JheS0xMDBcIj5cbiAgICAgIDxoMSBjbGFzc05hbWU9XCJ0ZXh0LTR4bCBmb250LWJvbGQgbWItOFwiPkJlbS12aW5kbyBhbyBKb2dvPC9oMT5cblxuICAgICAge2N1cnJlbnRQYWdlID09PSBcImxvZ2luXCIgJiYgPExvZ2luIG9uU2lnblVwQ2xpY2s9e2hhbmRsZVNpZ25VcENsaWNrfSAvPn0gey8qIFJlbmRlcml6YSBvIExvZ2luIHNlIGEgcMOhZ2luYSBhdHVhbCBmb3IgbG9naW4gKi99XG4gICAgICB7Y3VycmVudFBhZ2UgPT09IFwibmF2aWdhdGlvblwiICYmIDxOYXZpZ2F0aW9uUGFnZSAvPn0gey8qIFJlbmRlcml6YSBhIE5hdmlnYXRpb25QYWdlIHNlIGEgcMOhZ2luYSBhdHVhbCBmb3IgbmF2aWdhdGlvbiAqL31cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEhvbWVQYWdlO1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJMb2dpbiIsIk5hdmlnYXRpb25QYWdlIiwiSG9tZVBhZ2UiLCJjdXJyZW50UGFnZSIsInNldEN1cnJlbnRQYWdlIiwiaGFuZGxlU2lnblVwQ2xpY2siLCJkaXYiLCJjbGFzc05hbWUiLCJoMSIsIm9uU2lnblVwQ2xpY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/LoginPage/page.tsx":
/*!***************************************!*\
  !*** ./components/LoginPage/page.tsx ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_object_spread.js\");\n/* harmony import */ var _swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_object_spread_props.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/image */ \"(app-pages-browser)/./node_modules/next/dist/api/image.js\");\n/* harmony import */ var _components_SignUpButton_page__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/SignUpButton/page */ \"(app-pages-browser)/./components/SignUpButton/page.tsx\");\n/* harmony import */ var lottie_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lottie-react */ \"(app-pages-browser)/./node_modules/lottie-react/build/index.umd.js\");\n/* harmony import */ var lottie_react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lottie_react__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var react_slick__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-slick */ \"(app-pages-browser)/./node_modules/react-slick/lib/index.js\");\n/* harmony import */ var _public_brasao_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/public/brasao.json */ \"(app-pages-browser)/./public/brasao.json\");\n// app/components/LoginPage/page.tsx\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\nvar _this = undefined;\n\nvar _s = $RefreshSig$();\n\n\n\n\n // Importando o Slider\n // Importando o JSON da animação\nvar LoginPage = function(param) {\n    var onSignUpClick = param.onSignUpClick;\n    _s();\n    // Referência para o áudio\n    var audioRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Configurações do carrossel\n    var settings = {\n        dots: false,\n        infinite: true,\n        speed: 500,\n        slidesToShow: 5,\n        slidesToScroll: 1,\n        autoplay: true,\n        autoplaySpeed: 2000,\n        centerMode: true,\n        centerPadding: '0px',\n        responsive: [\n            {\n                breakpoint: 1024,\n                settings: {\n                    slidesToShow: 4\n                }\n            },\n            {\n                breakpoint: 768,\n                settings: {\n                    slidesToShow: 3\n                }\n            },\n            {\n                breakpoint: 480,\n                settings: {\n                    slidesToShow: 2\n                }\n            }\n        ]\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        // Tocar o áudio ao carregar a página\n        audioRef.current = new Audio(\"/som-de-torcida-de-futebol.mp3\");\n        audioRef.current.loop = true; // Loop contínuo\n        audioRef.current.play()[\"catch\"](function(error) {\n            console.log(\"Erro ao reproduzir áudio:\", error);\n        });\n        // Parar o áudio ao sair da página\n        return function() {\n            if (audioRef.current) {\n                audioRef.current.pause();\n                audioRef.current = null;\n            }\n        };\n    }, []);\n    // Função para parar o áudio ao clicar no botão\n    var handleSignUpClick = function() {\n        if (audioRef.current) {\n            audioRef.current.pause(); // Para a reprodução do áudio\n            audioRef.current.currentTime = 0; // Reseta o tempo para o início\n        }\n        onSignUpClick(); // Chama a função recebida por props\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"relative flex flex-col items-center justify-center w-screen h-screen\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"video\", {\n                autoPlay: true,\n                muted: true,\n                loop: true,\n                playsInline: true,\n                className: \"absolute top-0 left-0 w-full h-full object-cover\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"source\", {\n                        src: \"/videoinicio.mp4\",\n                        type: \"video/mp4\"\n                    }, void 0, false, {\n                        fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n                        lineNumber: 88,\n                        columnNumber: 9\n                    }, _this),\n                    \"Seu navegador n\\xe3o suporta o v\\xeddeo.\"\n                ]\n            }, void 0, true, {\n                fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n                lineNumber: 81,\n                columnNumber: 7\n            }, _this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute inset-0 bg-black opacity-70 z-10\"\n            }, void 0, false, {\n                fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n                lineNumber: 93,\n                columnNumber: 7\n            }, _this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute top-5 left-1/2 transform -translate-x-1/2 z-20 w-1/4 md:w-1/6\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((lottie_react__WEBPACK_IMPORTED_MODULE_4___default()), {\n                    animationData: _public_brasao_json__WEBPACK_IMPORTED_MODULE_6__,\n                    loop: true,\n                    autoplay: true,\n                    style: {\n                        width: '100%',\n                        height: 'auto'\n                    }\n                }, void 0, false, {\n                    fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n                    lineNumber: 97,\n                    columnNumber: 9\n                }, _this)\n            }, void 0, false, {\n                fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n                lineNumber: 96,\n                columnNumber: 7\n            }, _this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"relative z-10 bg-opacity-90 bg-gray-900 p-6 rounded-lg w-5/6 sm:w-3/4 md:w-1/2 lg:w-1/3 mx-4\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                        className: \"text-lg md:text-xl font-bold text-white mb-4 text-center\",\n                        children: \"Step into the exciting world of NFT card battles! Join us for a chance to earn tokens while challenging your friends. Come have fun and earn rewards!\"\n                    }, void 0, false, {\n                        fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n                        lineNumber: 102,\n                        columnNumber: 9\n                    }, _this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_SignUpButton_page__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                        text: \"PLAY NOW\",\n                        redirectTo: \"/game\",\n                        onSignUpClick: handleSignUpClick\n                    }, void 0, false, {\n                        fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n                        lineNumber: 106,\n                        columnNumber: 9\n                    }, _this)\n                ]\n            }, void 0, true, {\n                fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n                lineNumber: 101,\n                columnNumber: 7\n            }, _this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute left-5 top-20 z-20 w-1/2 md:w-1/3 lg:w-1/4\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                    src: \"/kicking2.svg\",\n                    alt: \"Kicking\",\n                    layout: \"responsive\",\n                    width: 350,\n                    height: 350\n                }, void 0, false, {\n                    fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n                    lineNumber: 111,\n                    columnNumber: 9\n                }, _this)\n            }, void 0, false, {\n                fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n                lineNumber: 110,\n                columnNumber: 7\n            }, _this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute bottom-10 z-20 w-full px-4\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_slick__WEBPACK_IMPORTED_MODULE_5__[\"default\"], (0,_swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_7__._)((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_8__._)({}, settings), {\n                    className: \"flex justify-center\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex justify-center mx-1\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                src: \"/abalonga.png\",\n                                alt: \"Abalonga\",\n                                layout: \"intrinsic\",\n                                width: 80,\n                                height: 80,\n                                className: \"h-auto\"\n                            }, void 0, false, {\n                                fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n                                lineNumber: 118,\n                                columnNumber: 13\n                            }, _this)\n                        }, void 0, false, {\n                            fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n                            lineNumber: 117,\n                            columnNumber: 11\n                        }, _this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex justify-center mx-1\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                src: \"/jiparana.png\",\n                                alt: \"Jiparana\",\n                                layout: \"intrinsic\",\n                                width: 80,\n                                height: 80,\n                                className: \"h-auto\"\n                            }, void 0, false, {\n                                fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n                                lineNumber: 121,\n                                columnNumber: 13\n                            }, _this)\n                        }, void 0, false, {\n                            fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n                            lineNumber: 120,\n                            columnNumber: 11\n                        }, _this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex justify-center mx-1\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                src: \"/Logo_Vidal.png\",\n                                alt: \"Logo Vidal\",\n                                layout: \"intrinsic\",\n                                width: 80,\n                                height: 80,\n                                className: \"h-auto\"\n                            }, void 0, false, {\n                                fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n                                lineNumber: 124,\n                                columnNumber: 13\n                            }, _this)\n                        }, void 0, false, {\n                            fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n                            lineNumber: 123,\n                            columnNumber: 11\n                        }, _this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex justify-center mx-1\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                src: \"/Logo_ELITE.png\",\n                                alt: \"Logo Elite\",\n                                layout: \"intrinsic\",\n                                width: 80,\n                                height: 80,\n                                className: \"h-auto\"\n                            }, void 0, false, {\n                                fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n                                lineNumber: 127,\n                                columnNumber: 13\n                            }, _this)\n                        }, void 0, false, {\n                            fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n                            lineNumber: 126,\n                            columnNumber: 11\n                        }, _this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex justify-center mx-1\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                src: \"/rondoniense.png\",\n                                alt: \"Rondoniense\",\n                                layout: \"intrinsic\",\n                                width: 80,\n                                height: 80,\n                                className: \"h-auto\"\n                            }, void 0, false, {\n                                fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n                                lineNumber: 130,\n                                columnNumber: 13\n                            }, _this)\n                        }, void 0, false, {\n                            fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n                            lineNumber: 129,\n                            columnNumber: 11\n                        }, _this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex justify-center mx-1\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                src: \"/uniao.png\",\n                                alt: \"Uniao\",\n                                layout: \"intrinsic\",\n                                width: 80,\n                                height: 80,\n                                className: \"h-auto\"\n                            }, void 0, false, {\n                                fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n                                lineNumber: 133,\n                                columnNumber: 13\n                            }, _this)\n                        }, void 0, false, {\n                            fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n                            lineNumber: 132,\n                            columnNumber: 11\n                        }, _this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex justify-center mx-1\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                src: \"/genus.png\",\n                                alt: \"Genus\",\n                                layout: \"intrinsic\",\n                                width: 80,\n                                height: 80,\n                                className: \"h-auto\"\n                            }, void 0, false, {\n                                fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n                                lineNumber: 136,\n                                columnNumber: 13\n                            }, _this)\n                        }, void 0, false, {\n                            fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n                            lineNumber: 135,\n                            columnNumber: 11\n                        }, _this)\n                    ]\n                }), void 0, true, {\n                    fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n                    lineNumber: 116,\n                    columnNumber: 9\n                }, _this)\n            }, void 0, false, {\n                fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n                lineNumber: 115,\n                columnNumber: 7\n            }, _this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/ianov/game3/trump-cards/components/LoginPage/page.tsx\",\n        lineNumber: 79,\n        columnNumber: 5\n    }, _this);\n};\n_s(LoginPage, \"+byXHHf22FzALubYzgUeSQRtz1Y=\");\n_c = LoginPage;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LoginPage);\nvar _c;\n$RefreshReg$(_c, \"LoginPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvTG9naW5QYWdlL3BhZ2UudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG9DQUFvQzs7Ozs7O0FBR2E7QUFDbEI7QUFDMkI7QUFDeEI7QUFDRCxDQUFDLHNCQUFzQjtBQUNMLENBQUMsZ0NBQWdDO0FBTXBGLElBQU1RLFlBQXNDO1FBQUdDLHNCQUFBQTs7SUFDN0MsMEJBQTBCO0lBQzFCLElBQU1DLFdBQVdSLDZDQUFNQSxDQUEwQjtJQUVqRCw2QkFBNkI7SUFDN0IsSUFBTVMsV0FBVztRQUNmQyxNQUFNO1FBQ05DLFVBQVU7UUFDVkMsT0FBTztRQUNQQyxjQUFjO1FBQ2RDLGdCQUFnQjtRQUNoQkMsVUFBVTtRQUNWQyxlQUFlO1FBQ2ZDLFlBQVk7UUFDWkMsZUFBZTtRQUNmQyxZQUFZO1lBQ1Y7Z0JBQ0VDLFlBQVk7Z0JBQ1pYLFVBQVU7b0JBQ1JJLGNBQWM7Z0JBQ2hCO1lBQ0Y7WUFDQTtnQkFDRU8sWUFBWTtnQkFDWlgsVUFBVTtvQkFDUkksY0FBYztnQkFDaEI7WUFDRjtZQUNBO2dCQUNFTyxZQUFZO2dCQUNaWCxVQUFVO29CQUNSSSxjQUFjO2dCQUNoQjtZQUNGO1NBQ0Q7SUFDSDtJQUVBZCxnREFBU0EsQ0FBQztRQUNSLHFDQUFxQztRQUNyQ1MsU0FBU2EsT0FBTyxHQUFHLElBQUlDLE1BQU07UUFDN0JkLFNBQVNhLE9BQU8sQ0FBQ0UsSUFBSSxHQUFHLE1BQU0sZ0JBQWdCO1FBQzlDZixTQUFTYSxPQUFPLENBQUNHLElBQUksRUFBR0MsQ0FBQUEsUUFBSyxDQUFDLFNBQUNDO1lBQzdCQyxRQUFRQyxHQUFHLENBQUMsNkJBQTZCRjtRQUMzQztRQUVBLGtDQUFrQztRQUNsQyxPQUFPO1lBQ0wsSUFBSWxCLFNBQVNhLE9BQU8sRUFBRTtnQkFDcEJiLFNBQVNhLE9BQU8sQ0FBQ1EsS0FBSztnQkFDdEJyQixTQUFTYSxPQUFPLEdBQUc7WUFDckI7UUFDRjtJQUNGLEdBQUcsRUFBRTtJ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TXBHO0dBL0hNM0I7S0FBQUE7QUFpSU4saUVBQWVBLFNBQVNBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9Mb2dpblBhZ2UvcGFnZS50c3g/N2Q3NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBhcHAvY29tcG9uZW50cy9Mb2dpblBhZ2UvcGFnZS50c3hcblwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBJbWFnZSBmcm9tIFwibmV4dC9pbWFnZVwiO1xuaW1wb3J0IFNpZ25VcEJ1dHRvbiBmcm9tIFwiQC9jb21wb25lbnRzL1NpZ25VcEJ1dHRvbi9wYWdlXCI7XG5pbXBvcnQgTG90dGllIGZyb20gXCJsb3R0aWUtcmVhY3RcIjtcbmltcG9ydCBTbGlkZXIgZnJvbSBcInJlYWN0LXNsaWNrXCI7IC8vIEltcG9ydGFuZG8gbyBTbGlkZXJcbmltcG9ydCBicmFzYW9BbmltYXRpb24gZnJvbSAnQC9wdWJsaWMvYnJhc2FvLmpzb24nOyAvLyBJbXBvcnRhbmRvIG8gSlNPTiBkYSBhbmltYcOnw6NvXG5cbmludGVyZmFjZSBMb2dpblBhZ2VQcm9wcyB7XG4gIG9uU2lnblVwQ2xpY2s6ICgpID0+IHZvaWQ7IC8vIERlZmluZSBhIHByb3AgcGFyYSByZWNlYmVyIGEgZnVuw6fDo29cbn1cblxuY29uc3QgTG9naW5QYWdlOiBSZWFjdC5GQzxMb2dpblBhZ2VQcm9wcz4gPSAoeyBvblNpZ25VcENsaWNrIH0pID0+IHtcbiAgLy8gUmVmZXLDqm5jaWEgcGFyYSBvIMOhdWRpb1xuICBjb25zdCBhdWRpb1JlZiA9IHVzZVJlZjxIVE1MQXVkaW9FbGVtZW50IHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gQ29uZmlndXJhw6fDtWVzIGRvIGNhcnJvc3NlbFxuICBjb25zdCBzZXR0aW5ncyA9IHtcbiAgICBkb3RzOiBmYWxzZSxcbiAgICBpbmZpbml0ZTogdHJ1ZSxcbiAgICBzcGVlZDogNTAwLFxuICAgIHNsaWRlc1RvU2hvdzogNSwgLy8gTW9zdHJhIDUgaW1hZ2VucyBhbyBtZXNtbyB0ZW1wb1xuICAgIHNsaWRlc1RvU2Nyb2xsOiAxLFxuICAgIGF1dG9wbGF5OiB0cnVlLFxuICAgIGF1dG9wbGF5U3BlZWQ6IDIwMDAsXG4gICAgY2VudGVyTW9kZTogdHJ1ZSwgLy8gQWRpY2lvbmEgbyBtb2RvIGNlbnRyYWxcbiAgICBjZW50ZXJQYWRkaW5nOiAnMHB4JywgLy8gUmVtb3ZlIG8gcHJlZW5jaGltZW50byBuYXMgYm9yZGFzXG4gICAgcmVzcG9uc2l2ZTogW1xuICAgICAge1xuICAgICAgICBicmVha3BvaW50OiAxMDI0LFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIHNsaWRlc1RvU2hvdzogNCwgLy8gUGFyYSB0ZWxhcyBncmFuZGVzLCBtb3N0cmEgNCBpbWFnZW5zXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBicmVha3BvaW50OiA3NjgsXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgc2xpZGVzVG9TaG93OiAzLCAvLyBQYXJhIHRlbGFzIG3DqWRpYXMsIG1vc3RyYSAzIGltYWdlbnNcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJyZWFrcG9pbnQ6IDQ4MCxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBzbGlkZXNUb1Nob3c6IDIsIC8vIFBhcmEgdGVsYXMgcGVxdWVuYXMsIG1vc3RyYSAyIGltYWdlbnNcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgXSxcbiAgfTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFRvY2FyIG8gw6F1ZGlvIGFvIGNhcnJlZ2FyIGEgcMOhZ2luYVxuICAgIGF1ZGlvUmVmLmN1cnJlbnQgPSBuZXcgQXVkaW8oXCIvc29tLWRlLXRvcmNpZGEtZGUtZnV0ZWJvbC5tcDNcIik7XG4gICAgYXVkaW9SZWYuY3VycmVudC5sb29wID0gdHJ1ZTsgLy8gTG9vcCBjb250w61udW9cbiAgICBhdWRpb1JlZi5jdXJyZW50LnBsYXkoKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRXJybyBhbyByZXByb2R1emlyIMOhdWRpbzpcIiwgZXJyb3IpO1xuICAgIH0pO1xuXG4gICAgLy8gUGFyYXIgbyDDoXVkaW8gYW8gc2FpciBkYSBww6FnaW5hXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChhdWRpb1JlZi5jdXJyZW50KSB7XG4gICAgICAgIGF1ZGlvUmVmLmN1cnJlbnQucGF1c2UoKTtcbiAgICAgICAgYXVkaW9SZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIC8vIEZ1bsOnw6NvIHBhcmEgcGFyYXIgbyDDoXVkaW8gYW8gY2xpY2FyIG5vIGJvdMOjb1xuICBjb25zdCBoYW5kbGVTaWduVXBDbGljayA9ICgpID0+IHtcbiAgICBpZiAoYXVkaW9SZWYuY3VycmVudCkge1xuICAgICAgYXVkaW9SZWYuY3VycmVudC5wYXVzZSgpOyAvLyBQYXJhIGEgcmVwcm9kdcOnw6NvIGRvIMOhdWRpb1xuICAgICAgYXVkaW9SZWYuY3VycmVudC5jdXJyZW50VGltZSA9IDA7IC8vIFJlc2V0YSBvIHRlbXBvIHBhcmEgbyBpbsOtY2lvXG4gICAgfVxuICAgIG9uU2lnblVwQ2xpY2soKTsgLy8gQ2hhbWEgYSBmdW7Dp8OjbyByZWNlYmlkYSBwb3IgcHJvcHNcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwicmVsYXRpdmUgZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgdy1zY3JlZW4gaC1zY3JlZW5cIj5cbiAgICAgIHsvKiBWaWRlbyBkZSBmdW5kbyAqL31cbiAgICAgIDx2aWRlb1xuICAgICAgICBhdXRvUGxheVxuICAgICAgICBtdXRlZFxuICAgICAgICBsb29wXG4gICAgICAgIHBsYXlzSW5saW5lXG4gICAgICAgIGNsYXNzTmFtZT1cImFic29sdXRlIHRvcC0wIGxlZnQtMCB3LWZ1bGwgaC1mdWxsIG9iamVjdC1jb3ZlclwiXG4gICAgICA+XG4gICAgICAgIDxzb3VyY2Ugc3JjPVwiL3ZpZGVvaW5pY2lvLm1wNFwiIHR5cGU9XCJ2aWRlby9tcDRcIiAvPlxuICAgICAgICBTZXUgbmF2ZWdhZG9yIG7Do28gc3Vwb3J0YSBvIHbDrWRlby5cbiAgICAgIDwvdmlkZW8+XG5cbiAgICAgIHsvKiBDYW1hZGEgZGUgc29icmVwb3Npw6fDo28gZXNjdXJhIHBhcmEgZXNjdXJlY2VyIHRvZG8gbyB2w61kZW8gKi99XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIGluc2V0LTAgYmctYmxhY2sgb3BhY2l0eS03MCB6LTEwXCI+PC9kaXY+XG5cbiAgICAgIHsvKiBBbmltYcOnw6NvIGRvIGJyYXPDo28gY2VudHJhbGl6YWRhIG5hIHBhcnRlIHN1cGVyaW9yICovfVxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJhYnNvbHV0ZSB0b3AtNSBsZWZ0LTEvMiB0cmFuc2Zvcm0gLXRyYW5zbGF0ZS14LTEvMiB6LTIwIHctMS80IG1kOnctMS82XCI+XG4gICAgICAgIDxMb3R0aWUgYW5pbWF0aW9uRGF0YT17YnJhc2FvQW5pbWF0aW9ufSBsb29wPXt0cnVlfSBhdXRvcGxheT17dHJ1ZX0gc3R5bGU9e3sgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnYXV0bycgfX0gLz5cbiAgICAgIDwvZGl2PlxuXG4gICAgICB7LyogQ2FpeGEgZGUgdGV4dG8gYWdvcmEgYXRyw6FzIGRhIGFuaW1hw6fDo28gKi99XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInJlbGF0aXZlIHotMTAgYmctb3BhY2l0eS05MCBiZy1ncmF5LTkwMCBwLTYgcm91bmRlZC1sZyB3LTUvNiBzbTp3LTMvNCBtZDp3LTEvMiBsZzp3LTEvMyBteC00XCI+XG4gICAgICAgIDxoMSBjbGFzc05hbWU9XCJ0ZXh0LWxnIG1kOnRleHQteGwgZm9udC1ib2xkIHRleHQtd2hpdGUgbWItNCB0ZXh0LWNlbnRlclwiPlxuICAgICAgICAgIFN0ZXAgaW50byB0aGUgZXhjaXRpbmcgd29ybGQgb2YgTkZUIGNhcmQgYmF0dGxlcyEgSm9pbiB1cyBmb3IgYSBjaGFuY2UgdG8gZWFybiB0b2tlbnMgd2hpbGUgY2hhbGxlbmdpbmcgeW91ciBmcmllbmRzLiBDb21lIGhhdmUgZnVuIGFuZCBlYXJuIHJld2FyZHMhXG4gICAgICAgIDwvaDE+XG4gICAgICAgIHsvKiBQYXNzYSBhIGZ1bsOnw6NvIGhhbmRsZVNpZ25VcENsaWNrIHBhcmEgbyBib3TDo28gZGUgaW5zY3Jpw6fDo28gKi99XG4gICAgICAgIDxTaWduVXBCdXR0b24gdGV4dD1cIlBMQVkgTk9XXCIgcmVkaXJlY3RUbz1cIi9nYW1lXCIgb25TaWduVXBDbGljaz17aGFuZGxlU2lnblVwQ2xpY2t9IC8+XG4gICAgICA8L2Rpdj5cblxuICAgICAgey8qIEltYWdlbSBuYSBwYXJ0ZSBpbmZlcmlvciAqL31cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgbGVmdC01IHRvcC0yMCB6LTIwIHctMS8yIG1kOnctMS8zIGxnOnctMS80XCI+XG4gICAgICAgIDxJbWFnZSBzcmM9XCIva2lja2luZzIuc3ZnXCIgYWx0PVwiS2lja2luZ1wiIGxheW91dD1cInJlc3BvbnNpdmVcIiB3aWR0aD17MzUwfSBoZWlnaHQ9ezM1MH0gLz5cbiAgICAgIDwvZGl2PlxuXG4gICAgICB7LyogQ2Fycm9zc2VsIGRlIGltYWdlbnMgbmEgcGFydGUgaW5mZXJpb3IgKi99XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIGJvdHRvbS0xMCB6LTIwIHctZnVsbCBweC00XCI+XG4gICAgICAgIDxTbGlkZXIgey4uLnNldHRpbmdzfSBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktY2VudGVyXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktY2VudGVyIG14LTFcIj5cbiAgICAgICAgICAgIDxJbWFnZSBzcmM9XCIvYWJhbG9uZ2EucG5nXCIgYWx0PVwiQWJhbG9uZ2FcIiBsYXlvdXQ9XCJpbnRyaW5zaWNcIiB3aWR0aD17ODB9IGhlaWdodD17ODB9IGNsYXNzTmFtZT1cImgtYXV0b1wiIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktY2VudGVyIG14LTFcIj5cbiAgICAgICAgICAgIDxJbWFnZSBzcmM9XCIvamlwYXJhbmEucG5nXCIgYWx0PVwiSmlwYXJhbmFcIiBsYXlvdXQ9XCJpbnRyaW5zaWNcIiB3aWR0aD17ODB9IGhlaWdodD17ODB9IGNsYXNzTmFtZT1cImgtYXV0b1wiIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktY2VudGVyIG14LTFcIj5cbiAgICAgICAgICAgIDxJbWFnZSBzcmM9XCIvTG9nb19WaWRhbC5wbmdcIiBhbHQ9XCJMb2dvIFZpZGFsXCIgbGF5b3V0PVwiaW50cmluc2ljXCIgd2lkdGg9ezgwfSBoZWlnaHQ9ezgwfSBjbGFzc05hbWU9XCJoLWF1dG9cIiAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWNlbnRlciBteC0xXCI+XG4gICAgICAgICAgICA8SW1hZ2Ugc3JjPVwiL0xvZ29fRUxJVEUucG5nXCIgYWx0PVwiTG9nbyBFbGl0ZVwiIGxheW91dD1cImludHJpbnNpY1wiIHdpZHRoPXs4MH0gaGVpZ2h0PXs4MH0gY2xhc3NOYW1lPVwiaC1hdXRvXCIgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1jZW50ZXIgbXgtMVwiPlxuICAgICAgICAgICAgPEltYWdlIHNyYz1cIi9yb25kb25pZW5zZS5wbmdcIiBhbHQ9XCJSb25kb25pZW5zZVwiIGxheW91dD1cImludHJpbnNpY1wiIHdpZHRoPXs4MH0gaGVpZ2h0PXs4MH0gY2xhc3NOYW1lPVwiaC1hdXRvXCIgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1jZW50ZXIgbXgtMVwiPlxuICAgICAgICAgICAgPEltYWdlIHNyYz1cIi91bmlhby5wbmdcIiBhbHQ9XCJVbmlhb1wiIGxheW91dD1cImludHJpbnNpY1wiIHdpZHRoPXs4MH0gaGVpZ2h0PXs4MH0gY2xhc3NOYW1lPVwiaC1hdXRvXCIgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1jZW50ZXIgbXgtMVwiPlxuICAgICAgICAgICAgPEltYWdlIHNyYz1cIi9nZW51cy5wbmdcIiBhbHQ9XCJHZW51c1wiIGxheW91dD1cImludHJpbnNpY1wiIHdpZHRoPXs4MH0gaGVpZ2h0PXs4MH0gY2xhc3NOYW1lPVwiaC1hdXRvXCIgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9TbGlkZXI+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IExvZ2luUGFnZTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZVJlZiIsIkltYWdlIiwiU2lnblVwQnV0dG9uIiwiTG90dGllIiwiU2xpZGVyIiwiYnJhc2FvQW5pbWF0aW9uIiwiTG9naW5QYWdlIiwib25TaWduVXBDbGljayIsImF1ZGlvUmVmIiwic2V0dGluZ3MiLCJkb3RzIiwiaW5maW5pdGUiLCJzcGVlZCIsInNsaWRlc1RvU2hvdyIsInNsaWRlc1RvU2Nyb2xsIiwiYXV0b3BsYXkiLCJhdXRvcGxheVNwZWVkIiwiY2VudGVyTW9kZSIsImNlbnRlclBhZGRpbmciLCJyZXNwb25zaXZlIiwiYnJlYWtwb2ludCIsImN1cnJlbnQiLCJBdWRpbyIsImxvb3AiLCJwbGF5IiwiY2F0Y2giLCJlcnJvciIsImNvbnNvbGUiLCJsb2ciLCJwYXVzZSIsImhhbmRsZVNpZ25VcENsaWNrIiwiY3VycmVudFRpbWUiLCJkaXYiLCJjbGFzc05hbWUiLCJ2aWRlbyIsImF1dG9QbGF5IiwibXV0ZWQiLCJwbGF5c0lubGluZSIsInNvdXJjZSIsInNyYyIsInR5cGUiLCJhbmltYXRpb25EYXRhIiwic3R5bGUiLCJ3aWR0aCIsImhlaWdodCIsImgxIiwidGV4dCIsInJlZGlyZWN0VG8iLCJhbHQiLCJsYXlvdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/LoginPage/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/Navigation/page.tsx":
/*!****************************************!*\
  !*** ./components/Navigation/page.tsx ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_object_spread.js\");\n/* harmony import */ var _swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_object_spread_props.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/image */ \"(app-pages-browser)/./node_modules/next/dist/api/image.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\nvar _this = undefined;\n\nvar _s = $RefreshSig$();\n\n\n // Importa o useRouter\n// Array de dados dos botões\nvar authButtons = [\n    {\n        title: 'CONNECT YOUR',\n        subtitle: 'WALLET',\n        iconSrc: '/icon1p2.png',\n        onClick: function() {}\n    },\n    {\n        title: 'LOGIN TO YOUR',\n        subtitle: 'ACCOUNT',\n        iconSrc: '/icon2p2.png',\n        onClick: function() {}\n    },\n    {\n        title: 'REGISTER NOW',\n        iconSrc: '/icon3p2.png',\n        onClick: function() {}\n    }\n];\n// Componente principal\nvar NavigationPage = function() {\n    _s();\n    var router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_3__.useRouter)(); // Hook de navegação\n    // Funções para navegação\n    var handleConnectWallet = function() {\n        // Navega para a página de conexão da wallet\n        router.push('/game/metamask'); // Ajuste a rota conforme necessário\n    };\n    var handleRegister = function() {\n        // Navega para a página de registro\n        router.push('/game/register'); // Ajuste a rota conforme necessário\n    };\n    // Atualizando o array de botões com as funções de clique\n    var updatedAuthButtons = authButtons.map(function(button) {\n        switch(button.title){\n            case 'CONNECT YOUR':\n                return (0,_swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_4__._)((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_5__._)({}, button), {\n                    onClick: handleConnectWallet\n                });\n            case 'REGISTER NOW':\n                return (0,_swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_4__._)((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_5__._)({}, button), {\n                    onClick: handleRegister\n                });\n            default:\n                return button;\n        }\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n        className: \"relative flex flex-col w-full min-h-screen\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"video\", {\n                autoPlay: true,\n                loop: true,\n                muted: true,\n                className: \"absolute inset-0 object-cover w-full h-full z-0\" // Ajuste de z-index\n                ,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"source\", {\n                        src: \"/estadiodia.mp4\",\n                        type: \"video/mp4\"\n                    }, void 0, false, {\n                        fileName: \"/home/ianov/game3/trump-cards/components/Navigation/page.tsx\",\n                        lineNumber: 71,\n                        columnNumber: 9\n                    }, _this),\n                    \"Seu navegador n\\xe3o suporta v\\xeddeos.\"\n                ]\n            }, void 0, true, {\n                fileName: \"/home/ianov/game3/trump-cards/components/Navigation/page.tsx\",\n                lineNumber: 65,\n                columnNumber: 7\n            }, _this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                className: \"flex relative flex-col self-center mt-8 mb-0 ml-8 max-w-full w-[325px] max-md:mb-2.5\",\n                children: updatedAuthButtons.map(function(button, index) {\n                    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: index > 0 ? 'mt-6' : '',\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthButton, (0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_5__._)({}, button), void 0, false, {\n                            fileName: \"/home/ianov/game3/trump-cards/components/Navigation/page.tsx\",\n                            lineNumber: 79,\n                            columnNumber: 13\n                        }, _this)\n                    }, index, false, {\n                        fileName: \"/home/ianov/game3/trump-cards/components/Navigation/page.tsx\",\n                        lineNumber: 78,\n                        columnNumber: 11\n                    }, _this);\n                })\n            }, void 0, false, {\n                fileName: \"/home/ianov/game3/trump-cards/components/Navigation/page.tsx\",\n                lineNumber: 76,\n                columnNumber: 7\n            }, _this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/ianov/game3/trump-cards/components/Navigation/page.tsx\",\n        lineNumber: 63,\n        columnNumber: 5\n    }, _this);\n};\n_s(NavigationPage, \"fN7XvhJ+p5oE6+Xlo0NJmXpxjC8=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_3__.useRouter\n    ];\n});\n_c = NavigationPage;\nvar AuthButton = function(param) {\n    var title = param.title, subtitle = param.subtitle, iconSrc = param.iconSrc, onClick = param.onClick;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-col justify-center py-0.5 w-full bg-cyan-900 rounded-[43px]\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n            onClick: onClick,\n            className: \"flex z-10 gap-5 justify-between py-3.5 pr-4 pl-14 -mt-1 border-white border-solid bg-slate-900 border-[3px] rounded-[43px] max-md:pl-5\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex flex-col my-auto text-xl font-bold text-white\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            children: title\n                        }, void 0, false, {\n                            fileName: \"/home/ianov/game3/trump-cards/components/Navigation/page.tsx\",\n                            lineNumber: 103,\n                            columnNumber: 11\n                        }, _this),\n                        subtitle && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            className: \"self-center\",\n                            children: subtitle\n                        }, void 0, false, {\n                            fileName: \"/home/ianov/game3/trump-cards/components/Navigation/page.tsx\",\n                            lineNumber: 104,\n                            columnNumber: 24\n                        }, _this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/ianov/game3/trump-cards/components/Navigation/page.tsx\",\n                    lineNumber: 102,\n                    columnNumber: 9\n                }, _this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex flex-col justify-center items-center px-1.5 w-16 h-16 bg-white rounded-full\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                        loading: \"lazy\",\n                        src: iconSrc,\n                        alt: \"\",\n                        width: 52,\n                        height: 52,\n                        className: \"object-contain aspect-square\"\n                    }, void 0, false, {\n                        fileName: \"/home/ianov/game3/trump-cards/components/Navigation/page.tsx\",\n                        lineNumber: 107,\n                        columnNumber: 11\n                    }, _this)\n                }, void 0, false, {\n                    fileName: \"/home/ianov/game3/trump-cards/components/Navigation/page.tsx\",\n                    lineNumber: 106,\n                    columnNumber: 9\n                }, _this)\n            ]\n        }, void 0, true, {\n            fileName: \"/home/ianov/game3/trump-cards/components/Navigation/page.tsx\",\n            lineNumber: 98,\n            columnNumber: 7\n        }, _this)\n    }, void 0, false, {\n        fileName: \"/home/ianov/game3/trump-cards/components/Navigation/page.tsx\",\n        lineNumber: 97,\n        columnNumber: 5\n    }, _this);\n};\n_c1 = AuthButton;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NavigationPage);\nvar _c, _c1;\n$RefreshReg$(_c, \"NavigationPage\");\n$RefreshReg$(_c1, \"AuthButton\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvTmF2aWdhdGlvbi9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQzBCO0FBQ0s7QUFDYSxDQUFDLHNCQUFzQjtBQVVuRSw0QkFBNEI7QUFDNUIsSUFBTUcsY0FBZ0M7SUFDcEM7UUFDRUMsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFNBQVM7UUFDVEMsU0FBUyxZQUFPO0lBQ2xCO0lBQ0E7UUFDRUgsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFNBQVM7UUFDVEMsU0FBUyxZQUFPO0lBQ2xCO0lBQ0E7UUFDRUgsT0FBTztRQUNQRSxTQUFTO1FBQ1RDLFNBQVMsWUFBTztJQUNsQjtDQUNEO0FBRUQsdUJBQXVCO0FBQ3ZCLElBQU1DLGlCQUEyQjs7SUFDL0IsSUFBTUMsU0FBU1AsMERBQVNBLElBQUksb0JBQW9CO0lBRWhELHlCQUF5QjtJQUN6QixJQUFNUSxzQkFBc0I7UUFDMUIsNENBQTRDO1FBQzVDRCxPQUFPRSxJQUFJLENBQUMsbUJBQW1CLG9DQUFvQztJQUNyRTtJQUVBLElBQU1DLGlCQUFpQjtRQUNyQixtQ0FBbUM7UUFDbkNILE9BQU9FLElBQUksQ0FBQyxtQkFBbUIsb0NBQW9DO0lBQ3JFO0lBRUEseURBQXlEO0lBQ3pELElBQU1FLHFCQUFxQlYsWUFBWVcsR0FBRyxDQUFDQyxTQUFBQTtRQUN6QyxPQUFRQSxPQUFPWCxLQUFLO1lBQ2xCLEtBQUs7Z0JBQ0gsT0FBTyxzSUFBS1c7b0JBQVFSLFNBQVNHOztZQUMvQixLQUFLO2dCQUNILE9BQU8sc0lBQUtLO29CQUFRUixTQUFTSzs7WUFDL0I7Z0JBQ0UsT0FBT0c7UUFDWDtJQUNGO0lBRUEscUJBQ0UsOERBQUNDO1FBQUtDLFdBQVU7OzBCQUVkLDhEQUFDQztnQkFDQ0MsUUFBUTtnQkFDUkMsSUFBSTtnQkFDSkMsS0FBSztnQkFDTEosV0FBVSxrREFBa0Qsb0JBQW9COzs7a0NBRWhGLDhEQUFDSzt3QkFBT0MsS0FBSTt3QkFBa0JDLE1BQUs7Ozs7OztvQkFBYzs7Ozs7OzswQkFLbkQsOERBQUNDO2dCQUFRUixXQUFVOzBCQUNoQkosbUJBQW1CQyxHQUFHLENBQUMsU0FBQ0MsUUFBUVc7eUNBQy9CLDhEQUFDQzt3QkFBZ0JWLFdBQVdTLFFBQVEsSUFBSSxTQUFTO2tDQUMvQyw0RUFBQ0UsWUFBQUEsNkRBQUFBLEtBQWViOzs7Ozt1QkFEUlc7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBT3BCO0dBakRNbEI7O1FBQ1dOLHNEQUFTQTs7O0tBRHBCTTtBQTJETixJQUFNb0IsYUFBd0M7UUFBR3hCLGNBQUFBLE9BQU9DLGlCQUFBQSxVQUFVQyxnQkFBQUEsU0FBU0MsZ0JBQUFBO0lBQ3pFLHFCQUNFLDhEQUFDb0I7UUFBSVYsV0FBVTtrQkFDYiw0RUFBQ0Y7WUFDQ1IsU0FBU0E7WUFDVFUsV0FBVTs7OEJBRVYsOERBQUNVO29CQUFJVixXQUFVOztzQ0FDYiw4REFBQ1k7c0NBQU16Qjs7Ozs7O3dCQUNOQywwQkFBWSw4REFBQ3dCOzRCQUFLWixXQUFVO3NDQUFlWjs7Ozs7Ozs7Ozs7OzhCQUU5Qyw4REFBQ3NCO29CQUFJVixXQUFVOzhCQUNiLDRFQUFDaEIsa0RBQUtBO3dCQUNKNkIsU0FBUTt3QkFDUlAsS0FBS2pCO3dCQUNMeUIsS0FBSTt3QkFDSkMsT0FBTzt3QkFDUEMsUUFBUTt3QkFDUmhCLFdBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNdEI7TUF4Qk1XO0FBMEJOLGlFQUFlcEIsY0FBY0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL05hdmlnYXRpb24vcGFnZS50c3g/NTQwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgSW1hZ2UgZnJvbSAnbmV4dC9pbWFnZSc7XG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tICduZXh0L25hdmlnYXRpb24nOyAvLyBJbXBvcnRhIG8gdXNlUm91dGVyXG5cbi8vIERlZmluacOnw6NvIGRvIHRpcG8gcGFyYSBvcyBib3TDtWVzIGRlIGF1dGVudGljYcOnw6NvXG5pbnRlcmZhY2UgQXV0aEJ1dHRvbkRhdGEge1xuICB0aXRsZTogc3RyaW5nO1xuICBzdWJ0aXRsZT86IHN0cmluZztcbiAgaWNvblNyYzogc3RyaW5nO1xuICBvbkNsaWNrOiAoKSA9PiB2b2lkOyAvLyBGdW7Dp8OjbyBkZSBjbGlxdWUgcGFyYSBjYWRhIGJvdMOjb1xufVxuXG4vLyBBcnJheSBkZSBkYWRvcyBkb3MgYm90w7Vlc1xuY29uc3QgYXV0aEJ1dHRvbnM6IEF1dGhCdXR0b25EYXRhW10gPSBbXG4gIHtcbiAgICB0aXRsZTogJ0NPTk5FQ1QgWU9VUicsXG4gICAgc3VidGl0bGU6ICdXQUxMRVQnLFxuICAgIGljb25TcmM6ICcvaWNvbjFwMi5wbmcnLFxuICAgIG9uQ2xpY2s6ICgpID0+IHt9LCAvLyBQbGFjZWhvbGRlciwgc2Vyw6Egc3Vic3RpdHXDrWRvXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xPR0lOIFRPIFlPVVInLFxuICAgIHN1YnRpdGxlOiAnQUNDT1VOVCcsXG4gICAgaWNvblNyYzogJy9pY29uMnAyLnBuZycsXG4gICAgb25DbGljazogKCkgPT4ge30sIC8vIFBsYWNlaG9sZGVyXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ1JFR0lTVEVSIE5PVycsXG4gICAgaWNvblNyYzogJy9pY29uM3AyLnBuZycsXG4gICAgb25DbGljazogKCkgPT4ge30sIC8vIFBsYWNlaG9sZGVyXG4gIH0sXG5dO1xuXG4vLyBDb21wb25lbnRlIHByaW5jaXBhbFxuY29uc3QgTmF2aWdhdGlvblBhZ2U6IFJlYWN0LkZDID0gKCkgPT4ge1xuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTsgLy8gSG9vayBkZSBuYXZlZ2HDp8Ojb1xuXG4gIC8vIEZ1bsOnw7VlcyBwYXJhIG5hdmVnYcOnw6NvXG4gIGNvbnN0IGhhbmRsZUNvbm5lY3RXYWxsZXQgPSAoKSA9PiB7XG4gICAgLy8gTmF2ZWdhIHBhcmEgYSBww6FnaW5hIGRlIGNvbmV4w6NvIGRhIHdhbGxldFxuICAgIHJvdXRlci5wdXNoKCcvZ2FtZS9tZXRhbWFzaycpOyAvLyBBanVzdGUgYSByb3RhIGNvbmZvcm1lIG5lY2Vzc8OhcmlvXG4gIH07XG5cbiAgY29uc3QgaGFuZGxlUmVnaXN0ZXIgPSAoKSA9PiB7XG4gICAgLy8gTmF2ZWdhIHBhcmEgYSBww6FnaW5hIGRlIHJlZ2lzdHJvXG4gICAgcm91dGVyLnB1c2goJy9nYW1lL3JlZ2lzdGVyJyk7IC8vIEFqdXN0ZSBhIHJvdGEgY29uZm9ybWUgbmVjZXNzw6FyaW9cbiAgfTtcblxuICAvLyBBdHVhbGl6YW5kbyBvIGFycmF5IGRlIGJvdMO1ZXMgY29tIGFzIGZ1bsOnw7VlcyBkZSBjbGlxdWVcbiAgY29uc3QgdXBkYXRlZEF1dGhCdXR0b25zID0gYXV0aEJ1dHRvbnMubWFwKGJ1dHRvbiA9PiB7XG4gICAgc3dpdGNoIChidXR0b24udGl0bGUpIHtcbiAgICAgIGNhc2UgJ0NPTk5FQ1QgWU9VUic6XG4gICAgICAgIHJldHVybiB7IC4uLmJ1dHRvbiwgb25DbGljazogaGFuZGxlQ29ubmVjdFdhbGxldCB9O1xuICAgICAgY2FzZSAnUkVHSVNURVIgTk9XJzpcbiAgICAgICAgcmV0dXJuIHsgLi4uYnV0dG9uLCBvbkNsaWNrOiBoYW5kbGVSZWdpc3RlciB9O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiAoXG4gICAgPG1haW4gY2xhc3NOYW1lPVwicmVsYXRpdmUgZmxleCBmbGV4LWNvbCB3LWZ1bGwgbWluLWgtc2NyZWVuXCI+XG4gICAgICB7LyogVsOtZGVvIGRlIGZ1bmRvICovfVxuICAgICAgPHZpZGVvXG4gICAgICAgIGF1dG9QbGF5XG4gICAgICAgIGxvb3BcbiAgICAgICAgbXV0ZWRcbiAgICAgICAgY2xhc3NOYW1lPVwiYWJzb2x1dGUgaW5zZXQtMCBvYmplY3QtY292ZXIgdy1mdWxsIGgtZnVsbCB6LTBcIiAvLyBBanVzdGUgZGUgei1pbmRleFxuICAgICAgPlxuICAgICAgICA8c291cmNlIHNyYz1cIi9lc3RhZGlvZGlhLm1wNFwiIHR5cGU9XCJ2aWRlby9tcDRcIiAvPlxuICAgICAgICBTZXUgbmF2ZWdhZG9yIG7Do28gc3Vwb3J0YSB2w61kZW9zLlxuICAgICAgPC92aWRlbz5cblxuICAgICAgey8qIFNlw6fDo28gZGUgYm90w7VlcyBkZSBhdXRlbnRpY2HDp8OjbyAqL31cbiAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT1cImZsZXggcmVsYXRpdmUgZmxleC1jb2wgc2VsZi1jZW50ZXIgbXQtOCBtYi0wIG1sLTggbWF4LXctZnVsbCB3LVszMjVweF0gbWF4LW1kOm1iLTIuNVwiPlxuICAgICAgICB7dXBkYXRlZEF1dGhCdXR0b25zLm1hcCgoYnV0dG9uLCBpbmRleCkgPT4gKFxuICAgICAgICAgIDxkaXYga2V5PXtpbmRleH0gY2xhc3NOYW1lPXtpbmRleCA+IDAgPyAnbXQtNicgOiAnJ30+XG4gICAgICAgICAgICA8QXV0aEJ1dHRvbiB7Li4uYnV0dG9ufSAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApKX1cbiAgICAgIDwvc2VjdGlvbj5cbiAgICA8L21haW4+XG4gICk7XG59O1xuXG4vLyBDb21wb25lbnRlIGRvIGJvdMOjbyBkZSBhdXRlbnRpY2HDp8Ojb1xuaW50ZXJmYWNlIEF1dGhCdXR0b25Qcm9wcyB7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIHN1YnRpdGxlPzogc3RyaW5nO1xuICBpY29uU3JjOiBzdHJpbmc7XG4gIG9uQ2xpY2s6ICgpID0+IHZvaWQ7IC8vIEFkaWNpb25hIG9uQ2xpY2tcbn1cblxuY29uc3QgQXV0aEJ1dHRvbjogUmVhY3QuRkM8QXV0aEJ1dHRvblByb3BzPiA9ICh7IHRpdGxlLCBzdWJ0aXRsZSwgaWNvblNyYywgb25DbGljayB9KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGp1c3RpZnktY2VudGVyIHB5LTAuNSB3LWZ1bGwgYmctY3lhbi05MDAgcm91bmRlZC1bNDNweF1cIj5cbiAgICAgIDxidXR0b25cbiAgICAgICAgb25DbGljaz17b25DbGlja30gLy8gQWRpY2lvbmEgYSBsw7NnaWNhIGRlIGNsaXF1ZSBhcXVpXG4gICAgICAgIGNsYXNzTmFtZT1cImZsZXggei0xMCBnYXAtNSBqdXN0aWZ5LWJldHdlZW4gcHktMy41IHByLTQgcGwtMTQgLW10LTEgYm9yZGVyLXdoaXRlIGJvcmRlci1zb2xpZCBiZy1zbGF0ZS05MDAgYm9yZGVyLVszcHhdIHJvdW5kZWQtWzQzcHhdIG1heC1tZDpwbC01XCJcbiAgICAgID5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIG15LWF1dG8gdGV4dC14bCBmb250LWJvbGQgdGV4dC13aGl0ZVwiPlxuICAgICAgICAgIDxzcGFuPnt0aXRsZX08L3NwYW4+XG4gICAgICAgICAge3N1YnRpdGxlICYmIDxzcGFuIGNsYXNzTmFtZT1cInNlbGYtY2VudGVyXCI+e3N1YnRpdGxlfTwvc3Bhbj59XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHB4LTEuNSB3LTE2IGgtMTYgYmctd2hpdGUgcm91bmRlZC1mdWxsXCI+XG4gICAgICAgICAgPEltYWdlXG4gICAgICAgICAgICBsb2FkaW5nPVwibGF6eVwiXG4gICAgICAgICAgICBzcmM9e2ljb25TcmN9XG4gICAgICAgICAgICBhbHQ9XCJcIlxuICAgICAgICAgICAgd2lkdGg9ezUyfVxuICAgICAgICAgICAgaGVpZ2h0PXs1Mn1cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cIm9iamVjdC1jb250YWluIGFzcGVjdC1zcXVhcmVcIlxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBOYXZpZ2F0aW9uUGFnZTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIkltYWdlIiwidXNlUm91dGVyIiwiYXV0aEJ1dHRvbnMiLCJ0aXRsZSIsInN1YnRpdGxlIiwiaWNvblNyYyIsIm9uQ2xpY2siLCJOYXZpZ2F0aW9uUGFnZSIsInJvdXRlciIsImhhbmRsZUNvbm5lY3RXYWxsZXQiLCJwdXNoIiwiaGFuZGxlUmVnaXN0ZXIiLCJ1cGRhdGVkQXV0aEJ1dHRvbnMiLCJtYXAiLCJidXR0b24iLCJtYWluIiwiY2xhc3NOYW1lIiwidmlkZW8iLCJhdXRvUGxheSIsImxvb3AiLCJtdXRlZCIsInNvdXJjZSIsInNyYyIsInR5cGUiLCJzZWN0aW9uIiwiaW5kZXgiLCJkaXYiLCJBdXRoQnV0dG9uIiwic3BhbiIsImxvYWRpbmciLCJhbHQiLCJ3aWR0aCIsImhlaWdodCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/Navigation/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/SignUpButton/page.tsx":
/*!******************************************!*\
  !*** ./components/SignUpButton/page.tsx ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n// components/SignUpButton/page.tsx\n/* __next_internal_client_entry_do_not_use__ default auto */ var _this = undefined;\n\nvar _s = $RefreshSig$();\n\n // Use o hook correto para redirecionamento no Next.js\nvar SignUpButton = function(param) {\n    var text = param.text, redirectTo = param.redirectTo, onSignUpClick = param.onSignUpClick;\n    _s();\n    var router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    var handleClick = function() {\n        onSignUpClick(); // Chama a função passada para o clique\n        router.push(redirectTo); // Redireciona o usuário\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-col items-center\",\n        children: [\n            \" \",\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex justify-center mt-4\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                    onClick: handleClick,\n                    className: \"relative inline-flex items-center justify-center h-15 p-2 text-white transition-colors duration-300 border border-white rounded-lg  bg-transparent hover:outline hover:outline-2 hover:outline-light-blue hover:outline-offset-2  hover:bg-light-blue hover:text-dark-blue focus:outline-none  focus:ring focus:ring-blue-300 shadow-lg hover:shadow-[0px_0px_40px_20px_rgba(0,255,255,0.5)]\",\n                    children: text\n                }, void 0, false, {\n                    fileName: \"/home/ianov/game3/trump-cards/components/SignUpButton/page.tsx\",\n                    lineNumber: 24,\n                    columnNumber: 9\n                }, _this)\n            }, void 0, false, {\n                fileName: \"/home/ianov/game3/trump-cards/components/SignUpButton/page.tsx\",\n                lineNumber: 23,\n                columnNumber: 7\n            }, _this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/ianov/game3/trump-cards/components/SignUpButton/page.tsx\",\n        lineNumber: 22,\n        columnNumber: 5\n    }, _this);\n};\n_s(SignUpButton, \"fN7XvhJ+p5oE6+Xlo0NJmXpxjC8=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter\n    ];\n});\n_c = SignUpButton;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SignUpButton);\nvar _c;\n$RefreshReg$(_c, \"SignUpButton\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvU2lnblVwQnV0dG9uL3BhZ2UudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsbUNBQW1DOzs7O0FBR1Q7QUFDa0IsQ0FBQyxzREFBc0Q7QUFRbkcsSUFBTUUsZUFBNEM7UUFBR0MsYUFBQUEsTUFBTUMsbUJBQUFBLFlBQVlDLHNCQUFBQTs7SUFDckUsSUFBTUMsU0FBU0wsMERBQVNBO0lBRXhCLElBQU1NLGNBQWM7UUFDbEJGLGlCQUFpQix1Q0FBdUM7UUFDeERDLE9BQU9FLElBQUksQ0FBQ0osYUFBYSx3QkFBd0I7SUFDbkQ7SUFFQSxxQkFDRSw4REFBQ0s7UUFBSUMsV0FBVTs7WUFBNkI7MEJBQzFDLDhEQUFDRDtnQkFBSUMsV0FBVTswQkFDYiw0RUFBQ0M7b0JBQ0NDLFNBQVNMO29CQUNURyxXQUFVOzhCQUtUUDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLWDtHQXZCTUQ7O1FBQ1dELHNEQUFTQTs7O0tBRHBCQztBQXlCTixpRUFBZUEsWUFBWUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL1NpZ25VcEJ1dHRvbi9wYWdlLnRzeD9hZjhmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvbXBvbmVudHMvU2lnblVwQnV0dG9uL3BhZ2UudHN4XG5cInVzZSBjbGllbnRcIjsgLy8gUGFyYSBnYXJhbnRpciBxdWUgbyBjb21wb25lbnRlIGZ1bmNpb25lIG5vIGxhZG8gZG8gY2xpZW50ZVxuXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tIFwibmV4dC9uYXZpZ2F0aW9uXCI7IC8vIFVzZSBvIGhvb2sgY29ycmV0byBwYXJhIHJlZGlyZWNpb25hbWVudG8gbm8gTmV4dC5qc1xuXG5pbnRlcmZhY2UgU2lnblVwQnV0dG9uUHJvcHMge1xuICB0ZXh0OiBzdHJpbmc7XG4gIHJlZGlyZWN0VG86IHN0cmluZztcbiAgb25TaWduVXBDbGljazogKCkgPT4gdm9pZDsgLy8gQWRpY2lvbmUgYSBwcm9wcmllZGFkZSBwYXJhIG8gY2xpcXVlXG59XG5cbmNvbnN0IFNpZ25VcEJ1dHRvbjogUmVhY3QuRkM8U2lnblVwQnV0dG9uUHJvcHM+ID0gKHsgdGV4dCwgcmVkaXJlY3RUbywgb25TaWduVXBDbGljayB9KSA9PiB7XG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xuXG4gIGNvbnN0IGhhbmRsZUNsaWNrID0gKCkgPT4ge1xuICAgIG9uU2lnblVwQ2xpY2soKTsgLy8gQ2hhbWEgYSBmdW7Dp8OjbyBwYXNzYWRhIHBhcmEgbyBjbGlxdWVcbiAgICByb3V0ZXIucHVzaChyZWRpcmVjdFRvKTsgLy8gUmVkaXJlY2lvbmEgbyB1c3XDoXJpb1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlclwiPiB7LyogRmxleGJveCBwYXJhIGNlbnRyYWxpemFyIG8gYm90w6NvICovfVxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktY2VudGVyIG10LTRcIj4gXG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVDbGlja31cbiAgICAgICAgICBjbGFzc05hbWU9XCJyZWxhdGl2ZSBpbmxpbmUtZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgaC0xNSBwLTIgdGV4dC13aGl0ZSB0cmFuc2l0aW9uLWNvbG9ycyBkdXJhdGlvbi0zMDAgYm9yZGVyIGJvcmRlci13aGl0ZSByb3VuZGVkLWxnIFxuICAgICAgICAgICAgICAgICAgICAgYmctdHJhbnNwYXJlbnQgaG92ZXI6b3V0bGluZSBob3ZlcjpvdXRsaW5lLTIgaG92ZXI6b3V0bGluZS1saWdodC1ibHVlIGhvdmVyOm91dGxpbmUtb2Zmc2V0LTIgXG4gICAgICAgICAgICAgICAgICAgICBob3ZlcjpiZy1saWdodC1ibHVlIGhvdmVyOnRleHQtZGFyay1ibHVlIGZvY3VzOm91dGxpbmUtbm9uZSBcbiAgICAgICAgICAgICAgICAgICAgIGZvY3VzOnJpbmcgZm9jdXM6cmluZy1ibHVlLTMwMCBzaGFkb3ctbGcgaG92ZXI6c2hhZG93LVswcHhfMHB4XzQwcHhfMjBweF9yZ2JhKDAsMjU1LDI1NSwwLjUpXVwiXG4gICAgICAgID5cbiAgICAgICAgICB7dGV4dH1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNpZ25VcEJ1dHRvbjtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVJvdXRlciIsIlNpZ25VcEJ1dHRvbiIsInRleHQiLCJyZWRpcmVjdFRvIiwib25TaWduVXBDbGljayIsInJvdXRlciIsImhhbmRsZUNsaWNrIiwicHVzaCIsImRpdiIsImNsYXNzTmFtZSIsImJ1dHRvbiIsIm9uQ2xpY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/SignUpButton/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/image-component.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/client/image-component.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_object_spread.js\");\nvar _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_object_spread_props.js\");\nvar _object_without_properties = __webpack_require__(/*! @swc/helpers/_/_object_without_properties */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_object_without_properties.js\");\nvar _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_sliced_to_array.js\");\nvar _to_consumable_array = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_to_consumable_array.js\");\nvar _type_of = __webpack_require__(/*! @swc/helpers/_/_type_of */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_type_of.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Image\", ({\n    enumerable: true,\n    get: function get() {\n        return Image;\n    }\n}));\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nvar _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nvar _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\"));\nvar _head = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/head */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js\"));\nvar _getimgprops = __webpack_require__(/*! ../shared/lib/get-img-props */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\");\nvar _imageconfig = __webpack_require__(/*! ../shared/lib/image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nvar _imageconfigcontextsharedruntime = __webpack_require__(/*! ../shared/lib/image-config-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\");\nvar _warnonce = __webpack_require__(/*! ../shared/lib/utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nvar _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nvar _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\"));\nvar _usemergedref = __webpack_require__(/*! ./use-merged-ref */ \"(app-pages-browser)/./node_modules/next/dist/client/use-merged-ref.js\");\n// This is replaced by webpack define plugin\nvar configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[]};\nif (typeof window === 'undefined') {\n    globalThis.__NEXT_IMAGE_IMPORTED = true;\n}\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput) {\n    var src = img == null ? void 0 : img.src;\n    if (!img || img['data-loaded-src'] === src) {\n        return;\n    }\n    img['data-loaded-src'] = src;\n    var p = 'decode' in img ? img.decode() : Promise.resolve();\n    p[\"catch\"](function() {}).then(function() {\n        if (!img.parentElement || !img.isConnected) {\n            // Exit early in case of race condition:\n            // - onload() is called\n            // - decode() is called but incomplete\n            // - unmount is called\n            // - decode() completes\n            return;\n        }\n        if (placeholder !== 'empty') {\n            setBlurComplete(true);\n        }\n        if (onLoadRef == null ? void 0 : onLoadRef.current) {\n            // Since we don't have the SyntheticEvent here,\n            // we must create one with the same shape.\n            // See https://reactjs.org/docs/events.html\n            var event = new Event('load');\n            Object.defineProperty(event, 'target', {\n                writable: false,\n                value: img\n            });\n            var prevented = false;\n            var stopped = false;\n            onLoadRef.current(_object_spread_props._(_object_spread._({}, event), {\n                nativeEvent: event,\n                currentTarget: img,\n                target: img,\n                isDefaultPrevented: function() {\n                    return prevented;\n                },\n                isPropagationStopped: function() {\n                    return stopped;\n                },\n                persist: function() {},\n                preventDefault: function() {\n                    prevented = true;\n                    event.preventDefault();\n                },\n                stopPropagation: function() {\n                    stopped = true;\n                    event.stopPropagation();\n                }\n            }));\n        }\n        if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n            onLoadingCompleteRef.current(img);\n        }\n        if (true) {\n            var origSrc = new URL(src, 'http://n').searchParams.get('url') || src;\n            if (img.getAttribute('data-nimg') === 'fill') {\n                if (!unoptimized && (!sizesInput || sizesInput === '100vw')) {\n                    var widthViewportRatio = img.getBoundingClientRect().width / window.innerWidth;\n                    if (widthViewportRatio < 0.6) {\n                        if (sizesInput === '100vw') {\n                            (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" prop and \"sizes\" prop of \"100vw\", but image is not rendered at full viewport width. Please adjust \"sizes\" to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                        } else {\n                            (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" but is missing \"sizes\" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                        }\n                    }\n                }\n                if (img.parentElement) {\n                    var position = window.getComputedStyle(img.parentElement).position;\n                    var valid = [\n                        'absolute',\n                        'fixed',\n                        'relative'\n                    ];\n                    if (!valid.includes(position)) {\n                        (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and parent element with invalid \"position\". Provided \"' + position + '\" should be one of ' + valid.map(String).join(',') + \".\");\n                    }\n                }\n                if (img.height === 0) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.');\n                }\n            }\n            var heightModified = img.height.toString() !== img.getAttribute('height');\n            var widthModified = img.width.toString() !== img.getAttribute('width');\n            if (heightModified && !widthModified || !heightModified && widthModified) {\n                (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles \\'width: \"auto\"\\' or \\'height: \"auto\"\\' to maintain the aspect ratio.');\n            }\n        }\n    });\n}\nfunction getDynamicProps(fetchPriority) {\n    if (Boolean(_react.use)) {\n        // In React 19.0.0 or newer, we must use camelCase\n        // prop to avoid \"Warning: Invalid DOM property\".\n        // See https://github.com/facebook/react/pull/25927\n        return {\n            fetchPriority: fetchPriority\n        };\n    }\n    // In React 18.2.0 or older, we must use lowercase prop\n    // to avoid \"Warning: Invalid DOM property\".\n    return {\n        fetchpriority: fetchPriority\n    };\n}\nvar ImageElement = /*#__PURE__*/ (0, _react.forwardRef)(function(param, forwardedRef) {\n    var src = param.src, srcSet = param.srcSet, sizes = param.sizes, height = param.height, width = param.width, decoding = param.decoding, className = param.className, style = param.style, fetchPriority = param.fetchPriority, placeholder = param.placeholder, loading = param.loading, unoptimized = param.unoptimized, fill = param.fill, onLoadRef = param.onLoadRef, onLoadingCompleteRef = param.onLoadingCompleteRef, setBlurComplete = param.setBlurComplete, setShowAltText = param.setShowAltText, sizesInput = param.sizesInput, onLoad = param.onLoad, onError = param.onError, rest = _object_without_properties._(param, [\n        \"src\",\n        \"srcSet\",\n        \"sizes\",\n        \"height\",\n        \"width\",\n        \"decoding\",\n        \"className\",\n        \"style\",\n        \"fetchPriority\",\n        \"placeholder\",\n        \"loading\",\n        \"unoptimized\",\n        \"fill\",\n        \"onLoadRef\",\n        \"onLoadingCompleteRef\",\n        \"setBlurComplete\",\n        \"setShowAltText\",\n        \"sizesInput\",\n        \"onLoad\",\n        \"onError\"\n    ]);\n    var ownRef = (0, _react.useCallback)(function(img) {\n        if (!img) {\n            return;\n        }\n        if (onError) {\n            // If the image has an error before react hydrates, then the error is lost.\n            // The workaround is to wait until the image is mounted which is after hydration,\n            // then we set the src again to trigger the error handler (if there was an error).\n            // eslint-disable-next-line no-self-assign\n            img.src = img.src;\n        }\n        if (true) {\n            if (!src) {\n                console.error('Image is missing required \"src\" property:', img);\n            }\n            if (img.getAttribute('alt') === null) {\n                console.error('Image is missing required \"alt\" property. Please add Alternative Text to describe the image for screen readers and search engines.');\n            }\n        }\n        if (img.complete) {\n            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);\n        }\n    }, [\n        src,\n        placeholder,\n        onLoadRef,\n        onLoadingCompleteRef,\n        setBlurComplete,\n        onError,\n        unoptimized,\n        sizesInput\n    ]);\n    var ref = (0, _usemergedref.useMergedRef)(forwardedRef, ownRef);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"img\", _object_spread_props._(_object_spread._({}, rest, getDynamicProps(fetchPriority)), {\n        // It's intended to keep `loading` before `src` because React updates\n        // props in order which causes Safari/Firefox to not lazy load properly.\n        // See https://github.com/facebook/react/issues/25883\n        loading: loading,\n        width: width,\n        height: height,\n        decoding: decoding,\n        \"data-nimg\": fill ? 'fill' : '1',\n        className: className,\n        style: style,\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        sizes: sizes,\n        srcSet: srcSet,\n        src: src,\n        ref: ref,\n        onLoad: function(event) {\n            var img = event.currentTarget;\n            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);\n        },\n        onError: function(event) {\n            // if the real image fails to load, this will ensure \"alt\" is visible\n            setShowAltText(true);\n            if (placeholder !== 'empty') {\n                // If the real image fails to load, this will still remove the placeholder.\n                setBlurComplete(true);\n            }\n            if (onError) {\n                onError(event);\n            }\n        }\n    }));\n});\nfunction ImagePreload(param) {\n    var isAppRouter = param.isAppRouter, imgAttributes = param.imgAttributes;\n    var opts = _object_spread._({\n        as: 'image',\n        imageSrcSet: imgAttributes.srcSet,\n        imageSizes: imgAttributes.sizes,\n        crossOrigin: imgAttributes.crossOrigin,\n        referrerPolicy: imgAttributes.referrerPolicy\n    }, getDynamicProps(imgAttributes.fetchPriority));\n    if (isAppRouter && _reactdom[\"default\"].preload) {\n        // See https://github.com/facebook/react/pull/26940\n        _reactdom[\"default\"].preload(imgAttributes.src, opts);\n        return null;\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_head[\"default\"], {\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", _object_spread._({\n            rel: \"preload\",\n            // Note how we omit the `href` attribute, as it would only be relevant\n            // for browsers that do not support `imagesrcset`, and in those cases\n            // it would cause the incorrect image to be preloaded.\n            //\n            // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n            href: imgAttributes.srcSet ? undefined : imgAttributes.src\n        }, opts), '__nimg-' + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes)\n    });\n}\n_c = ImagePreload;\nvar Image = /*#__PURE__*/ (0, _react.forwardRef)(function(props, forwardedRef) {\n    var pagesRouter = (0, _react.useContext)(_routercontextsharedruntime.RouterContext);\n    // We're in the app directory if there is no pages router.\n    var isAppRouter = !pagesRouter;\n    var configContext = (0, _react.useContext)(_imageconfigcontextsharedruntime.ImageConfigContext);\n    var config = (0, _react.useMemo)(function() {\n        var c = configEnv || configContext || _imageconfig.imageConfigDefault;\n        var allSizes = _to_consumable_array._(c.deviceSizes).concat(_to_consumable_array._(c.imageSizes)).sort(function(a, b) {\n            return a - b;\n        });\n        var deviceSizes = c.deviceSizes.sort(function(a, b) {\n            return a - b;\n        });\n        return _object_spread_props._(_object_spread._({}, c), {\n            allSizes: allSizes,\n            deviceSizes: deviceSizes\n        });\n    }, [\n        configContext\n    ]);\n    var onLoad = props.onLoad, onLoadingComplete = props.onLoadingComplete;\n    var onLoadRef = (0, _react.useRef)(onLoad);\n    (0, _react.useEffect)(function() {\n        onLoadRef.current = onLoad;\n    }, [\n        onLoad\n    ]);\n    var onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);\n    (0, _react.useEffect)(function() {\n        onLoadingCompleteRef.current = onLoadingComplete;\n    }, [\n        onLoadingComplete\n    ]);\n    var _ref = _sliced_to_array._((0, _react.useState)(false), 2), blurComplete = _ref[0], setBlurComplete = _ref[1];\n    var _ref1 = _sliced_to_array._((0, _react.useState)(false), 2), showAltText = _ref1[0], setShowAltText = _ref1[1];\n    var _ref2 = (0, _getimgprops.getImgProps)(props, {\n        defaultLoader: _imageloader[\"default\"],\n        imgConf: config,\n        blurComplete: blurComplete,\n        showAltText: showAltText\n    }), imgAttributes = _ref2.props, imgMeta = _ref2.meta;\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(ImageElement, _object_spread_props._(_object_spread._({}, imgAttributes), {\n                unoptimized: imgMeta.unoptimized,\n                placeholder: imgMeta.placeholder,\n                fill: imgMeta.fill,\n                onLoadRef: onLoadRef,\n                onLoadingCompleteRef: onLoadingCompleteRef,\n                setBlurComplete: setBlurComplete,\n                setShowAltText: setShowAltText,\n                sizesInput: props.sizes,\n                ref: forwardedRef\n            })),\n            imgMeta.priority ? /*#__PURE__*/ (0, _jsxruntime.jsx)(ImagePreload, {\n                isAppRouter: isAppRouter,\n                imgAttributes: imgAttributes\n            }) : null\n        ]\n    });\n});\nif ((typeof exports[\"default\"] === 'function' || _type_of._(exports[\"default\"]) === 'object' && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === 'undefined') {\n    Object.defineProperty(exports[\"default\"], '__esModule', {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=image-component.js.map\nvar _c;\n$RefreshReg$(_c, \"ImagePreload\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2ltYWdlLWNvbXBvbmVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7ZUEwV2FBOzs7Ozs7OzhKQTlWUTs0RUFDSjsyQkFDVzt1Q0FZTztrSkFDQTt3QkFDVjtxSkFDSzttTUFHSjs0QkFDRztBQUU3Qix1SUFBNEM7QUFDNUMsTUFBTUMsWUFBWUMsUUFBUUMsR0FBRyxDQUFDQyxjQUFBQTtBQUU5QixJQUFJLEtBQU9DLE9BQUFBLDBOQUF3QjtJQUMvQkMsT0FBQUEsSUFBbUJDLE9BQUFBLGFBQUFBLENBQXFCO0lBQzVDO0FBbUJBO0FBQ0EsaURBQWlEO0FBQ2pELFNBQVNDLGNBQ1BDLEdBQTJCLEVBQzNCQyxXQUE2QixFQUM3QkMsUUFBQUE7SUFNQSxNQUFNSyxNQUFNUCxPQUFBQSxHQUFBQSxFQUFBQSxXQUFBQSxFQUFBQSxFQUFLTyxHQUFHO0lBQ3BCLElBQUksQ0FBQ1AsS0FBT0EsR0FBRyxDQUFDLGtCQUFrQixLQUFLTyxHQUFBQTtRQUNyQztRQUNGO0lBQ0FQO0lBQ0EsTUFBTVEsSUFBSSxZQUFZUixHQUFBQSxHQUFNQTtJQUM1QlEsRUFBRUksRUFBQUEsQ0FBSyxDQUFDLEtBQU8sR0FBR0MsSUFBSSxDQUFDO09BQ3JCLFFBQUksQ0FBQ2IsV0FBSWMsR0FBQUEsSUFBQUEsQ0FBQUEsS0FBYSxJQUFJLENBQUNkO1lBQ3pCLHdDQUF3QztZQUN4Qyx1QkFBdUI7WUFDdkI7WUFDQSxzQkFBc0I7WUFDdEI7WUFDQTtZQUNGO1FBQ0E7WUFDRUksZ0JBQWdCO1lBQ2xCO1FBQ0E7WUFDRSwrQ0FBK0M7WUFDL0MsMENBQTBDO1lBQzFDO1lBQ0EsTUFBTWEsUUFBUSxJQUFJQyxNQUFNO1lBQ3hCQyxJQUFBQSxDQUFPQyxPQUFBQSxJQUFBQSxHQUFjLENBQUNILEVBQUFBLEtBQU87Z0JBQVlJLEdBQUFBLE9BQVU7Z0JBQU9DLE9BQU90QixHQUFBQTtnQkFBSTtZQUNy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QUFBQTtRQUNyQjtRQUNiRyxTQUFTbkIsTUFBQUEsWUFBQUEsQ0FBQUEsVUFBQUE7UUFDVFksU0FBQUE7c0JBQ0FFO1FBQ0Y7SUFFQSxJQU5FSSxJQUFBQSxZQUFhLENBT2IsS0FQQUEsT0FBQUEsR0FBYSxhQUFiQTs7O2dCQVVPLEdBQUd0QyxJQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxFQUFhLHlFQUNqQi9FLFVBQWFtSDtnQkFDYnZILGFBQWF1SCxRQUFRdkgsV0FBVztnQkFDaENvRSxNQUFNbUQsT0FBQUEsQ0FBUW5ELElBQUk7Z0JBQ2xCbkUsTUFBQUEsS0FBV0EsR0FBQUEsSUFBQUE7Z0JBQ1hDLFdBQUFBO2dCQUNBQyxpQkFBaUJBLEtBQUFBO2dCQUNqQmtFLGdCQUFnQkEsQ0FBQUE7Z0JBQ2hCaEUsWUFBWTRGLElBQUFBLEVBQU1sQyxLQUFLO2dCQUN2QmUsS0FBS2pCLE9BQUFBLE1BQUFBLEtBQUFBOzs7Z0JBS0xxQixJQUFBQSxRQUFBQSxDQUFhQSxFQUFBQSxXQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxZQUFBQSxHQUFBQSxFQUFBQSxjQUFBQTtnQkFDYkMsYUFBQUEsRUFBZUE7aUJBRWY7OztJQUdWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY2xpZW50L2ltYWdlLWNvbXBvbmVudC50c3g/NTFlMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IFJlYWN0LCB7XG4gIHVzZVJlZixcbiAgdXNlRWZmZWN0LFxuICB1c2VDYWxsYmFjayxcbiAgdXNlQ29udGV4dCxcbiAgdXNlTWVtbyxcbiAgdXNlU3RhdGUsXG4gIGZvcndhcmRSZWYsXG4gIHVzZSxcbn0gZnJvbSAncmVhY3QnXG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJ1xuaW1wb3J0IEhlYWQgZnJvbSAnLi4vc2hhcmVkL2xpYi9oZWFkJ1xuaW1wb3J0IHsgZ2V0SW1nUHJvcHMgfSBmcm9tICcuLi9zaGFyZWQvbGliL2dldC1pbWctcHJvcHMnXG5pbXBvcnQgdHlwZSB7XG4gIEltYWdlUHJvcHMsXG4gIEltZ1Byb3BzLFxuICBPbkxvYWQsXG4gIE9uTG9hZGluZ0NvbXBsZXRlLFxuICBQbGFjZWhvbGRlclZhbHVlLFxufSBmcm9tICcuLi9zaGFyZWQvbGliL2dldC1pbWctcHJvcHMnXG5pbXBvcnQgdHlwZSB7XG4gIEltYWdlQ29uZmlnQ29tcGxldGUsXG4gIEltYWdlTG9hZGVyUHJvcHMsXG59IGZyb20gJy4uL3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnJ1xuaW1wb3J0IHsgaW1hZ2VDb25maWdEZWZhdWx0IH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9pbWFnZS1jb25maWcnXG5pbXBvcnQgeyBJbWFnZUNvbmZpZ0NvbnRleHQgfSBmcm9tICcuLi9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tICcuLi9zaGFyZWQvbGliL3V0aWxzL3dhcm4tb25jZSdcbmltcG9ydCB7IFJvdXRlckNvbnRleHQgfSBmcm9tICcuLi9zaGFyZWQvbGliL3JvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuXG4vLyBAdHMtaWdub3JlIC0gVGhpcyBpcyByZXBsYWNlZCBieSB3ZWJwYWNrIGFsaWFzXG5pbXBvcnQgZGVmYXVsdExvYWRlciBmcm9tICduZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXInXG5pbXBvcnQgeyB1c2VNZXJnZWRSZWYgfSBmcm9tICcuL3VzZS1tZXJnZWQtcmVmJ1xuXG4vLyBUaGlzIGlzIHJlcGxhY2VkIGJ5IHdlYnBhY2sgZGVmaW5lIHBsdWdpblxuY29uc3QgY29uZmlnRW52ID0gcHJvY2Vzcy5lbnYuX19ORVhUX0lNQUdFX09QVFMgYXMgYW55IGFzIEltYWdlQ29uZmlnQ29tcGxldGVcblxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gIDsoZ2xvYmFsVGhpcyBhcyBhbnkpLl9fTkVYVF9JTUFHRV9JTVBPUlRFRCA9IHRydWVcbn1cblxuZXhwb3J0IHR5cGUgeyBJbWFnZUxvYWRlclByb3BzIH1cbmV4cG9ydCB0eXBlIEltYWdlTG9hZGVyID0gKHA6IEltYWdlTG9hZGVyUHJvcHMpID0+IHN0cmluZ1xuXG50eXBlIEltZ0VsZW1lbnRXaXRoRGF0YVByb3AgPSBIVE1MSW1hZ2VFbGVtZW50ICYge1xuICAnZGF0YS1sb2FkZWQtc3JjJzogc3RyaW5nIHwgdW5kZWZpbmVkXG59XG5cbnR5cGUgSW1hZ2VFbGVtZW50UHJvcHMgPSBJbWdQcm9wcyAmIHtcbiAgdW5vcHRpbWl6ZWQ6IGJvb2xlYW5cbiAgcGxhY2Vob2xkZXI6IFBsYWNlaG9sZGVyVmFsdWVcbiAgb25Mb2FkUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PE9uTG9hZCB8IHVuZGVmaW5lZD5cbiAgb25Mb2FkaW5nQ29tcGxldGVSZWY6IFJlYWN0Lk11dGFibGVSZWZPYmplY3Q8T25Mb2FkaW5nQ29tcGxldGUgfCB1bmRlZmluZWQ+XG4gIHNldEJsdXJDb21wbGV0ZTogKGI6IGJvb2xlYW4pID0+IHZvaWRcbiAgc2V0U2hvd0FsdFRleHQ6IChiOiBib29sZWFuKSA9PiB2b2lkXG4gIHNpemVzSW5wdXQ6IHN0cmluZyB8IHVuZGVmaW5lZFxufVxuXG4vLyBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzM5Nzc3ODMzLzI2NjUzNSBmb3Igd2h5IHdlIHVzZSB0aGlzIHJlZlxuLy8gaGFuZGxlciBpbnN0ZWFkIG9mIHRoZSBpbWcncyBvbkxvYWQgYXR0cmlidXRlLlxuZnVuY3Rpb24gaGFuZGxlTG9hZGluZyhcbiAgaW1nOiBJbWdFbGVtZW50V2l0aERhdGFQcm9wLFxuICBwbGFjZWhvbGRlcjogUGxhY2Vob2xkZXJWYWx1ZSxcbiAgb25Mb2FkUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PE9uTG9hZCB8IHVuZGVmaW5lZD4sXG4gIG9uTG9hZGluZ0NvbXBsZXRlUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PE9uTG9hZGluZ0NvbXBsZXRlIHwgdW5kZWZpbmVkPixcbiAgc2V0Qmx1ckNvbXBsZXRlOiAoYjogYm9vbGVhbikgPT4gdm9pZCxcbiAgdW5vcHRpbWl6ZWQ6IGJvb2xlYW4sXG4gIHNpemVzSW5wdXQ6IHN0cmluZyB8IHVuZGVmaW5lZFxuKSB7XG4gIGNvbnN0IHNyYyA9IGltZz8uc3JjXG4gIGlmICghaW1nIHx8IGltZ1snZGF0YS1sb2FkZWQtc3JjJ10gPT09IHNyYykge1xuICAgIHJldHVyblxuICB9XG4gIGltZ1snZGF0YS1sb2FkZWQtc3JjJ10gPSBzcmNcbiAgY29uc3QgcCA9ICdkZWNvZGUnIGluIGltZyA/IGltZy5kZWNvZGUoKSA6IFByb21pc2UucmVzb2x2ZSgpXG4gIHAuY2F0Y2goKCkgPT4ge30pLnRoZW4oKCkgPT4ge1xuICAgIGlmICghaW1nLnBhcmVudEVsZW1lbnQgfHwgIWltZy5pc0Nvbm5lY3RlZCkge1xuICAgICAgLy8gRXhpdCBlYXJseSBpbiBjYXNlIG9mIHJhY2UgY29uZGl0aW9uOlxuICAgICAgLy8gLSBvbmxvYWQoKSBpcyBjYWxsZWRcbiAgICAgIC8vIC0gZGVjb2RlKCkgaXMgY2FsbGVkIGJ1dCBpbmNvbXBsZXRlXG4gICAgICAvLyAtIHVubW91bnQgaXMgY2FsbGVkXG4gICAgICAvLyAtIGRlY29kZSgpIGNvbXBsZXRlc1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChwbGFjZWhvbGRlciAhPT0gJ2VtcHR5Jykge1xuICAgICAgc2V0Qmx1ckNvbXBsZXRlKHRydWUpXG4gICAgfVxuICAgIGlmIChvbkxvYWRSZWY/LmN1cnJlbnQpIHtcbiAgICAgIC8vIFNpbmNlIHdlIGRvbid0IGhhdmUgdGhlIFN5bnRoZXRpY0V2ZW50IGhlcmUsXG4gICAgICAvLyB3ZSBtdXN0IGNyZWF0ZSBvbmUgd2l0aCB0aGUgc2FtZSBzaGFwZS5cbiAgICAgIC8vIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvZXZlbnRzLmh0bWxcbiAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCdsb2FkJylcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudCwgJ3RhcmdldCcsIHsgd3JpdGFibGU6IGZhbHNlLCB2YWx1ZTogaW1nIH0pXG4gICAgICBsZXQgcHJldmVudGVkID0gZmFsc2VcbiAgICAgIGxldCBzdG9wcGVkID0gZmFsc2VcbiAgICAgIG9uTG9hZFJlZi5jdXJyZW50KHtcbiAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgIG5hdGl2ZUV2ZW50OiBldmVudCxcbiAgICAgICAgY3VycmVudFRhcmdldDogaW1nLFxuICAgICAgICB0YXJnZXQ6IGltZyxcbiAgICAgICAgaXNEZWZhdWx0UHJldmVudGVkOiAoKSA9PiBwcmV2ZW50ZWQsXG4gICAgICAgIGlzUHJvcGFnYXRpb25TdG9wcGVkOiAoKSA9PiBzdG9wcGVkLFxuICAgICAgICBwZXJzaXN0OiAoKSA9PiB7fSxcbiAgICAgICAgcHJldmVudERlZmF1bHQ6ICgpID0+IHtcbiAgICAgICAgICBwcmV2ZW50ZWQgPSB0cnVlXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICB9LFxuICAgICAgICBzdG9wUHJvcGFnYXRpb246ICgpID0+IHtcbiAgICAgICAgICBzdG9wcGVkID0gdHJ1ZVxuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH1cbiAgICBpZiAob25Mb2FkaW5nQ29tcGxldGVSZWY/LmN1cnJlbnQpIHtcbiAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLmN1cnJlbnQoaW1nKVxuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc3Qgb3JpZ1NyYyA9IG5ldyBVUkwoc3JjLCAnaHR0cDovL24nKS5zZWFyY2hQYXJhbXMuZ2V0KCd1cmwnKSB8fCBzcmNcbiAgICAgIGlmIChpbWcuZ2V0QXR0cmlidXRlKCdkYXRhLW5pbWcnKSA9PT0gJ2ZpbGwnKSB7XG4gICAgICAgIGlmICghdW5vcHRpbWl6ZWQgJiYgKCFzaXplc0lucHV0IHx8IHNpemVzSW5wdXQgPT09ICcxMDB2dycpKSB7XG4gICAgICAgICAgbGV0IHdpZHRoVmlld3BvcnRSYXRpbyA9XG4gICAgICAgICAgICBpbWcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLyB3aW5kb3cuaW5uZXJXaWR0aFxuICAgICAgICAgIGlmICh3aWR0aFZpZXdwb3J0UmF0aW8gPCAwLjYpIHtcbiAgICAgICAgICAgIGlmIChzaXplc0lucHV0ID09PSAnMTAwdncnKSB7XG4gICAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7b3JpZ1NyY31cIiBoYXMgXCJmaWxsXCIgcHJvcCBhbmQgXCJzaXplc1wiIHByb3Agb2YgXCIxMDB2d1wiLCBidXQgaW1hZ2UgaXMgbm90IHJlbmRlcmVkIGF0IGZ1bGwgdmlld3BvcnQgd2lkdGguIFBsZWFzZSBhZGp1c3QgXCJzaXplc1wiIHRvIGltcHJvdmUgcGFnZSBwZXJmb3JtYW5jZS4gUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvaW1hZ2Ujc2l6ZXNgXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7b3JpZ1NyY31cIiBoYXMgXCJmaWxsXCIgYnV0IGlzIG1pc3NpbmcgXCJzaXplc1wiIHByb3AuIFBsZWFzZSBhZGQgaXQgdG8gaW1wcm92ZSBwYWdlIHBlcmZvcm1hbmNlLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNzaXplc2BcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1nLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICBjb25zdCB7IHBvc2l0aW9uIH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpbWcucGFyZW50RWxlbWVudClcbiAgICAgICAgICBjb25zdCB2YWxpZCA9IFsnYWJzb2x1dGUnLCAnZml4ZWQnLCAncmVsYXRpdmUnXVxuICAgICAgICAgIGlmICghdmFsaWQuaW5jbHVkZXMocG9zaXRpb24pKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtvcmlnU3JjfVwiIGhhcyBcImZpbGxcIiBhbmQgcGFyZW50IGVsZW1lbnQgd2l0aCBpbnZhbGlkIFwicG9zaXRpb25cIi4gUHJvdmlkZWQgXCIke3Bvc2l0aW9ufVwiIHNob3VsZCBiZSBvbmUgb2YgJHt2YWxpZFxuICAgICAgICAgICAgICAgIC5tYXAoU3RyaW5nKVxuICAgICAgICAgICAgICAgIC5qb2luKCcsJyl9LmBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltZy5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7b3JpZ1NyY31cIiBoYXMgXCJmaWxsXCIgYW5kIGEgaGVpZ2h0IHZhbHVlIG9mIDAuIFRoaXMgaXMgbGlrZWx5IGJlY2F1c2UgdGhlIHBhcmVudCBlbGVtZW50IG9mIHRoZSBpbWFnZSBoYXMgbm90IGJlZW4gc3R5bGVkIHRvIGhhdmUgYSBzZXQgaGVpZ2h0LmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgaGVpZ2h0TW9kaWZpZWQgPVxuICAgICAgICBpbWcuaGVpZ2h0LnRvU3RyaW5nKCkgIT09IGltZy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpXG4gICAgICBjb25zdCB3aWR0aE1vZGlmaWVkID0gaW1nLndpZHRoLnRvU3RyaW5nKCkgIT09IGltZy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJylcbiAgICAgIGlmIChcbiAgICAgICAgKGhlaWdodE1vZGlmaWVkICYmICF3aWR0aE1vZGlmaWVkKSB8fFxuICAgICAgICAoIWhlaWdodE1vZGlmaWVkICYmIHdpZHRoTW9kaWZpZWQpXG4gICAgICApIHtcbiAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtvcmlnU3JjfVwiIGhhcyBlaXRoZXIgd2lkdGggb3IgaGVpZ2h0IG1vZGlmaWVkLCBidXQgbm90IHRoZSBvdGhlci4gSWYgeW91IHVzZSBDU1MgdG8gY2hhbmdlIHRoZSBzaXplIG9mIHlvdXIgaW1hZ2UsIGFsc28gaW5jbHVkZSB0aGUgc3R5bGVzICd3aWR0aDogXCJhdXRvXCInIG9yICdoZWlnaHQ6IFwiYXV0b1wiJyB0byBtYWludGFpbiB0aGUgYXNwZWN0IHJhdGlvLmBcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gZ2V0RHluYW1pY1Byb3BzKFxuICBmZXRjaFByaW9yaXR5Pzogc3RyaW5nXG4pOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgaWYgKEJvb2xlYW4odXNlKSkge1xuICAgIC8vIEluIFJlYWN0IDE5LjAuMCBvciBuZXdlciwgd2UgbXVzdCB1c2UgY2FtZWxDYXNlXG4gICAgLy8gcHJvcCB0byBhdm9pZCBcIldhcm5pbmc6IEludmFsaWQgRE9NIHByb3BlcnR5XCIuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzI1OTI3XG4gICAgcmV0dXJuIHsgZmV0Y2hQcmlvcml0eSB9XG4gIH1cbiAgLy8gSW4gUmVhY3QgMTguMi4wIG9yIG9sZGVyLCB3ZSBtdXN0IHVzZSBsb3dlcmNhc2UgcHJvcFxuICAvLyB0byBhdm9pZCBcIldhcm5pbmc6IEludmFsaWQgRE9NIHByb3BlcnR5XCIuXG4gIHJldHVybiB7IGZldGNocHJpb3JpdHk6IGZldGNoUHJpb3JpdHkgfVxufVxuXG5jb25zdCBJbWFnZUVsZW1lbnQgPSBmb3J3YXJkUmVmPEhUTUxJbWFnZUVsZW1lbnQgfCBudWxsLCBJbWFnZUVsZW1lbnRQcm9wcz4oXG4gIChcbiAgICB7XG4gICAgICBzcmMsXG4gICAgICBzcmNTZXQsXG4gICAgICBzaXplcyxcbiAgICAgIGhlaWdodCxcbiAgICAgIHdpZHRoLFxuICAgICAgZGVjb2RpbmcsXG4gICAgICBjbGFzc05hbWUsXG4gICAgICBzdHlsZSxcbiAgICAgIGZldGNoUHJpb3JpdHksXG4gICAgICBwbGFjZWhvbGRlcixcbiAgICAgIGxvYWRpbmcsXG4gICAgICB1bm9wdGltaXplZCxcbiAgICAgIGZpbGwsXG4gICAgICBvbkxvYWRSZWYsXG4gICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZixcbiAgICAgIHNldEJsdXJDb21wbGV0ZSxcbiAgICAgIHNldFNob3dBbHRUZXh0LFxuICAgICAgc2l6ZXNJbnB1dCxcbiAgICAgIG9uTG9hZCxcbiAgICAgIG9uRXJyb3IsXG4gICAgICAuLi5yZXN0XG4gICAgfSxcbiAgICBmb3J3YXJkZWRSZWZcbiAgKSA9PiB7XG4gICAgY29uc3Qgb3duUmVmID0gdXNlQ2FsbGJhY2soXG4gICAgICAoaW1nOiBJbWdFbGVtZW50V2l0aERhdGFQcm9wIHwgbnVsbCkgPT4ge1xuICAgICAgICBpZiAoIWltZykge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGltYWdlIGhhcyBhbiBlcnJvciBiZWZvcmUgcmVhY3QgaHlkcmF0ZXMsIHRoZW4gdGhlIGVycm9yIGlzIGxvc3QuXG4gICAgICAgICAgLy8gVGhlIHdvcmthcm91bmQgaXMgdG8gd2FpdCB1bnRpbCB0aGUgaW1hZ2UgaXMgbW91bnRlZCB3aGljaCBpcyBhZnRlciBoeWRyYXRpb24sXG4gICAgICAgICAgLy8gdGhlbiB3ZSBzZXQgdGhlIHNyYyBhZ2FpbiB0byB0cmlnZ2VyIHRoZSBlcnJvciBoYW5kbGVyIChpZiB0aGVyZSB3YXMgYW4gZXJyb3IpLlxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnblxuICAgICAgICAgIGltZy5zcmMgPSBpbWcuc3JjXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoIXNyYykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgSW1hZ2UgaXMgbWlzc2luZyByZXF1aXJlZCBcInNyY1wiIHByb3BlcnR5OmAsIGltZylcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGltZy5nZXRBdHRyaWJ1dGUoJ2FsdCcpID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBgSW1hZ2UgaXMgbWlzc2luZyByZXF1aXJlZCBcImFsdFwiIHByb3BlcnR5LiBQbGVhc2UgYWRkIEFsdGVybmF0aXZlIFRleHQgdG8gZGVzY3JpYmUgdGhlIGltYWdlIGZvciBzY3JlZW4gcmVhZGVycyBhbmQgc2VhcmNoIGVuZ2luZXMuYFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1nLmNvbXBsZXRlKSB7XG4gICAgICAgICAgaGFuZGxlTG9hZGluZyhcbiAgICAgICAgICAgIGltZyxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgb25Mb2FkUmVmLFxuICAgICAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYsXG4gICAgICAgICAgICBzZXRCbHVyQ29tcGxldGUsXG4gICAgICAgICAgICB1bm9wdGltaXplZCxcbiAgICAgICAgICAgIHNpemVzSW5wdXRcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbXG4gICAgICAgIHNyYyxcbiAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgIG9uTG9hZFJlZixcbiAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYsXG4gICAgICAgIHNldEJsdXJDb21wbGV0ZSxcbiAgICAgICAgb25FcnJvcixcbiAgICAgICAgdW5vcHRpbWl6ZWQsXG4gICAgICAgIHNpemVzSW5wdXQsXG4gICAgICBdXG4gICAgKVxuXG4gICAgY29uc3QgcmVmID0gdXNlTWVyZ2VkUmVmKGZvcndhcmRlZFJlZiwgb3duUmVmKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxpbWdcbiAgICAgICAgey4uLnJlc3R9XG4gICAgICAgIHsuLi5nZXREeW5hbWljUHJvcHMoZmV0Y2hQcmlvcml0eSl9XG4gICAgICAgIC8vIEl0J3MgaW50ZW5kZWQgdG8ga2VlcCBgbG9hZGluZ2AgYmVmb3JlIGBzcmNgIGJlY2F1c2UgUmVhY3QgdXBkYXRlc1xuICAgICAgICAvLyBwcm9wcyBpbiBvcmRlciB3aGljaCBjYXVzZXMgU2FmYXJpL0ZpcmVmb3ggdG8gbm90IGxhenkgbG9hZCBwcm9wZXJseS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjU4ODNcbiAgICAgICAgbG9hZGluZz17bG9hZGluZ31cbiAgICAgICAgd2lkdGg9e3dpZHRofVxuICAgICAgICBoZWlnaHQ9e2hlaWdodH1cbiAgICAgICAgZGVjb2Rpbmc9e2RlY29kaW5nfVxuICAgICAgICBkYXRhLW5pbWc9e2ZpbGwgPyAnZmlsbCcgOiAnMSd9XG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgICBzdHlsZT17c3R5bGV9XG4gICAgICAgIC8vIEl0J3MgaW50ZW5kZWQgdG8ga2VlcCBgc3JjYCB0aGUgbGFzdCBhdHRyaWJ1dGUgYmVjYXVzZSBSZWFjdCB1cGRhdGVzXG4gICAgICAgIC8vIGF0dHJpYnV0ZXMgaW4gb3JkZXIuIElmIHdlIGtlZXAgYHNyY2AgdGhlIGZpcnN0IG9uZSwgU2FmYXJpIHdpbGxcbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgc3RhcnQgdG8gZmV0Y2ggYHNyY2AsIGJlZm9yZSBgc2l6ZXNgIGFuZCBgc3JjU2V0YCBhcmUgZXZlblxuICAgICAgICAvLyB1cGRhdGVkIGJ5IFJlYWN0LiBUaGF0IGNhdXNlcyBtdWx0aXBsZSB1bm5lY2Vzc2FyeSByZXF1ZXN0cyBpZiBgc3JjU2V0YFxuICAgICAgICAvLyBhbmQgYHNpemVzYCBhcmUgZGVmaW5lZC5cbiAgICAgICAgLy8gVGhpcyBidWcgY2Fubm90IGJlIHJlcHJvZHVjZWQgaW4gQ2hyb21lIG9yIEZpcmVmb3guXG4gICAgICAgIHNpemVzPXtzaXplc31cbiAgICAgICAgc3JjU2V0PXtzcmNTZXR9XG4gICAgICAgIHNyYz17c3JjfVxuICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgb25Mb2FkPXsoZXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBpbWcgPSBldmVudC5jdXJyZW50VGFyZ2V0IGFzIEltZ0VsZW1lbnRXaXRoRGF0YVByb3BcbiAgICAgICAgICBoYW5kbGVMb2FkaW5nKFxuICAgICAgICAgICAgaW1nLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgICAgICBvbkxvYWRSZWYsXG4gICAgICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZixcbiAgICAgICAgICAgIHNldEJsdXJDb21wbGV0ZSxcbiAgICAgICAgICAgIHVub3B0aW1pemVkLFxuICAgICAgICAgICAgc2l6ZXNJbnB1dFxuICAgICAgICAgIClcbiAgICAgICAgfX1cbiAgICAgICAgb25FcnJvcj17KGV2ZW50KSA9PiB7XG4gICAgICAgICAgLy8gaWYgdGhlIHJlYWwgaW1hZ2UgZmFpbHMgdG8gbG9hZCwgdGhpcyB3aWxsIGVuc3VyZSBcImFsdFwiIGlzIHZpc2libGVcbiAgICAgICAgICBzZXRTaG93QWx0VGV4dCh0cnVlKVxuICAgICAgICAgIGlmIChwbGFjZWhvbGRlciAhPT0gJ2VtcHR5Jykge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHJlYWwgaW1hZ2UgZmFpbHMgdG8gbG9hZCwgdGhpcyB3aWxsIHN0aWxsIHJlbW92ZSB0aGUgcGxhY2Vob2xkZXIuXG4gICAgICAgICAgICBzZXRCbHVyQ29tcGxldGUodHJ1ZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoZXZlbnQpXG4gICAgICAgICAgfVxuICAgICAgICB9fVxuICAgICAgLz5cbiAgICApXG4gIH1cbilcblxuZnVuY3Rpb24gSW1hZ2VQcmVsb2FkKHtcbiAgaXNBcHBSb3V0ZXIsXG4gIGltZ0F0dHJpYnV0ZXMsXG59OiB7XG4gIGlzQXBwUm91dGVyOiBib29sZWFuXG4gIGltZ0F0dHJpYnV0ZXM6IEltZ1Byb3BzXG59KSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgYXM6ICdpbWFnZScsXG4gICAgaW1hZ2VTcmNTZXQ6IGltZ0F0dHJpYnV0ZXMuc3JjU2V0LFxuICAgIGltYWdlU2l6ZXM6IGltZ0F0dHJpYnV0ZXMuc2l6ZXMsXG4gICAgY3Jvc3NPcmlnaW46IGltZ0F0dHJpYnV0ZXMuY3Jvc3NPcmlnaW4sXG4gICAgcmVmZXJyZXJQb2xpY3k6IGltZ0F0dHJpYnV0ZXMucmVmZXJyZXJQb2xpY3ksXG4gICAgLi4uZ2V0RHluYW1pY1Byb3BzKGltZ0F0dHJpYnV0ZXMuZmV0Y2hQcmlvcml0eSksXG4gIH1cblxuICBpZiAoaXNBcHBSb3V0ZXIgJiYgUmVhY3RET00ucHJlbG9hZCkge1xuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yNjk0MFxuICAgIFJlYWN0RE9NLnByZWxvYWQoXG4gICAgICBpbWdBdHRyaWJ1dGVzLnNyYyxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogdXBncmFkZSB0byBgQHR5cGVzL3JlYWN0LWRvbUAxOC4zLnhgXG4gICAgICBvcHRzXG4gICAgKVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxIZWFkPlxuICAgICAgPGxpbmtcbiAgICAgICAga2V5PXtcbiAgICAgICAgICAnX19uaW1nLScgK1xuICAgICAgICAgIGltZ0F0dHJpYnV0ZXMuc3JjICtcbiAgICAgICAgICBpbWdBdHRyaWJ1dGVzLnNyY1NldCArXG4gICAgICAgICAgaW1nQXR0cmlidXRlcy5zaXplc1xuICAgICAgICB9XG4gICAgICAgIHJlbD1cInByZWxvYWRcIlxuICAgICAgICAvLyBOb3RlIGhvdyB3ZSBvbWl0IHRoZSBgaHJlZmAgYXR0cmlidXRlLCBhcyBpdCB3b3VsZCBvbmx5IGJlIHJlbGV2YW50XG4gICAgICAgIC8vIGZvciBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IGBpbWFnZXNyY3NldGAsIGFuZCBpbiB0aG9zZSBjYXNlc1xuICAgICAgICAvLyBpdCB3b3VsZCBjYXVzZSB0aGUgaW5jb3JyZWN0IGltYWdlIHRvIGJlIHByZWxvYWRlZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjYXR0ci1saW5rLWltYWdlc3Jjc2V0XG4gICAgICAgIGhyZWY9e2ltZ0F0dHJpYnV0ZXMuc3JjU2V0ID8gdW5kZWZpbmVkIDogaW1nQXR0cmlidXRlcy5zcmN9XG4gICAgICAgIHsuLi5vcHRzfVxuICAgICAgLz5cbiAgICA8L0hlYWQ+XG4gIClcbn1cblxuLyoqXG4gKiBUaGUgYEltYWdlYCBjb21wb25lbnQgaXMgdXNlZCB0byBvcHRpbWl6ZSBpbWFnZXMuXG4gKlxuICogUmVhZCBtb3JlOiBbTmV4dC5qcyBkb2NzOiBgSW1hZ2VgXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL2ltYWdlKVxuICovXG5leHBvcnQgY29uc3QgSW1hZ2UgPSBmb3J3YXJkUmVmPEhUTUxJbWFnZUVsZW1lbnQgfCBudWxsLCBJbWFnZVByb3BzPihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCBwYWdlc1JvdXRlciA9IHVzZUNvbnRleHQoUm91dGVyQ29udGV4dClcbiAgICAvLyBXZSdyZSBpbiB0aGUgYXBwIGRpcmVjdG9yeSBpZiB0aGVyZSBpcyBubyBwYWdlcyByb3V0ZXIuXG4gICAgY29uc3QgaXNBcHBSb3V0ZXIgPSAhcGFnZXNSb3V0ZXJcblxuICAgIGNvbnN0IGNvbmZpZ0NvbnRleHQgPSB1c2VDb250ZXh0KEltYWdlQ29uZmlnQ29udGV4dClcbiAgICBjb25zdCBjb25maWcgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgIGNvbnN0IGMgPSBjb25maWdFbnYgfHwgY29uZmlnQ29udGV4dCB8fCBpbWFnZUNvbmZpZ0RlZmF1bHRcbiAgICAgIGNvbnN0IGFsbFNpemVzID0gWy4uLmMuZGV2aWNlU2l6ZXMsIC4uLmMuaW1hZ2VTaXplc10uc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gICAgICBjb25zdCBkZXZpY2VTaXplcyA9IGMuZGV2aWNlU2l6ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gICAgICByZXR1cm4geyAuLi5jLCBhbGxTaXplcywgZGV2aWNlU2l6ZXMgfVxuICAgIH0sIFtjb25maWdDb250ZXh0XSlcblxuICAgIGNvbnN0IHsgb25Mb2FkLCBvbkxvYWRpbmdDb21wbGV0ZSB9ID0gcHJvcHNcbiAgICBjb25zdCBvbkxvYWRSZWYgPSB1c2VSZWYob25Mb2FkKVxuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIG9uTG9hZFJlZi5jdXJyZW50ID0gb25Mb2FkXG4gICAgfSwgW29uTG9hZF0pXG5cbiAgICBjb25zdCBvbkxvYWRpbmdDb21wbGV0ZVJlZiA9IHVzZVJlZihvbkxvYWRpbmdDb21wbGV0ZSlcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZi5jdXJyZW50ID0gb25Mb2FkaW5nQ29tcGxldGVcbiAgICB9LCBbb25Mb2FkaW5nQ29tcGxldGVdKVxuXG4gICAgY29uc3QgW2JsdXJDb21wbGV0ZSwgc2V0Qmx1ckNvbXBsZXRlXSA9IHVzZVN0YXRlKGZhbHNlKVxuICAgIGNvbnN0IFtzaG93QWx0VGV4dCwgc2V0U2hvd0FsdFRleHRdID0gdXNlU3RhdGUoZmFsc2UpXG5cbiAgICBjb25zdCB7IHByb3BzOiBpbWdBdHRyaWJ1dGVzLCBtZXRhOiBpbWdNZXRhIH0gPSBnZXRJbWdQcm9wcyhwcm9wcywge1xuICAgICAgZGVmYXVsdExvYWRlcixcbiAgICAgIGltZ0NvbmY6IGNvbmZpZyxcbiAgICAgIGJsdXJDb21wbGV0ZSxcbiAgICAgIHNob3dBbHRUZXh0LFxuICAgIH0pXG5cbiAgICByZXR1cm4gKFxuICAgICAgPD5cbiAgICAgICAge1xuICAgICAgICAgIDxJbWFnZUVsZW1lbnRcbiAgICAgICAgICAgIHsuLi5pbWdBdHRyaWJ1dGVzfVxuICAgICAgICAgICAgdW5vcHRpbWl6ZWQ9e2ltZ01ldGEudW5vcHRpbWl6ZWR9XG4gICAgICAgICAgICBwbGFjZWhvbGRlcj17aW1nTWV0YS5wbGFjZWhvbGRlcn1cbiAgICAgICAgICAgIGZpbGw9e2ltZ01ldGEuZmlsbH1cbiAgICAgICAgICAgIG9uTG9hZFJlZj17b25Mb2FkUmVmfVxuICAgICAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWY9e29uTG9hZGluZ0NvbXBsZXRlUmVmfVxuICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlPXtzZXRCbHVyQ29tcGxldGV9XG4gICAgICAgICAgICBzZXRTaG93QWx0VGV4dD17c2V0U2hvd0FsdFRleHR9XG4gICAgICAgICAgICBzaXplc0lucHV0PXtwcm9wcy5zaXplc31cbiAgICAgICAgICAgIHJlZj17Zm9yd2FyZGVkUmVmfVxuICAgICAgICAgIC8+XG4gICAgICAgIH1cbiAgICAgICAge2ltZ01ldGEucHJpb3JpdHkgPyAoXG4gICAgICAgICAgPEltYWdlUHJlbG9hZFxuICAgICAgICAgICAgaXNBcHBSb3V0ZXI9e2lzQXBwUm91dGVyfVxuICAgICAgICAgICAgaW1nQXR0cmlidXRlcz17aW1nQXR0cmlidXRlc31cbiAgICAgICAgICAvPlxuICAgICAgICApIDogbnVsbH1cbiAgICAgIDwvPlxuICAgIClcbiAgfVxuKVxuIl0sIm5hbWVzIjpbIkltYWdlIiwiY29uZmlnRW52IiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9JTUFHRV9PUFRTIiwid2luZG93IiwiZ2xvYmFsVGhpcyIsIl9fTkVYVF9JTUFHRV9JTVBPUlRFRCIsImhhbmRsZUxvYWRpbmciLCJpbWciLCJwbGFjZWhvbGRlciIsIm9uTG9hZFJlZiIsIm9uTG9hZGluZ0NvbXBsZXRlUmVmIiwic2V0Qmx1ckNvbXBsZXRlIiwidW5vcHRpbWl6ZWQiLCJzaXplc0lucHV0Iiwic3JjIiwicCIsImRlY29kZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiY2F0Y2giLCJ0aGVuIiwicGFyZW50RWxlbWVudCIsImlzQ29ubmVjdGVkIiwiY3VycmVudCIsImV2ZW50IiwiRXZlbnQiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIndyaXRhYmxlIiwidmFsdWUiLCJwcmV2ZW50ZWQiLCJzdG9wcGVkIiwibmF0aXZlRXZlbnQiLCJjdXJyZW50VGFyZ2V0IiwidGFyZ2V0IiwiaXNEZWZhdWx0UHJldmVudGVkIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJwZXJzaXN0IiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJOT0RFX0VOViIsIm9yaWdTcmMiLCJVUkwiLCJzZWFyY2hQYXJhbXMiLCJnZXQiLCJnZXRBdHRyaWJ1dGUiLCJ3aWR0aFZpZXdwb3J0UmF0aW8iLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aWR0aCIsImlubmVyV2lkdGgiLCJ3YXJuT25jZSIsInBvc2l0aW9uIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInZhbGlkIiwiaW5jbHVkZXMiLCJtYXAiLCJTdHJpbmciLCJqb2luIiwiaGVpZ2h0IiwiaGVpZ2h0TW9kaWZpZWQiLCJ0b1N0cmluZyIsIndpZHRoTW9kaWZpZWQiLCJnZXREeW5hbWljUHJvcHMiLCJmZXRjaFByaW9yaXR5IiwiQm9vbGVhbiIsInVzZSIsImZldGNocHJpb3JpdHkiLCJJbWFnZUVsZW1lbnQiLCJmb3J3YXJkUmVmIiwiZm9yd2FyZGVkUmVmIiwic3JjU2V0Iiwic2l6ZXMiLCJkZWNvZGluZyIsImNsYXNzTmFtZSIsInN0eWxlIiwibG9hZGluZyIsImZpbGwiLCJzZXRTaG93QWx0VGV4dCIsIm9uTG9hZCIsIm9uRXJyb3IiLCJyZXN0Iiwib3duUmVmIiwidXNlQ2FsbGJhY2siLCJjb25zb2xlIiwiZXJyb3IiLCJjb21wbGV0ZSIsInJlZiIsInVzZU1lcmdlZFJlZiIsImRhdGEtbmltZyIsIkltYWdlUHJlbG9hZCIsImlzQXBwUm91dGVyIiwiaW1nQXR0cmlidXRlcyIsIm9wdHMiLCJhcyIsImltYWdlU3JjU2V0IiwiaW1hZ2VTaXplcyIsImNyb3NzT3JpZ2luIiwicmVmZXJyZXJQb2xpY3kiLCJSZWFjdERPTSIsInByZWxvYWQiLCJIZWFkIiwibGluayIsInJlbCIsImhyZWYiLCJ1bmRlZmluZWQiLCJwcm9wcyIsInBhZ2VzUm91dGVyIiwidXNlQ29udGV4dCIsIlJvdXRlckNvbnRleHQiLCJjb25maWdDb250ZXh0IiwiSW1hZ2VDb25maWdDb250ZXh0IiwiY29uZmlnIiwidXNlTWVtbyIsImMiLCJpbWFnZUNvbmZpZ0RlZmF1bHQiLCJhbGxTaXplcyIsImRldmljZVNpemVzIiwic29ydCIsImEiLCJiIiwib25Mb2FkaW5nQ29tcGxldGUiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJibHVyQ29tcGxldGUiLCJ1c2VTdGF0ZSIsInNob3dBbHRUZXh0IiwibWV0YSIsImltZ01ldGEiLCJnZXRJbWdQcm9wcyIsImRlZmF1bHRMb2FkZXIiLCJpbWdDb25mIiwicHJpb3JpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/image-component.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/use-merged-ref.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/client/use-merged-ref.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _type_of = __webpack_require__(/*! @swc/helpers/_/_type_of */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_type_of.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useMergedRef\", ({\n    enumerable: true,\n    get: function get() {\n        return useMergedRef;\n    }\n}));\nvar _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nfunction useMergedRef(refA, refB) {\n    var cleanupA = (0, _react.useRef)(function() {});\n    var cleanupB = (0, _react.useRef)(function() {});\n    return (0, _react.useMemo)(function() {\n        if (!refA || !refB) {\n            return refA || refB;\n        }\n        return function(current) {\n            if (current === null) {\n                cleanupA.current();\n                cleanupB.current();\n            } else {\n                cleanupA.current = applyRef(refA, current);\n                cleanupB.current = applyRef(refB, current);\n            }\n        };\n    }, [\n        refA,\n        refB\n    ]);\n}\nfunction applyRef(refA, current) {\n    if (typeof refA === 'function') {\n        var cleanup = refA(current);\n        if (typeof cleanup === 'function') {\n            return cleanup;\n        } else {\n            return function() {\n                return refA(null);\n            };\n        }\n    } else {\n        refA.current = current;\n        return function() {\n            refA.current = null;\n        };\n    }\n}\nif ((typeof exports[\"default\"] === 'function' || _type_of._(exports[\"default\"]) === 'object' && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === 'undefined') {\n    Object.defineProperty(exports[\"default\"], '__esModule', {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=use-merged-ref.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1tZXJnZWQtcmVmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O2dEQVNnQkE7OztlQUFBQTs7O2lDQVQwQjtBQVNuQyxTQUFTQSxhQUNkQyxJQUFtQixFQUNuQkMsSUFBbUI7SUFFbkIsSUFBTUMsV0FBV0MsQ0FBQUEsR0FBQUEsT0FBQUEsTUFBQUEsRUFBbUIsWUFBTztJQUMzQyxJQUFNQyxXQUFXRCxDQUFBQSxHQUFBQSxPQUFBQSxNQUFBQSxFQUFtQixZQUFPO0lBRTNDLE9BQU9FLENBQUFBLEdBQUFBLE9BQUFBLE9BQUFBLEVBQVE7UUFDYixJQUFJLENBQUNMLFFBQVEsQ0FBQ0MsTUFBTTtZQUNsQixPQUFPRCxRQUFRQztRQUNqQjtRQUVBLE9BQU8sU0FBQ0s7WUFDTixJQUFJQSxZQUFZLE1BQU07Z0JBQ3BCSixTQUFTSSxPQUFPO2dCQUNoQkYsU0FBU0UsT0FBTztZQUNsQixPQUFPO2dCQUNMSixTQUFTSSxPQUFPLEdBQUdDLFNBQVNQLE1BQU1NO2dCQUNsQ0YsU0FBU0UsT0FBTyxHQUFHQyxTQUFTTixNQUFNSztZQUNwQztRQUNGO0lBQ0YsR0FBRztRQUFDTjtRQUFNQztLQUFLO0FBQ2pCO0FBRUEsU0FBU00sU0FDUFAsSUFBZ0MsRUFDaENNLE9BQWlCO0lBRWpCLElBQUksT0FBT04sU0FBUyxZQUFZO1FBQzlCLElBQU1RLFVBQVVSLEtBQUtNO1FBQ3JCLElBQUksT0FBT0UsWUFBWSxZQUFZO1lBQ2pDLE9BQU9BO1FBQ1QsT0FBTztZQUNMLE9BQU87dUJBQU1SLEtBQUs7O1FBQ3BCO0lBQ0YsT0FBTztRQUNMQSxLQUFLTSxPQUFPLEdBQUdBO1FBQ2YsT0FBTztZQUNMTixLQUFLTSxPQUFPLEdBQUc7UUFDakI7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY2xpZW50L3VzZS1tZXJnZWQtcmVmLnRzP2RjYzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlTWVtbywgdXNlUmVmLCB0eXBlIFJlZiB9IGZyb20gJ3JlYWN0J1xuXG4vLyBUaGlzIGlzIGEgY29tcGF0aWJpbGl0eSBob29rIHRvIHN1cHBvcnQgUmVhY3QgMTggYW5kIDE5IHJlZnMuXG4vLyBJbiAxOSwgYSBjbGVhbnVwIGZ1bmN0aW9uIGZyb20gcmVmcyBtYXkgYmUgcmV0dXJuZWQuXG4vLyBJbiAxOCwgcmV0dXJuaW5nIGEgY2xlYW51cCBmdW5jdGlvbiBjcmVhdGVzIGEgd2FybmluZy5cbi8vIFNpbmNlIHdlIHRha2UgdXNlcnNwYWNlIHJlZnMsIHdlIGRvbid0IGtub3cgYWhlYWQgb2YgdGltZSBpZiBhIGNsZWFudXAgZnVuY3Rpb24gd2lsbCBiZSByZXR1cm5lZC5cbi8vIFRoaXMgaW1wbGVtZW50cyBjbGVhbnVwIGZ1bmN0aW9ucyB3aXRoIHRoZSBvbGQgYmVoYXZpb3IgaW4gMTguXG4vLyBXZSBrbm93IHJlZnMgYXJlIGFsd2F5cyBjYWxsZWQgYWx0ZXJuYXRpbmcgd2l0aCBgbnVsbGAgYW5kIHRoZW4gYFRgLlxuLy8gU28gYSBjYWxsIHdpdGggYG51bGxgIG1lYW5zIHdlIG5lZWQgdG8gY2FsbCB0aGUgcHJldmlvdXMgY2xlYW51cCBmdW5jdGlvbnMuXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkUmVmPFRFbGVtZW50PihcbiAgcmVmQTogUmVmPFRFbGVtZW50PixcbiAgcmVmQjogUmVmPFRFbGVtZW50PlxuKTogUmVmPFRFbGVtZW50PiB7XG4gIGNvbnN0IGNsZWFudXBBID0gdXNlUmVmPCgpID0+IHZvaWQ+KCgpID0+IHt9KVxuICBjb25zdCBjbGVhbnVwQiA9IHVzZVJlZjwoKSA9PiB2b2lkPigoKSA9PiB7fSlcblxuICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFyZWZBIHx8ICFyZWZCKSB7XG4gICAgICByZXR1cm4gcmVmQSB8fCByZWZCXG4gICAgfVxuXG4gICAgcmV0dXJuIChjdXJyZW50OiBURWxlbWVudCB8IG51bGwpOiB2b2lkID0+IHtcbiAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIGNsZWFudXBBLmN1cnJlbnQoKVxuICAgICAgICBjbGVhbnVwQi5jdXJyZW50KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsZWFudXBBLmN1cnJlbnQgPSBhcHBseVJlZihyZWZBLCBjdXJyZW50KVxuICAgICAgICBjbGVhbnVwQi5jdXJyZW50ID0gYXBwbHlSZWYocmVmQiwgY3VycmVudClcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtyZWZBLCByZWZCXSlcbn1cblxuZnVuY3Rpb24gYXBwbHlSZWY8VEVsZW1lbnQ+KFxuICByZWZBOiBOb25OdWxsYWJsZTxSZWY8VEVsZW1lbnQ+PixcbiAgY3VycmVudDogVEVsZW1lbnRcbikge1xuICBpZiAodHlwZW9mIHJlZkEgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCBjbGVhbnVwID0gcmVmQShjdXJyZW50KVxuICAgIGlmICh0eXBlb2YgY2xlYW51cCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGNsZWFudXBcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgpID0+IHJlZkEobnVsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVmQS5jdXJyZW50ID0gY3VycmVudFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZWZBLmN1cnJlbnQgPSBudWxsXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsidXNlTWVyZ2VkUmVmIiwicmVmQSIsInJlZkIiLCJjbGVhbnVwQSIsInVzZVJlZiIsImNsZWFudXBCIiwidXNlTWVtbyIsImN1cnJlbnQiLCJhcHBseVJlZiIsImNsZWFudXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/use-merged-ref.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js ***!
  \*************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"AmpStateContext\", ({\n    enumerable: true,\n    get: function get() {\n        return AmpStateContext;\n    }\n}));\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar AmpStateContext = _react[\"default\"].createContext({});\nif (true) {\n    AmpStateContext.displayName = 'AmpStateContext';\n} //# sourceMappingURL=amp-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O21EQUVhQTs7O2VBQUFBOzs7OzBFQUZLO0FBRVgsSUFBTUEsa0JBQXNDQyxNQUFBQSxDQUFBQSxVQUFLLENBQUNDLGFBQWEsQ0FBQyxDQUFDO0FBRXhFLElBQUlDLElBQW9CLEVBQW1CO0lBQ3pDSCxnQkFBZ0JNLFdBQVcsR0FBRztBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvYW1wLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUudHM/OTY0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmV4cG9ydCBjb25zdCBBbXBTdGF0ZUNvbnRleHQ6IFJlYWN0LkNvbnRleHQ8YW55PiA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe30pXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIEFtcFN0YXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdBbXBTdGF0ZUNvbnRleHQnXG59XG4iXSwibmFtZXMiOlsiQW1wU3RhdGVDb250ZXh0IiwiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-mode.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isInAmpMode\", ({\n    enumerable: true,\n    get: function get() {\n        return isInAmpMode;\n    }\n}));\nfunction isInAmpMode(param) {\n    var _ref = param === void 0 ? {} : param, _ref_ampFirst = _ref.ampFirst, ampFirst = _ref_ampFirst === void 0 ? false : _ref_ampFirst, _ref_hybrid = _ref.hybrid, hybrid = _ref_hybrid === void 0 ? false : _ref_hybrid, _ref_hasQuery = _ref.hasQuery, hasQuery = _ref_hasQuery === void 0 ? false : _ref_hasQuery;\n    return ampFirst || hybrid && hasQuery;\n} //# sourceMappingURL=amp-mode.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtbW9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7OytDQUFnQkE7OztlQUFBQTs7O0FBQVQsU0FBU0EsWUFBWTtJQUFBLDhCQUl4QixDQUFDLElBSnVCLHNDQUMxQkMsc0NBQVcsS0FBSyw2Q0FDaEJDLGtDQUFTLEtBQUssZ0NBRlksZUFHMUJDLHNDQUFXLEtBQUssRUFDakI7SUFDQyxPQUFPRixZQUFhQyxVQUFVQztBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvYW1wLW1vZGUudHM/Y2UwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gaXNJbkFtcE1vZGUoe1xuICBhbXBGaXJzdCA9IGZhbHNlLFxuICBoeWJyaWQgPSBmYWxzZSxcbiAgaGFzUXVlcnkgPSBmYWxzZSxcbn0gPSB7fSk6IGJvb2xlYW4ge1xuICByZXR1cm4gYW1wRmlyc3QgfHwgKGh5YnJpZCAmJiBoYXNRdWVyeSlcbn1cbiJdLCJuYW1lcyI6WyJpc0luQW1wTW9kZSIsImFtcEZpcnN0IiwiaHlicmlkIiwiaGFzUXVlcnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/get-img-props.js ***!
  \************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_object_spread.js\");\nvar _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_object_spread_props.js\");\nvar _object_without_properties = __webpack_require__(/*! @swc/helpers/_/_object_without_properties */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_object_without_properties.js\");\nvar _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_sliced_to_array.js\");\nvar _to_consumable_array = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_to_consumable_array.js\");\nvar _type_of = __webpack_require__(/*! @swc/helpers/_/_type_of */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_type_of.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImgProps\", ({\n    enumerable: true,\n    get: function get() {\n        return getImgProps;\n    }\n}));\nvar _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nvar _imageblursvg = __webpack_require__(/*! ./image-blur-svg */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js\");\nvar _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nvar VALID_LOADING_VALUES = [\n    'lazy',\n    'eager',\n    undefined\n];\nfunction isStaticRequire(src) {\n    return src[\"default\"] !== undefined;\n}\nfunction isStaticImageData(src) {\n    return src.src !== undefined;\n}\nfunction isStaticImport(src) {\n    return !!src && (typeof src === \"undefined\" ? \"undefined\" : _type_of._(src)) === 'object' && (isStaticRequire(src) || isStaticImageData(src));\n}\nvar allImgs = new Map();\nvar perfObserver;\nfunction getInt(x) {\n    if (typeof x === 'undefined') {\n        return x;\n    }\n    if (typeof x === 'number') {\n        return Number.isFinite(x) ? x : NaN;\n    }\n    if (typeof x === 'string' && /^[0-9]+$/.test(x)) {\n        return parseInt(x, 10);\n    }\n    return NaN;\n}\nfunction getWidths(param, width, sizes) {\n    var deviceSizes = param.deviceSizes, allSizes = param.allSizes;\n    if (sizes) {\n        // Find all the \"vw\" percent sizes used in the sizes prop\n        var viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n        var percentSizes = [];\n        for(var match; match = viewportWidthRe.exec(sizes); match){\n            percentSizes.push(parseInt(match[2]));\n        }\n        if (percentSizes.length) {\n            var _Math;\n            var smallestRatio = (_Math = Math).min.apply(_Math, _to_consumable_array._(percentSizes)) * 0.01;\n            return {\n                widths: allSizes.filter(function(s) {\n                    return s >= deviceSizes[0] * smallestRatio;\n                }),\n                kind: 'w'\n            };\n        }\n        return {\n            widths: allSizes,\n            kind: 'w'\n        };\n    }\n    if (typeof width !== 'number') {\n        return {\n            widths: deviceSizes,\n            kind: 'w'\n        };\n    }\n    var widths = _to_consumable_array._(new Set(// > are actually 3x in the green color, but only 1.5x in the red and\n    // > blue colors. Showing a 3x resolution image in the app vs a 2x\n    // > resolution image will be visually the same, though the 3x image\n    // > takes significantly more data. Even true 3x resolution screens are\n    // > wasteful as the human eye cannot see that level of detail without\n    // > something like a magnifying glass.\n    // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n    [\n        width,\n        width * 2 /*, width * 3*/ \n    ].map(function(w) {\n        return allSizes.find(function(p) {\n            return p >= w;\n        }) || allSizes[allSizes.length - 1];\n    })));\n    return {\n        widths: widths,\n        kind: 'x'\n    };\n}\nfunction generateImgAttrs(param) {\n    var config = param.config, src = param.src, unoptimized = param.unoptimized, width = param.width, quality = param.quality, sizes = param.sizes, loader = param.loader;\n    if (unoptimized) {\n        return {\n            src: src,\n            srcSet: undefined,\n            sizes: undefined\n        };\n    }\n    var _getWidths = getWidths(config, width, sizes), widths = _getWidths.widths, kind = _getWidths.kind;\n    var last = widths.length - 1;\n    return {\n        sizes: !sizes && kind === 'w' ? '100vw' : sizes,\n        srcSet: widths.map(function(w, i) {\n            return loader({\n                config: config,\n                src: src,\n                quality: quality,\n                width: w\n            }) + \" \" + (kind === 'w' ? w : i + 1) + kind;\n        }).join(', '),\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        src: loader({\n            config: config,\n            src: src,\n            quality: quality,\n            width: widths[last]\n        })\n    };\n}\nfunction getImgProps(param, _state) {\n    var src = param.src, sizes = param.sizes, _param_unoptimized = param.unoptimized, unoptimized = _param_unoptimized === void 0 ? false : _param_unoptimized, _param_priority = param.priority, priority = _param_priority === void 0 ? false : _param_priority, loading = param.loading, className = param.className, quality = param.quality, width = param.width, height = param.height, _param_fill = param.fill, fill = _param_fill === void 0 ? false : _param_fill, style = param.style, overrideSrc = param.overrideSrc, onLoad = param.onLoad, onLoadingComplete = param.onLoadingComplete, _param_placeholder = param.placeholder, placeholder = _param_placeholder === void 0 ? 'empty' : _param_placeholder, blurDataURL = param.blurDataURL, fetchPriority = param.fetchPriority, _param_decoding = param.decoding, decoding = _param_decoding === void 0 ? 'async' : _param_decoding, layout = param.layout, objectFit = param.objectFit, objectPosition = param.objectPosition, lazyBoundary = param.lazyBoundary, lazyRoot = param.lazyRoot, rest = _object_without_properties._(param, [\n        \"src\",\n        \"sizes\",\n        \"unoptimized\",\n        \"priority\",\n        \"loading\",\n        \"className\",\n        \"quality\",\n        \"width\",\n        \"height\",\n        \"fill\",\n        \"style\",\n        \"overrideSrc\",\n        \"onLoad\",\n        \"onLoadingComplete\",\n        \"placeholder\",\n        \"blurDataURL\",\n        \"fetchPriority\",\n        \"decoding\",\n        \"layout\",\n        \"objectFit\",\n        \"objectPosition\",\n        \"lazyBoundary\",\n        \"lazyRoot\"\n    ]);\n    var imgConf = _state.imgConf, showAltText = _state.showAltText, blurComplete = _state.blurComplete, defaultLoader = _state.defaultLoader;\n    var config;\n    var c = imgConf || _imageconfig.imageConfigDefault;\n    if ('allSizes' in c) {\n        config = c;\n    } else {\n        var allSizes = _to_consumable_array._(c.deviceSizes).concat(_to_consumable_array._(c.imageSizes)).sort(function(a, b) {\n            return a - b;\n        });\n        var deviceSizes = c.deviceSizes.sort(function(a, b) {\n            return a - b;\n        });\n        config = _object_spread_props._(_object_spread._({}, c), {\n            allSizes: allSizes,\n            deviceSizes: deviceSizes\n        });\n    }\n    if (typeof defaultLoader === 'undefined') {\n        throw new Error('images.loaderFile detected but the file is missing default export.\\nRead more: https://nextjs.org/docs/messages/invalid-images-config');\n    }\n    var loader = rest.loader || defaultLoader;\n    // Remove property so it's not spread on <img> element\n    delete rest.loader;\n    delete rest.srcSet;\n    // This special value indicates that the user\n    // didn't define a \"loader\" prop or \"loader\" config.\n    var isDefaultLoader = '__next_img_default' in loader;\n    if (isDefaultLoader) {\n        if (config.loader === 'custom') {\n            throw new Error('Image with src \"' + src + '\" is missing \"loader\" prop.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader\");\n        }\n    } else {\n        // The user defined a \"loader\" prop or config.\n        // Since the config object is internal only, we\n        // must not pass it to the user-defined \"loader\".\n        var customImageLoader = loader;\n        loader = function(obj) {\n            var _ = obj.config, opts = _object_without_properties._(obj, [\n                \"config\"\n            ]);\n            return customImageLoader(opts);\n        };\n    }\n    if (layout) {\n        if (layout === 'fill') {\n            fill = true;\n        }\n        var layoutToStyle = {\n            intrinsic: {\n                maxWidth: '100%',\n                height: 'auto'\n            },\n            responsive: {\n                width: '100%',\n                height: 'auto'\n            }\n        };\n        var layoutToSizes = {\n            responsive: '100vw',\n            fill: '100vw'\n        };\n        var layoutStyle = layoutToStyle[layout];\n        if (layoutStyle) {\n            style = _object_spread._({}, style, layoutStyle);\n        }\n        var layoutSizes = layoutToSizes[layout];\n        if (layoutSizes && !sizes) {\n            sizes = layoutSizes;\n        }\n    }\n    var staticSrc = '';\n    var widthInt = getInt(width);\n    var heightInt = getInt(height);\n    var blurWidth;\n    var blurHeight;\n    if (isStaticImport(src)) {\n        var staticImageData = isStaticRequire(src) ? src[\"default\"] : src;\n        if (!staticImageData.src) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received \" + JSON.stringify(staticImageData));\n        }\n        if (!staticImageData.height || !staticImageData.width) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received \" + JSON.stringify(staticImageData));\n        }\n        blurWidth = staticImageData.blurWidth;\n        blurHeight = staticImageData.blurHeight;\n        blurDataURL = blurDataURL || staticImageData.blurDataURL;\n        staticSrc = staticImageData.src;\n        if (!fill) {\n            if (!widthInt && !heightInt) {\n                widthInt = staticImageData.width;\n                heightInt = staticImageData.height;\n            } else if (widthInt && !heightInt) {\n                var ratio = widthInt / staticImageData.width;\n                heightInt = Math.round(staticImageData.height * ratio);\n            } else if (!widthInt && heightInt) {\n                var ratio1 = heightInt / staticImageData.height;\n                widthInt = Math.round(staticImageData.width * ratio1);\n            }\n        }\n    }\n    src = typeof src === 'string' ? src : staticSrc;\n    var isLazy = !priority && (loading === 'lazy' || typeof loading === 'undefined');\n    if (!src || src.startsWith('data:') || src.startsWith('blob:')) {\n        // https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n        unoptimized = true;\n        isLazy = false;\n    }\n    if (config.unoptimized) {\n        unoptimized = true;\n    }\n    if (isDefaultLoader && src.endsWith('.svg') && !config.dangerouslyAllowSVG) {\n        // Special case to make svg serve as-is to avoid proxying\n        // through the built-in Image Optimization API.\n        unoptimized = true;\n    }\n    var qualityInt = getInt(quality);\n    if (true) {\n        if (config.output === 'export' && isDefaultLoader && !unoptimized) {\n            throw new Error(\"Image Optimization using the default loader is not compatible with `{ output: 'export' }`.\\n  Possible solutions:\\n    - Remove `{ output: 'export' }` and run \\\"next start\\\" to run server mode including the Image Optimization API.\\n    - Configure `{ images: { unoptimized: true } }` in `next.config.js` to disable the Image Optimization API.\\n  Read more: https://nextjs.org/docs/messages/export-image-api\");\n        }\n        if (!src) {\n            // React doesn't show the stack trace and there's\n            // no `src` to help identify which image, so we\n            // instead console.error(ref) during mount.\n            unoptimized = true;\n        } else {\n            if (fill) {\n                if (width) {\n                    throw new Error('Image with src \"' + src + '\" has both \"width\" and \"fill\" properties. Only one should be used.');\n                }\n                if (height) {\n                    throw new Error('Image with src \"' + src + '\" has both \"height\" and \"fill\" properties. Only one should be used.');\n                }\n                if ((style == null ? void 0 : style.position) && style.position !== 'absolute') {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.position\" properties. Images with \"fill\" always use position absolute - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.width) && style.width !== '100%') {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.width\" properties. Images with \"fill\" always use width 100% - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.height) && style.height !== '100%') {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.height\" properties. Images with \"fill\" always use height 100% - it cannot be modified.');\n                }\n            } else {\n                if (typeof widthInt === 'undefined') {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"width\" property.');\n                } else if (isNaN(widthInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"width\" property. Expected a numeric value in pixels but received \"' + width + '\".');\n                }\n                if (typeof heightInt === 'undefined') {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"height\" property.');\n                } else if (isNaN(heightInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"height\" property. Expected a numeric value in pixels but received \"' + height + '\".');\n                }\n                // eslint-disable-next-line no-control-regex\n                if (/^[\\x00-\\x20]/.test(src)) {\n                    throw new Error('Image with src \"' + src + '\" cannot start with a space or control character. Use src.trimStart() to remove it or encodeURIComponent(src) to keep it.');\n                }\n                // eslint-disable-next-line no-control-regex\n                if (/[\\x00-\\x20]$/.test(src)) {\n                    throw new Error('Image with src \"' + src + '\" cannot end with a space or control character. Use src.trimEnd() to remove it or encodeURIComponent(src) to keep it.');\n                }\n            }\n        }\n        if (!VALID_LOADING_VALUES.includes(loading)) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"loading\" property. Provided \"' + loading + '\" should be one of ' + VALID_LOADING_VALUES.map(String).join(',') + \".\");\n        }\n        if (priority && loading === 'lazy') {\n            throw new Error('Image with src \"' + src + '\" has both \"priority\" and \"loading=\\'lazy\\'\" properties. Only one should be used.');\n        }\n        if (placeholder !== 'empty' && placeholder !== 'blur' && !placeholder.startsWith('data:image/')) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"placeholder\" property \"' + placeholder + '\".');\n        }\n        if (placeholder !== 'empty') {\n            if (widthInt && heightInt && widthInt * heightInt < 1600) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is smaller than 40x40. Consider removing the \"placeholder\" property to improve performance.');\n            }\n        }\n        if (placeholder === 'blur' && !blurDataURL) {\n            var VALID_BLUR_EXT = [\n                'jpeg',\n                'png',\n                'webp',\n                'avif'\n            ] // should match next-image-loader\n            ;\n            throw new Error('Image with src \"' + src + '\" has \"placeholder=\\'blur\\'\" property but is missing the \"blurDataURL\" property.\\n        Possible solutions:\\n          - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\\n          - Change the \"src\" property to a static import with one of the supported file types: ' + VALID_BLUR_EXT.join(',') + ' (animated images not supported)\\n          - Remove the \"placeholder\" property, effectively no blur effect\\n        Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url');\n        }\n        if ('ref' in rest) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using unsupported \"ref\" property. Consider using the \"onLoad\" property instead.');\n        }\n        if (!unoptimized && !isDefaultLoader) {\n            var urlStr = loader({\n                config: config,\n                src: src,\n                width: widthInt || 400,\n                quality: qualityInt || 75\n            });\n            var url;\n            try {\n                url = new URL(urlStr);\n            } catch (err) {}\n            if (urlStr === src || url && url.pathname === src && !url.search) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width\");\n            }\n        }\n        if (onLoadingComplete) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using deprecated \"onLoadingComplete\" property. Please use the \"onLoad\" property instead.');\n        }\n        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n        try {\n            for(var _iterator = Object.entries({\n                layout: layout,\n                objectFit: objectFit,\n                objectPosition: objectPosition,\n                lazyBoundary: lazyBoundary,\n                lazyRoot: lazyRoot\n            })[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                var _step_value = _sliced_to_array._(_step.value, 2), legacyKey = _step_value[0], legacyValue = _step_value[1];\n                if (legacyValue) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has legacy prop \"' + legacyKey + '\". Did you forget to run the codemod?' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-upgrade-to-13\");\n                }\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                    _iterator[\"return\"]();\n                }\n            } finally{\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n        if (typeof window !== 'undefined' && !perfObserver && window.PerformanceObserver) {\n            perfObserver = new PerformanceObserver(function(entryList) {\n                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n                try {\n                    for(var _iterator = entryList.getEntries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                        var entry = _step.value;\n                        var _entry_element;\n                        // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n                        var imgSrc = (entry == null ? void 0 : (_entry_element = entry.element) == null ? void 0 : _entry_element.src) || '';\n                        var lcpImage = allImgs.get(imgSrc);\n                        if (lcpImage && !lcpImage.priority && lcpImage.placeholder === 'empty' && !lcpImage.src.startsWith('data:') && !lcpImage.src.startsWith('blob:')) {\n                            // https://web.dev/lcp/#measure-lcp-in-javascript\n                            (0, _warnonce.warnOnce)('Image with src \"' + lcpImage.src + '\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.' + \"\\nRead more: https://nextjs.org/docs/api-reference/next/image#priority\");\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally{\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                            _iterator[\"return\"]();\n                        }\n                    } finally{\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n            });\n            try {\n                perfObserver.observe({\n                    type: 'largest-contentful-paint',\n                    buffered: true\n                });\n            } catch (err) {\n                // Log error but don't crash the app\n                console.error(err);\n            }\n        }\n    }\n    var imgStyle = Object.assign(fill ? {\n        position: 'absolute',\n        height: '100%',\n        width: '100%',\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        objectFit: objectFit,\n        objectPosition: objectPosition\n    } : {}, showAltText ? {} : {\n        color: 'transparent'\n    }, style);\n    var backgroundImage = !blurComplete && placeholder !== 'empty' ? placeholder === 'blur' ? 'url(\"data:image/svg+xml;charset=utf-8,' + (0, _imageblursvg.getImageBlurSvg)({\n        widthInt: widthInt,\n        heightInt: heightInt,\n        blurWidth: blurWidth,\n        blurHeight: blurHeight,\n        blurDataURL: blurDataURL || '',\n        objectFit: imgStyle.objectFit\n    }) + '\")' : 'url(\"' + placeholder + '\")' // assume `data:image/`\n     : null;\n    var placeholderStyle = backgroundImage ? {\n        backgroundSize: imgStyle.objectFit || 'cover',\n        backgroundPosition: imgStyle.objectPosition || '50% 50%',\n        backgroundRepeat: 'no-repeat',\n        backgroundImage: backgroundImage\n    } : {};\n    if (true) {\n        if (placeholderStyle.backgroundImage && placeholder === 'blur' && (blurDataURL == null ? void 0 : blurDataURL.startsWith('/'))) {\n            // During `next dev`, we don't want to generate blur placeholders with webpack\n            // because it can delay starting the dev server. Instead, `next-image-loader.js`\n            // will inline a special url to lazily generate the blur placeholder at request time.\n            placeholderStyle.backgroundImage = 'url(\"' + blurDataURL + '\")';\n        }\n    }\n    var imgAttributes = generateImgAttrs({\n        config: config,\n        src: src,\n        unoptimized: unoptimized,\n        width: widthInt,\n        quality: qualityInt,\n        sizes: sizes,\n        loader: loader\n    });\n    if (true) {\n        if (typeof window !== 'undefined') {\n            var fullUrl;\n            try {\n                fullUrl = new URL(imgAttributes.src);\n            } catch (e) {\n                fullUrl = new URL(imgAttributes.src, window.location.href);\n            }\n            allImgs.set(fullUrl.href, {\n                src: src,\n                priority: priority,\n                placeholder: placeholder\n            });\n        }\n    }\n    var props = _object_spread_props._(_object_spread._({}, rest), {\n        loading: isLazy ? 'lazy' : loading,\n        fetchPriority: fetchPriority,\n        width: widthInt,\n        height: heightInt,\n        decoding: decoding,\n        className: className,\n        style: _object_spread._({}, imgStyle, placeholderStyle),\n        sizes: imgAttributes.sizes,\n        srcSet: imgAttributes.srcSet,\n        src: overrideSrc || imgAttributes.src\n    });\n    var meta = {\n        unoptimized: unoptimized,\n        priority: priority,\n        placeholder: placeholder,\n        fill: fill\n    };\n    return {\n        props: props,\n        meta: meta\n    };\n} //# sourceMappingURL=get-img-props.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7K0NBOE9nQkE7OztlQUFBQTs7O29DQTlPUzt3Q0FDTzt1Q0FDRztBQStFbkMsSUFBTUMsdUJBQXVCO0lBQUM7SUFBUTtJQUFTQztDQUFVO0FBa0J6RCxTQUFTQyxnQkFDUEMsR0FBb0M7SUFFcEMsT0FBUUEsSUFBc0JDLFVBQU8sS0FBS0g7QUFDNUM7QUFFQSxTQUFTSSxrQkFDUEYsR0FBb0M7SUFFcEMsT0FBUUEsSUFBd0JBLEdBQUcsS0FBS0Y7QUFDMUM7QUFFQSxTQUFTSyxlQUFlSCxHQUEwQjtJQUNoRCxPQUNFLENBQUMsQ0FBQ0EsbURBQ0YsVUFBT0EsQ0FBQUEsSUFBQUEsTUFBUSxZQUNkRCxDQUFBQSxnQkFBZ0JDLFFBQ2ZFLGtCQUFrQkYsSUFBQUEsQ0FBbUI7QUFFM0M7QUFFQSxJQUFNSSxVQUFVLElBQUlDO0FBSXBCLElBQUlDO0FBRUosU0FBU0MsT0FBT0MsQ0FBVTtJQUN4QixJQUFJLE9BQU9BLE1BQU0sYUFBYTtRQUM1QixPQUFPQTtJQUNUO0lBQ0EsSUFBSSxPQUFPQSxNQUFNLFVBQVU7UUFDekIsT0FBT0MsT0FBT0MsUUFBUSxDQUFDRixLQUFLQSxJQUFJRztJQUNsQztJQUNBLElBQUksT0FBT0gsTUFBTSxZQUFZLFdBQVdJLElBQUksQ0FBQ0osSUFBSTtRQUMvQyxPQUFPSyxTQUFTTCxHQUFHO0lBQ3JCO0lBQ0EsT0FBT0c7QUFDVDtBQUVBLFNBQVNHLFVBQ1AsS0FBc0MsRUFDdENDLEtBQXlCLEVBQ3pCQyxLQUF5QjtJQUZ6Qix3QkFBRUMsV0FBVyxhQUFiLE1BQWVDLFFBQVE7SUFJdkIsSUFBSUYsT0FBTztRQUNULHlEQUF5RDtRQUN6RCxJQUFNRyxrQkFBa0I7UUFDeEIsSUFBTUMsZUFBZSxFQUFFO1FBQ3ZCLElBQUssSUFBSUMsT0FBUUEsUUFBUUYsZ0JBQWdC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RztjQUFPQztJQUFLO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzLnRzP2VjOTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tICcuL3V0aWxzL3dhcm4tb25jZSdcbmltcG9ydCB7IGdldEltYWdlQmx1clN2ZyB9IGZyb20gJy4vaW1hZ2UtYmx1ci1zdmcnXG5pbXBvcnQgeyBpbWFnZUNvbmZpZ0RlZmF1bHQgfSBmcm9tICcuL2ltYWdlLWNvbmZpZydcbmltcG9ydCB0eXBlIHtcbiAgSW1hZ2VDb25maWdDb21wbGV0ZSxcbiAgSW1hZ2VMb2FkZXJQcm9wcyxcbiAgSW1hZ2VMb2FkZXJQcm9wc1dpdGhDb25maWcsXG59IGZyb20gJy4vaW1hZ2UtY29uZmlnJ1xuXG5pbXBvcnQgdHlwZSB7IEpTWCB9IGZyb20gJ3JlYWN0J1xuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRpY0ltYWdlRGF0YSB7XG4gIHNyYzogc3RyaW5nXG4gIGhlaWdodDogbnVtYmVyXG4gIHdpZHRoOiBudW1iZXJcbiAgYmx1ckRhdGFVUkw/OiBzdHJpbmdcbiAgYmx1cldpZHRoPzogbnVtYmVyXG4gIGJsdXJIZWlnaHQ/OiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGF0aWNSZXF1aXJlIHtcbiAgZGVmYXVsdDogU3RhdGljSW1hZ2VEYXRhXG59XG5cbmV4cG9ydCB0eXBlIFN0YXRpY0ltcG9ydCA9IFN0YXRpY1JlcXVpcmUgfCBTdGF0aWNJbWFnZURhdGFcblxuZXhwb3J0IHR5cGUgSW1hZ2VQcm9wcyA9IE9taXQ8XG4gIEpTWC5JbnRyaW5zaWNFbGVtZW50c1snaW1nJ10sXG4gICdzcmMnIHwgJ3NyY1NldCcgfCAncmVmJyB8ICdhbHQnIHwgJ3dpZHRoJyB8ICdoZWlnaHQnIHwgJ2xvYWRpbmcnXG4+ICYge1xuICBzcmM6IHN0cmluZyB8IFN0YXRpY0ltcG9ydFxuICBhbHQ6IHN0cmluZ1xuICB3aWR0aD86IG51bWJlciB8IGAke251bWJlcn1gXG4gIGhlaWdodD86IG51bWJlciB8IGAke251bWJlcn1gXG4gIGZpbGw/OiBib29sZWFuXG4gIGxvYWRlcj86IEltYWdlTG9hZGVyXG4gIHF1YWxpdHk/OiBudW1iZXIgfCBgJHtudW1iZXJ9YFxuICBwcmlvcml0eT86IGJvb2xlYW5cbiAgbG9hZGluZz86IExvYWRpbmdWYWx1ZVxuICBwbGFjZWhvbGRlcj86IFBsYWNlaG9sZGVyVmFsdWVcbiAgYmx1ckRhdGFVUkw/OiBzdHJpbmdcbiAgdW5vcHRpbWl6ZWQ/OiBib29sZWFuXG4gIG92ZXJyaWRlU3JjPzogc3RyaW5nXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYG9uTG9hZGAgaW5zdGVhZC5cbiAgICogQHNlZSBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL2ltYWdlI29ubG9hZFxuICAgKi9cbiAgb25Mb2FkaW5nQ29tcGxldGU/OiBPbkxvYWRpbmdDb21wbGV0ZVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBmaWxsYCBwcm9wIGluc3RlYWQgb2YgYGxheW91dD1cImZpbGxcImAgb3IgY2hhbmdlIGltcG9ydCB0byBgbmV4dC9sZWdhY3kvaW1hZ2VgLlxuICAgKiBAc2VlIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9sZWdhY3kvaW1hZ2VcbiAgICovXG4gIGxheW91dD86IHN0cmluZ1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBzdHlsZWAgcHJvcCBpbnN0ZWFkLlxuICAgKi9cbiAgb2JqZWN0Rml0Pzogc3RyaW5nXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYHN0eWxlYCBwcm9wIGluc3RlYWQuXG4gICAqL1xuICBvYmplY3RQb3NpdGlvbj86IHN0cmluZ1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVGhpcyBwcm9wIGRvZXMgbm90IGRvIGFueXRoaW5nLlxuICAgKi9cbiAgbGF6eUJvdW5kYXJ5Pzogc3RyaW5nXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBUaGlzIHByb3AgZG9lcyBub3QgZG8gYW55dGhpbmcuXG4gICAqL1xuICBsYXp5Um9vdD86IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBJbWdQcm9wcyA9IE9taXQ8SW1hZ2VQcm9wcywgJ3NyYycgfCAnbG9hZGVyJz4gJiB7XG4gIGxvYWRpbmc6IExvYWRpbmdWYWx1ZVxuICB3aWR0aDogbnVtYmVyIHwgdW5kZWZpbmVkXG4gIGhlaWdodDogbnVtYmVyIHwgdW5kZWZpbmVkXG4gIHN0eWxlOiBOb25OdWxsYWJsZTxKU1guSW50cmluc2ljRWxlbWVudHNbJ2ltZyddWydzdHlsZSddPlxuICBzaXplczogc3RyaW5nIHwgdW5kZWZpbmVkXG4gIHNyY1NldDogc3RyaW5nIHwgdW5kZWZpbmVkXG4gIHNyYzogc3RyaW5nXG59XG5cbmNvbnN0IFZBTElEX0xPQURJTkdfVkFMVUVTID0gWydsYXp5JywgJ2VhZ2VyJywgdW5kZWZpbmVkXSBhcyBjb25zdFxudHlwZSBMb2FkaW5nVmFsdWUgPSAodHlwZW9mIFZBTElEX0xPQURJTkdfVkFMVUVTKVtudW1iZXJdXG50eXBlIEltYWdlQ29uZmlnID0gSW1hZ2VDb25maWdDb21wbGV0ZSAmIHtcbiAgYWxsU2l6ZXM6IG51bWJlcltdXG4gIG91dHB1dD86ICdzdGFuZGFsb25lJyB8ICdleHBvcnQnXG59XG5cbmV4cG9ydCB0eXBlIEltYWdlTG9hZGVyID0gKHA6IEltYWdlTG9hZGVyUHJvcHMpID0+IHN0cmluZ1xuXG4vLyBEbyBub3QgZXhwb3J0IC0gdGhpcyBpcyBhbiBpbnRlcm5hbCB0eXBlIG9ubHlcbi8vIGJlY2F1c2UgYG5leHQuY29uZmlnLmpzYCBpcyBvbmx5IG1lYW50IGZvciB0aGVcbi8vIGJ1aWx0LWluIGxvYWRlcnMsIG5vdCBmb3IgYSBjdXN0b20gbG9hZGVyKCkgcHJvcC5cbnR5cGUgSW1hZ2VMb2FkZXJXaXRoQ29uZmlnID0gKHA6IEltYWdlTG9hZGVyUHJvcHNXaXRoQ29uZmlnKSA9PiBzdHJpbmdcblxuZXhwb3J0IHR5cGUgUGxhY2Vob2xkZXJWYWx1ZSA9ICdibHVyJyB8ICdlbXB0eScgfCBgZGF0YTppbWFnZS8ke3N0cmluZ31gXG5leHBvcnQgdHlwZSBPbkxvYWQgPSBSZWFjdC5SZWFjdEV2ZW50SGFuZGxlcjxIVE1MSW1hZ2VFbGVtZW50PiB8IHVuZGVmaW5lZFxuZXhwb3J0IHR5cGUgT25Mb2FkaW5nQ29tcGxldGUgPSAoaW1nOiBIVE1MSW1hZ2VFbGVtZW50KSA9PiB2b2lkXG5cbmZ1bmN0aW9uIGlzU3RhdGljUmVxdWlyZShcbiAgc3JjOiBTdGF0aWNSZXF1aXJlIHwgU3RhdGljSW1hZ2VEYXRhXG4pOiBzcmMgaXMgU3RhdGljUmVxdWlyZSB7XG4gIHJldHVybiAoc3JjIGFzIFN0YXRpY1JlcXVpcmUpLmRlZmF1bHQgIT09IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc1N0YXRpY0ltYWdlRGF0YShcbiAgc3JjOiBTdGF0aWNSZXF1aXJlIHwgU3RhdGljSW1hZ2VEYXRhXG4pOiBzcmMgaXMgU3RhdGljSW1hZ2VEYXRhIHtcbiAgcmV0dXJuIChzcmMgYXMgU3RhdGljSW1hZ2VEYXRhKS5zcmMgIT09IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc1N0YXRpY0ltcG9ydChzcmM6IHN0cmluZyB8IFN0YXRpY0ltcG9ydCk6IHNyYyBpcyBTdGF0aWNJbXBvcnQge1xuICByZXR1cm4gKFxuICAgICEhc3JjICYmXG4gICAgdHlwZW9mIHNyYyA9PT0gJ29iamVjdCcgJiZcbiAgICAoaXNTdGF0aWNSZXF1aXJlKHNyYyBhcyBTdGF0aWNJbXBvcnQpIHx8XG4gICAgICBpc1N0YXRpY0ltYWdlRGF0YShzcmMgYXMgU3RhdGljSW1wb3J0KSlcbiAgKVxufVxuXG5jb25zdCBhbGxJbWdzID0gbmV3IE1hcDxcbiAgc3RyaW5nLFxuICB7IHNyYzogc3RyaW5nOyBwcmlvcml0eTogYm9vbGVhbjsgcGxhY2Vob2xkZXI6IFBsYWNlaG9sZGVyVmFsdWUgfVxuPigpXG5sZXQgcGVyZk9ic2VydmVyOiBQZXJmb3JtYW5jZU9ic2VydmVyIHwgdW5kZWZpbmVkXG5cbmZ1bmN0aW9uIGdldEludCh4OiB1bmtub3duKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHR5cGVvZiB4ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB4XG4gIH1cbiAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUoeCkgPyB4IDogTmFOXG4gIH1cbiAgaWYgKHR5cGVvZiB4ID09PSAnc3RyaW5nJyAmJiAvXlswLTldKyQvLnRlc3QoeCkpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoeCwgMTApXG4gIH1cbiAgcmV0dXJuIE5hTlxufVxuXG5mdW5jdGlvbiBnZXRXaWR0aHMoXG4gIHsgZGV2aWNlU2l6ZXMsIGFsbFNpemVzIH06IEltYWdlQ29uZmlnLFxuICB3aWR0aDogbnVtYmVyIHwgdW5kZWZpbmVkLFxuICBzaXplczogc3RyaW5nIHwgdW5kZWZpbmVkXG4pOiB7IHdpZHRoczogbnVtYmVyW107IGtpbmQ6ICd3JyB8ICd4JyB9IHtcbiAgaWYgKHNpemVzKSB7XG4gICAgLy8gRmluZCBhbGwgdGhlIFwidndcIiBwZXJjZW50IHNpemVzIHVzZWQgaW4gdGhlIHNpemVzIHByb3BcbiAgICBjb25zdCB2aWV3cG9ydFdpZHRoUmUgPSAvKF58XFxzKSgxP1xcZD9cXGQpdncvZ1xuICAgIGNvbnN0IHBlcmNlbnRTaXplcyA9IFtdXG4gICAgZm9yIChsZXQgbWF0Y2g7IChtYXRjaCA9IHZpZXdwb3J0V2lkdGhSZS5leGVjKHNpemVzKSk7IG1hdGNoKSB7XG4gICAgICBwZXJjZW50U2l6ZXMucHVzaChwYXJzZUludChtYXRjaFsyXSkpXG4gICAgfVxuICAgIGlmIChwZXJjZW50U2l6ZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzbWFsbGVzdFJhdGlvID0gTWF0aC5taW4oLi4ucGVyY2VudFNpemVzKSAqIDAuMDFcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoczogYWxsU2l6ZXMuZmlsdGVyKChzKSA9PiBzID49IGRldmljZVNpemVzWzBdICogc21hbGxlc3RSYXRpbyksXG4gICAgICAgIGtpbmQ6ICd3JyxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgd2lkdGhzOiBhbGxTaXplcywga2luZDogJ3cnIH1cbiAgfVxuICBpZiAodHlwZW9mIHdpZHRoICE9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB7IHdpZHRoczogZGV2aWNlU2l6ZXMsIGtpbmQ6ICd3JyB9XG4gIH1cblxuICBjb25zdCB3aWR0aHMgPSBbXG4gICAgLi4ubmV3IFNldChcbiAgICAgIC8vID4gVGhpcyBtZWFucyB0aGF0IG1vc3QgT0xFRCBzY3JlZW5zIHRoYXQgc2F5IHRoZXkgYXJlIDN4IHJlc29sdXRpb24sXG4gICAgICAvLyA+IGFyZSBhY3R1YWxseSAzeCBpbiB0aGUgZ3JlZW4gY29sb3IsIGJ1dCBvbmx5IDEuNXggaW4gdGhlIHJlZCBhbmRcbiAgICAgIC8vID4gYmx1ZSBjb2xvcnMuIFNob3dpbmcgYSAzeCByZXNvbHV0aW9uIGltYWdlIGluIHRoZSBhcHAgdnMgYSAyeFxuICAgICAgLy8gPiByZXNvbHV0aW9uIGltYWdlIHdpbGwgYmUgdmlzdWFsbHkgdGhlIHNhbWUsIHRob3VnaCB0aGUgM3ggaW1hZ2VcbiAgICAgIC8vID4gdGFrZXMgc2lnbmlmaWNhbnRseSBtb3JlIGRhdGEuIEV2ZW4gdHJ1ZSAzeCByZXNvbHV0aW9uIHNjcmVlbnMgYXJlXG4gICAgICAvLyA+IHdhc3RlZnVsIGFzIHRoZSBodW1hbiBleWUgY2Fubm90IHNlZSB0aGF0IGxldmVsIG9mIGRldGFpbCB3aXRob3V0XG4gICAgICAvLyA+IHNvbWV0aGluZyBsaWtlIGEgbWFnbmlmeWluZyBnbGFzcy5cbiAgICAgIC8vIGh0dHBzOi8vYmxvZy50d2l0dGVyLmNvbS9lbmdpbmVlcmluZy9lbl91cy90b3BpY3MvaW5mcmFzdHJ1Y3R1cmUvMjAxOS9jYXBwaW5nLWltYWdlLWZpZGVsaXR5LW9uLXVsdHJhLWhpZ2gtcmVzb2x1dGlvbi1kZXZpY2VzLmh0bWxcbiAgICAgIFt3aWR0aCwgd2lkdGggKiAyIC8qLCB3aWR0aCAqIDMqL10ubWFwKFxuICAgICAgICAodykgPT4gYWxsU2l6ZXMuZmluZCgocCkgPT4gcCA+PSB3KSB8fCBhbGxTaXplc1thbGxTaXplcy5sZW5ndGggLSAxXVxuICAgICAgKVxuICAgICksXG4gIF1cbiAgcmV0dXJuIHsgd2lkdGhzLCBraW5kOiAneCcgfVxufVxuXG50eXBlIEdlbkltZ0F0dHJzRGF0YSA9IHtcbiAgY29uZmlnOiBJbWFnZUNvbmZpZ1xuICBzcmM6IHN0cmluZ1xuICB1bm9wdGltaXplZDogYm9vbGVhblxuICBsb2FkZXI6IEltYWdlTG9hZGVyV2l0aENvbmZpZ1xuICB3aWR0aD86IG51bWJlclxuICBxdWFsaXR5PzogbnVtYmVyXG4gIHNpemVzPzogc3RyaW5nXG59XG5cbnR5cGUgR2VuSW1nQXR0cnNSZXN1bHQgPSB7XG4gIHNyYzogc3RyaW5nXG4gIHNyY1NldDogc3RyaW5nIHwgdW5kZWZpbmVkXG4gIHNpemVzOiBzdHJpbmcgfCB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVJbWdBdHRycyh7XG4gIGNvbmZpZyxcbiAgc3JjLFxuICB1bm9wdGltaXplZCxcbiAgd2lkdGgsXG4gIHF1YWxpdHksXG4gIHNpemVzLFxuICBsb2FkZXIsXG59OiBHZW5JbWdBdHRyc0RhdGEpOiBHZW5JbWdBdHRyc1Jlc3VsdCB7XG4gIGlmICh1bm9wdGltaXplZCkge1xuICAgIHJldHVybiB7IHNyYywgc3JjU2V0OiB1bmRlZmluZWQsIHNpemVzOiB1bmRlZmluZWQgfVxuICB9XG5cbiAgY29uc3QgeyB3aWR0aHMsIGtpbmQgfSA9IGdldFdpZHRocyhjb25maWcsIHdpZHRoLCBzaXplcylcbiAgY29uc3QgbGFzdCA9IHdpZHRocy5sZW5ndGggLSAxXG5cbiAgcmV0dXJuIHtcbiAgICBzaXplczogIXNpemVzICYmIGtpbmQgPT09ICd3JyA/ICcxMDB2dycgOiBzaXplcyxcbiAgICBzcmNTZXQ6IHdpZHRoc1xuICAgICAgLm1hcChcbiAgICAgICAgKHcsIGkpID0+XG4gICAgICAgICAgYCR7bG9hZGVyKHsgY29uZmlnLCBzcmMsIHF1YWxpdHksIHdpZHRoOiB3IH0pfSAke1xuICAgICAgICAgICAga2luZCA9PT0gJ3cnID8gdyA6IGkgKyAxXG4gICAgICAgICAgfSR7a2luZH1gXG4gICAgICApXG4gICAgICAuam9pbignLCAnKSxcblxuICAgIC8vIEl0J3MgaW50ZW5kZWQgdG8ga2VlcCBgc3JjYCB0aGUgbGFzdCBhdHRyaWJ1dGUgYmVjYXVzZSBSZWFjdCB1cGRhdGVzXG4gICAgLy8gYXR0cmlidXRlcyBpbiBvcmRlci4gSWYgd2Uga2VlcCBgc3JjYCB0aGUgZmlyc3Qgb25lLCBTYWZhcmkgd2lsbFxuICAgIC8vIGltbWVkaWF0ZWx5IHN0YXJ0IHRvIGZldGNoIGBzcmNgLCBiZWZvcmUgYHNpemVzYCBhbmQgYHNyY1NldGAgYXJlIGV2ZW5cbiAgICAvLyB1cGRhdGVkIGJ5IFJlYWN0LiBUaGF0IGNhdXNlcyBtdWx0aXBsZSB1bm5lY2Vzc2FyeSByZXF1ZXN0cyBpZiBgc3JjU2V0YFxuICAgIC8vIGFuZCBgc2l6ZXNgIGFyZSBkZWZpbmVkLlxuICAgIC8vIFRoaXMgYnVnIGNhbm5vdCBiZSByZXByb2R1Y2VkIGluIENocm9tZSBvciBGaXJlZm94LlxuICAgIHNyYzogbG9hZGVyKHsgY29uZmlnLCBzcmMsIHF1YWxpdHksIHdpZHRoOiB3aWR0aHNbbGFzdF0gfSksXG4gIH1cbn1cblxuLyoqXG4gKiBBIHNoYXJlZCBmdW5jdGlvbiwgdXNlZCBvbiBib3RoIGNsaWVudCBhbmQgc2VydmVyLCB0byBnZW5lcmF0ZSB0aGUgcHJvcHMgZm9yIDxpbWc+LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW1nUHJvcHMoXG4gIHtcbiAgICBzcmMsXG4gICAgc2l6ZXMsXG4gICAgdW5vcHRpbWl6ZWQgPSBmYWxzZSxcbiAgICBwcmlvcml0eSA9IGZhbHNlLFxuICAgIGxvYWRpbmcsXG4gICAgY2xhc3NOYW1lLFxuICAgIHF1YWxpdHksXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGZpbGwgPSBmYWxzZSxcbiAgICBzdHlsZSxcbiAgICBvdmVycmlkZVNyYyxcbiAgICBvbkxvYWQsXG4gICAgb25Mb2FkaW5nQ29tcGxldGUsXG4gICAgcGxhY2Vob2xkZXIgPSAnZW1wdHknLFxuICAgIGJsdXJEYXRhVVJMLFxuICAgIGZldGNoUHJpb3JpdHksXG4gICAgZGVjb2RpbmcgPSAnYXN5bmMnLFxuICAgIGxheW91dCxcbiAgICBvYmplY3RGaXQsXG4gICAgb2JqZWN0UG9zaXRpb24sXG4gICAgbGF6eUJvdW5kYXJ5LFxuICAgIGxhenlSb290LFxuICAgIC4uLnJlc3RcbiAgfTogSW1hZ2VQcm9wcyxcbiAgX3N0YXRlOiB7XG4gICAgZGVmYXVsdExvYWRlcjogSW1hZ2VMb2FkZXJXaXRoQ29uZmlnXG4gICAgaW1nQ29uZjogSW1hZ2VDb25maWdDb21wbGV0ZVxuICAgIHNob3dBbHRUZXh0PzogYm9vbGVhblxuICAgIGJsdXJDb21wbGV0ZT86IGJvb2xlYW5cbiAgfVxuKToge1xuICBwcm9wczogSW1nUHJvcHNcbiAgbWV0YToge1xuICAgIHVub3B0aW1pemVkOiBib29sZWFuXG4gICAgcHJpb3JpdHk6IGJvb2xlYW5cbiAgICBwbGFjZWhvbGRlcjogTm9uTnVsbGFibGU8SW1hZ2VQcm9wc1sncGxhY2Vob2xkZXInXT5cbiAgICBmaWxsOiBib29sZWFuXG4gIH1cbn0ge1xuICBjb25zdCB7IGltZ0NvbmYsIHNob3dBbHRUZXh0LCBibHVyQ29tcGxldGUsIGRlZmF1bHRMb2FkZXIgfSA9IF9zdGF0ZVxuICBsZXQgY29uZmlnOiBJbWFnZUNvbmZpZ1xuICBsZXQgYyA9IGltZ0NvbmYgfHwgaW1hZ2VDb25maWdEZWZhdWx0XG4gIGlmICgnYWxsU2l6ZXMnIGluIGMpIHtcbiAgICBjb25maWcgPSBjIGFzIEltYWdlQ29uZmlnXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYWxsU2l6ZXMgPSBbLi4uYy5kZXZpY2VTaXplcywgLi4uYy5pbWFnZVNpemVzXS5zb3J0KChhLCBiKSA9PiBhIC0gYilcbiAgICBjb25zdCBkZXZpY2VTaXplcyA9IGMuZGV2aWNlU2l6ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gICAgY29uZmlnID0geyAuLi5jLCBhbGxTaXplcywgZGV2aWNlU2l6ZXMgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBkZWZhdWx0TG9hZGVyID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdpbWFnZXMubG9hZGVyRmlsZSBkZXRlY3RlZCBidXQgdGhlIGZpbGUgaXMgbWlzc2luZyBkZWZhdWx0IGV4cG9ydC5cXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2ludmFsaWQtaW1hZ2VzLWNvbmZpZydcbiAgICApXG4gIH1cbiAgbGV0IGxvYWRlcjogSW1hZ2VMb2FkZXJXaXRoQ29uZmlnID0gcmVzdC5sb2FkZXIgfHwgZGVmYXVsdExvYWRlclxuXG4gIC8vIFJlbW92ZSBwcm9wZXJ0eSBzbyBpdCdzIG5vdCBzcHJlYWQgb24gPGltZz4gZWxlbWVudFxuICBkZWxldGUgcmVzdC5sb2FkZXJcbiAgZGVsZXRlIChyZXN0IGFzIGFueSkuc3JjU2V0XG5cbiAgLy8gVGhpcyBzcGVjaWFsIHZhbHVlIGluZGljYXRlcyB0aGF0IHRoZSB1c2VyXG4gIC8vIGRpZG4ndCBkZWZpbmUgYSBcImxvYWRlclwiIHByb3Agb3IgXCJsb2FkZXJcIiBjb25maWcuXG4gIGNvbnN0IGlzRGVmYXVsdExvYWRlciA9ICdfX25leHRfaW1nX2RlZmF1bHQnIGluIGxvYWRlclxuXG4gIGlmIChpc0RlZmF1bHRMb2FkZXIpIHtcbiAgICBpZiAoY29uZmlnLmxvYWRlciA9PT0gJ2N1c3RvbScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaXMgbWlzc2luZyBcImxvYWRlclwiIHByb3AuYCArXG4gICAgICAgICAgYFxcblJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1pbWFnZS1taXNzaW5nLWxvYWRlcmBcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlIHVzZXIgZGVmaW5lZCBhIFwibG9hZGVyXCIgcHJvcCBvciBjb25maWcuXG4gICAgLy8gU2luY2UgdGhlIGNvbmZpZyBvYmplY3QgaXMgaW50ZXJuYWwgb25seSwgd2VcbiAgICAvLyBtdXN0IG5vdCBwYXNzIGl0IHRvIHRoZSB1c2VyLWRlZmluZWQgXCJsb2FkZXJcIi5cbiAgICBjb25zdCBjdXN0b21JbWFnZUxvYWRlciA9IGxvYWRlciBhcyBJbWFnZUxvYWRlclxuICAgIGxvYWRlciA9IChvYmopID0+IHtcbiAgICAgIGNvbnN0IHsgY29uZmlnOiBfLCAuLi5vcHRzIH0gPSBvYmpcbiAgICAgIHJldHVybiBjdXN0b21JbWFnZUxvYWRlcihvcHRzKVxuICAgIH1cbiAgfVxuXG4gIGlmIChsYXlvdXQpIHtcbiAgICBpZiAobGF5b3V0ID09PSAnZmlsbCcpIHtcbiAgICAgIGZpbGwgPSB0cnVlXG4gICAgfVxuICAgIGNvbnN0IGxheW91dFRvU3R5bGU6IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfCB1bmRlZmluZWQ+ID0ge1xuICAgICAgaW50cmluc2ljOiB7IG1heFdpZHRoOiAnMTAwJScsIGhlaWdodDogJ2F1dG8nIH0sXG4gICAgICByZXNwb25zaXZlOiB7IHdpZHRoOiAnMTAwJScsIGhlaWdodDogJ2F1dG8nIH0sXG4gICAgfVxuICAgIGNvbnN0IGxheW91dFRvU2l6ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZD4gPSB7XG4gICAgICByZXNwb25zaXZlOiAnMTAwdncnLFxuICAgICAgZmlsbDogJzEwMHZ3JyxcbiAgICB9XG4gICAgY29uc3QgbGF5b3V0U3R5bGUgPSBsYXlvdXRUb1N0eWxlW2xheW91dF1cbiAgICBpZiAobGF5b3V0U3R5bGUpIHtcbiAgICAgIHN0eWxlID0geyAuLi5zdHlsZSwgLi4ubGF5b3V0U3R5bGUgfVxuICAgIH1cbiAgICBjb25zdCBsYXlvdXRTaXplcyA9IGxheW91dFRvU2l6ZXNbbGF5b3V0XVxuICAgIGlmIChsYXlvdXRTaXplcyAmJiAhc2l6ZXMpIHtcbiAgICAgIHNpemVzID0gbGF5b3V0U2l6ZXNcbiAgICB9XG4gIH1cblxuICBsZXQgc3RhdGljU3JjID0gJydcbiAgbGV0IHdpZHRoSW50ID0gZ2V0SW50KHdpZHRoKVxuICBsZXQgaGVpZ2h0SW50ID0gZ2V0SW50KGhlaWdodClcbiAgbGV0IGJsdXJXaWR0aDogbnVtYmVyIHwgdW5kZWZpbmVkXG4gIGxldCBibHVySGVpZ2h0OiBudW1iZXIgfCB1bmRlZmluZWRcbiAgaWYgKGlzU3RhdGljSW1wb3J0KHNyYykpIHtcbiAgICBjb25zdCBzdGF0aWNJbWFnZURhdGEgPSBpc1N0YXRpY1JlcXVpcmUoc3JjKSA/IHNyYy5kZWZhdWx0IDogc3JjXG5cbiAgICBpZiAoIXN0YXRpY0ltYWdlRGF0YS5zcmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEFuIG9iamVjdCBzaG91bGQgb25seSBiZSBwYXNzZWQgdG8gdGhlIGltYWdlIGNvbXBvbmVudCBzcmMgcGFyYW1ldGVyIGlmIGl0IGNvbWVzIGZyb20gYSBzdGF0aWMgaW1hZ2UgaW1wb3J0LiBJdCBtdXN0IGluY2x1ZGUgc3JjLiBSZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIHN0YXRpY0ltYWdlRGF0YVxuICAgICAgICApfWBcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKCFzdGF0aWNJbWFnZURhdGEuaGVpZ2h0IHx8ICFzdGF0aWNJbWFnZURhdGEud2lkdGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEFuIG9iamVjdCBzaG91bGQgb25seSBiZSBwYXNzZWQgdG8gdGhlIGltYWdlIGNvbXBvbmVudCBzcmMgcGFyYW1ldGVyIGlmIGl0IGNvbWVzIGZyb20gYSBzdGF0aWMgaW1hZ2UgaW1wb3J0LiBJdCBtdXN0IGluY2x1ZGUgaGVpZ2h0IGFuZCB3aWR0aC4gUmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBzdGF0aWNJbWFnZURhdGFcbiAgICAgICAgKX1gXG4gICAgICApXG4gICAgfVxuXG4gICAgYmx1cldpZHRoID0gc3RhdGljSW1hZ2VEYXRhLmJsdXJXaWR0aFxuICAgIGJsdXJIZWlnaHQgPSBzdGF0aWNJbWFnZURhdGEuYmx1ckhlaWdodFxuICAgIGJsdXJEYXRhVVJMID0gYmx1ckRhdGFVUkwgfHwgc3RhdGljSW1hZ2VEYXRhLmJsdXJEYXRhVVJMXG4gICAgc3RhdGljU3JjID0gc3RhdGljSW1hZ2VEYXRhLnNyY1xuXG4gICAgaWYgKCFmaWxsKSB7XG4gICAgICBpZiAoIXdpZHRoSW50ICYmICFoZWlnaHRJbnQpIHtcbiAgICAgICAgd2lkdGhJbnQgPSBzdGF0aWNJbWFnZURhdGEud2lkdGhcbiAgICAgICAgaGVpZ2h0SW50ID0gc3RhdGljSW1hZ2VEYXRhLmhlaWdodFxuICAgICAgfSBlbHNlIGlmICh3aWR0aEludCAmJiAhaGVpZ2h0SW50KSB7XG4gICAgICAgIGNvbnN0IHJhdGlvID0gd2lkdGhJbnQgLyBzdGF0aWNJbWFnZURhdGEud2lkdGhcbiAgICAgICAgaGVpZ2h0SW50ID0gTWF0aC5yb3VuZChzdGF0aWNJbWFnZURhdGEuaGVpZ2h0ICogcmF0aW8pXG4gICAgICB9IGVsc2UgaWYgKCF3aWR0aEludCAmJiBoZWlnaHRJbnQpIHtcbiAgICAgICAgY29uc3QgcmF0aW8gPSBoZWlnaHRJbnQgLyBzdGF0aWNJbWFnZURhdGEuaGVpZ2h0XG4gICAgICAgIHdpZHRoSW50ID0gTWF0aC5yb3VuZChzdGF0aWNJbWFnZURhdGEud2lkdGggKiByYXRpbylcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3JjID0gdHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgPyBzcmMgOiBzdGF0aWNTcmNcblxuICBsZXQgaXNMYXp5ID1cbiAgICAhcHJpb3JpdHkgJiYgKGxvYWRpbmcgPT09ICdsYXp5JyB8fCB0eXBlb2YgbG9hZGluZyA9PT0gJ3VuZGVmaW5lZCcpXG4gIGlmICghc3JjIHx8IHNyYy5zdGFydHNXaXRoKCdkYXRhOicpIHx8IHNyYy5zdGFydHNXaXRoKCdibG9iOicpKSB7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSFRUUC9CYXNpY3Nfb2ZfSFRUUC9EYXRhX1VSSXNcbiAgICB1bm9wdGltaXplZCA9IHRydWVcbiAgICBpc0xhenkgPSBmYWxzZVxuICB9XG4gIGlmIChjb25maWcudW5vcHRpbWl6ZWQpIHtcbiAgICB1bm9wdGltaXplZCA9IHRydWVcbiAgfVxuICBpZiAoaXNEZWZhdWx0TG9hZGVyICYmIHNyYy5lbmRzV2l0aCgnLnN2ZycpICYmICFjb25maWcuZGFuZ2Vyb3VzbHlBbGxvd1NWRykge1xuICAgIC8vIFNwZWNpYWwgY2FzZSB0byBtYWtlIHN2ZyBzZXJ2ZSBhcy1pcyB0byBhdm9pZCBwcm94eWluZ1xuICAgIC8vIHRocm91Z2ggdGhlIGJ1aWx0LWluIEltYWdlIE9wdGltaXphdGlvbiBBUEkuXG4gICAgdW5vcHRpbWl6ZWQgPSB0cnVlXG4gIH1cblxuICBjb25zdCBxdWFsaXR5SW50ID0gZ2V0SW50KHF1YWxpdHkpXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoY29uZmlnLm91dHB1dCA9PT0gJ2V4cG9ydCcgJiYgaXNEZWZhdWx0TG9hZGVyICYmICF1bm9wdGltaXplZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW1hZ2UgT3B0aW1pemF0aW9uIHVzaW5nIHRoZSBkZWZhdWx0IGxvYWRlciBpcyBub3QgY29tcGF0aWJsZSB3aXRoIFxcYHsgb3V0cHV0OiAnZXhwb3J0JyB9XFxgLlxuICBQb3NzaWJsZSBzb2x1dGlvbnM6XG4gICAgLSBSZW1vdmUgXFxgeyBvdXRwdXQ6ICdleHBvcnQnIH1cXGAgYW5kIHJ1biBcIm5leHQgc3RhcnRcIiB0byBydW4gc2VydmVyIG1vZGUgaW5jbHVkaW5nIHRoZSBJbWFnZSBPcHRpbWl6YXRpb24gQVBJLlxuICAgIC0gQ29uZmlndXJlIFxcYHsgaW1hZ2VzOiB7IHVub3B0aW1pemVkOiB0cnVlIH0gfVxcYCBpbiBcXGBuZXh0LmNvbmZpZy5qc1xcYCB0byBkaXNhYmxlIHRoZSBJbWFnZSBPcHRpbWl6YXRpb24gQVBJLlxuICBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2V4cG9ydC1pbWFnZS1hcGlgXG4gICAgICApXG4gICAgfVxuICAgIGlmICghc3JjKSB7XG4gICAgICAvLyBSZWFjdCBkb2Vzbid0IHNob3cgdGhlIHN0YWNrIHRyYWNlIGFuZCB0aGVyZSdzXG4gICAgICAvLyBubyBgc3JjYCB0byBoZWxwIGlkZW50aWZ5IHdoaWNoIGltYWdlLCBzbyB3ZVxuICAgICAgLy8gaW5zdGVhZCBjb25zb2xlLmVycm9yKHJlZikgZHVyaW5nIG1vdW50LlxuICAgICAgdW5vcHRpbWl6ZWQgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBib3RoIFwid2lkdGhcIiBhbmQgXCJmaWxsXCIgcHJvcGVydGllcy4gT25seSBvbmUgc2hvdWxkIGJlIHVzZWQuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGJvdGggXCJoZWlnaHRcIiBhbmQgXCJmaWxsXCIgcHJvcGVydGllcy4gT25seSBvbmUgc2hvdWxkIGJlIHVzZWQuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGU/LnBvc2l0aW9uICYmIHN0eWxlLnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGJvdGggXCJmaWxsXCIgYW5kIFwic3R5bGUucG9zaXRpb25cIiBwcm9wZXJ0aWVzLiBJbWFnZXMgd2l0aCBcImZpbGxcIiBhbHdheXMgdXNlIHBvc2l0aW9uIGFic29sdXRlIC0gaXQgY2Fubm90IGJlIG1vZGlmaWVkLmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlPy53aWR0aCAmJiBzdHlsZS53aWR0aCAhPT0gJzEwMCUnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGJvdGggXCJmaWxsXCIgYW5kIFwic3R5bGUud2lkdGhcIiBwcm9wZXJ0aWVzLiBJbWFnZXMgd2l0aCBcImZpbGxcIiBhbHdheXMgdXNlIHdpZHRoIDEwMCUgLSBpdCBjYW5ub3QgYmUgbW9kaWZpZWQuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGU/LmhlaWdodCAmJiBzdHlsZS5oZWlnaHQgIT09ICcxMDAlJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBib3RoIFwiZmlsbFwiIGFuZCBcInN0eWxlLmhlaWdodFwiIHByb3BlcnRpZXMuIEltYWdlcyB3aXRoIFwiZmlsbFwiIGFsd2F5cyB1c2UgaGVpZ2h0IDEwMCUgLSBpdCBjYW5ub3QgYmUgbW9kaWZpZWQuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aEludCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBpcyBtaXNzaW5nIHJlcXVpcmVkIFwid2lkdGhcIiBwcm9wZXJ0eS5gXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKHdpZHRoSW50KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBpbnZhbGlkIFwid2lkdGhcIiBwcm9wZXJ0eS4gRXhwZWN0ZWQgYSBudW1lcmljIHZhbHVlIGluIHBpeGVscyBidXQgcmVjZWl2ZWQgXCIke3dpZHRofVwiLmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHRJbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaXMgbWlzc2luZyByZXF1aXJlZCBcImhlaWdodFwiIHByb3BlcnR5LmBcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSBpZiAoaXNOYU4oaGVpZ2h0SW50KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBpbnZhbGlkIFwiaGVpZ2h0XCIgcHJvcGVydHkuIEV4cGVjdGVkIGEgbnVtZXJpYyB2YWx1ZSBpbiBwaXhlbHMgYnV0IHJlY2VpdmVkIFwiJHtoZWlnaHR9XCIuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuICAgICAgICBpZiAoL15bXFx4MDAtXFx4MjBdLy50ZXN0KHNyYykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBjYW5ub3Qgc3RhcnQgd2l0aCBhIHNwYWNlIG9yIGNvbnRyb2wgY2hhcmFjdGVyLiBVc2Ugc3JjLnRyaW1TdGFydCgpIHRvIHJlbW92ZSBpdCBvciBlbmNvZGVVUklDb21wb25lbnQoc3JjKSB0byBrZWVwIGl0LmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgICAgICAgaWYgKC9bXFx4MDAtXFx4MjBdJC8udGVzdChzcmMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgY2Fubm90IGVuZCB3aXRoIGEgc3BhY2Ugb3IgY29udHJvbCBjaGFyYWN0ZXIuIFVzZSBzcmMudHJpbUVuZCgpIHRvIHJlbW92ZSBpdCBvciBlbmNvZGVVUklDb21wb25lbnQoc3JjKSB0byBrZWVwIGl0LmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFWQUxJRF9MT0FESU5HX1ZBTFVFUy5pbmNsdWRlcyhsb2FkaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgaW52YWxpZCBcImxvYWRpbmdcIiBwcm9wZXJ0eS4gUHJvdmlkZWQgXCIke2xvYWRpbmd9XCIgc2hvdWxkIGJlIG9uZSBvZiAke1ZBTElEX0xPQURJTkdfVkFMVUVTLm1hcChcbiAgICAgICAgICBTdHJpbmdcbiAgICAgICAgKS5qb2luKCcsJyl9LmBcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKHByaW9yaXR5ICYmIGxvYWRpbmcgPT09ICdsYXp5Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgYm90aCBcInByaW9yaXR5XCIgYW5kIFwibG9hZGluZz0nbGF6eSdcIiBwcm9wZXJ0aWVzLiBPbmx5IG9uZSBzaG91bGQgYmUgdXNlZC5gXG4gICAgICApXG4gICAgfVxuICAgIGlmIChcbiAgICAgIHBsYWNlaG9sZGVyICE9PSAnZW1wdHknICYmXG4gICAgICBwbGFjZWhvbGRlciAhPT0gJ2JsdXInICYmXG4gICAgICAhcGxhY2Vob2xkZXIuc3RhcnRzV2l0aCgnZGF0YTppbWFnZS8nKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgaW52YWxpZCBcInBsYWNlaG9sZGVyXCIgcHJvcGVydHkgXCIke3BsYWNlaG9sZGVyfVwiLmBcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKHBsYWNlaG9sZGVyICE9PSAnZW1wdHknKSB7XG4gICAgICBpZiAod2lkdGhJbnQgJiYgaGVpZ2h0SW50ICYmIHdpZHRoSW50ICogaGVpZ2h0SW50IDwgMTYwMCkge1xuICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBpcyBzbWFsbGVyIHRoYW4gNDB4NDAuIENvbnNpZGVyIHJlbW92aW5nIHRoZSBcInBsYWNlaG9sZGVyXCIgcHJvcGVydHkgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS5gXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBsYWNlaG9sZGVyID09PSAnYmx1cicgJiYgIWJsdXJEYXRhVVJMKSB7XG4gICAgICBjb25zdCBWQUxJRF9CTFVSX0VYVCA9IFsnanBlZycsICdwbmcnLCAnd2VicCcsICdhdmlmJ10gLy8gc2hvdWxkIG1hdGNoIG5leHQtaW1hZ2UtbG9hZGVyXG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIFwicGxhY2Vob2xkZXI9J2JsdXInXCIgcHJvcGVydHkgYnV0IGlzIG1pc3NpbmcgdGhlIFwiYmx1ckRhdGFVUkxcIiBwcm9wZXJ0eS5cbiAgICAgICAgUG9zc2libGUgc29sdXRpb25zOlxuICAgICAgICAgIC0gQWRkIGEgXCJibHVyRGF0YVVSTFwiIHByb3BlcnR5LCB0aGUgY29udGVudHMgc2hvdWxkIGJlIGEgc21hbGwgRGF0YSBVUkwgdG8gcmVwcmVzZW50IHRoZSBpbWFnZVxuICAgICAgICAgIC0gQ2hhbmdlIHRoZSBcInNyY1wiIHByb3BlcnR5IHRvIGEgc3RhdGljIGltcG9ydCB3aXRoIG9uZSBvZiB0aGUgc3VwcG9ydGVkIGZpbGUgdHlwZXM6ICR7VkFMSURfQkxVUl9FWFQuam9pbihcbiAgICAgICAgICAgICcsJ1xuICAgICAgICAgICl9IChhbmltYXRlZCBpbWFnZXMgbm90IHN1cHBvcnRlZClcbiAgICAgICAgICAtIFJlbW92ZSB0aGUgXCJwbGFjZWhvbGRlclwiIHByb3BlcnR5LCBlZmZlY3RpdmVseSBubyBibHVyIGVmZmVjdFxuICAgICAgICBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3BsYWNlaG9sZGVyLWJsdXItZGF0YS11cmxgXG4gICAgICApXG4gICAgfVxuICAgIGlmICgncmVmJyBpbiByZXN0KSB7XG4gICAgICB3YXJuT25jZShcbiAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaXMgdXNpbmcgdW5zdXBwb3J0ZWQgXCJyZWZcIiBwcm9wZXJ0eS4gQ29uc2lkZXIgdXNpbmcgdGhlIFwib25Mb2FkXCIgcHJvcGVydHkgaW5zdGVhZC5gXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKCF1bm9wdGltaXplZCAmJiAhaXNEZWZhdWx0TG9hZGVyKSB7XG4gICAgICBjb25zdCB1cmxTdHIgPSBsb2FkZXIoe1xuICAgICAgICBjb25maWcsXG4gICAgICAgIHNyYyxcbiAgICAgICAgd2lkdGg6IHdpZHRoSW50IHx8IDQwMCxcbiAgICAgICAgcXVhbGl0eTogcXVhbGl0eUludCB8fCA3NSxcbiAgICAgIH0pXG4gICAgICBsZXQgdXJsOiBVUkwgfCB1bmRlZmluZWRcbiAgICAgIHRyeSB7XG4gICAgICAgIHVybCA9IG5ldyBVUkwodXJsU3RyKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgaWYgKHVybFN0ciA9PT0gc3JjIHx8ICh1cmwgJiYgdXJsLnBhdGhuYW1lID09PSBzcmMgJiYgIXVybC5zZWFyY2gpKSB7XG4gICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBhIFwibG9hZGVyXCIgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBpbXBsZW1lbnQgd2lkdGguIFBsZWFzZSBpbXBsZW1lbnQgaXQgb3IgdXNlIHRoZSBcInVub3B0aW1pemVkXCIgcHJvcGVydHkgaW5zdGVhZC5gICtcbiAgICAgICAgICAgIGBcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtbWlzc2luZy1sb2FkZXItd2lkdGhgXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob25Mb2FkaW5nQ29tcGxldGUpIHtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBpcyB1c2luZyBkZXByZWNhdGVkIFwib25Mb2FkaW5nQ29tcGxldGVcIiBwcm9wZXJ0eS4gUGxlYXNlIHVzZSB0aGUgXCJvbkxvYWRcIiBwcm9wZXJ0eSBpbnN0ZWFkLmBcbiAgICAgIClcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IFtsZWdhY3lLZXksIGxlZ2FjeVZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh7XG4gICAgICBsYXlvdXQsXG4gICAgICBvYmplY3RGaXQsXG4gICAgICBvYmplY3RQb3NpdGlvbixcbiAgICAgIGxhenlCb3VuZGFyeSxcbiAgICAgIGxhenlSb290LFxuICAgIH0pKSB7XG4gICAgICBpZiAobGVnYWN5VmFsdWUpIHtcbiAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGxlZ2FjeSBwcm9wIFwiJHtsZWdhY3lLZXl9XCIuIERpZCB5b3UgZm9yZ2V0IHRvIHJ1biB0aGUgY29kZW1vZD9gICtcbiAgICAgICAgICAgIGBcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtdXBncmFkZS10by0xM2BcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAhcGVyZk9ic2VydmVyICYmXG4gICAgICB3aW5kb3cuUGVyZm9ybWFuY2VPYnNlcnZlclxuICAgICkge1xuICAgICAgcGVyZk9ic2VydmVyID0gbmV3IFBlcmZvcm1hbmNlT2JzZXJ2ZXIoKGVudHJ5TGlzdCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJ5TGlzdC5nZXRFbnRyaWVzKCkpIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gbWlzc2luZyBcIkxhcmdlc3RDb250ZW50ZnVsUGFpbnRcIiBjbGFzcyB3aXRoIFwiZWxlbWVudFwiIHByb3BcbiAgICAgICAgICBjb25zdCBpbWdTcmMgPSBlbnRyeT8uZWxlbWVudD8uc3JjIHx8ICcnXG4gICAgICAgICAgY29uc3QgbGNwSW1hZ2UgPSBhbGxJbWdzLmdldChpbWdTcmMpXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbGNwSW1hZ2UgJiZcbiAgICAgICAgICAgICFsY3BJbWFnZS5wcmlvcml0eSAmJlxuICAgICAgICAgICAgbGNwSW1hZ2UucGxhY2Vob2xkZXIgPT09ICdlbXB0eScgJiZcbiAgICAgICAgICAgICFsY3BJbWFnZS5zcmMuc3RhcnRzV2l0aCgnZGF0YTonKSAmJlxuICAgICAgICAgICAgIWxjcEltYWdlLnNyYy5zdGFydHNXaXRoKCdibG9iOicpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3dlYi5kZXYvbGNwLyNtZWFzdXJlLWxjcC1pbi1qYXZhc2NyaXB0XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtsY3BJbWFnZS5zcmN9XCIgd2FzIGRldGVjdGVkIGFzIHRoZSBMYXJnZXN0IENvbnRlbnRmdWwgUGFpbnQgKExDUCkuIFBsZWFzZSBhZGQgdGhlIFwicHJpb3JpdHlcIiBwcm9wZXJ0eSBpZiB0aGlzIGltYWdlIGlzIGFib3ZlIHRoZSBmb2xkLmAgK1xuICAgICAgICAgICAgICAgIGBcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNwcmlvcml0eWBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICB0cnkge1xuICAgICAgICBwZXJmT2JzZXJ2ZXIub2JzZXJ2ZSh7XG4gICAgICAgICAgdHlwZTogJ2xhcmdlc3QtY29udGVudGZ1bC1wYWludCcsXG4gICAgICAgICAgYnVmZmVyZWQ6IHRydWUsXG4gICAgICAgIH0pXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gTG9nIGVycm9yIGJ1dCBkb24ndCBjcmFzaCB0aGUgYXBwXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBpbWdTdHlsZSA9IE9iamVjdC5hc3NpZ24oXG4gICAgZmlsbFxuICAgICAgPyB7XG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgb2JqZWN0Rml0LFxuICAgICAgICAgIG9iamVjdFBvc2l0aW9uLFxuICAgICAgICB9XG4gICAgICA6IHt9LFxuICAgIHNob3dBbHRUZXh0ID8ge30gOiB7IGNvbG9yOiAndHJhbnNwYXJlbnQnIH0sXG4gICAgc3R5bGVcbiAgKVxuXG4gIGNvbnN0IGJhY2tncm91bmRJbWFnZSA9XG4gICAgIWJsdXJDb21wbGV0ZSAmJiBwbGFjZWhvbGRlciAhPT0gJ2VtcHR5J1xuICAgICAgPyBwbGFjZWhvbGRlciA9PT0gJ2JsdXInXG4gICAgICAgID8gYHVybChcImRhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0Zi04LCR7Z2V0SW1hZ2VCbHVyU3ZnKHtcbiAgICAgICAgICAgIHdpZHRoSW50LFxuICAgICAgICAgICAgaGVpZ2h0SW50LFxuICAgICAgICAgICAgYmx1cldpZHRoLFxuICAgICAgICAgICAgYmx1ckhlaWdodCxcbiAgICAgICAgICAgIGJsdXJEYXRhVVJMOiBibHVyRGF0YVVSTCB8fCAnJywgLy8gYXNzdW1lIG5vdCB1bmRlZmluZWRcbiAgICAgICAgICAgIG9iamVjdEZpdDogaW1nU3R5bGUub2JqZWN0Rml0LFxuICAgICAgICAgIH0pfVwiKWBcbiAgICAgICAgOiBgdXJsKFwiJHtwbGFjZWhvbGRlcn1cIilgIC8vIGFzc3VtZSBgZGF0YTppbWFnZS9gXG4gICAgICA6IG51bGxcblxuICBsZXQgcGxhY2Vob2xkZXJTdHlsZSA9IGJhY2tncm91bmRJbWFnZVxuICAgID8ge1xuICAgICAgICBiYWNrZ3JvdW5kU2l6ZTogaW1nU3R5bGUub2JqZWN0Rml0IHx8ICdjb3ZlcicsXG4gICAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogaW1nU3R5bGUub2JqZWN0UG9zaXRpb24gfHwgJzUwJSA1MCUnLFxuICAgICAgICBiYWNrZ3JvdW5kUmVwZWF0OiAnbm8tcmVwZWF0JyxcbiAgICAgICAgYmFja2dyb3VuZEltYWdlLFxuICAgICAgfVxuICAgIDoge31cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICBpZiAoXG4gICAgICBwbGFjZWhvbGRlclN0eWxlLmJhY2tncm91bmRJbWFnZSAmJlxuICAgICAgcGxhY2Vob2xkZXIgPT09ICdibHVyJyAmJlxuICAgICAgYmx1ckRhdGFVUkw/LnN0YXJ0c1dpdGgoJy8nKVxuICAgICkge1xuICAgICAgLy8gRHVyaW5nIGBuZXh0IGRldmAsIHdlIGRvbid0IHdhbnQgdG8gZ2VuZXJhdGUgYmx1ciBwbGFjZWhvbGRlcnMgd2l0aCB3ZWJwYWNrXG4gICAgICAvLyBiZWNhdXNlIGl0IGNhbiBkZWxheSBzdGFydGluZyB0aGUgZGV2IHNlcnZlci4gSW5zdGVhZCwgYG5leHQtaW1hZ2UtbG9hZGVyLmpzYFxuICAgICAgLy8gd2lsbCBpbmxpbmUgYSBzcGVjaWFsIHVybCB0byBsYXppbHkgZ2VuZXJhdGUgdGhlIGJsdXIgcGxhY2Vob2xkZXIgYXQgcmVxdWVzdCB0aW1lLlxuICAgICAgcGxhY2Vob2xkZXJTdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKFwiJHtibHVyRGF0YVVSTH1cIilgXG4gICAgfVxuICB9XG5cbiAgY29uc3QgaW1nQXR0cmlidXRlcyA9IGdlbmVyYXRlSW1nQXR0cnMoe1xuICAgIGNvbmZpZyxcbiAgICBzcmMsXG4gICAgdW5vcHRpbWl6ZWQsXG4gICAgd2lkdGg6IHdpZHRoSW50LFxuICAgIHF1YWxpdHk6IHF1YWxpdHlJbnQsXG4gICAgc2l6ZXMsXG4gICAgbG9hZGVyLFxuICB9KVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsZXQgZnVsbFVybDogVVJMXG4gICAgICB0cnkge1xuICAgICAgICBmdWxsVXJsID0gbmV3IFVSTChpbWdBdHRyaWJ1dGVzLnNyYylcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZnVsbFVybCA9IG5ldyBVUkwoaW1nQXR0cmlidXRlcy5zcmMsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICAgICAgfVxuICAgICAgYWxsSW1ncy5zZXQoZnVsbFVybC5ocmVmLCB7IHNyYywgcHJpb3JpdHksIHBsYWNlaG9sZGVyIH0pXG4gICAgfVxuICB9XG5cbiAgY29uc3QgcHJvcHM6IEltZ1Byb3BzID0ge1xuICAgIC4uLnJlc3QsXG4gICAgbG9hZGluZzogaXNMYXp5ID8gJ2xhenknIDogbG9hZGluZyxcbiAgICBmZXRjaFByaW9yaXR5LFxuICAgIHdpZHRoOiB3aWR0aEludCxcbiAgICBoZWlnaHQ6IGhlaWdodEludCxcbiAgICBkZWNvZGluZyxcbiAgICBjbGFzc05hbWUsXG4gICAgc3R5bGU6IHsgLi4uaW1nU3R5bGUsIC4uLnBsYWNlaG9sZGVyU3R5bGUgfSxcbiAgICBzaXplczogaW1nQXR0cmlidXRlcy5zaXplcyxcbiAgICBzcmNTZXQ6IGltZ0F0dHJpYnV0ZXMuc3JjU2V0LFxuICAgIHNyYzogb3ZlcnJpZGVTcmMgfHwgaW1nQXR0cmlidXRlcy5zcmMsXG4gIH1cbiAgY29uc3QgbWV0YSA9IHsgdW5vcHRpbWl6ZWQsIHByaW9yaXR5LCBwbGFjZWhvbGRlciwgZmlsbCB9XG4gIHJldHVybiB7IHByb3BzLCBtZXRhIH1cbn1cbiJdLCJuYW1lcyI6WyJnZXRJbWdQcm9wcyIsIlZBTElEX0xPQURJTkdfVkFMVUVTIiwidW5kZWZpbmVkIiwiaXNTdGF0aWNSZXF1aXJlIiwic3JjIiwiZGVmYXVsdCIsImlzU3RhdGljSW1hZ2VEYXRhIiwiaXNTdGF0aWNJbXBvcnQiLCJhbGxJbWdzIiwiTWFwIiwicGVyZk9ic2VydmVyIiwiZ2V0SW50IiwieCIsIk51bWJlciIsImlzRmluaXRlIiwiTmFOIiwidGVzdCIsInBhcnNlSW50IiwiZ2V0V2lkdGhzIiwid2lkdGgiLCJzaXplcyIsImRldmljZVNpemVzIiwiYWxsU2l6ZXMiLCJ2aWV3cG9ydFdpZHRoUmUiLCJwZXJjZW50U2l6ZXMiLCJtYXRjaCIsImV4ZWMiLCJwdXNoIiwibGVuZ3RoIiwic21hbGxlc3RSYXRpbyIsIk1hdGgiLCJtaW4iLCJ3aWR0aHMiLCJmaWx0ZXIiLCJzIiwia2luZCIsIlNldCIsIm1hcCIsInciLCJmaW5kIiwicCIsImdlbmVyYXRlSW1nQXR0cnMiLCJjb25maWciLCJ1bm9wdGltaXplZCIsInF1YWxpdHkiLCJsb2FkZXIiLCJzcmNTZXQiLCJsYXN0IiwiaSIsImpvaW4iLCJfc3RhdGUiLCJwcmlvcml0eSIsImxvYWRpbmciLCJjbGFzc05hbWUiLCJoZWlnaHQiLCJmaWxsIiwic3R5bGUiLCJvdmVycmlkZVNyYyIsIm9uTG9hZCIsIm9uTG9hZGluZ0NvbXBsZXRlIiwicGxhY2Vob2xkZXIiLCJibHVyRGF0YVVSTCIsImZldGNoUHJpb3JpdHkiLCJkZWNvZGluZyIsImxheW91dCIsIm9iamVjdEZpdCIsIm9iamVjdFBvc2l0aW9uIiwibGF6eUJvdW5kYXJ5IiwibGF6eVJvb3QiLCJyZXN0IiwiaW1nQ29uZiIsInNob3dBbHRUZXh0IiwiYmx1ckNvbXBsZXRlIiwiZGVmYXVsdExvYWRlciIsImMiLCJpbWFnZUNvbmZpZ0RlZmF1bHQiLCJpbWFnZVNpemVzIiwic29ydCIsImEiLCJiIiwiRXJyb3IiLCJpc0RlZmF1bHRMb2FkZXIiLCJjdXN0b21JbWFnZUxvYWRlciIsIm9iaiIsIl8iLCJvcHRzIiwibGF5b3V0VG9TdHlsZSIsImludHJpbnNpYyIsIm1heFdpZHRoIiwicmVzcG9uc2l2ZSIsImxheW91dFRvU2l6ZXMiLCJsYXlvdXRTdHlsZSIsImxheW91dFNpemVzIiwic3RhdGljU3JjIiwid2lkdGhJbnQiLCJoZWlnaHRJbnQiLCJibHVyV2lkdGgiLCJibHVySGVpZ2h0Iiwic3RhdGljSW1hZ2VEYXRhIiwiSlNPTiIsInN0cmluZ2lmeSIsInJhdGlvIiwicm91bmQiLCJpc0xhenkiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJkYW5nZXJvdXNseUFsbG93U1ZHIiwicXVhbGl0eUludCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIm91dHB1dCIsInBvc2l0aW9uIiwiaXNOYU4iLCJpbmNsdWRlcyIsIlN0cmluZyIsIndhcm5PbmNlIiwiVkFMSURfQkxVUl9FWFQiLCJ1cmxTdHIiLCJ1cmwiLCJVUkwiLCJlcnIiLCJwYXRobmFtZSIsInNlYXJjaCIsImxlZ2FjeUtleSIsImxlZ2FjeVZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsIndpbmRvdyIsIlBlcmZvcm1hbmNlT2JzZXJ2ZXIiLCJlbnRyeUxpc3QiLCJlbnRyeSIsImdldEVudHJpZXMiLCJpbWdTcmMiLCJlbGVtZW50IiwibGNwSW1hZ2UiLCJnZXQiLCJvYnNlcnZlIiwidHlwZSIsImJ1ZmZlcmVkIiwiY29uc29sZSIsImVycm9yIiwiaW1nU3R5bGUiLCJhc3NpZ24iLCJsZWZ0IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJjb2xvciIsImJhY2tncm91bmRJbWFnZSIsImdldEltYWdlQmx1clN2ZyIsInBsYWNlaG9sZGVyU3R5bGUiLCJiYWNrZ3JvdW5kU2l6ZSIsImJhY2tncm91bmRQb3NpdGlvbiIsImJhY2tncm91bmRSZXBlYXQiLCJpbWdBdHRyaWJ1dGVzIiwiZnVsbFVybCIsImUiLCJsb2NhdGlvbiIsImhyZWYiLCJzZXQiLCJwcm9wcyIsIm1ldGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/head.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_object_spread.js\");\nvar _type_of = __webpack_require__(/*! @swc/helpers/_/_type_of */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_type_of.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    \"default\": function _default1() {\n        return _default;\n    },\n    defaultHead: function defaultHead1() {\n        return defaultHead;\n    }\n});\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nvar _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nvar _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar _sideeffect = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./side-effect */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js\"));\nvar _ampcontextsharedruntime = __webpack_require__(/*! ./amp-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\");\nvar _headmanagercontextsharedruntime = __webpack_require__(/*! ./head-manager-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nvar _ampmode = __webpack_require__(/*! ./amp-mode */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js\");\nvar _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nfunction defaultHead(inAmpMode) {\n    if (inAmpMode === void 0) inAmpMode = false;\n    var head = [\n        /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            charSet: \"utf-8\"\n        }, \"charset\")\n    ];\n    if (!inAmpMode) {\n        head.push(/*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            name: \"viewport\",\n            content: \"width=device-width\"\n        }, \"viewport\"));\n    }\n    return head;\n}\nfunction onlyReactElement(list, child) {\n    // React children can be \"string\" or \"number\" in this case we ignore them for backwards compat\n    if (typeof child === 'string' || typeof child === 'number') {\n        return list;\n    }\n    // Adds support for React.Fragment\n    if (child.type === _react[\"default\"].Fragment) {\n        return list.concat(_react[\"default\"].Children.toArray(child.props.children).reduce(function(fragmentList, fragmentChild) {\n            if (typeof fragmentChild === 'string' || typeof fragmentChild === 'number') {\n                return fragmentList;\n            }\n            return fragmentList.concat(fragmentChild);\n        }, []));\n    }\n    return list.concat(child);\n}\nvar METATYPES = [\n    'name',\n    'httpEquiv',\n    'charSet',\n    'itemProp'\n];\n/*\n returns a function for filtering head child elements\n which shouldn't be duplicated, like <title/>\n Also adds support for deduplicated `key` properties\n*/ function unique() {\n    var keys = new Set();\n    var tags = new Set();\n    var metaTypes = new Set();\n    var metaCategories = {};\n    return function(h) {\n        var isUnique = true;\n        var hasKey = false;\n        if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {\n            hasKey = true;\n            var key = h.key.slice(h.key.indexOf('$') + 1);\n            if (keys.has(key)) {\n                isUnique = false;\n            } else {\n                keys.add(key);\n            }\n        }\n        // eslint-disable-next-line default-case\n        switch(h.type){\n            case 'title':\n            case 'base':\n                if (tags.has(h.type)) {\n                    isUnique = false;\n                } else {\n                    tags.add(h.type);\n                }\n                break;\n            case 'meta':\n                for(var i = 0, len = METATYPES.length; i < len; i++){\n                    var metatype = METATYPES[i];\n                    if (!h.props.hasOwnProperty(metatype)) continue;\n                    if (metatype === 'charSet') {\n                        if (metaTypes.has(metatype)) {\n                            isUnique = false;\n                        } else {\n                            metaTypes.add(metatype);\n                        }\n                    } else {\n                        var category = h.props[metatype];\n                        var categories = metaCategories[metatype] || new Set();\n                        if ((metatype !== 'name' || !hasKey) && categories.has(category)) {\n                            isUnique = false;\n                        } else {\n                            categories.add(category);\n                            metaCategories[metatype] = categories;\n                        }\n                    }\n                }\n                break;\n        }\n        return isUnique;\n    };\n}\n/**\n *\n * @param headChildrenElements List of children of <Head>\n */ function reduceComponents(headChildrenElements, props) {\n    var inAmpMode = props.inAmpMode;\n    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead(inAmpMode).reverse()).filter(unique()).reverse().map(function(c, i) {\n        var key = c.key || i;\n        if (false) { var newProps; }\n        if (true) {\n            // omit JSON-LD structured data snippets from the warning\n            if (c.type === 'script' && c.props['type'] !== 'application/ld+json') {\n                var srcMessage = c.props['src'] ? '<script> tag with src=\"' + c.props['src'] + '\"' : \"inline <script>\";\n                (0, _warnonce.warnOnce)(\"Do not add <script> tags using next/head (see \" + srcMessage + \"). Use next/script instead. \\nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component\");\n            } else if (c.type === 'link' && c.props['rel'] === 'stylesheet') {\n                (0, _warnonce.warnOnce)('Do not add stylesheets using next/head (see <link rel=\"stylesheet\"> tag with href=\"' + c.props['href'] + '\"). Use Document instead. \\nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component');\n            }\n        }\n        return /*#__PURE__*/ _react[\"default\"].cloneElement(c, {\n            key: key\n        });\n    });\n}\n/**\n * This component injects elements to `<head>` of your page.\n * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.\n */ function Head(param) {\n    var children = param.children;\n    var ampState = (0, _react.useContext)(_ampcontextsharedruntime.AmpStateContext);\n    var headManager = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_sideeffect[\"default\"], {\n        reduceComponentsToState: reduceComponents,\n        headManager: headManager,\n        inAmpMode: (0, _ampmode.isInAmpMode)(ampState),\n        children: children\n    });\n}\n_c = Head;\nvar _default = Head;\nif ((typeof exports[\"default\"] === 'function' || _type_of._(exports[\"default\"]) === 'object' && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === 'undefined') {\n    Object.defineProperty(exports[\"default\"], '__esModule', {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=head.js.map\nvar _c;\n$RefreshReg$(_c, \"Head\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9oZWFkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7SUF1TUEsT0FBbUI7aUJBQW5COztJQTFMZ0JBO2lCQUFBQSxvQkFBQUE7Ozs7Ozs7OEpBVkc7dUNBQ2E7OEtBQ0c7dUJBQ1A7MEhBQ0g7QUFNbEIsT0FBU0EsU0FBQUEsbUJBQVlDLENBQUFBLHFHQUFpQjtJQUFqQkEsS0FBQUEsWUFBQUEsU0FBQUE7SUFDMUIsTUFBTUMsT0FBTzs7WUFBT0UsT0FBQUEsRUFBUTtZQUFZO1FBQWE7S0FDckQ7UUFDRUYsQ0FBQUEsSUFBS0csSUFBSTtZQUNEQyxDQUFBQSxJQUFBQSxDQUFLO1lBQVdDLE1BQUFBLEdBQVE7WUFBeUI7UUFFM0Q7SUFDQTtJQUNGO0FBRUE7SUFJRTtJQUNBLElBQUksT0FBT0csVUFBVSxZQUFZLE9BQU9BLFVBQVUsVUFBVTtRQUMxRCxPQUFPRCxVQUFBQSxZQUFBQSxPQUFBQSxVQUFBQSxVQUFBQTtRQUNUO0lBQ0E7SUFDQSxJQUFJQyxNQUFNQyxJQUFJLEtBQUtDLGNBQUssQ0FBQ0M7UUFDdkIsT0FBT0osR0FBQUEsRUFBS0ssR0FBQUEsR0FBTSxDQUNoQjtRQUNBRixPQUFBQSxLQUFBQSxFQUFLLENBQUNHLEdBQUFBLENBRUosQ0FDRUssR0FIVSxDQUFDSixDQUdYSSxDQUFBQSxLQUhrQixDQUFDVixJQUduQlUsQ0FDQUMsQ0FKeUJKLEtBQUssQ0FBQ0MsQ0FJL0JHLENBQUFBLE1BSnVDLENBSXZDQSxDQUp5Q0YsTUFBTSxDQUNqRCxJQUdFRSxDQUFBQSxRQUFBQSxFQUFBQSxNQUFBQSxhQUVBLElBQ0UsT0FBT0E7Z0JBR1AsT0FBT0Qsa0JBQUFBLFlBQUFBLE9BQUFBLGtCQUFBQSxVQUFBQTtnQkFDVDtZQUNBO1lBRUYsQ0FBRTtRQUdSO0lBQ0E7SUFDRjtBQUVBO0lBQW1CO0lBQVE7SUFBYTtJQUFXO0lBQVc7Q0FFOUQ7Ozs7O0lB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QUEsWUFBQUEsQ0FBQUEsR0FBQUE7WUFBSTtRQUNyQztJQUNKO0FBRUE7Ozs7SUFJYyxNQUFFZCxHQUFBQSxLQUFRLEVBQWlDLEdBQTNDO0lBQ1osZUFBaUI4QyxFQUFBQSxJQUFYRDtJQUNOLElBQU1HLFdBQUFBLENBQUFBLEVBQWNGLENBQUFBLEdBQUFBLElBQUFBLFVBQUFBLEVBQUFBLENBQVUsRUFBQ0csc0JBQUFBLGVBQUFBO0lBQy9CLG1CQUNFLHFCQUFDQyxDQUFBQSxrQkFBTTtRQUNMQyxHQUFBQSxXQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxJQUF5QnpCLFFBQUFBLEdBQUFBLEVBQUFBLFdBQUFBLENBQUFBLFVBQUFBLEVBQUFBO1FBQ3pCc0IsYUFBYUEsWUFBQUE7UUFDYmpFLFdBQVdxRSxFQUFBQSxFQUFBQTtrQkFFVnBELENBQUFBLENBQUFBLEdBQUFBLFNBQUFBLFdBQUFBLEVBQUFBOztJQUdQOztLQVpnQkEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2hlYWQudHN4PzM2NzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCBSZWFjdCwgeyB1c2VDb250ZXh0LCB0eXBlIEpTWCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IEVmZmVjdCBmcm9tICcuL3NpZGUtZWZmZWN0J1xuaW1wb3J0IHsgQW1wU3RhdGVDb250ZXh0IH0gZnJvbSAnLi9hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IEhlYWRNYW5hZ2VyQ29udGV4dCB9IGZyb20gJy4vaGVhZC1tYW5hZ2VyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBpc0luQW1wTW9kZSB9IGZyb20gJy4vYW1wLW1vZGUnXG5pbXBvcnQgeyB3YXJuT25jZSB9IGZyb20gJy4vdXRpbHMvd2Fybi1vbmNlJ1xuXG50eXBlIFdpdGhJbkFtcE1vZGUgPSB7XG4gIGluQW1wTW9kZT86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRIZWFkKGluQW1wTW9kZSA9IGZhbHNlKTogSlNYLkVsZW1lbnRbXSB7XG4gIGNvbnN0IGhlYWQgPSBbPG1ldGEgY2hhclNldD1cInV0Zi04XCIga2V5PVwiY2hhcnNldFwiIC8+XVxuICBpZiAoIWluQW1wTW9kZSkge1xuICAgIGhlYWQucHVzaChcbiAgICAgIDxtZXRhIG5hbWU9XCJ2aWV3cG9ydFwiIGNvbnRlbnQ9XCJ3aWR0aD1kZXZpY2Utd2lkdGhcIiBrZXk9XCJ2aWV3cG9ydFwiIC8+XG4gICAgKVxuICB9XG4gIHJldHVybiBoZWFkXG59XG5cbmZ1bmN0aW9uIG9ubHlSZWFjdEVsZW1lbnQoXG4gIGxpc3Q6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PixcbiAgY2hpbGQ6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bWJlciB8IHN0cmluZ1xuKTogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+IHtcbiAgLy8gUmVhY3QgY2hpbGRyZW4gY2FuIGJlIFwic3RyaW5nXCIgb3IgXCJudW1iZXJcIiBpbiB0aGlzIGNhc2Ugd2UgaWdub3JlIHRoZW0gZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBsaXN0XG4gIH1cbiAgLy8gQWRkcyBzdXBwb3J0IGZvciBSZWFjdC5GcmFnbWVudFxuICBpZiAoY2hpbGQudHlwZSA9PT0gUmVhY3QuRnJhZ21lbnQpIHtcbiAgICByZXR1cm4gbGlzdC5jb25jYXQoXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEB0eXBlcy9yZWFjdCBkb2VzIG5vdCByZW1vdmUgZnJhZ21lbnRzIGJ1dCB0aGlzIGNvdWxkIGFsc28gcmV0dXJuIFJlYWN0UG9ydGFsW11cbiAgICAgIFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGQucHJvcHMuY2hpbGRyZW4pLnJlZHVjZShcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBAdHlwZXMvcmVhY3QgZG9lcyBub3QgcmVtb3ZlIGZyYWdtZW50cyBidXQgdGhpcyBjb3VsZCBhbHNvIHJldHVybiBSZWFjdFBvcnRhbFtdXG4gICAgICAgIChcbiAgICAgICAgICBmcmFnbWVudExpc3Q6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PixcbiAgICAgICAgICBmcmFnbWVudENoaWxkOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudW1iZXIgfCBzdHJpbmdcbiAgICAgICAgKTogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+ID0+IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0eXBlb2YgZnJhZ21lbnRDaGlsZCA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIHR5cGVvZiBmcmFnbWVudENoaWxkID09PSAnbnVtYmVyJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50TGlzdFxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZnJhZ21lbnRMaXN0LmNvbmNhdChmcmFnbWVudENoaWxkKVxuICAgICAgICB9LFxuICAgICAgICBbXVxuICAgICAgKVxuICAgIClcbiAgfVxuICByZXR1cm4gbGlzdC5jb25jYXQoY2hpbGQpXG59XG5cbmNvbnN0IE1FVEFUWVBFUyA9IFsnbmFtZScsICdodHRwRXF1aXYnLCAnY2hhclNldCcsICdpdGVtUHJvcCddXG5cbi8qXG4gcmV0dXJucyBhIGZ1bmN0aW9uIGZvciBmaWx0ZXJpbmcgaGVhZCBjaGlsZCBlbGVtZW50c1xuIHdoaWNoIHNob3VsZG4ndCBiZSBkdXBsaWNhdGVkLCBsaWtlIDx0aXRsZS8+XG4gQWxzbyBhZGRzIHN1cHBvcnQgZm9yIGRlZHVwbGljYXRlZCBga2V5YCBwcm9wZXJ0aWVzXG4qL1xuZnVuY3Rpb24gdW5pcXVlKCkge1xuICBjb25zdCBrZXlzID0gbmV3IFNldCgpXG4gIGNvbnN0IHRhZ3MgPSBuZXcgU2V0KClcbiAgY29uc3QgbWV0YVR5cGVzID0gbmV3IFNldCgpXG4gIGNvbnN0IG1ldGFDYXRlZ29yaWVzOiB7IFttZXRhdHlwZTogc3RyaW5nXTogU2V0PHN0cmluZz4gfSA9IHt9XG5cbiAgcmV0dXJuIChoOiBSZWFjdC5SZWFjdEVsZW1lbnQ8YW55PikgPT4ge1xuICAgIGxldCBpc1VuaXF1ZSA9IHRydWVcbiAgICBsZXQgaGFzS2V5ID0gZmFsc2VcblxuICAgIGlmIChoLmtleSAmJiB0eXBlb2YgaC5rZXkgIT09ICdudW1iZXInICYmIGgua2V5LmluZGV4T2YoJyQnKSA+IDApIHtcbiAgICAgIGhhc0tleSA9IHRydWVcbiAgICAgIGNvbnN0IGtleSA9IGgua2V5LnNsaWNlKGgua2V5LmluZGV4T2YoJyQnKSArIDEpXG4gICAgICBpZiAoa2V5cy5oYXMoa2V5KSkge1xuICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzLmFkZChrZXkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlZmF1bHQtY2FzZVxuICAgIHN3aXRjaCAoaC50eXBlKSB7XG4gICAgICBjYXNlICd0aXRsZSc6XG4gICAgICBjYXNlICdiYXNlJzpcbiAgICAgICAgaWYgKHRhZ3MuaGFzKGgudHlwZSkpIHtcbiAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFncy5hZGQoaC50eXBlKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdtZXRhJzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IE1FVEFUWVBFUy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNvbnN0IG1ldGF0eXBlID0gTUVUQVRZUEVTW2ldXG4gICAgICAgICAgaWYgKCFoLnByb3BzLmhhc093blByb3BlcnR5KG1ldGF0eXBlKSkgY29udGludWVcblxuICAgICAgICAgIGlmIChtZXRhdHlwZSA9PT0gJ2NoYXJTZXQnKSB7XG4gICAgICAgICAgICBpZiAobWV0YVR5cGVzLmhhcyhtZXRhdHlwZSkpIHtcbiAgICAgICAgICAgICAgaXNVbmlxdWUgPSBmYWxzZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWV0YVR5cGVzLmFkZChtZXRhdHlwZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSBoLnByb3BzW21ldGF0eXBlXVxuICAgICAgICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IG1ldGFDYXRlZ29yaWVzW21ldGF0eXBlXSB8fCBuZXcgU2V0KClcbiAgICAgICAgICAgIGlmICgobWV0YXR5cGUgIT09ICduYW1lJyB8fCAhaGFzS2V5KSAmJiBjYXRlZ29yaWVzLmhhcyhjYXRlZ29yeSkpIHtcbiAgICAgICAgICAgICAgaXNVbmlxdWUgPSBmYWxzZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2F0ZWdvcmllcy5hZGQoY2F0ZWdvcnkpXG4gICAgICAgICAgICAgIG1ldGFDYXRlZ29yaWVzW21ldGF0eXBlXSA9IGNhdGVnb3JpZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNVbmlxdWVcbiAgfVxufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gaGVhZENoaWxkcmVuRWxlbWVudHMgTGlzdCBvZiBjaGlsZHJlbiBvZiA8SGVhZD5cbiAqL1xuZnVuY3Rpb24gcmVkdWNlQ29tcG9uZW50czxUIGV4dGVuZHMge30gJiBXaXRoSW5BbXBNb2RlPihcbiAgaGVhZENoaWxkcmVuRWxlbWVudHM6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PixcbiAgcHJvcHM6IFRcbikge1xuICBjb25zdCB7IGluQW1wTW9kZSB9ID0gcHJvcHNcbiAgcmV0dXJuIGhlYWRDaGlsZHJlbkVsZW1lbnRzXG4gICAgLnJlZHVjZShvbmx5UmVhY3RFbGVtZW50LCBbXSlcbiAgICAucmV2ZXJzZSgpXG4gICAgLmNvbmNhdChkZWZhdWx0SGVhZChpbkFtcE1vZGUpLnJldmVyc2UoKSlcbiAgICAuZmlsdGVyKHVuaXF1ZSgpKVxuICAgIC5yZXZlcnNlKClcbiAgICAubWFwKChjOiBSZWFjdC5SZWFjdEVsZW1lbnQ8YW55PiwgaTogbnVtYmVyKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBjLmtleSB8fCBpXG4gICAgICBpZiAoXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnICYmXG4gICAgICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9PUFRJTUlaRV9GT05UUyAmJlxuICAgICAgICAhaW5BbXBNb2RlXG4gICAgICApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGMudHlwZSA9PT0gJ2xpbmsnICYmXG4gICAgICAgICAgYy5wcm9wc1snaHJlZiddICYmXG4gICAgICAgICAgLy8gVE9ETyhwcmF0ZWVrYmhAKTogUmVwbGFjZSB0aGlzIHdpdGggY29uc3QgZnJvbSBgY29uc3RhbnRzYCB3aGVuIHRoZSB0cmVlIHNoYWtpbmcgd29ya3MuXG4gICAgICAgICAgWydodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2NzcycsICdodHRwczovL3VzZS50eXBla2l0Lm5ldC8nXS5zb21lKFxuICAgICAgICAgICAgKHVybCkgPT4gYy5wcm9wc1snaHJlZiddLnN0YXJ0c1dpdGgodXJsKVxuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgbmV3UHJvcHMgPSB7IC4uLihjLnByb3BzIHx8IHt9KSB9XG4gICAgICAgICAgbmV3UHJvcHNbJ2RhdGEtaHJlZiddID0gbmV3UHJvcHNbJ2hyZWYnXVxuICAgICAgICAgIG5ld1Byb3BzWydocmVmJ10gPSB1bmRlZmluZWRcblxuICAgICAgICAgIC8vIEFkZCB0aGlzIGF0dHJpYnV0ZSB0byBtYWtlIGl0IGVhc3kgdG8gaWRlbnRpZnkgb3B0aW1pemVkIHRhZ3NcbiAgICAgICAgICBuZXdQcm9wc1snZGF0YS1vcHRpbWl6ZWQtZm9udHMnXSA9IHRydWVcblxuICAgICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoYywgbmV3UHJvcHMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAvLyBvbWl0IEpTT04tTEQgc3RydWN0dXJlZCBkYXRhIHNuaXBwZXRzIGZyb20gdGhlIHdhcm5pbmdcbiAgICAgICAgaWYgKGMudHlwZSA9PT0gJ3NjcmlwdCcgJiYgYy5wcm9wc1sndHlwZSddICE9PSAnYXBwbGljYXRpb24vbGQranNvbicpIHtcbiAgICAgICAgICBjb25zdCBzcmNNZXNzYWdlID0gYy5wcm9wc1snc3JjJ11cbiAgICAgICAgICAgID8gYDxzY3JpcHQ+IHRhZyB3aXRoIHNyYz1cIiR7Yy5wcm9wc1snc3JjJ119XCJgXG4gICAgICAgICAgICA6IGBpbmxpbmUgPHNjcmlwdD5gXG4gICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICBgRG8gbm90IGFkZCA8c2NyaXB0PiB0YWdzIHVzaW5nIG5leHQvaGVhZCAoc2VlICR7c3JjTWVzc2FnZX0pLiBVc2UgbmV4dC9zY3JpcHQgaW5zdGVhZC4gXFxuU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uby1zY3JpcHQtdGFncy1pbi1oZWFkLWNvbXBvbmVudGBcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSBpZiAoYy50eXBlID09PSAnbGluaycgJiYgYy5wcm9wc1sncmVsJ10gPT09ICdzdHlsZXNoZWV0Jykge1xuICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgYERvIG5vdCBhZGQgc3R5bGVzaGVldHMgdXNpbmcgbmV4dC9oZWFkIChzZWUgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiPiB0YWcgd2l0aCBocmVmPVwiJHtjLnByb3BzWydocmVmJ119XCIpLiBVc2UgRG9jdW1lbnQgaW5zdGVhZC4gXFxuU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uby1zdHlsZXNoZWV0cy1pbi1oZWFkLWNvbXBvbmVudGBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoYywgeyBrZXkgfSlcbiAgICB9KVxufVxuXG4vKipcbiAqIFRoaXMgY29tcG9uZW50IGluamVjdHMgZWxlbWVudHMgdG8gYDxoZWFkPmAgb2YgeW91ciBwYWdlLlxuICogVG8gYXZvaWQgZHVwbGljYXRlZCBgdGFnc2AgaW4gYDxoZWFkPmAgeW91IGNhbiB1c2UgdGhlIGBrZXlgIHByb3BlcnR5LCB3aGljaCB3aWxsIG1ha2Ugc3VyZSBldmVyeSB0YWcgaXMgb25seSByZW5kZXJlZCBvbmNlLlxuICovXG5mdW5jdGlvbiBIZWFkKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0pIHtcbiAgY29uc3QgYW1wU3RhdGUgPSB1c2VDb250ZXh0KEFtcFN0YXRlQ29udGV4dClcbiAgY29uc3QgaGVhZE1hbmFnZXIgPSB1c2VDb250ZXh0KEhlYWRNYW5hZ2VyQ29udGV4dClcbiAgcmV0dXJuIChcbiAgICA8RWZmZWN0XG4gICAgICByZWR1Y2VDb21wb25lbnRzVG9TdGF0ZT17cmVkdWNlQ29tcG9uZW50c31cbiAgICAgIGhlYWRNYW5hZ2VyPXtoZWFkTWFuYWdlcn1cbiAgICAgIGluQW1wTW9kZT17aXNJbkFtcE1vZGUoYW1wU3RhdGUpfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0VmZmVjdD5cbiAgKVxufVxuXG5leHBvcnQgZGVmYXVsdCBIZWFkXG4iXSwibmFtZXMiOlsiZGVmYXVsdEhlYWQiLCJpbkFtcE1vZGUiLCJoZWFkIiwibWV0YSIsImNoYXJTZXQiLCJwdXNoIiwibmFtZSIsImNvbnRlbnQiLCJvbmx5UmVhY3RFbGVtZW50IiwibGlzdCIsImNoaWxkIiwidHlwZSIsIlJlYWN0IiwiRnJhZ21lbnQiLCJjb25jYXQiLCJDaGlsZHJlbiIsInRvQXJyYXkiLCJwcm9wcyIsImNoaWxkcmVuIiwicmVkdWNlIiwiZnJhZ21lbnRMaXN0IiwiZnJhZ21lbnRDaGlsZCIsIk1FVEFUWVBFUyIsInVuaXF1ZSIsImtleXMiLCJTZXQiLCJ0YWdzIiwibWV0YVR5cGVzIiwibWV0YUNhdGVnb3JpZXMiLCJoIiwiaXNVbmlxdWUiLCJoYXNLZXkiLCJrZXkiLCJpbmRleE9mIiwic2xpY2UiLCJoYXMiLCJhZGQiLCJpIiwibGVuIiwibGVuZ3RoIiwibWV0YXR5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhdGVnb3J5IiwiY2F0ZWdvcmllcyIsInJlZHVjZUNvbXBvbmVudHMiLCJoZWFkQ2hpbGRyZW5FbGVtZW50cyIsInJldmVyc2UiLCJmaWx0ZXIiLCJtYXAiLCJjIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiX19ORVhUX09QVElNSVpFX0ZPTlRTIiwic29tZSIsInVybCIsInN0YXJ0c1dpdGgiLCJuZXdQcm9wcyIsInVuZGVmaW5lZCIsImNsb25lRWxlbWVudCIsInNyY01lc3NhZ2UiLCJ3YXJuT25jZSIsIkhlYWQiLCJhbXBTdGF0ZSIsInVzZUNvbnRleHQiLCJBbXBTdGF0ZUNvbnRleHQiLCJoZWFkTWFuYWdlciIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsIkVmZmVjdCIsInJlZHVjZUNvbXBvbmVudHNUb1N0YXRlIiwiaXNJbkFtcE1vZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-blur-svg.js ***!
  \*************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * A shared function, used on both client and server, to generate a SVG blur placeholder.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImageBlurSvg\", ({\n    enumerable: true,\n    get: function get() {\n        return getImageBlurSvg;\n    }\n}));\nfunction getImageBlurSvg(param) {\n    var widthInt = param.widthInt, heightInt = param.heightInt, blurWidth = param.blurWidth, blurHeight = param.blurHeight, blurDataURL = param.blurDataURL, objectFit = param.objectFit;\n    var std = 20;\n    var svgWidth = blurWidth ? blurWidth * 40 : widthInt;\n    var svgHeight = blurHeight ? blurHeight * 40 : heightInt;\n    var viewBox = svgWidth && svgHeight ? \"viewBox='0 0 \" + svgWidth + \" \" + svgHeight + \"'\" : '';\n    var preserveAspectRatio = viewBox ? 'none' : objectFit === 'contain' ? 'xMidYMid' : objectFit === 'cover' ? 'xMidYMid slice' : 'none';\n    return \"%3Csvg xmlns='http://www.w3.org/2000/svg' \" + viewBox + \"%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='\" + preserveAspectRatio + \"' style='filter: url(%23b);' href='\" + blurDataURL + \"'/%3E%3C/svg%3E\";\n} //# sourceMappingURL=image-blur-svg.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1ibHVyLXN2Zy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQzs7OzttREFDZUE7OztlQUFBQTs7O0FBQVQsU0FBU0EsZ0JBQWdCLEtBYy9CO0lBZCtCLHFCQUM5QkMsUUFBUSxvQkFDUkMsU0FBUyxvQkFDVEMsU0FBUyxxQkFDVEMsVUFBVSxzQkFDVkMsV0FBVyxjQUxtQixNQU05QkMsU0FBUztJQVNULElBQU1DLE1BQU07SUFDWixJQUFNQyxXQUFXTCxZQUFZQSxZQUFZLEtBQUtGO0lBQzlDLElBQU1RLFlBQVlMLGFBQWFBLGFBQWEsS0FBS0Y7SUFFakQsSUFBTVEsVUFDSkYsWUFBWUMsWUFBYSxrQkFBZUQsV0FBUyxNQUFHQyxZQUFVLE1BQUs7SUFDckUsSUFBTUUsc0JBQXNCRCxVQUN4QixTQUNBSixjQUFjLFlBQ1osYUFDQUEsY0FBYyxVQUNaLG1CQUNBO0lBRVIsT0FBUSwrQ0FBNENJLFVBQVEsOEZBQTJGSCxNQUFJLG9RQUFpUUEsTUFBSSxnR0FBNkZJLHNCQUFvQix3Q0FBcUNOLGNBQVk7QUFDcGtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9pbWFnZS1ibHVyLXN2Zy50cz9jNzljIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBzaGFyZWQgZnVuY3Rpb24sIHVzZWQgb24gYm90aCBjbGllbnQgYW5kIHNlcnZlciwgdG8gZ2VuZXJhdGUgYSBTVkcgYmx1ciBwbGFjZWhvbGRlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEltYWdlQmx1clN2Zyh7XG4gIHdpZHRoSW50LFxuICBoZWlnaHRJbnQsXG4gIGJsdXJXaWR0aCxcbiAgYmx1ckhlaWdodCxcbiAgYmx1ckRhdGFVUkwsXG4gIG9iamVjdEZpdCxcbn06IHtcbiAgd2lkdGhJbnQ/OiBudW1iZXJcbiAgaGVpZ2h0SW50PzogbnVtYmVyXG4gIGJsdXJXaWR0aD86IG51bWJlclxuICBibHVySGVpZ2h0PzogbnVtYmVyXG4gIGJsdXJEYXRhVVJMOiBzdHJpbmdcbiAgb2JqZWN0Rml0Pzogc3RyaW5nXG59KTogc3RyaW5nIHtcbiAgY29uc3Qgc3RkID0gMjBcbiAgY29uc3Qgc3ZnV2lkdGggPSBibHVyV2lkdGggPyBibHVyV2lkdGggKiA0MCA6IHdpZHRoSW50XG4gIGNvbnN0IHN2Z0hlaWdodCA9IGJsdXJIZWlnaHQgPyBibHVySGVpZ2h0ICogNDAgOiBoZWlnaHRJbnRcblxuICBjb25zdCB2aWV3Qm94ID1cbiAgICBzdmdXaWR0aCAmJiBzdmdIZWlnaHQgPyBgdmlld0JveD0nMCAwICR7c3ZnV2lkdGh9ICR7c3ZnSGVpZ2h0fSdgIDogJydcbiAgY29uc3QgcHJlc2VydmVBc3BlY3RSYXRpbyA9IHZpZXdCb3hcbiAgICA/ICdub25lJ1xuICAgIDogb2JqZWN0Rml0ID09PSAnY29udGFpbidcbiAgICAgID8gJ3hNaWRZTWlkJ1xuICAgICAgOiBvYmplY3RGaXQgPT09ICdjb3ZlcidcbiAgICAgICAgPyAneE1pZFlNaWQgc2xpY2UnXG4gICAgICAgIDogJ25vbmUnXG5cbiAgcmV0dXJuIGAlM0NzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyAke3ZpZXdCb3h9JTNFJTNDZmlsdGVyIGlkPSdiJyBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9J3NSR0InJTNFJTNDZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPScke3N0ZH0nLyUzRSUzQ2ZlQ29sb3JNYXRyaXggdmFsdWVzPScxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxMDAgLTEnIHJlc3VsdD0ncycvJTNFJTNDZmVGbG9vZCB4PScwJyB5PScwJyB3aWR0aD0nMTAwJTI1JyBoZWlnaHQ9JzEwMCUyNScvJTNFJTNDZmVDb21wb3NpdGUgb3BlcmF0b3I9J291dCcgaW49J3MnLyUzRSUzQ2ZlQ29tcG9zaXRlIGluMj0nU291cmNlR3JhcGhpYycvJTNFJTNDZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPScke3N0ZH0nLyUzRSUzQy9maWx0ZXIlM0UlM0NpbWFnZSB3aWR0aD0nMTAwJTI1JyBoZWlnaHQ9JzEwMCUyNScgeD0nMCcgeT0nMCcgcHJlc2VydmVBc3BlY3RSYXRpbz0nJHtwcmVzZXJ2ZUFzcGVjdFJhdGlvfScgc3R5bGU9J2ZpbHRlcjogdXJsKCUyM2IpOycgaHJlZj0nJHtibHVyRGF0YVVSTH0nLyUzRSUzQy9zdmclM0VgXG59XG4iXSwibmFtZXMiOlsiZ2V0SW1hZ2VCbHVyU3ZnIiwid2lkdGhJbnQiLCJoZWlnaHRJbnQiLCJibHVyV2lkdGgiLCJibHVySGVpZ2h0IiwiYmx1ckRhdGFVUkwiLCJvYmplY3RGaXQiLCJzdGQiLCJzdmdXaWR0aCIsInN2Z0hlaWdodCIsInZpZXdCb3giLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js ***!
  \**********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ImageConfigContext\", ({\n    enumerable: true,\n    get: function get() {\n        return ImageConfigContext;\n    }\n}));\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nvar ImageConfigContext = _react[\"default\"].createContext(_imageconfig.imageConfigDefault);\nif (true) {\n    ImageConfigContext.displayName = 'ImageConfigContext';\n} //# sourceMappingURL=image-config-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O3NEQUlhQTs7O2VBQUFBOzs7OzBFQUpLO3VDQUVpQjtBQUU1QixJQUFNQSxxQkFDWEMsTUFBQUEsQ0FBQUEsVUFBSyxDQUFDQyxhQUFhLENBQXNCQyxhQUFBQSxrQkFBa0I7QUFFN0QsSUFBSUMsSUFBb0IsRUFBbUI7SUFDekNKLG1CQUFtQk8sV0FBVyxHQUFHO0FBQ25DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZS50cz8zZDc1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB0eXBlIHsgSW1hZ2VDb25maWdDb21wbGV0ZSB9IGZyb20gJy4vaW1hZ2UtY29uZmlnJ1xuaW1wb3J0IHsgaW1hZ2VDb25maWdEZWZhdWx0IH0gZnJvbSAnLi9pbWFnZS1jb25maWcnXG5cbmV4cG9ydCBjb25zdCBJbWFnZUNvbmZpZ0NvbnRleHQgPVxuICBSZWFjdC5jcmVhdGVDb250ZXh0PEltYWdlQ29uZmlnQ29tcGxldGU+KGltYWdlQ29uZmlnRGVmYXVsdClcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgSW1hZ2VDb25maWdDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0ltYWdlQ29uZmlnQ29udGV4dCdcbn1cbiJdLCJuYW1lcyI6WyJJbWFnZUNvbmZpZ0NvbnRleHQiLCJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJpbWFnZUNvbmZpZ0RlZmF1bHQiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJkaXNwbGF5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-config.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    VALID_LOADERS: function VALID_LOADERS1() {\n        return VALID_LOADERS;\n    },\n    imageConfigDefault: function imageConfigDefault1() {\n        return imageConfigDefault;\n    }\n});\nvar VALID_LOADERS = [\n    'default',\n    'imgix',\n    'cloudinary',\n    'akamai',\n    'custom'\n];\nvar imageConfigDefault = {\n    deviceSizes: [\n        640,\n        750,\n        828,\n        1080,\n        1200,\n        1920,\n        2048,\n        3840\n    ],\n    imageSizes: [\n        16,\n        32,\n        48,\n        64,\n        96,\n        128,\n        256,\n        384\n    ],\n    path: '/_next/image',\n    loader: 'default',\n    loaderFile: '',\n    domains: [],\n    disableStaticImages: false,\n    minimumCacheTTL: 60,\n    formats: [\n        'image/webp'\n    ],\n    dangerouslyAllowSVG: false,\n    contentSecurityPolicy: \"script-src 'none'; frame-src 'none'; sandbox;\",\n    contentDispositionType: 'attachment',\n    localPatterns: undefined,\n    remotePatterns: [],\n    unoptimized: false\n}; //# sourceMappingURL=image-config.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O21CQUEwQixTQUFiQSxhQUFhO2VBQWJBOzt3QkE4SGtCLFNBQWxCQyxrQkFBa0I7ZUFBbEJBOzs7QUE5SE4sSUFBTUQsZ0JBQWdCO0lBQzNCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQXdITSxJQUFNQyxxQkFBMEM7SUFDckRDLGFBQWE7UUFBQztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO0tBQUs7SUFDMURDLFlBQVk7UUFBQztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSztRQUFLO0tBQUk7SUFDL0NDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxZQUFZO0lBQ1pDLFNBQVMsRUFBRTtJQUNYQyxxQkFBcUI7SUFDckJDLGlCQUFpQjtJQUNqQkMsU0FBUztRQUFDO0tBQWE7SUFDdkJDLHFCQUFxQjtJQUNyQkMsdUJBQXdCO0lBQ3hCQyx3QkFBd0I7SUFDeEJDLGVBQWVDO0lBQ2ZDLGdCQUFnQixFQUFFO0lBQ2xCQyxhQUFhO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy50cz8xMzRhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBWQUxJRF9MT0FERVJTID0gW1xuICAnZGVmYXVsdCcsXG4gICdpbWdpeCcsXG4gICdjbG91ZGluYXJ5JyxcbiAgJ2FrYW1haScsXG4gICdjdXN0b20nLFxuXSBhcyBjb25zdFxuXG5leHBvcnQgdHlwZSBMb2FkZXJWYWx1ZSA9ICh0eXBlb2YgVkFMSURfTE9BREVSUylbbnVtYmVyXVxuXG5leHBvcnQgdHlwZSBJbWFnZUxvYWRlclByb3BzID0ge1xuICBzcmM6IHN0cmluZ1xuICB3aWR0aDogbnVtYmVyXG4gIHF1YWxpdHk/OiBudW1iZXJcbn1cblxuZXhwb3J0IHR5cGUgSW1hZ2VMb2FkZXJQcm9wc1dpdGhDb25maWcgPSBJbWFnZUxvYWRlclByb3BzICYge1xuICBjb25maWc6IFJlYWRvbmx5PEltYWdlQ29uZmlnPlxufVxuXG5leHBvcnQgdHlwZSBMb2NhbFBhdHRlcm4gPSB7XG4gIC8qKlxuICAgKiBDYW4gYmUgbGl0ZXJhbCBvciB3aWxkY2FyZC5cbiAgICogU2luZ2xlIGAqYCBtYXRjaGVzIGEgc2luZ2xlIHBhdGggc2VnbWVudC5cbiAgICogRG91YmxlIGAqKmAgbWF0Y2hlcyBhbnkgbnVtYmVyIG9mIHBhdGggc2VnbWVudHMuXG4gICAqL1xuICBwYXRobmFtZT86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBDYW4gYmUgbGl0ZXJhbCBxdWVyeSBzdHJpbmcgc3VjaCBhcyBgP3Y9MWAgb3JcbiAgICogZW1wdHkgc3RyaW5nIG1lYW5pbmcgbm8gcXVlcnkgc3RyaW5nLlxuICAgKi9cbiAgc2VhcmNoPzogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIFJlbW90ZVBhdHRlcm4gPSB7XG4gIC8qKlxuICAgKiBNdXN0IGJlIGBodHRwYCBvciBgaHR0cHNgLlxuICAgKi9cbiAgcHJvdG9jb2w/OiAnaHR0cCcgfCAnaHR0cHMnXG5cbiAgLyoqXG4gICAqIENhbiBiZSBsaXRlcmFsIG9yIHdpbGRjYXJkLlxuICAgKiBTaW5nbGUgYCpgIG1hdGNoZXMgYSBzaW5nbGUgc3ViZG9tYWluLlxuICAgKiBEb3VibGUgYCoqYCBtYXRjaGVzIGFueSBudW1iZXIgb2Ygc3ViZG9tYWlucy5cbiAgICovXG4gIGhvc3RuYW1lOiBzdHJpbmdcblxuICAvKipcbiAgICogQ2FuIGJlIGxpdGVyYWwgcG9ydCBzdWNoIGFzIGA4MDgwYCBvciBlbXB0eSBzdHJpbmdcbiAgICogbWVhbmluZyBubyBwb3J0LlxuICAgKi9cbiAgcG9ydD86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBDYW4gYmUgbGl0ZXJhbCBvciB3aWxkY2FyZC5cbiAgICogU2luZ2xlIGAqYCBtYXRjaGVzIGEgc2luZ2xlIHBhdGggc2VnbWVudC5cbiAgICogRG91YmxlIGAqKmAgbWF0Y2hlcyBhbnkgbnVtYmVyIG9mIHBhdGggc2VnbWVudHMuXG4gICAqL1xuICBwYXRobmFtZT86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBDYW4gYmUgbGl0ZXJhbCBxdWVyeSBzdHJpbmcgc3VjaCBhcyBgP3Y9MWAgb3JcbiAgICogZW1wdHkgc3RyaW5nIG1lYW5pbmcgbm8gcXVlcnkgc3RyaW5nLlxuICAgKi9cbiAgc2VhcmNoPzogc3RyaW5nXG59XG5cbnR5cGUgSW1hZ2VGb3JtYXQgPSAnaW1hZ2UvYXZpZicgfCAnaW1hZ2Uvd2VicCdcblxuLyoqXG4gKiBJbWFnZSBjb25maWd1cmF0aW9uc1xuICpcbiAqIEBzZWUgW0ltYWdlIGNvbmZpZ3VyYXRpb24gb3B0aW9uc10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI2NvbmZpZ3VyYXRpb24tb3B0aW9ucylcbiAqL1xuZXhwb3J0IHR5cGUgSW1hZ2VDb25maWdDb21wbGV0ZSA9IHtcbiAgLyoqIEBzZWUgW0RldmljZSBzaXplcyBkb2N1bWVudGF0aW9uXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvaW1hZ2UjZGV2aWNlLXNpemVzKSAqL1xuICBkZXZpY2VTaXplczogbnVtYmVyW11cblxuICAvKiogQHNlZSBbSW1hZ2Ugc2l6aW5nIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2Jhc2ljLWZlYXR1cmVzL2ltYWdlLW9wdGltaXphdGlvbiNpbWFnZS1zaXppbmcpICovXG4gIGltYWdlU2l6ZXM6IG51bWJlcltdXG5cbiAgLyoqIEBzZWUgW0ltYWdlIGxvYWRlcnMgY29uZmlndXJhdGlvbl0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2xlZ2FjeS9pbWFnZSNsb2FkZXIpICovXG4gIGxvYWRlcjogTG9hZGVyVmFsdWVcblxuICAvKiogQHNlZSBbSW1hZ2UgbG9hZGVyIGNvbmZpZ3VyYXRpb25dKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9sZWdhY3kvaW1hZ2UjbG9hZGVyLWNvbmZpZ3VyYXRpb24pICovXG4gIHBhdGg6IHN0cmluZ1xuXG4gIC8qKiBAc2VlIFtJbWFnZSBsb2FkZXIgY29uZmlndXJhdGlvbl0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI2xvYWRlci1jb25maWd1cmF0aW9uKSAqL1xuICBsb2FkZXJGaWxlOiBzdHJpbmdcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGByZW1vdGVQYXR0ZXJuc2AgaW5zdGVhZC5cbiAgICovXG4gIGRvbWFpbnM6IHN0cmluZ1tdXG5cbiAgLyoqIEBzZWUgW0Rpc2FibGUgc3RhdGljIGltYWdlIGltcG9ydCBjb25maWd1cmF0aW9uXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvaW1hZ2UjZGlzYWJsZS1zdGF0aWMtaW1wb3J0cykgKi9cbiAgZGlzYWJsZVN0YXRpY0ltYWdlczogYm9vbGVhblxuXG4gIC8qKiBAc2VlIFtDYWNoZSBiZWhhdmlvcl0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI2NhY2hpbmctYmVoYXZpb3IpICovXG4gIG1pbmltdW1DYWNoZVRUTDogbnVtYmVyXG5cbiAgLyoqIEBzZWUgW0FjY2VwdGFibGUgZm9ybWF0c10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI2FjY2VwdGFibGUtZm9ybWF0cykgKi9cbiAgZm9ybWF0czogSW1hZ2VGb3JtYXRbXVxuXG4gIC8qKiBAc2VlIFtEYW5nZXJvdXNseSBBbGxvdyBTVkddKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNkYW5nZXJvdXNseS1hbGxvdy1zdmcpICovXG4gIGRhbmdlcm91c2x5QWxsb3dTVkc6IGJvb2xlYW5cblxuICAvKiogQHNlZSBbRGFuZ2Vyb3VzbHkgQWxsb3cgU1ZHXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvaW1hZ2UjZGFuZ2Vyb3VzbHktYWxsb3ctc3ZnKSAqL1xuICBjb250ZW50U2VjdXJpdHlQb2xpY3k6IHN0cmluZ1xuXG4gIC8qKiBAc2VlIFtEYW5nZXJvdXNseSBBbGxvdyBTVkddKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNkYW5nZXJvdXNseS1hbGxvdy1zdmcpICovXG4gIGNvbnRlbnREaXNwb3NpdGlvblR5cGU6ICdpbmxpbmUnIHwgJ2F0dGFjaG1lbnQnXG5cbiAgLyoqIEBzZWUgW1JlbW90ZSBQYXR0ZXJuc10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI3JlbW90ZXBhdHRlcm5zKSAqL1xuICByZW1vdGVQYXR0ZXJuczogUmVtb3RlUGF0dGVybltdXG5cbiAgLyoqIEBzZWUgW1JlbW90ZSBQYXR0ZXJuc10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI2xvY2FsUGF0dGVybnMpICovXG4gIGxvY2FsUGF0dGVybnM6IExvY2FsUGF0dGVybltdIHwgdW5kZWZpbmVkXG5cbiAgLyoqIEBzZWUgW1Vub3B0aW1pemVkXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvaW1hZ2UjdW5vcHRpbWl6ZWQpICovXG4gIHVub3B0aW1pemVkOiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIEltYWdlQ29uZmlnID0gUGFydGlhbDxJbWFnZUNvbmZpZ0NvbXBsZXRlPlxuXG5leHBvcnQgY29uc3QgaW1hZ2VDb25maWdEZWZhdWx0OiBJbWFnZUNvbmZpZ0NvbXBsZXRlID0ge1xuICBkZXZpY2VTaXplczogWzY0MCwgNzUwLCA4MjgsIDEwODAsIDEyMDAsIDE5MjAsIDIwNDgsIDM4NDBdLFxuICBpbWFnZVNpemVzOiBbMTYsIDMyLCA0OCwgNjQsIDk2LCAxMjgsIDI1NiwgMzg0XSxcbiAgcGF0aDogJy9fbmV4dC9pbWFnZScsXG4gIGxvYWRlcjogJ2RlZmF1bHQnLFxuICBsb2FkZXJGaWxlOiAnJyxcbiAgZG9tYWluczogW10sXG4gIGRpc2FibGVTdGF0aWNJbWFnZXM6IGZhbHNlLFxuICBtaW5pbXVtQ2FjaGVUVEw6IDYwLFxuICBmb3JtYXRzOiBbJ2ltYWdlL3dlYnAnXSxcbiAgZGFuZ2Vyb3VzbHlBbGxvd1NWRzogZmFsc2UsXG4gIGNvbnRlbnRTZWN1cml0eVBvbGljeTogYHNjcmlwdC1zcmMgJ25vbmUnOyBmcmFtZS1zcmMgJ25vbmUnOyBzYW5kYm94O2AsXG4gIGNvbnRlbnREaXNwb3NpdGlvblR5cGU6ICdhdHRhY2htZW50JyxcbiAgbG9jYWxQYXR0ZXJuczogdW5kZWZpbmVkLCAvLyBkZWZhdWx0OiBhbGxvdyBhbGwgbG9jYWwgaW1hZ2VzXG4gIHJlbW90ZVBhdHRlcm5zOiBbXSwgLy8gZGVmYXVsdDogYWxsb3cgbm8gcmVtb3RlIGltYWdlc1xuICB1bm9wdGltaXplZDogZmFsc2UsXG59XG4iXSwibmFtZXMiOlsiVkFMSURfTE9BREVSUyIsImltYWdlQ29uZmlnRGVmYXVsdCIsImRldmljZVNpemVzIiwiaW1hZ2VTaXplcyIsInBhdGgiLCJsb2FkZXIiLCJsb2FkZXJGaWxlIiwiZG9tYWlucyIsImRpc2FibGVTdGF0aWNJbWFnZXMiLCJtaW5pbXVtQ2FjaGVUVEwiLCJmb3JtYXRzIiwiZGFuZ2Vyb3VzbHlBbGxvd1NWRyIsImNvbnRlbnRTZWN1cml0eVBvbGljeSIsImNvbnRlbnREaXNwb3NpdGlvblR5cGUiLCJsb2NhbFBhdHRlcm5zIiwidW5kZWZpbmVkIiwicmVtb3RlUGF0dGVybnMiLCJ1bm9wdGltaXplZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-external.js ***!
  \*************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_sliced_to_array.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    \"default\": function _default1() {\n        return _default;\n    },\n    getImageProps: function getImageProps1() {\n        return getImageProps;\n    }\n});\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _getimgprops = __webpack_require__(/*! ./get-img-props */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\");\nvar _imagecomponent = __webpack_require__(/*! ../../client/image-component */ \"(app-pages-browser)/./node_modules/next/dist/client/image-component.js\");\nvar _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\"));\nfunction getImageProps(imgProps) {\n    var props = (0, _getimgprops.getImgProps)(imgProps, {\n        defaultLoader: _imageloader[\"default\"],\n        // This is replaced by webpack define plugin\n        imgConf: {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[]}\n    }).props;\n    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n    try {\n        // Normally we don't care about undefined props because we pass to JSX,\n        // but this exported function could be used by the end user for anything\n        // so we delete undefined props to clean it up a little.\n        for(var _iterator = Object.entries(props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n            var _step_value = _sliced_to_array._(_step.value, 2), key = _step_value[0], value = _step_value[1];\n            if (value === undefined) {\n                delete props[key];\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally{\n        try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                _iterator[\"return\"]();\n            }\n        } finally{\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n    return {\n        props: props\n    };\n}\nvar _default = _imagecomponent.Image; //# sourceMappingURL=image-external.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1leHRlcm5hbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0lBaUNBLE9BQW9CO2VBQXBCOzttQkFqQjZCLFNBQWJBLGFBQWE7ZUFBYkE7Ozs7dUNBYlk7MENBQ047Z0ZBR0k7QUFTbkIsU0FBU0EsY0FBY0MsUUFBb0I7SUFDaEQsSUFBTSxRQUFZRSxDQUFBQSxHQUFBQSxhQUFBQSxXQUFBQSxFQUFZRixVQUFVO1FBQ3RDRyxlQUFBQSxZQUFBQSxDQUFBQSxVQUFhO1FBQ2IsNENBQTRDO1FBQzVDQyxTQUFTQywwTkFBNkI7SUFDeEMsR0FKUUosS0FBSzs7O1FBS2IsdUVBQXVFO1FBQ3ZFLHdFQUF3RTtRQUN4RSx3REFBd0Q7UUFDeEQsb0JBQTJCUyxPQUFPQyxPQUFPLENBQUNWLG1JQUFRO2tFQUF0Q08sc0JBQUtDLE1BQU07WUFDckIsSUFBSUEsVUFBVUcsV0FBVztnQkFDdkIsT0FBT1gsS0FBSyxDQUFDTyxJQUEwQjtZQUN6QztRQUNGOzs7Ozs7Ozs7OztzQkFKSyxNQUFNOzs7O0lBS1gsT0FBTztlQUFFUDtJQUFNO0FBQ2pCO0lBRUEsV0FBZVksZ0JBQUFBLEtBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2ltYWdlLWV4dGVybmFsLnRzeD8zODI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgSW1hZ2VDb25maWdDb21wbGV0ZSwgSW1hZ2VMb2FkZXJQcm9wcyB9IGZyb20gJy4vaW1hZ2UtY29uZmlnJ1xuaW1wb3J0IHR5cGUgeyBJbWFnZVByb3BzLCBJbWFnZUxvYWRlciwgU3RhdGljSW1hZ2VEYXRhIH0gZnJvbSAnLi9nZXQtaW1nLXByb3BzJ1xuXG5pbXBvcnQgeyBnZXRJbWdQcm9wcyB9IGZyb20gJy4vZ2V0LWltZy1wcm9wcydcbmltcG9ydCB7IEltYWdlIH0gZnJvbSAnLi4vLi4vY2xpZW50L2ltYWdlLWNvbXBvbmVudCdcblxuLy8gQHRzLWlnbm9yZSAtIFRoaXMgaXMgcmVwbGFjZWQgYnkgd2VicGFjayBhbGlhc1xuaW1wb3J0IGRlZmF1bHRMb2FkZXIgZnJvbSAnbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtbG9hZGVyJ1xuXG4vKipcbiAqIEZvciBtb3JlIGFkdmFuY2VkIHVzZSBjYXNlcywgeW91IGNhbiBjYWxsIGBnZXRJbWFnZVByb3BzKClgXG4gKiB0byBnZXQgdGhlIHByb3BzIHRoYXQgd291bGQgYmUgcGFzc2VkIHRvIHRoZSB1bmRlcmx5aW5nIGA8aW1nPmAgZWxlbWVudCxcbiAqIGFuZCBpbnN0ZWFkIHBhc3MgdG8gdGhlbSB0byBhbm90aGVyIGNvbXBvbmVudCwgc3R5bGUsIGNhbnZhcywgZXRjLlxuICpcbiAqIFJlYWQgbW9yZTogW05leHQuanMgZG9jczogYGdldEltYWdlUHJvcHNgXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL2ltYWdlI2dldGltYWdlcHJvcHMpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbWFnZVByb3BzKGltZ1Byb3BzOiBJbWFnZVByb3BzKSB7XG4gIGNvbnN0IHsgcHJvcHMgfSA9IGdldEltZ1Byb3BzKGltZ1Byb3BzLCB7XG4gICAgZGVmYXVsdExvYWRlcixcbiAgICAvLyBUaGlzIGlzIHJlcGxhY2VkIGJ5IHdlYnBhY2sgZGVmaW5lIHBsdWdpblxuICAgIGltZ0NvbmY6IHByb2Nlc3MuZW52Ll9fTkVYVF9JTUFHRV9PUFRTIGFzIGFueSBhcyBJbWFnZUNvbmZpZ0NvbXBsZXRlLFxuICB9KVxuICAvLyBOb3JtYWxseSB3ZSBkb24ndCBjYXJlIGFib3V0IHVuZGVmaW5lZCBwcm9wcyBiZWNhdXNlIHdlIHBhc3MgdG8gSlNYLFxuICAvLyBidXQgdGhpcyBleHBvcnRlZCBmdW5jdGlvbiBjb3VsZCBiZSB1c2VkIGJ5IHRoZSBlbmQgdXNlciBmb3IgYW55dGhpbmdcbiAgLy8gc28gd2UgZGVsZXRlIHVuZGVmaW5lZCBwcm9wcyB0byBjbGVhbiBpdCB1cCBhIGxpdHRsZS5cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcHMpKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlbGV0ZSBwcm9wc1trZXkgYXMga2V5b2YgdHlwZW9mIHByb3BzXVxuICAgIH1cbiAgfVxuICByZXR1cm4geyBwcm9wcyB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEltYWdlXG5cbmV4cG9ydCB0eXBlIHsgSW1hZ2VQcm9wcywgSW1hZ2VMb2FkZXJQcm9wcywgSW1hZ2VMb2FkZXIsIFN0YXRpY0ltYWdlRGF0YSB9XG4iXSwibmFtZXMiOlsiZ2V0SW1hZ2VQcm9wcyIsImltZ1Byb3BzIiwicHJvcHMiLCJnZXRJbWdQcm9wcyIsImRlZmF1bHRMb2FkZXIiLCJpbWdDb25mIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9JTUFHRV9PUFRTIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwidW5kZWZpbmVkIiwiSW1hZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-loader.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function get() {\n        return _default;\n    }\n}));\nfunction defaultLoader(param) {\n    var config = param.config, src = param.src, width = param.width, quality = param.quality;\n    if (true) {\n        var missingValues = [];\n        // these should always be provided but make sure they are\n        if (!src) missingValues.push('src');\n        if (!width) missingValues.push('width');\n        if (missingValues.length > 0) {\n            throw new Error(\"Next Image Optimization requires \" + missingValues.join(', ') + \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \" + JSON.stringify({\n                src: src,\n                width: width,\n                quality: quality\n            }));\n        }\n        if (src.startsWith('//')) {\n            throw new Error('Failed to parse src \"' + src + '\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)');\n        }\n        if (src.startsWith('/') && config.localPatterns) {\n            if (true) {\n                // We use dynamic require because this should only error in development\n                var hasLocalMatch = (__webpack_require__(/*! ./match-local-pattern */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/match-local-pattern.js\").hasLocalMatch);\n                if (!hasLocalMatch(config.localPatterns, src)) {\n                    throw new Error(\"Invalid src prop (\" + src + \") on `next/image` does not match `images.localPatterns` configured in your `next.config.js`\\n\" + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-localpatterns\");\n                }\n            }\n        }\n        if (!src.startsWith('/') && (config.domains || config.remotePatterns)) {\n            var parsedSrc;\n            try {\n                parsedSrc = new URL(src);\n            } catch (err) {\n                console.error(err);\n                throw new Error('Failed to parse src \"' + src + '\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)');\n            }\n            if (true) {\n                // We use dynamic require because this should only error in development\n                var hasRemoteMatch = (__webpack_require__(/*! ./match-remote-pattern */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js\").hasRemoteMatch);\n                if (!hasRemoteMatch(config.domains, config.remotePatterns, parsedSrc)) {\n                    throw new Error(\"Invalid src prop (\" + src + ') on `next/image`, hostname \"' + parsedSrc.hostname + '\" is not configured under images in your `next.config.js`\\n' + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host\");\n                }\n            }\n        }\n    }\n    return config.path + \"?url=\" + encodeURIComponent(src) + \"&w=\" + width + \"&q=\" + (quality || 75) + ( false ? 0 : '');\n}\n// We use this to determine if the import is the default loader\n// or a custom loader defined by the user in next.config.js\ndefaultLoader.__next_img_default = true;\nvar _default = defaultLoader; //# sourceMappingURL=image-loader.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7OzsyQ0F5RkE7OztlQUFBOzs7QUF2RkEsU0FBU0EsY0FBYyxLQUtNO0lBTE4sbUJBQ3JCQyxNQUFNLGNBQ05DLEdBQUcsZ0JBQ0hDLEtBQUssWUFIZ0IsTUFJckJDLE9BQU87SUFFUCxJQUFJQyxJQUFvQixFQUFtQjtRQUN6QyxJQUFNRyxnQkFBZ0IsRUFBRTtRQUV4Qix5REFBeUQ7UUFDekQsSUFBSSxDQUFDTixLQUFLTSxjQUFjQyxJQUFJLENBQUM7UUFDN0IsSUFBSSxDQUFDTixPQUFPSyxjQUFjQyxJQUFJLENBQUM7UUFFL0IsSUFBSUQsY0FBY0UsTUFBTSxHQUFHLEdBQUc7WUFDNUIsTUFBTSxJQUFJQyxNQUNQLHNDQUFtQ0gsY0FBY0ksSUFBSSxDQUNwRCxRQUNBLGdHQUErRkMsS0FBS0MsU0FBUyxDQUM3RztnQkFBRVo7dUJBQUtDO3lCQUFPQztZQUFRO1FBRzVCO1FBRUEsSUFBSUYsSUFBSWEsVUFBVSxDQUFDLE9BQU87WUFDeEIsTUFBTSxJQUFJSixNQUNQLDBCQUF1QlQsTUFBSTtRQUVoQztRQUVBLElBQUlBLElBQUlhLFVBQVUsQ0FBQyxRQUFRZCxPQUFPZSxhQUFhLEVBQUU7WUFDL0MsSUFEaUIsSUFJb0IsRUFDbkM7Z0JBQ0EsdUVBQXVFO2dCQUN2RSxJQUFNLGdCQUFvQkcsa0pBQUw7Z0JBQ3JCLElBQUksQ0FBQ0QsY0FBY2pCLE9BQU9lLGFBQWEsRUFBRWQsTUFBTTtvQkFDN0MsTUFBTSxJQUFJUyxNQUNQLHVCQUFvQlQsTUFBSSxrR0FDdEI7Z0JBRVA7WUFDRjtRQUNGO1FBRUEsSUFBSSxDQUFDQSxJQUFJYSxVQUFVLENBQUMsUUFBU2QsQ0FBQUEsT0FBT21CLE9BQU8sSUFBSW5CLE9BQU9vQixjQUFBQSxHQUFpQjtZQUNyRSxJQUFJQztZQUNKLElBQUk7Z0JBQ0ZBLFlBQVksSUFBSUMsSUFBSXJCO1lBQ3RCLEVBQUUsT0FBT3NCLEtBQUs7Z0JBQ1pDLFFBQVFDLEtBQUssQ0FBQ0Y7Z0JBQ2QsTUFBTSxJQUFJYixNQUNQLDBCQUF1QlQsTUFBSTtZQUVoQztZQUVBLElBQ0VHLElBRW1DLEVBQ25DO2dCQUNBLHVFQUF1RTtnQkFDdkUsSUFBTSxpQkFBcUJjLHFKQUFMO2dCQUN0QixJQUFJLENBQUNRLGVBQWUxQixPQUFPbUIsT0FBTyxFQUFFbkIsT0FBT29CLGNBQWMsRUFBRUMsWUFBWTtvQkFDckUsTUFBTSxJQUFJWCxNQUNQLHVCQUFvQlQsTUFBSSxrQ0FBaUNvQixVQUFVTSxRQUFRLEdBQUMsZ0VBQzFFO2dCQUVQO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsT0FBVTNCLE9BQU80QixJQUFJLEdBQUMsVUFBT0MsbUJBQW1CNUIsT0FBSyxRQUFLQyxRQUFNLFFBQzlEQyxZQUFXLEdBQUMsSUFFWkMsTUFBOEIsR0FDekIsQ0FBcUMsR0FDdEMsR0FBQztBQUVUO0FBRUEsK0RBQStEO0FBQy9ELDJEQUEyRDtBQUMzREwsY0FBY2dDLGtCQUFrQixHQUFHO0lBRW5DLFdBQWVoQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvaW1hZ2UtbG9hZGVyLnRzP2QyODAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBJbWFnZUxvYWRlclByb3BzV2l0aENvbmZpZyB9IGZyb20gJy4vaW1hZ2UtY29uZmlnJ1xuXG5mdW5jdGlvbiBkZWZhdWx0TG9hZGVyKHtcbiAgY29uZmlnLFxuICBzcmMsXG4gIHdpZHRoLFxuICBxdWFsaXR5LFxufTogSW1hZ2VMb2FkZXJQcm9wc1dpdGhDb25maWcpOiBzdHJpbmcge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IG1pc3NpbmdWYWx1ZXMgPSBbXVxuXG4gICAgLy8gdGhlc2Ugc2hvdWxkIGFsd2F5cyBiZSBwcm92aWRlZCBidXQgbWFrZSBzdXJlIHRoZXkgYXJlXG4gICAgaWYgKCFzcmMpIG1pc3NpbmdWYWx1ZXMucHVzaCgnc3JjJylcbiAgICBpZiAoIXdpZHRoKSBtaXNzaW5nVmFsdWVzLnB1c2goJ3dpZHRoJylcblxuICAgIGlmIChtaXNzaW5nVmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYE5leHQgSW1hZ2UgT3B0aW1pemF0aW9uIHJlcXVpcmVzICR7bWlzc2luZ1ZhbHVlcy5qb2luKFxuICAgICAgICAgICcsICdcbiAgICAgICAgKX0gdG8gYmUgcHJvdmlkZWQuIE1ha2Ugc3VyZSB5b3UgcGFzcyB0aGVtIGFzIHByb3BzIHRvIHRoZSBcXGBuZXh0L2ltYWdlXFxgIGNvbXBvbmVudC4gUmVjZWl2ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgeyBzcmMsIHdpZHRoLCBxdWFsaXR5IH1cbiAgICAgICAgKX1gXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHNyYy5zdGFydHNXaXRoKCcvLycpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gcGFyc2Ugc3JjIFwiJHtzcmN9XCIgb24gXFxgbmV4dC9pbWFnZVxcYCwgcHJvdG9jb2wtcmVsYXRpdmUgVVJMICgvLykgbXVzdCBiZSBjaGFuZ2VkIHRvIGFuIGFic29sdXRlIFVSTCAoaHR0cDovLyBvciBodHRwczovLylgXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHNyYy5zdGFydHNXaXRoKCcvJykgJiYgY29uZmlnLmxvY2FsUGF0dGVybnMpIHtcbiAgICAgIGlmIChcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJlxuICAgICAgICAvLyBtaWNyb21hdGNoIGlzbid0IGNvbXBhdGlibGUgd2l0aCBlZGdlIHJ1bnRpbWVcbiAgICAgICAgcHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FICE9PSAnZWRnZSdcbiAgICAgICkge1xuICAgICAgICAvLyBXZSB1c2UgZHluYW1pYyByZXF1aXJlIGJlY2F1c2UgdGhpcyBzaG91bGQgb25seSBlcnJvciBpbiBkZXZlbG9wbWVudFxuICAgICAgICBjb25zdCB7IGhhc0xvY2FsTWF0Y2ggfSA9IHJlcXVpcmUoJy4vbWF0Y2gtbG9jYWwtcGF0dGVybicpXG4gICAgICAgIGlmICghaGFzTG9jYWxNYXRjaChjb25maWcubG9jYWxQYXR0ZXJucywgc3JjKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbnZhbGlkIHNyYyBwcm9wICgke3NyY30pIG9uIFxcYG5leHQvaW1hZ2VcXGAgZG9lcyBub3QgbWF0Y2ggXFxgaW1hZ2VzLmxvY2FsUGF0dGVybnNcXGAgY29uZmlndXJlZCBpbiB5b3VyIFxcYG5leHQuY29uZmlnLmpzXFxgXFxuYCArXG4gICAgICAgICAgICAgIGBTZWUgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLXVuY29uZmlndXJlZC1sb2NhbHBhdHRlcm5zYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc3JjLnN0YXJ0c1dpdGgoJy8nKSAmJiAoY29uZmlnLmRvbWFpbnMgfHwgY29uZmlnLnJlbW90ZVBhdHRlcm5zKSkge1xuICAgICAgbGV0IHBhcnNlZFNyYzogVVJMXG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWRTcmMgPSBuZXcgVVJMKHNyYylcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBGYWlsZWQgdG8gcGFyc2Ugc3JjIFwiJHtzcmN9XCIgb24gXFxgbmV4dC9pbWFnZVxcYCwgaWYgdXNpbmcgcmVsYXRpdmUgaW1hZ2UgaXQgbXVzdCBzdGFydCB3aXRoIGEgbGVhZGluZyBzbGFzaCBcIi9cIiBvciBiZSBhbiBhYnNvbHV0ZSBVUkwgKGh0dHA6Ly8gb3IgaHR0cHM6Ly8pYFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJlxuICAgICAgICAvLyBtaWNyb21hdGNoIGlzbid0IGNvbXBhdGlibGUgd2l0aCBlZGdlIHJ1bnRpbWVcbiAgICAgICAgcHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FICE9PSAnZWRnZSdcbiAgICAgICkge1xuICAgICAgICAvLyBXZSB1c2UgZHluYW1pYyByZXF1aXJlIGJlY2F1c2UgdGhpcyBzaG91bGQgb25seSBlcnJvciBpbiBkZXZlbG9wbWVudFxuICAgICAgICBjb25zdCB7IGhhc1JlbW90ZU1hdGNoIH0gPSByZXF1aXJlKCcuL21hdGNoLXJlbW90ZS1wYXR0ZXJuJylcbiAgICAgICAgaWYgKCFoYXNSZW1vdGVNYXRjaChjb25maWcuZG9tYWlucywgY29uZmlnLnJlbW90ZVBhdHRlcm5zLCBwYXJzZWRTcmMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEludmFsaWQgc3JjIHByb3AgKCR7c3JjfSkgb24gXFxgbmV4dC9pbWFnZVxcYCwgaG9zdG5hbWUgXCIke3BhcnNlZFNyYy5ob3N0bmFtZX1cIiBpcyBub3QgY29uZmlndXJlZCB1bmRlciBpbWFnZXMgaW4geW91ciBcXGBuZXh0LmNvbmZpZy5qc1xcYFxcbmAgK1xuICAgICAgICAgICAgICBgU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1pbWFnZS11bmNvbmZpZ3VyZWQtaG9zdGBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gYCR7Y29uZmlnLnBhdGh9P3VybD0ke2VuY29kZVVSSUNvbXBvbmVudChzcmMpfSZ3PSR7d2lkdGh9JnE9JHtcbiAgICBxdWFsaXR5IHx8IDc1XG4gIH0ke1xuICAgIHByb2Nlc3MuZW52Lk5FWFRfREVQTE9ZTUVOVF9JRFxuICAgICAgPyBgJmRwbD0ke3Byb2Nlc3MuZW52Lk5FWFRfREVQTE9ZTUVOVF9JRH1gXG4gICAgICA6ICcnXG4gIH1gXG59XG5cbi8vIFdlIHVzZSB0aGlzIHRvIGRldGVybWluZSBpZiB0aGUgaW1wb3J0IGlzIHRoZSBkZWZhdWx0IGxvYWRlclxuLy8gb3IgYSBjdXN0b20gbG9hZGVyIGRlZmluZWQgYnkgdGhlIHVzZXIgaW4gbmV4dC5jb25maWcuanNcbmRlZmF1bHRMb2FkZXIuX19uZXh0X2ltZ19kZWZhdWx0ID0gdHJ1ZVxuXG5leHBvcnQgZGVmYXVsdCBkZWZhdWx0TG9hZGVyXG4iXSwibmFtZXMiOlsiZGVmYXVsdExvYWRlciIsImNvbmZpZyIsInNyYyIsIndpZHRoIiwicXVhbGl0eSIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIm1pc3NpbmdWYWx1ZXMiLCJwdXNoIiwibGVuZ3RoIiwiRXJyb3IiLCJqb2luIiwiSlNPTiIsInN0cmluZ2lmeSIsInN0YXJ0c1dpdGgiLCJsb2NhbFBhdHRlcm5zIiwiTkVYVF9SVU5USU1FIiwiaGFzTG9jYWxNYXRjaCIsInJlcXVpcmUiLCJkb21haW5zIiwicmVtb3RlUGF0dGVybnMiLCJwYXJzZWRTcmMiLCJVUkwiLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJoYXNSZW1vdGVNYXRjaCIsImhvc3RuYW1lIiwicGF0aCIsImVuY29kZVVSSUNvbXBvbmVudCIsIk5FWFRfREVQTE9ZTUVOVF9JRCIsIl9fbmV4dF9pbWdfZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/match-local-pattern.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/match-local-pattern.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    hasLocalMatch: function hasLocalMatch1() {\n        return hasLocalMatch;\n    },\n    matchLocalPattern: function matchLocalPattern1() {\n        return matchLocalPattern;\n    }\n});\nvar _picomatch = __webpack_require__(/*! next/dist/compiled/picomatch */ \"(app-pages-browser)/./node_modules/next/dist/compiled/picomatch/index.js\");\nfunction matchLocalPattern(pattern, url) {\n    if (pattern.search !== undefined) {\n        if (pattern.search !== url.search) {\n            return false;\n        }\n    }\n    var _pattern_pathname;\n    if (!(0, _picomatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : '**', {\n        dot: true\n    }).test(url.pathname)) {\n        return false;\n    }\n    return true;\n}\nfunction hasLocalMatch(localPatterns, urlPathAndQuery) {\n    if (!localPatterns) {\n        // if the user didn't define \"localPatterns\", we allow all local images\n        return true;\n    }\n    var url = new URL(urlPathAndQuery, 'http://n');\n    return localPatterns.some(function(p) {\n        return matchLocalPattern(p, url);\n    });\n} //# sourceMappingURL=match-local-pattern.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9tYXRjaC1sb2NhbC1wYXR0ZXJuLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQWtCZ0JBLGFBQWE7ZUFBYkE7O3VCQWRpQixTQUFqQkMsaUJBQWlCO2VBQWpCQTs7O3FDQUhPO0FBR2hCLFNBQVNBLGtCQUFrQkMsT0FBcUIsRUFBRUMsR0FBUTtJQUMvRCxJQUFJRCxRQUFRRSxNQUFNLEtBQUtDLFdBQVc7UUFDaEMsSUFBSUgsUUFBUUUsTUFBTSxLQUFLRCxJQUFJQyxNQUFNLEVBQUU7WUFDakMsT0FBTztRQUNUO0lBQ0Y7UUFFWUY7SUFBWixJQUFJLENBQUNJLENBQUFBLEdBQUFBLFdBQUFBLE1BQUFBLEVBQU9KLENBQUFBLG9CQUFBQSxRQUFRSyxRQUFBQSxLQUFRLE9BQWhCTCxvQkFBb0IsTUFBTTtRQUFFTSxLQUFLO0lBQUssR0FBR0MsSUFBSSxDQUFDTixJQUFJSSxRQUFRLEdBQUc7UUFDdkUsT0FBTztJQUNUO0lBRUEsT0FBTztBQUNUO0FBRU8sU0FBU1AsY0FDZFUsYUFBeUMsRUFDekNDLGVBQXVCO0lBRXZCLElBQUksQ0FBQ0QsZUFBZTtRQUNsQix1RUFBdUU7UUFDdkUsT0FBTztJQUNUO0lBQ0EsSUFBTVAsTUFBTSxJQUFJUyxJQUFJRCxpQkFBaUI7SUFDckMsT0FBT0QsY0FBY0csSUFBSSxDQUFDLFNBQUNDO2VBQU1iLGtCQUFrQmEsR0FBR1g7O0FBQ3hEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9tYXRjaC1sb2NhbC1wYXR0ZXJuLnRzPzYzNWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBMb2NhbFBhdHRlcm4gfSBmcm9tICcuL2ltYWdlLWNvbmZpZydcbmltcG9ydCB7IG1ha2VSZSB9IGZyb20gJ25leHQvZGlzdC9jb21waWxlZC9waWNvbWF0Y2gnXG5cbi8vIE1vZGlmeWluZyB0aGlzIGZ1bmN0aW9uIHNob3VsZCBhbHNvIG1vZGlmeSB3cml0ZUltYWdlc01hbmlmZXN0KClcbmV4cG9ydCBmdW5jdGlvbiBtYXRjaExvY2FsUGF0dGVybihwYXR0ZXJuOiBMb2NhbFBhdHRlcm4sIHVybDogVVJMKTogYm9vbGVhbiB7XG4gIGlmIChwYXR0ZXJuLnNlYXJjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHBhdHRlcm4uc2VhcmNoICE9PSB1cmwuc2VhcmNoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBpZiAoIW1ha2VSZShwYXR0ZXJuLnBhdGhuYW1lID8/ICcqKicsIHsgZG90OiB0cnVlIH0pLnRlc3QodXJsLnBhdGhuYW1lKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0xvY2FsTWF0Y2goXG4gIGxvY2FsUGF0dGVybnM6IExvY2FsUGF0dGVybltdIHwgdW5kZWZpbmVkLFxuICB1cmxQYXRoQW5kUXVlcnk6IHN0cmluZ1xuKTogYm9vbGVhbiB7XG4gIGlmICghbG9jYWxQYXR0ZXJucykge1xuICAgIC8vIGlmIHRoZSB1c2VyIGRpZG4ndCBkZWZpbmUgXCJsb2NhbFBhdHRlcm5zXCIsIHdlIGFsbG93IGFsbCBsb2NhbCBpbWFnZXNcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwodXJsUGF0aEFuZFF1ZXJ5LCAnaHR0cDovL24nKVxuICByZXR1cm4gbG9jYWxQYXR0ZXJucy5zb21lKChwKSA9PiBtYXRjaExvY2FsUGF0dGVybihwLCB1cmwpKVxufVxuIl0sIm5hbWVzIjpbImhhc0xvY2FsTWF0Y2giLCJtYXRjaExvY2FsUGF0dGVybiIsInBhdHRlcm4iLCJ1cmwiLCJzZWFyY2giLCJ1bmRlZmluZWQiLCJtYWtlUmUiLCJwYXRobmFtZSIsImRvdCIsInRlc3QiLCJsb2NhbFBhdHRlcm5zIiwidXJsUGF0aEFuZFF1ZXJ5IiwiVVJMIiwic29tZSIsInAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/match-local-pattern.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/match-remote-pattern.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    hasRemoteMatch: function hasRemoteMatch1() {\n        return hasRemoteMatch;\n    },\n    matchRemotePattern: function matchRemotePattern1() {\n        return matchRemotePattern;\n    }\n});\nvar _picomatch = __webpack_require__(/*! next/dist/compiled/picomatch */ \"(app-pages-browser)/./node_modules/next/dist/compiled/picomatch/index.js\");\nfunction matchRemotePattern(pattern, url) {\n    if (pattern.protocol !== undefined) {\n        var actualProto = url.protocol.slice(0, -1);\n        if (pattern.protocol !== actualProto) {\n            return false;\n        }\n    }\n    if (pattern.port !== undefined) {\n        if (pattern.port !== url.port) {\n            return false;\n        }\n    }\n    if (pattern.hostname === undefined) {\n        throw new Error(\"Pattern should define hostname but found\\n\" + JSON.stringify(pattern));\n    } else {\n        if (!(0, _picomatch.makeRe)(pattern.hostname).test(url.hostname)) {\n            return false;\n        }\n    }\n    if (pattern.search !== undefined) {\n        if (pattern.search !== url.search) {\n            return false;\n        }\n    }\n    var _pattern_pathname;\n    // Should be the same as writeImagesManifest()\n    if (!(0, _picomatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : '**', {\n        dot: true\n    }).test(url.pathname)) {\n        return false;\n    }\n    return true;\n}\nfunction hasRemoteMatch(domains, remotePatterns, url) {\n    return domains.some(function(domain) {\n        return url.hostname === domain;\n    }) || remotePatterns.some(function(p) {\n        return matchRemotePattern(p, url);\n    });\n} //# sourceMappingURL=match-remote-pattern.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9tYXRjaC1yZW1vdGUtcGF0dGVybi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7b0JBeUM4QixTQUFkQSxjQUFjO2VBQWRBOzt3QkFyQ2tCLFNBQWxCQyxrQkFBa0I7ZUFBbEJBOzs7cUNBSE87QUFHaEIsU0FBU0EsbUJBQW1CQyxPQUFzQixFQUFFQyxHQUFRO0lBQ2pFLElBQUlELFFBQVFFLFFBQVEsS0FBS0MsV0FBVztRQUNsQyxJQUFNQyxjQUFjSCxJQUFJQyxRQUFRLENBQUNHLEtBQUssQ0FBQyxHQUFHLENBQUM7UUFDM0MsSUFBSUwsUUFBUUUsUUFBUSxLQUFLRSxhQUFhO1lBQ3BDLE9BQU87UUFDVDtJQUNGO0lBQ0EsSUFBSUosUUFBUU0sSUFBSSxLQUFLSCxXQUFXO1FBQzlCLElBQUlILFFBQVFNLElBQUksS0FBS0wsSUFBSUssSUFBSSxFQUFFO1lBQzdCLE9BQU87UUFDVDtJQUNGO0lBRUEsSUFBSU4sUUFBUU8sUUFBUSxLQUFLSixXQUFXO1FBQ2xDLE1BQU0sSUFBSUssTUFDUCwrQ0FBNENDLEtBQUtDLFNBQVMsQ0FBQ1Y7SUFFaEUsT0FBTztRQUNMLElBQUksQ0FBQ1csQ0FBQUEsR0FBQUEsV0FBQUEsTUFBQUEsRUFBT1gsUUFBUU8sUUFBUSxFQUFFSyxJQUFJLENBQUNYLElBQUlNLFFBQVEsR0FBRztZQUNoRCxPQUFPO1FBQ1Q7SUFDRjtJQUVBLElBQUlQLFFBQVFhLE1BQU0sS0FBS1YsV0FBVztRQUNoQyxJQUFJSCxRQUFRYSxNQUFNLEtBQUtaLElBQUlZLE1BQU0sRUFBRTtZQUNqQyxPQUFPO1FBQ1Q7SUFDRjtRQUdZYjtJQURaLDhDQUE4QztJQUM5QyxJQUFJLENBQUNXLENBQUFBLEdBQUFBLFdBQUFBLE1BQUFBLEVBQU9YLENBQUFBLG9CQUFBQSxRQUFRYyxRQUFBQSxLQUFRLE9BQWhCZCxvQkFBb0IsTUFBTTtRQUFFZSxLQUFLO0lBQUssR0FBR0gsSUFBSSxDQUFDWCxJQUFJYSxRQUFRLEdBQUc7UUFDdkUsT0FBTztJQUNUO0lBRUEsT0FBTztBQUNUO0FBRU8sU0FBU2hCLGVBQ2RrQixPQUFpQixFQUNqQkMsY0FBK0IsRUFDL0JoQixHQUFRO0lBRVIsT0FDRWUsUUFBUUUsSUFBSSxDQUFDLFNBQUNDO2VBQVdsQixJQUFJTSxRQUFRLEtBQUtZO1VBQzFDRixlQUFlQyxJQUFJLENBQUMsU0FBQ0U7ZUFBTXJCLG1CQUFtQnFCLEdBQUduQjs7QUFFckQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL21hdGNoLXJlbW90ZS1wYXR0ZXJuLnRzP2Q2MWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBSZW1vdGVQYXR0ZXJuIH0gZnJvbSAnLi9pbWFnZS1jb25maWcnXG5pbXBvcnQgeyBtYWtlUmUgfSBmcm9tICduZXh0L2Rpc3QvY29tcGlsZWQvcGljb21hdGNoJ1xuXG4vLyBNb2RpZnlpbmcgdGhpcyBmdW5jdGlvbiBzaG91bGQgYWxzbyBtb2RpZnkgd3JpdGVJbWFnZXNNYW5pZmVzdCgpXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hSZW1vdGVQYXR0ZXJuKHBhdHRlcm46IFJlbW90ZVBhdHRlcm4sIHVybDogVVJMKTogYm9vbGVhbiB7XG4gIGlmIChwYXR0ZXJuLnByb3RvY29sICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBhY3R1YWxQcm90byA9IHVybC5wcm90b2NvbC5zbGljZSgwLCAtMSlcbiAgICBpZiAocGF0dGVybi5wcm90b2NvbCAhPT0gYWN0dWFsUHJvdG8pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICBpZiAocGF0dGVybi5wb3J0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAocGF0dGVybi5wb3J0ICE9PSB1cmwucG9ydCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgaWYgKHBhdHRlcm4uaG9zdG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBQYXR0ZXJuIHNob3VsZCBkZWZpbmUgaG9zdG5hbWUgYnV0IGZvdW5kXFxuJHtKU09OLnN0cmluZ2lmeShwYXR0ZXJuKX1gXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIGlmICghbWFrZVJlKHBhdHRlcm4uaG9zdG5hbWUpLnRlc3QodXJsLmhvc3RuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgaWYgKHBhdHRlcm4uc2VhcmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAocGF0dGVybi5zZWFyY2ggIT09IHVybC5zZWFyY2gpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIFNob3VsZCBiZSB0aGUgc2FtZSBhcyB3cml0ZUltYWdlc01hbmlmZXN0KClcbiAgaWYgKCFtYWtlUmUocGF0dGVybi5wYXRobmFtZSA/PyAnKionLCB7IGRvdDogdHJ1ZSB9KS50ZXN0KHVybC5wYXRobmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNSZW1vdGVNYXRjaChcbiAgZG9tYWluczogc3RyaW5nW10sXG4gIHJlbW90ZVBhdHRlcm5zOiBSZW1vdGVQYXR0ZXJuW10sXG4gIHVybDogVVJMXG4pOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBkb21haW5zLnNvbWUoKGRvbWFpbikgPT4gdXJsLmhvc3RuYW1lID09PSBkb21haW4pIHx8XG4gICAgcmVtb3RlUGF0dGVybnMuc29tZSgocCkgPT4gbWF0Y2hSZW1vdGVQYXR0ZXJuKHAsIHVybCkpXG4gIClcbn1cbiJdLCJuYW1lcyI6WyJoYXNSZW1vdGVNYXRjaCIsIm1hdGNoUmVtb3RlUGF0dGVybiIsInBhdHRlcm4iLCJ1cmwiLCJwcm90b2NvbCIsInVuZGVmaW5lZCIsImFjdHVhbFByb3RvIiwic2xpY2UiLCJwb3J0IiwiaG9zdG5hbWUiLCJFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJtYWtlUmUiLCJ0ZXN0Iiwic2VhcmNoIiwicGF0aG5hbWUiLCJkb3QiLCJkb21haW5zIiwicmVtb3RlUGF0dGVybnMiLCJzb21lIiwiZG9tYWluIiwicCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router-context.shared-runtime.js ***!
  \****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"RouterContext\", ({\n    enumerable: true,\n    get: function get() {\n        return RouterContext;\n    }\n}));\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar RouterContext = _react[\"default\"].createContext(null);\nif (true) {\n    RouterContext.displayName = 'RouterContext';\n} //# sourceMappingURL=router-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O2lEQUdhQTs7O2VBQUFBOzs7OzBFQUhLO0FBR1gsSUFBTUEsZ0JBQWdCQyxNQUFBQSxDQUFBQSxVQUFLLENBQUNDLGFBQWEsQ0FBb0I7QUFFcEUsSUFBSUMsSUFBb0IsRUFBbUI7SUFDekNILGNBQWNNLFdBQVcsR0FBRztBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUudHM/NjM2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgdHlwZSB7IE5leHRSb3V0ZXIgfSBmcm9tICcuL3JvdXRlci9yb3V0ZXInXG5cbmV4cG9ydCBjb25zdCBSb3V0ZXJDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxOZXh0Um91dGVyIHwgbnVsbD4obnVsbClcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgUm91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdSb3V0ZXJDb250ZXh0J1xufVxuIl0sIm5hbWVzIjpbIlJvdXRlckNvbnRleHQiLCJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJkaXNwbGF5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/side-effect.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function get() {\n        return SideEffect;\n    }\n}));\nvar _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar isServer = typeof window === 'undefined';\nvar useClientOnlyLayoutEffect = isServer ? function() {} : _react.useLayoutEffect;\nvar useClientOnlyEffect = isServer ? function() {} : _react.useEffect;\nfunction SideEffect(props) {\n    _s();\n    var headManager = props.headManager, reduceComponentsToState = props.reduceComponentsToState;\n    function emitChange() {\n        if (headManager && headManager.mountedInstances) {\n            var headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));\n            headManager.updateHead(reduceComponentsToState(headElements, props));\n        }\n    }\n    if (isServer) {\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        emitChange();\n    }\n    useClientOnlyLayoutEffect(function() {\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        return function() {\n            var _headManager_mountedInstances;\n            headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances[\"delete\"](props.children);\n        };\n    });\n    // We need to call `updateHead` method whenever the `SideEffect` is trigger in all\n    // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s\n    // being rendered, we only trigger the method from the last one.\n    // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`\n    // singleton in the layout effect pass, and actually trigger it in the effect pass.\n    useClientOnlyLayoutEffect(function() {\n        if (headManager) {\n            headManager._pendingUpdate = emitChange;\n        }\n        return function() {\n            if (headManager) {\n                headManager._pendingUpdate = emitChange;\n            }\n        };\n    });\n    useClientOnlyEffect(function() {\n        if (headManager && headManager._pendingUpdate) {\n            headManager._pendingUpdate();\n            headManager._pendingUpdate = null;\n        }\n        return function() {\n            if (headManager && headManager._pendingUpdate) {\n                headManager._pendingUpdate();\n                headManager._pendingUpdate = null;\n            }\n        };\n    });\n    return null;\n} //# sourceMappingURL=side-effect.js.map\n_s(SideEffect, \"gHVkikNHNxjVdD11eJBzaqkCiPY=\", false, function() {\n    return [\n        useClientOnlyLayoutEffect,\n        useClientOnlyLayoutEffect,\n        useClientOnlyEffect\n    ];\n});\n_c = SideEffect;\nvar _c;\n$RefreshReg$(_c, \"SideEffect\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9zaWRlLWVmZmVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7MkNBb0JBOzs7ZUFBd0JBOzs7aUNBbkJ1QztBQWUvRCxJQUFNQyxXQUFXLE9BQU9DLFdBQVc7QUFDbkMsSUFBTUMsNEJBQTRCRixXQUFXLFlBQU8sSUFBSUcsT0FBQUEsZUFBZTtBQUN2RSxJQUFNQyxzQkFBc0JKLFdBQVcsWUFBTyxJQUFJSyxPQUFBQSxTQUFTO0FBRTVDLG9CQUFvQkMsS0FBc0I7O0lBQ3ZELE1BQU0sa0JBQUVDLFdBQVcsNEJBQThCRCxNQUE1QkUsdUJBQXVCO0lBRTVDLFNBQVNDO1FBQ1AsSUFBSUYsZUFBZUEsWUFBWUcsZ0JBQWdCLEVBQUU7WUFDL0MsSUFBTUMsZUFBZUMsT0FBQUEsUUFBUSxDQUFDQyxPQUFPLENBQ25DQyxNQUFNQyxJQUFJLENBQUNSLFlBQVlHLGdCQUFnQixFQUEwQk0sTUFBTSxDQUNyRUM7WUFHSlYsWUFBWVcsVUFBVSxDQUFDVix3QkFBd0JHLGNBQWNMO1FBQy9EO0lBQ0Y7SUFFQSxJQUFJTixVQUFVO1lBQ1pPO1FBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLGdDQUFBQSxZQUFhRyxnQkFBQUEsS0FBZ0IsZ0JBQTdCSCw4QkFBK0JZLEdBQUcsQ0FBQ2IsTUFBTWMsUUFBUTtRQUNqRFg7SUFDRjs4QkFFMEI7WUFDeEJGO1FBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLGdDQUFBQSxZQUFhRyxnQkFBQUEsS0FBZ0IsZ0JBQTdCSCw4QkFBK0JZLEdBQUcsQ0FBQ2IsTUFBTWMsUUFBUTtRQUNqRCxPQUFPO2dCQUNMYjtZQUFBQSxlQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxDQUFBQSxnQ0FBQUEsWUFBYUcsZ0JBQUFBLEtBQWdCLGdCQUE3QkgsOEJBQStCYyxTQUFNLENBQUNmLE1BQU1jLFFBQVE7UUFDdEQ7SUFDRjtJQUVBLGtGQUFrRjtJQUNsRixvRkFBb0Y7SUFDcEYsZ0VBQWdFO0lBQ2hFLHFGQUFxRjtJQUNyRixtRkFBbUY7OEJBQ3pEO1FBQ3hCLElBQUliLGFBQWE7WUFDZkEsWUFBWWUsY0FBYyxHQUFHYjtRQUMvQjtRQUNBLE9BQU87WUFDTCxJQUFJRixhQUFhO2dCQUNmQSxZQUFZZSxjQUFjLEdBQUdiO1lBQy9CO1FBQ0Y7SUFDRjt3QkFFb0I7UUFDbEIsSUFBSUYsZUFBZUEsWUFBWWUsY0FBYyxFQUFFO1lBQzdDZixZQUFZZSxjQUFjO1lBQzFCZixZQUFZZSxjQUFjLEdBQUc7UUFDL0I7UUFDQSxPQUFPO1lBQ0wsSUFBSWYsZUFBZUEsWUFBWWUsY0FBYyxFQUFFO2dCQUM3Q2YsWUFBWWUsY0FBYztnQkFDMUJmLFlBQVllLGNBQWMsR0FBRztZQUMvQjtRQUNGO0lBQ0Y7SUFFQSxPQUFPO0FBQ1Q7OztRQXJDRXBCO1FBWUFBO1FBV0FFOzs7S0ExQ3NCTCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvc2lkZS1lZmZlY3QudHN4P2U4ZGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBDaGlsZHJlbiwgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QsIHR5cGUgSlNYIH0gZnJvbSAncmVhY3QnXG5cbnR5cGUgU3RhdGUgPSBKU1guRWxlbWVudFtdIHwgdW5kZWZpbmVkXG5cbmV4cG9ydCB0eXBlIFNpZGVFZmZlY3RQcm9wcyA9IHtcbiAgcmVkdWNlQ29tcG9uZW50c1RvU3RhdGU6IDxUIGV4dGVuZHMge30+KFxuICAgIGNvbXBvbmVudHM6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PixcbiAgICBwcm9wczogVFxuICApID0+IFN0YXRlXG4gIGhhbmRsZVN0YXRlQ2hhbmdlPzogKHN0YXRlOiBTdGF0ZSkgPT4gdm9pZFxuICBoZWFkTWFuYWdlcjogYW55XG4gIGluQW1wTW9kZT86IGJvb2xlYW5cbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZVxufVxuXG5jb25zdCBpc1NlcnZlciA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnXG5jb25zdCB1c2VDbGllbnRPbmx5TGF5b3V0RWZmZWN0ID0gaXNTZXJ2ZXIgPyAoKSA9PiB7fSA6IHVzZUxheW91dEVmZmVjdFxuY29uc3QgdXNlQ2xpZW50T25seUVmZmVjdCA9IGlzU2VydmVyID8gKCkgPT4ge30gOiB1c2VFZmZlY3RcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2lkZUVmZmVjdChwcm9wczogU2lkZUVmZmVjdFByb3BzKSB7XG4gIGNvbnN0IHsgaGVhZE1hbmFnZXIsIHJlZHVjZUNvbXBvbmVudHNUb1N0YXRlIH0gPSBwcm9wc1xuXG4gIGZ1bmN0aW9uIGVtaXRDaGFuZ2UoKSB7XG4gICAgaWYgKGhlYWRNYW5hZ2VyICYmIGhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXMpIHtcbiAgICAgIGNvbnN0IGhlYWRFbGVtZW50cyA9IENoaWxkcmVuLnRvQXJyYXkoXG4gICAgICAgIEFycmF5LmZyb20oaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcyBhcyBTZXQ8UmVhY3QuUmVhY3ROb2RlPikuZmlsdGVyKFxuICAgICAgICAgIEJvb2xlYW5cbiAgICAgICAgKVxuICAgICAgKSBhcyBSZWFjdC5SZWFjdEVsZW1lbnRbXVxuICAgICAgaGVhZE1hbmFnZXIudXBkYXRlSGVhZChyZWR1Y2VDb21wb25lbnRzVG9TdGF0ZShoZWFkRWxlbWVudHMsIHByb3BzKSlcbiAgICB9XG4gIH1cblxuICBpZiAoaXNTZXJ2ZXIpIHtcbiAgICBoZWFkTWFuYWdlcj8ubW91bnRlZEluc3RhbmNlcz8uYWRkKHByb3BzLmNoaWxkcmVuKVxuICAgIGVtaXRDaGFuZ2UoKVxuICB9XG5cbiAgdXNlQ2xpZW50T25seUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaGVhZE1hbmFnZXI/Lm1vdW50ZWRJbnN0YW5jZXM/LmFkZChwcm9wcy5jaGlsZHJlbilcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaGVhZE1hbmFnZXI/Lm1vdW50ZWRJbnN0YW5jZXM/LmRlbGV0ZShwcm9wcy5jaGlsZHJlbilcbiAgICB9XG4gIH0pXG5cbiAgLy8gV2UgbmVlZCB0byBjYWxsIGB1cGRhdGVIZWFkYCBtZXRob2Qgd2hlbmV2ZXIgdGhlIGBTaWRlRWZmZWN0YCBpcyB0cmlnZ2VyIGluIGFsbFxuICAvLyBsaWZlLWN5Y2xlczogbW91bnQsIHVwZGF0ZSwgdW5tb3VudC4gSG93ZXZlciwgaWYgdGhlcmUgYXJlIG11bHRpcGxlIGBTaWRlRWZmZWN0YHNcbiAgLy8gYmVpbmcgcmVuZGVyZWQsIHdlIG9ubHkgdHJpZ2dlciB0aGUgbWV0aG9kIGZyb20gdGhlIGxhc3Qgb25lLlxuICAvLyBUaGlzIGlzIGVuc3VyZWQgYnkga2VlcGluZyB0aGUgbGFzdCB1bmZsdXNoZWQgYHVwZGF0ZUhlYWRgIGluIHRoZSBgX3BlbmRpbmdVcGRhdGVgXG4gIC8vIHNpbmdsZXRvbiBpbiB0aGUgbGF5b3V0IGVmZmVjdCBwYXNzLCBhbmQgYWN0dWFsbHkgdHJpZ2dlciBpdCBpbiB0aGUgZWZmZWN0IHBhc3MuXG4gIHVzZUNsaWVudE9ubHlMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChoZWFkTWFuYWdlcikge1xuICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUgPSBlbWl0Q2hhbmdlXG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoaGVhZE1hbmFnZXIpIHtcbiAgICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUgPSBlbWl0Q2hhbmdlXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIHVzZUNsaWVudE9ubHlFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChoZWFkTWFuYWdlciAmJiBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSkge1xuICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUoKVxuICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUgPSBudWxsXG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoaGVhZE1hbmFnZXIgJiYgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUpIHtcbiAgICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUoKVxuICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSA9IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIG51bGxcbn1cbiJdLCJuYW1lcyI6WyJTaWRlRWZmZWN0IiwiaXNTZXJ2ZXIiLCJ3aW5kb3ciLCJ1c2VDbGllbnRPbmx5TGF5b3V0RWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlQ2xpZW50T25seUVmZmVjdCIsInVzZUVmZmVjdCIsInByb3BzIiwiaGVhZE1hbmFnZXIiLCJyZWR1Y2VDb21wb25lbnRzVG9TdGF0ZSIsImVtaXRDaGFuZ2UiLCJtb3VudGVkSW5zdGFuY2VzIiwiaGVhZEVsZW1lbnRzIiwiQ2hpbGRyZW4iLCJ0b0FycmF5IiwiQXJyYXkiLCJmcm9tIiwiZmlsdGVyIiwiQm9vbGVhbiIsInVwZGF0ZUhlYWQiLCJhZGQiLCJjaGlsZHJlbiIsImRlbGV0ZSIsIl9wZW5kaW5nVXBkYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE$2\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PORTAL_TYPE:\n          return \"Portal\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function disabledLog() {}\n    function disableLogs() {\n      if (0 === disabledDepth) {\n        prevLog = console.log;\n        prevInfo = console.info;\n        prevWarn = console.warn;\n        prevError = console.error;\n        prevGroup = console.group;\n        prevGroupCollapsed = console.groupCollapsed;\n        prevGroupEnd = console.groupEnd;\n        var props = {\n          configurable: !0,\n          enumerable: !0,\n          value: disabledLog,\n          writable: !0\n        };\n        Object.defineProperties(console, {\n          info: props,\n          log: props,\n          warn: props,\n          error: props,\n          group: props,\n          groupCollapsed: props,\n          groupEnd: props\n        });\n      }\n      disabledDepth++;\n    }\n    function reenableLogs() {\n      disabledDepth--;\n      if (0 === disabledDepth) {\n        var props = { configurable: !0, enumerable: !0, writable: !0 };\n        Object.defineProperties(console, {\n          log: assign({}, props, { value: prevLog }),\n          info: assign({}, props, { value: prevInfo }),\n          warn: assign({}, props, { value: prevWarn }),\n          error: assign({}, props, { value: prevError }),\n          group: assign({}, props, { value: prevGroup }),\n          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),\n          groupEnd: assign({}, props, { value: prevGroupEnd })\n        });\n      }\n      0 > disabledDepth &&\n        console.error(\n          \"disabledDepth fell below zero. This is a bug in React. Please file an issue.\"\n        );\n    }\n    function describeBuiltInComponentFrame(name) {\n      if (void 0 === prefix)\n        try {\n          throw Error();\n        } catch (x) {\n          var match = x.stack.trim().match(/\\n( *(at )?)/);\n          prefix = (match && match[1]) || \"\";\n          suffix =\n            -1 < x.stack.indexOf(\"\\n    at\")\n              ? \" (<anonymous>)\"\n              : -1 < x.stack.indexOf(\"@\")\n                ? \"@unknown:0:0\"\n                : \"\";\n        }\n      return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      if (!fn || reentry) return \"\";\n      var frame = componentFrameCache.get(fn);\n      if (void 0 !== frame) return frame;\n      reentry = !0;\n      frame = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var previousDispatcher = null;\n      previousDispatcher = ReactSharedInternals.H;\n      ReactSharedInternals.H = null;\n      disableLogs();\n      try {\n        var RunInRootFrame = {\n          DetermineComponentFrameRoot: function () {\n            try {\n              if (construct) {\n                var Fake = function () {\n                  throw Error();\n                };\n                Object.defineProperty(Fake.prototype, \"props\", {\n                  set: function () {\n                    throw Error();\n                  }\n                });\n                if (\"object\" === typeof Reflect && Reflect.construct) {\n                  try {\n                    Reflect.construct(Fake, []);\n                  } catch (x) {\n                    var control = x;\n                  }\n                  Reflect.construct(fn, [], Fake);\n                } else {\n                  try {\n                    Fake.call();\n                  } catch (x$0) {\n                    control = x$0;\n                  }\n                  fn.call(Fake.prototype);\n                }\n              } else {\n                try {\n                  throw Error();\n                } catch (x$1) {\n                  control = x$1;\n                }\n                (Fake = fn()) &&\n                  \"function\" === typeof Fake.catch &&\n                  Fake.catch(function () {});\n              }\n            } catch (sample) {\n              if (sample && control && \"string\" === typeof sample.stack)\n                return [sample.stack, control.stack];\n            }\n            return [null, null];\n          }\n        };\n        RunInRootFrame.DetermineComponentFrameRoot.displayName =\n          \"DetermineComponentFrameRoot\";\n        var namePropDescriptor = Object.getOwnPropertyDescriptor(\n          RunInRootFrame.DetermineComponentFrameRoot,\n          \"name\"\n        );\n        namePropDescriptor &&\n          namePropDescriptor.configurable &&\n          Object.defineProperty(\n            RunInRootFrame.DetermineComponentFrameRoot,\n            \"name\",\n            { value: \"DetermineComponentFrameRoot\" }\n          );\n        var _RunInRootFrame$Deter =\n            RunInRootFrame.DetermineComponentFrameRoot(),\n          sampleStack = _RunInRootFrame$Deter[0],\n          controlStack = _RunInRootFrame$Deter[1];\n        if (sampleStack && controlStack) {\n          var sampleLines = sampleStack.split(\"\\n\"),\n            controlLines = controlStack.split(\"\\n\");\n          for (\n            _RunInRootFrame$Deter = namePropDescriptor = 0;\n            namePropDescriptor < sampleLines.length &&\n            !sampleLines[namePropDescriptor].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            namePropDescriptor++;\n          for (\n            ;\n            _RunInRootFrame$Deter < controlLines.length &&\n            !controlLines[_RunInRootFrame$Deter].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            _RunInRootFrame$Deter++;\n          if (\n            namePropDescriptor === sampleLines.length ||\n            _RunInRootFrame$Deter === controlLines.length\n          )\n            for (\n              namePropDescriptor = sampleLines.length - 1,\n                _RunInRootFrame$Deter = controlLines.length - 1;\n              1 <= namePropDescriptor &&\n              0 <= _RunInRootFrame$Deter &&\n              sampleLines[namePropDescriptor] !==\n                controlLines[_RunInRootFrame$Deter];\n\n            )\n              _RunInRootFrame$Deter--;\n          for (\n            ;\n            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;\n            namePropDescriptor--, _RunInRootFrame$Deter--\n          )\n            if (\n              sampleLines[namePropDescriptor] !==\n              controlLines[_RunInRootFrame$Deter]\n            ) {\n              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                do\n                  if (\n                    (namePropDescriptor--,\n                    _RunInRootFrame$Deter--,\n                    0 > _RunInRootFrame$Deter ||\n                      sampleLines[namePropDescriptor] !==\n                        controlLines[_RunInRootFrame$Deter])\n                  ) {\n                    var _frame =\n                      \"\\n\" +\n                      sampleLines[namePropDescriptor].replace(\n                        \" at new \",\n                        \" at \"\n                      );\n                    fn.displayName &&\n                      _frame.includes(\"<anonymous>\") &&\n                      (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                    \"function\" === typeof fn &&\n                      componentFrameCache.set(fn, _frame);\n                    return _frame;\n                  }\n                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n              }\n              break;\n            }\n        }\n      } finally {\n        (reentry = !1),\n          (ReactSharedInternals.H = previousDispatcher),\n          reenableLogs(),\n          (Error.prepareStackTrace = frame);\n      }\n      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\")\n        ? describeBuiltInComponentFrame(sampleLines)\n        : \"\";\n      \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n      return sampleLines;\n    }\n    function describeUnknownElementTypeFrameInDEV(type) {\n      if (null == type) return \"\";\n      if (\"function\" === typeof type) {\n        var prototype = type.prototype;\n        return describeNativeComponentFrame(\n          type,\n          !(!prototype || !prototype.isReactComponent)\n        );\n      }\n      if (\"string\" === typeof type) return describeBuiltInComponentFrame(type);\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame(\"Suspense\");\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame(\"SuspenseList\");\n      }\n      if (\"object\" === typeof type)\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return (type = describeNativeComponentFrame(type.render, !1)), type;\n          case REACT_MEMO_TYPE:\n            return describeUnknownElementTypeFrameInDEV(type.type);\n          case REACT_LAZY_TYPE:\n            prototype = type._payload;\n            type = type._init;\n            try {\n              return describeUnknownElementTypeFrameInDEV(type(prototype));\n            } catch (x) {}\n        }\n      return \"\";\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function hasValidRef(config) {\n      if (hasOwnProperty.call(config, \"ref\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.ref;\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(type, key, _ref, self, source, owner, props) {\n      _ref = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== _ref ? _ref : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      if (\n        \"string\" === typeof type ||\n        \"function\" === typeof type ||\n        type === REACT_FRAGMENT_TYPE ||\n        type === REACT_PROFILER_TYPE ||\n        type === REACT_STRICT_MODE_TYPE ||\n        type === REACT_SUSPENSE_TYPE ||\n        type === REACT_SUSPENSE_LIST_TYPE ||\n        type === REACT_OFFSCREEN_TYPE ||\n        (\"object\" === typeof type &&\n          null !== type &&\n          (type.$$typeof === REACT_LAZY_TYPE ||\n            type.$$typeof === REACT_MEMO_TYPE ||\n            type.$$typeof === REACT_CONTEXT_TYPE ||\n            type.$$typeof === REACT_CONSUMER_TYPE ||\n            type.$$typeof === REACT_FORWARD_REF_TYPE ||\n            type.$$typeof === REACT_CLIENT_REFERENCE$1 ||\n            void 0 !== type.getModuleId))\n      ) {\n        var children = config.children;\n        if (void 0 !== children)\n          if (isStaticChildren)\n            if (isArrayImpl(children)) {\n              for (\n                isStaticChildren = 0;\n                isStaticChildren < children.length;\n                isStaticChildren++\n              )\n                validateChildKeys(children[isStaticChildren], type);\n              Object.freeze && Object.freeze(children);\n            } else\n              console.error(\n                \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n              );\n          else validateChildKeys(children, type);\n      } else {\n        children = \"\";\n        if (\n          void 0 === type ||\n          (\"object\" === typeof type &&\n            null !== type &&\n            0 === Object.keys(type).length)\n        )\n          children +=\n            \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n        null === type\n          ? (isStaticChildren = \"null\")\n          : isArrayImpl(type)\n            ? (isStaticChildren = \"array\")\n            : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE\n              ? ((isStaticChildren =\n                  \"<\" +\n                  (getComponentNameFromType(type.type) || \"Unknown\") +\n                  \" />\"),\n                (children =\n                  \" Did you accidentally export a JSX literal instead of a component?\"))\n              : (isStaticChildren = typeof type);\n        console.error(\n          \"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\",\n          isStaticChildren,\n          children\n        );\n      }\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      hasValidRef(config);\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        ((config =\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type),\n        children && defineKeyPropWarningGetter(maybeKey, config));\n      return ReactElement(\n        type,\n        children,\n        null,\n        self,\n        source,\n        getOwner(),\n        maybeKey\n      );\n    }\n    function validateChildKeys(node, parentType) {\n      if (\n        \"object\" === typeof node &&\n        node &&\n        node.$$typeof !== REACT_CLIENT_REFERENCE\n      )\n        if (isArrayImpl(node))\n          for (var i = 0; i < node.length; i++) {\n            var child = node[i];\n            isValidElement(child) && validateExplicitKey(child, parentType);\n          }\n        else if (isValidElement(node))\n          node._store && (node._store.validated = 1);\n        else if (\n          (null === node || \"object\" !== typeof node\n            ? (i = null)\n            : ((i =\n                (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||\n                node[\"@@iterator\"]),\n              (i = \"function\" === typeof i ? i : null)),\n          \"function\" === typeof i &&\n            i !== node.entries &&\n            ((i = i.call(node)), i !== node))\n        )\n          for (; !(node = i.next()).done; )\n            isValidElement(node.value) &&\n              validateExplicitKey(node.value, parentType);\n    }\n    function isValidElement(object) {\n      return (\n        \"object\" === typeof object &&\n        null !== object &&\n        object.$$typeof === REACT_ELEMENT_TYPE\n      );\n    }\n    function validateExplicitKey(element, parentType) {\n      if (\n        element._store &&\n        !element._store.validated &&\n        null == element.key &&\n        ((element._store.validated = 1),\n        (parentType = getCurrentComponentErrorInfo(parentType)),\n        !ownerHasKeyUseWarning[parentType])\n      ) {\n        ownerHasKeyUseWarning[parentType] = !0;\n        var childOwner = \"\";\n        element &&\n          null != element._owner &&\n          element._owner !== getOwner() &&\n          ((childOwner = null),\n          \"number\" === typeof element._owner.tag\n            ? (childOwner = getComponentNameFromType(element._owner.type))\n            : \"string\" === typeof element._owner.name &&\n              (childOwner = element._owner.name),\n          (childOwner = \" It was passed a child from \" + childOwner + \".\"));\n        var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;\n        ReactSharedInternals.getCurrentStack = function () {\n          var stack = describeUnknownElementTypeFrameInDEV(element.type);\n          prevGetCurrentStack && (stack += prevGetCurrentStack() || \"\");\n          return stack;\n        };\n        console.error(\n          'Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.',\n          parentType,\n          childOwner\n        );\n        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n      }\n    }\n    function getCurrentComponentErrorInfo(parentType) {\n      var info = \"\",\n        owner = getOwner();\n      owner &&\n        (owner = getComponentNameFromType(owner.type)) &&\n        (info = \"\\n\\nCheck the render method of `\" + owner + \"`.\");\n      info ||\n        ((parentType = getComponentNameFromType(parentType)) &&\n          (info =\n            \"\\n\\nCheck the top-level render call using <\" + parentType + \">.\"));\n      return info;\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      assign = Object.assign,\n      REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"),\n      isArrayImpl = Array.isArray,\n      disabledDepth = 0,\n      prevLog,\n      prevInfo,\n      prevWarn,\n      prevError,\n      prevGroup,\n      prevGroupCollapsed,\n      prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix,\n      suffix,\n      reentry = !1;\n    var componentFrameCache = new (\n      \"function\" === typeof WeakMap ? WeakMap : Map\n    )();\n    var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var didWarnAboutKeySpread = {},\n      ownerHasKeyUseWarning = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self);\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHdCQUF3QixXQUFXLGdCQUFnQjtBQUNuRCx5QkFBeUIsV0FBVyxpQkFBaUI7QUFDckQseUJBQXlCLFdBQVcsaUJBQWlCO0FBQ3JELDBCQUEwQixXQUFXLGtCQUFrQjtBQUN2RCwwQkFBMEIsV0FBVyxrQkFBa0I7QUFDdkQsbUNBQW1DLFdBQVcsMkJBQTJCO0FBQ3pFLDZCQUE2QixXQUFXLHFCQUFxQjtBQUM3RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCwrQ0FBK0MsNkJBQTZCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQixnREFBZ0Q7QUFDaEUsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBLGdDQUFnQyxrQ0FBa0MsT0FBTztBQUN6RTtBQUNBLGdHQUFnRyxTQUFTLFVBQVUsc0ZBQXNGLGFBQWEsVUFBVSxVQUFVO0FBQzFPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQixJQUFJLGNBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/YTMwOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDJcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgIChcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZS50YWcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB0eXBlLiQkdHlwZW9mKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG4gICAgZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gICAgICBpZiAoMCA9PT0gZGlzYWJsZWREZXB0aCkge1xuICAgICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkaXNhYmxlZERlcHRoKys7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAgICAgIGRpc2FibGVkRGVwdGgtLTtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHsgY29uZmlndXJhYmxlOiAhMCwgZW51bWVyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2TG9nIH0pLFxuICAgICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZJbmZvIH0pLFxuICAgICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZXYXJuIH0pLFxuICAgICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2RXJyb3IgfSksXG4gICAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cCB9KSxcbiAgICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkIH0pLFxuICAgICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBFbmQgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAwID4gZGlzYWJsZWREZXB0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IHByZWZpeClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICBwcmVmaXggPSAobWF0Y2ggJiYgbWF0Y2hbMV0pIHx8IFwiXCI7XG4gICAgICAgICAgc3VmZml4ID1cbiAgICAgICAgICAgIC0xIDwgeC5zdGFjay5pbmRleE9mKFwiXFxuICAgIGF0XCIpXG4gICAgICAgICAgICAgID8gXCIgKDxhbm9ueW1vdXM+KVwiXG4gICAgICAgICAgICAgIDogLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJAXCIpXG4gICAgICAgICAgICAgICAgPyBcIkB1bmtub3duOjA6MFwiXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcXG5cIiArIHByZWZpeCArIG5hbWUgKyBzdWZmaXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAgICAgaWYgKCFmbiB8fCByZWVudHJ5KSByZXR1cm4gXCJcIjtcbiAgICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGZyYW1lKSByZXR1cm4gZnJhbWU7XG4gICAgICByZWVudHJ5ID0gITA7XG4gICAgICBmcmFtZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyID0gbnVsbDtcbiAgICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gbnVsbDtcbiAgICAgIGRpc2FibGVMb2dzKCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgICAgICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IHg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0geCQwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMSkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHgkMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKEZha2UgPSBmbigpKSAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgRmFrZS5jYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgRmFrZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNhbXBsZS5zdGFjaylcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID1cbiAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiO1xuICAgICAgICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgXCJuYW1lXCJcbiAgICAgICAgKTtcbiAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSAmJlxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICAgIFwibmFtZVwiLFxuICAgICAgICAgICAgeyB2YWx1ZTogXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIiB9XG4gICAgICAgICAgKTtcbiAgICAgICAgdmFyIF9SdW5JblJvb3RGcmFtZSREZXRlciA9XG4gICAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG4gICAgICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdChcIlxcblwiKSxcbiAgICAgICAgICAgIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2xTdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gbmFtZVByb3BEZXNjcmlwdG9yID0gMDtcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIXNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IrKztcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIWNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyKys7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHxcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9PT0gY29udHJvbExpbmVzLmxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgICAgIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyICYmXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl07XG5cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyLS07XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLS0sIF9SdW5JblJvb3RGcmFtZSREZXRlci0tXG4gICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICgxICE9PSBuYW1lUHJvcERlc2NyaXB0b3IgfHwgMSAhPT0gX1J1bkluUm9vdEZyYW1lJERldGVyKSB7XG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKG5hbWVQcm9wRGVzY3JpcHRvci0tLFxuICAgICAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLSxcbiAgICAgICAgICAgICAgICAgICAgMCA+IF9SdW5JblJvb3RGcmFtZSREZXRlciB8fFxuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXSlcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID1cbiAgICAgICAgICAgICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBuZXcgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBcIlxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGZuLmRpc3BsYXlOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgX2ZyYW1lLmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBmbi5kaXNwbGF5TmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmbiAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlICgxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJiAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChyZWVudHJ5ID0gITEpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldmlvdXNEaXNwYXRjaGVyKSxcbiAgICAgICAgICByZWVuYWJsZUxvZ3MoKSxcbiAgICAgICAgICAoRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBmcmFtZSk7XG4gICAgICB9XG4gICAgICBzYW1wbGVMaW5lcyA9IChzYW1wbGVMaW5lcyA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6IFwiXCIpXG4gICAgICAgID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoc2FtcGxlTGluZXMpXG4gICAgICAgIDogXCJcIjtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzYW1wbGVMaW5lcyk7XG4gICAgICByZXR1cm4gc2FtcGxlTGluZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gXCJcIjtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKSB7XG4gICAgICAgIHZhciBwcm90b3R5cGUgPSB0eXBlLnByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICAhKCFwcm90b3R5cGUgfHwgIXByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlXCIpO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZSA9IGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIsICExKSksIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBwcm90b3R5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUocHJvdG90eXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0T3duZXIoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkE7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gZGlzcGF0Y2hlciA/IG51bGwgOiBkaXNwYXRjaGVyLmdldE93bmVyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcInJlZlwiKSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsIFwicmVmXCIpLmdldDtcbiAgICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbmZpZy5yZWY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbmZpZy5rZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICAgICAgZnVuY3Rpb24gd2FybkFib3V0QWNjZXNzaW5nS2V5KCkge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biB8fFxuICAgICAgICAgICgoc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0LmRldi9saW5rL3NwZWNpYWwtcHJvcHMpXCIsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZVxuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gITA7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsIFwia2V5XCIsIHtcbiAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZygpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHRoaXMudHlwZSk7XG4gICAgICBkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICgoZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSA9ICEwKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFjY2Vzc2luZyBlbGVtZW50LnJlZiB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gcmVmIGlzIG5vdyBhIHJlZ3VsYXIgcHJvcC4gSXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEpTWCBFbGVtZW50IHR5cGUgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIlxuICAgICAgICApKTtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSB0aGlzLnByb3BzLnJlZjtcbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbXBvbmVudE5hbWUgPyBjb21wb25lbnROYW1lIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgICAgIF9yZWYgPSBwcm9wcy5yZWY7XG4gICAgICB0eXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBfb3duZXI6IG93bmVyXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gKHZvaWQgMCAhPT0gX3JlZiA/IF9yZWYgOiBudWxsKVxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICB9KVxuICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7IGVudW1lcmFibGU6ICExLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgIHR5cGUuX3N0b3JlID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnSW5mb1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUodHlwZS5wcm9wcyksIE9iamVjdC5mcmVlemUodHlwZSkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGpzeERFVkltcGwoXG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnLFxuICAgICAgbWF5YmVLZXksXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgc291cmNlLFxuICAgICAgc2VsZlxuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSB8fFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8XG4gICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8XG4gICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OU1VNRVJfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxIHx8XG4gICAgICAgICAgICB2b2lkIDAgIT09IHR5cGUuZ2V0TW9kdWxlSWQpKVxuICAgICAgKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gY2hpbGRyZW4pXG4gICAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pXG4gICAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA9IDA7XG4gICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA8IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuKytcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2lzU3RhdGljQ2hpbGRyZW5dLCB0eXBlKTtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgZWxzZSB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZHJlbiA9IFwiXCI7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB2b2lkIDAgPT09IHR5cGUgfHxcbiAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAgIDAgPT09IE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aClcbiAgICAgICAgKVxuICAgICAgICAgIGNoaWxkcmVuICs9XG4gICAgICAgICAgICBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICAgIG51bGwgPT09IHR5cGVcbiAgICAgICAgICA/IChpc1N0YXRpY0NoaWxkcmVuID0gXCJudWxsXCIpXG4gICAgICAgICAgOiBpc0FycmF5SW1wbCh0eXBlKVxuICAgICAgICAgICAgPyAoaXNTdGF0aWNDaGlsZHJlbiA9IFwiYXJyYXlcIilcbiAgICAgICAgICAgIDogdm9pZCAwICE9PSB0eXBlICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgICAgICAgICA/ICgoaXNTdGF0aWNDaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICAgICAgICAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJVbmtub3duXCIpICtcbiAgICAgICAgICAgICAgICAgIFwiIC8+XCIpLFxuICAgICAgICAgICAgICAgIChjaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50P1wiKSlcbiAgICAgICAgICAgICAgOiAoaXNTdGF0aWNDaGlsZHJlbiA9IHR5cGVvZiB0eXBlKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lc1wiLFxuICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29uZmlnKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXlcIiAhPT0gaztcbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPVxuICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aFxuICAgICAgICAgICAgPyBcIntrZXk6IHNvbWVLZXksIFwiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCJcbiAgICAgICAgICAgIDogXCJ7a2V5OiBzb21lS2V5fVwiO1xuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSB8fFxuICAgICAgICAgICgoa2V5cyA9XG4gICAgICAgICAgICAwIDwga2V5cy5sZW5ndGggPyBcIntcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7fVwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMgey4uLnByb3BzfSAvPlxcblJlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JyxcbiAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGtleXMsXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dID0gITApKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgIHZvaWQgMCAhPT0gbWF5YmVLZXkgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgbWF5YmVLZXkpKTtcbiAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBjb25maWcua2V5KSk7XG4gICAgICBoYXNWYWxpZFJlZihjb25maWcpO1xuICAgICAgaWYgKFwia2V5XCIgaW4gY29uZmlnKSB7XG4gICAgICAgIG1heWJlS2V5ID0ge307XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGNvbmZpZylcbiAgICAgICAgICBcImtleVwiICE9PSBwcm9wTmFtZSAmJiAobWF5YmVLZXlbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XG4gICAgICB9IGVsc2UgbWF5YmVLZXkgPSBjb25maWc7XG4gICAgICBjaGlsZHJlbiAmJlxuICAgICAgICAoKGNvbmZpZyA9XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZVxuICAgICAgICAgICAgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBcIlVua25vd25cIlxuICAgICAgICAgICAgOiB0eXBlKSxcbiAgICAgICAgY2hpbGRyZW4gJiYgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIobWF5YmVLZXksIGNvbmZpZykpO1xuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIG51bGwsXG4gICAgICAgIHNlbGYsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZ2V0T3duZXIoKSxcbiAgICAgICAgbWF5YmVLZXlcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgbm9kZSAmJlxuICAgICAgICBub2RlLiQkdHlwZW9mICE9PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICApXG4gICAgICAgIGlmIChpc0FycmF5SW1wbChub2RlKSlcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICAgICAgICBpc1ZhbGlkRWxlbWVudChjaGlsZCkgJiYgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSlcbiAgICAgICAgICBub2RlLl9zdG9yZSAmJiAobm9kZS5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgIChudWxsID09PSBub2RlIHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBub2RlXG4gICAgICAgICAgICA/IChpID0gbnVsbClcbiAgICAgICAgICAgIDogKChpID1cbiAgICAgICAgICAgICAgICAoTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG5vZGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICAgICAgICAgICAgICBub2RlW1wiQEBpdGVyYXRvclwiXSksXG4gICAgICAgICAgICAgIChpID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSA/IGkgOiBudWxsKSksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSAmJlxuICAgICAgICAgICAgaSAhPT0gbm9kZS5lbnRyaWVzICYmXG4gICAgICAgICAgICAoKGkgPSBpLmNhbGwobm9kZSkpLCBpICE9PSBub2RlKSlcbiAgICAgICAgKVxuICAgICAgICAgIGZvciAoOyAhKG5vZGUgPSBpLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgICAgaXNWYWxpZEVsZW1lbnQobm9kZS52YWx1ZSkgJiZcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShub2RlLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb2JqZWN0ICYmXG4gICAgICAgIG51bGwgIT09IG9iamVjdCAmJlxuICAgICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGVsZW1lbnQuX3N0b3JlICYmXG4gICAgICAgICFlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgJiZcbiAgICAgICAgbnVsbCA9PSBlbGVtZW50LmtleSAmJlxuICAgICAgICAoKGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IDEpLFxuICAgICAgICAocGFyZW50VHlwZSA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkpLFxuICAgICAgICAhb3duZXJIYXNLZXlVc2VXYXJuaW5nW3BhcmVudFR5cGVdKVxuICAgICAgKSB7XG4gICAgICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1twYXJlbnRUeXBlXSA9ICEwO1xuICAgICAgICB2YXIgY2hpbGRPd25lciA9IFwiXCI7XG4gICAgICAgIGVsZW1lbnQgJiZcbiAgICAgICAgICBudWxsICE9IGVsZW1lbnQuX293bmVyICYmXG4gICAgICAgICAgZWxlbWVudC5fb3duZXIgIT09IGdldE93bmVyKCkgJiZcbiAgICAgICAgICAoKGNoaWxkT3duZXIgPSBudWxsKSxcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgZWxlbWVudC5fb3duZXIudGFnXG4gICAgICAgICAgICA/IChjaGlsZE93bmVyID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpKVxuICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2YgZWxlbWVudC5fb3duZXIubmFtZSAmJlxuICAgICAgICAgICAgICAoY2hpbGRPd25lciA9IGVsZW1lbnQuX293bmVyLm5hbWUpLFxuICAgICAgICAgIChjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBjaGlsZE93bmVyICsgXCIuXCIpKTtcbiAgICAgICAgdmFyIHByZXZHZXRDdXJyZW50U3RhY2sgPSBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2s7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlKTtcbiAgICAgICAgICBwcmV2R2V0Q3VycmVudFN0YWNrICYmIChzdGFjayArPSBwcmV2R2V0Q3VycmVudFN0YWNrKCkgfHwgXCJcIik7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgICBwYXJlbnRUeXBlLFxuICAgICAgICAgIGNoaWxkT3duZXJcbiAgICAgICAgKTtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gcHJldkdldEN1cnJlbnRTdGFjaztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9IFwiXCIsXG4gICAgICAgIG93bmVyID0gZ2V0T3duZXIoKTtcbiAgICAgIG93bmVyICYmXG4gICAgICAgIChvd25lciA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShvd25lci50eXBlKSkgJiZcbiAgICAgICAgKGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGBcIiArIG93bmVyICsgXCJgLlwiKTtcbiAgICAgIGluZm8gfHxcbiAgICAgICAgKChwYXJlbnRUeXBlID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpKSAmJlxuICAgICAgICAgIChpbmZvID1cbiAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnRUeXBlICsgXCI+LlwiKSk7XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKSxcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gICAgICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgICAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTtcbiAgICBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIik7XG4gICAgdmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksXG4gICAgICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICAgIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLFxuICAgICAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpLFxuICAgICAgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQyID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIGRpc2FibGVkRGVwdGggPSAwLFxuICAgICAgcHJldkxvZyxcbiAgICAgIHByZXZJbmZvLFxuICAgICAgcHJldldhcm4sXG4gICAgICBwcmV2RXJyb3IsXG4gICAgICBwcmV2R3JvdXAsXG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQsXG4gICAgICBwcmV2R3JvdXBFbmQ7XG4gICAgZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gITA7XG4gICAgdmFyIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIHJlZW50cnkgPSAhMTtcbiAgICB2YXIgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyAoXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBXZWFrTWFwID8gV2Vha01hcCA6IE1hcFxuICAgICkoKTtcbiAgICB2YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG4gICAgdmFyIGRpZFdhcm5BYm91dEVsZW1lbnRSZWYgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0S2V5U3ByZWFkID0ge30sXG4gICAgICBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLmpzeERFViA9IGZ1bmN0aW9uIChcbiAgICAgIHR5cGUsXG4gICAgICBjb25maWcsXG4gICAgICBtYXliZUtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICBzb3VyY2UsXG4gICAgICBzZWxmXG4gICAgKSB7XG4gICAgICByZXR1cm4ganN4REVWSW1wbCh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpO1xuICAgIH07XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/YWU3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/classnames/index.js":
/*!******************************************!*\
  !*** ./node_modules/classnames/index.js ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\tCopyright (c) 2018 Jed Watson.\n\tLicensed under the MIT License (MIT), see\n\thttp://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = '';\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (arg) {\n\t\t\t\tclasses = appendClass(classes, parseValue(arg));\n\t\t\t}\n\t\t}\n\n\t\treturn classes;\n\t}\n\n\tfunction parseValue (arg) {\n\t\tif (typeof arg === 'string' || typeof arg === 'number') {\n\t\t\treturn arg;\n\t\t}\n\n\t\tif (typeof arg !== 'object') {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (Array.isArray(arg)) {\n\t\t\treturn classNames.apply(null, arg);\n\t\t}\n\n\t\tif (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {\n\t\t\treturn arg.toString();\n\t\t}\n\n\t\tvar classes = '';\n\n\t\tfor (var key in arg) {\n\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\tclasses = appendClass(classes, key);\n\t\t\t}\n\t\t}\n\n\t\treturn classes;\n\t}\n\n\tfunction appendClass (value, newClass) {\n\t\tif (!newClass) {\n\t\t\treturn value;\n\t\t}\n\t\n\t\tif (value) {\n\t\t\treturn value + ' ' + newClass;\n\t\t}\n\t\n\t\treturn value + newClass;\n\t}\n\n\tif ( true && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (true) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn classNames;\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQjs7QUFFaEI7QUFDQTs7QUFFQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLLEtBQTZCO0FBQ2xDO0FBQ0E7QUFDQSxHQUFHLFNBQVMsSUFBNEU7QUFDeEY7QUFDQSxFQUFFLGlDQUFxQixFQUFFLG1DQUFFO0FBQzNCO0FBQ0EsR0FBRztBQUFBLGtHQUFDO0FBQ0osR0FBRyxLQUFLLEVBRU47QUFDRixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzP2E0ODUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG5cdENvcHlyaWdodCAoYykgMjAxOCBKZWQgV2F0c29uLlxuXHRMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuXHRodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMgKCkge1xuXHRcdHZhciBjbGFzc2VzID0gJyc7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmIChhcmcpIHtcblx0XHRcdFx0Y2xhc3NlcyA9IGFwcGVuZENsYXNzKGNsYXNzZXMsIHBhcnNlVmFsdWUoYXJnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXM7XG5cdH1cblxuXHRmdW5jdGlvbiBwYXJzZVZhbHVlIChhcmcpIHtcblx0XHRpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcblx0XHRcdHJldHVybiBhcmc7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiBhcmcgIT09ICdvYmplY3QnKSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXMuYXBwbHkobnVsbCwgYXJnKTtcblx0XHR9XG5cblx0XHRpZiAoYXJnLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nICYmICFhcmcudG9TdHJpbmcudG9TdHJpbmcoKS5pbmNsdWRlcygnW25hdGl2ZSBjb2RlXScpKSB7XG5cdFx0XHRyZXR1cm4gYXJnLnRvU3RyaW5nKCk7XG5cdFx0fVxuXG5cdFx0dmFyIGNsYXNzZXMgPSAnJztcblxuXHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0Y2xhc3NlcyA9IGFwcGVuZENsYXNzKGNsYXNzZXMsIGtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXM7XG5cdH1cblxuXHRmdW5jdGlvbiBhcHBlbmRDbGFzcyAodmFsdWUsIG5ld0NsYXNzKSB7XG5cdFx0aWYgKCFuZXdDbGFzcykge1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblx0XG5cdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgKyAnICcgKyBuZXdDbGFzcztcblx0XHR9XG5cdFxuXHRcdHJldHVybiB2YWx1ZSArIG5ld0NsYXNzO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0Y2xhc3NOYW1lcy5kZWZhdWx0ID0gY2xhc3NOYW1lcztcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/classnames/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/brasao.json":
/*!****************************!*\
  !*** ./public/brasao.json ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"v":"5.9.1","fr":25,"ip":0,"op":125,"w":400,"h":400,"nm":"Composição 1","ddd":0,"assets":[{"id":"image_0","w":400,"h":300,"u":"","p":"data:image/png;base64,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","e":1},{"id":"image_1","w":400,"h":401,"u":"","p":"data:image/png;base64,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","e":1},{"id":"image_2","w":400,"h":465,"u":"","p":"data:image/png;base64,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","e":1}],"layers":[{"ddd":0,"ind":1,"ty":2,"nm":"escrita.png","cl":"png","refId":"image_0","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":50,"s":[0]},{"t":75,"s":[100]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[193.691,211.356,0],"ix":2,"l":2},"a":{"a":0,"k":[200,150,0],"ix":1,"l":2},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":50,"s":[95,95,100]},{"t":75,"s":[65,65,100]}],"ix":6,"l":2}},"ao":0,"ip":50,"op":125,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":2,"nm":"bola.png","cl":"png","refId":"image_1","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":14,"s":[100]},{"t":50,"s":[100]}],"ix":11},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":0,"s":[0]},{"t":50,"s":[360]}],"ix":10},"p":{"a":1,"k":[{"i":{"x":0.833,"y":0.833},"o":{"x":0.167,"y":0.167},"t":29,"s":[196.215,225.237,0],"to":[0,-22.292,0],"ti":[0,22.292,0]},{"t":50,"s":[196.215,91.483,0]}],"ix":2,"l":2},"a":{"a":0,"k":[200,200.5,0],"ix":1,"l":2},"s":{"a":0,"k":[38,38,100],"ix":6,"l":2}},"ao":0,"ip":0,"op":129,"st":4,"bm":0},{"ddd":0,"ind":3,"ty":2,"nm":"brasão.png","cl":"png","refId":"image_2","sr":1,"ks":{"o":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"t":11,"s":[0]},{"t":64,"s":[100]}],"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[198.738,223.975,0],"ix":2,"l":2},"a":{"a":0,"k":[200,232.5,0],"ix":1,"l":2},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"t":11,"s":[6,6,100]},{"t":64,"s":[66,66,100]}],"ix":6,"l":2}},"ao":0,"ip":25,"op":136,"st":11,"bm":0}],"markers":[]}');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fianov%2Fgame3%2Ftrump-cards%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);